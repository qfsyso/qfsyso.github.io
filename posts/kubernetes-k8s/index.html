<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Kubernetes k8s | MLOG</title>
<meta name=keywords content><meta name=description content="Kubernetes k8s 描述什么是Kubernetes 描述Kubernetes的基本架构及核心概念 描述Kubernetes的应用编排方法 使用华为云CCE创建简单工作负载
容器编排技术 容器（如Docker）以及周边生态系统提供了很多工具来实现容器生命周期管理，能够满足在单台宿主机管理容器的需求。但越来越多企业开始使用容器，对容器技术的进一步发展提出了以下新的诉求： □高效的容器管理及编排。 □容器的跨主机部署及调度。 □容器的存储、网络、运维、安全等能力的拓展。 统一的容器编排管理工具
容器编排的价值 容器编排是指自动化容器的部署、管理、扩展和联网，可为企业带来以下价值： 灵活的资源管理及调度 自动化部署及服务发现 高效的监控及运维 弹性扩展及高可用
大规模容器集群管理工具，从Borg到Kubernetes ·Kubernetes起源于Google内部的Borg项目，它对计算资源进行了更高层次的抽象，通过将容器进行细致的组合，将最终的应用服务交给用户。它的目标是管理大规模的容器，提供基本的部署、维护以及应用伸缩等功能，其主要实现语言为Go语言。 ·Kubernetes作为容器集群管理工具，于2015年7月22日迭代到v1.0并正式对外公布。与此同时，谷歌联合Linux基金会及其他合作伙伴共同成立了CNCF基金会（CloudNativeComputingFoundation），并将Kuberentes作为首个编入CNCF管理体系的开源项目，助力容器技术生态的发展进步。
Kubernetes架构 ·一个基础的Kubernetes集群（Cluster）通常包含一个Master节点和多个Node节点。每个节点可以是一台物理机，也可以是一台虚拟机。
pod最小容器（container）
Kubernetes核心概念-Pod Pod是Kubernetes中最重要最基本的概念，Pod是Kubernetes最小工作单元。每一个Pod包含一个或多个相关容器，Kubernetes将Pod看做一个整体进行调度。 引入Pod的目的： 将联系紧密的容器封装在一个Pod单元内，以Pod整体进行调度、扩展和实现生命周期管理。 Pod内所有容器使用相同的网络Namespace和共享存储。即Pod内容器拥有相同IP地址和Port空间，容器间直接使用localhost通信。当挂载volume到Pod，即可实现将volume挂载到Pod中的每个容器。
Kubernetes核心概念-Controller ·工作负载是在Pod之上的一层抽象，我们可以通过控制器（controller）实现一系列基于Pod的高级特性，比如节点故障时Pod的自动迁移，Pod多副本横向扩展，应用滚动升级等。我们通常使用controller来做应用的真正的管理，而Pod是组成工作负载最小的单元
Kubernetes核心概念-Label ·当资源变得非常多的时候，如何分类管理就非常重要了，Kubernetes提供了一种机制来为资源分类，那就是Label（标签）。Label非常简单，但是却很强大，Kubernetes中几乎所有资源都可以用Label来组织。Label的具体形式是key-value的标记对，可以在创建资源的时候设置，也可以在后期添加和修改。
Kubernetes核心概念-Namespace ·命名空间（Namespace）是对一组资源和对象的抽象整合。在同一个集群内可创建不同的命名空间，不同命名空间中的数据彼此隔离。使得它们既可以共享同一个集群的服务，也能够互不干扰。 kube-public kube-system kube-node-lease default
Kubernetes核心概念-Service ·在Kubernetes中，Pod副本发生迁移或者伸缩的时候会发生变化，IP也是变化的。Kubernetes中的Service是一种抽象概念，它定义了一个Pod逻辑集合以及访问它们的策略。Service定义了外界访问一组特定Pod的方式。Service有自己的IP和端口，Service为Pod提供了负载均衡。
Kubernetes核心概念-Volume ·Volume用来管理Kubernetes存储，是用来声明在Pod中的容器可以访问的文件目录，含义如下： 声明在Pod中的容器可以访问的文件目录。 可以被挂载在Pod中一个或多个容器的指定路径下。 支持多种后端存储（本地存储、分布式存储、云存储等）。
Kubernetes管理-Kubectl ·Kubectl是Kubernetes的命令行工具。通过kubectl，用户能对集群进行管理，并在集群上进行容器化应用的安装部署。
Kubectl支持以下对象管理方式： 指令式：通过kubectl内置的驱动命令，如:kubectl +create/scale/delete/..+参数的形式， 直接快速创建、更新和删除Kubernetes对象。
声明式：使用kubectlapply创建指定目录中配置文件所定义的所有对象。通常，此配置文件 采用yaml进行描述。
Kubernetes管理-命令行语法 在Kubernetes中的很多操作都是用kubectl来完成，通过其命令可以管理Deployment、Replicaset、ReplicationController、Pod等，进行操作、扩容、删除等全生命周期操作，同时可以对管理对象进行查看或者监控资源使用情况。
kubectl的语法
kubectl [command] [TYPElNAME] [flags] Command：指定你希望进行的操作，如create，get，describe，delete等。 TYPE：指定操作对象的类型，如deployment，pod，service等。 hiPnNAME：指定对象的名字。hidhwyun flags:可选的标志位。
Kubernetes管理-yaml示例 ·kubernetes中的对象可以使用YAML描述（如果您对YAML格式不了解，可以参考YAML语法少，也可以使用JSON。其内容可以分为如下四个部分： typeMeta：对象类型的元信息，声明对象使用哪个API版本，哪个类型的对象。 objectMeta：对象的元信息，包括对象名称、使用的标签等。 spec：对象的期望状态，例如对象使用什么镜像、有多少副本等。 status：对象的实际状态，只能在对象创建后看到，创建对象时无需指定。"><meta name=author content="dwd"><link rel=canonical href=https://qfsyso.github.io/posts/kubernetes-k8s/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://qfsyso.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://qfsyso.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://qfsyso.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://qfsyso.github.io/apple-touch-icon.png><link rel=mask-icon href=https://qfsyso.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://qfsyso.github.io/posts/kubernetes-k8s/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://qfsyso.github.io/posts/kubernetes-k8s/"><meta property="og:site_name" content="MLOG"><meta property="og:title" content="Kubernetes k8s"><meta property="og:description" content="Kubernetes k8s 描述什么是Kubernetes 描述Kubernetes的基本架构及核心概念 描述Kubernetes的应用编排方法 使用华为云CCE创建简单工作负载
容器编排技术 容器（如Docker）以及周边生态系统提供了很多工具来实现容器生命周期管理，能够满足在单台宿主机管理容器的需求。但越来越多企业开始使用容器，对容器技术的进一步发展提出了以下新的诉求： □高效的容器管理及编排。 □容器的跨主机部署及调度。 □容器的存储、网络、运维、安全等能力的拓展。 统一的容器编排管理工具
容器编排的价值 容器编排是指自动化容器的部署、管理、扩展和联网，可为企业带来以下价值： 灵活的资源管理及调度 自动化部署及服务发现 高效的监控及运维 弹性扩展及高可用
大规模容器集群管理工具，从Borg到Kubernetes ·Kubernetes起源于Google内部的Borg项目，它对计算资源进行了更高层次的抽象，通过将容器进行细致的组合，将最终的应用服务交给用户。它的目标是管理大规模的容器，提供基本的部署、维护以及应用伸缩等功能，其主要实现语言为Go语言。 ·Kubernetes作为容器集群管理工具，于2015年7月22日迭代到v1.0并正式对外公布。与此同时，谷歌联合Linux基金会及其他合作伙伴共同成立了CNCF基金会（CloudNativeComputingFoundation），并将Kuberentes作为首个编入CNCF管理体系的开源项目，助力容器技术生态的发展进步。
Kubernetes架构 ·一个基础的Kubernetes集群（Cluster）通常包含一个Master节点和多个Node节点。每个节点可以是一台物理机，也可以是一台虚拟机。
pod最小容器（container）
Kubernetes核心概念-Pod Pod是Kubernetes中最重要最基本的概念，Pod是Kubernetes最小工作单元。每一个Pod包含一个或多个相关容器，Kubernetes将Pod看做一个整体进行调度。 引入Pod的目的： 将联系紧密的容器封装在一个Pod单元内，以Pod整体进行调度、扩展和实现生命周期管理。 Pod内所有容器使用相同的网络Namespace和共享存储。即Pod内容器拥有相同IP地址和Port空间，容器间直接使用localhost通信。当挂载volume到Pod，即可实现将volume挂载到Pod中的每个容器。
Kubernetes核心概念-Controller ·工作负载是在Pod之上的一层抽象，我们可以通过控制器（controller）实现一系列基于Pod的高级特性，比如节点故障时Pod的自动迁移，Pod多副本横向扩展，应用滚动升级等。我们通常使用controller来做应用的真正的管理，而Pod是组成工作负载最小的单元
Kubernetes核心概念-Label ·当资源变得非常多的时候，如何分类管理就非常重要了，Kubernetes提供了一种机制来为资源分类，那就是Label（标签）。Label非常简单，但是却很强大，Kubernetes中几乎所有资源都可以用Label来组织。Label的具体形式是key-value的标记对，可以在创建资源的时候设置，也可以在后期添加和修改。
Kubernetes核心概念-Namespace ·命名空间（Namespace）是对一组资源和对象的抽象整合。在同一个集群内可创建不同的命名空间，不同命名空间中的数据彼此隔离。使得它们既可以共享同一个集群的服务，也能够互不干扰。 kube-public kube-system kube-node-lease default
Kubernetes核心概念-Service ·在Kubernetes中，Pod副本发生迁移或者伸缩的时候会发生变化，IP也是变化的。Kubernetes中的Service是一种抽象概念，它定义了一个Pod逻辑集合以及访问它们的策略。Service定义了外界访问一组特定Pod的方式。Service有自己的IP和端口，Service为Pod提供了负载均衡。
Kubernetes核心概念-Volume ·Volume用来管理Kubernetes存储，是用来声明在Pod中的容器可以访问的文件目录，含义如下： 声明在Pod中的容器可以访问的文件目录。 可以被挂载在Pod中一个或多个容器的指定路径下。 支持多种后端存储（本地存储、分布式存储、云存储等）。
Kubernetes管理-Kubectl ·Kubectl是Kubernetes的命令行工具。通过kubectl，用户能对集群进行管理，并在集群上进行容器化应用的安装部署。
Kubectl支持以下对象管理方式： 指令式：通过kubectl内置的驱动命令，如:kubectl +create/scale/delete/..+参数的形式， 直接快速创建、更新和删除Kubernetes对象。
声明式：使用kubectlapply创建指定目录中配置文件所定义的所有对象。通常，此配置文件 采用yaml进行描述。
Kubernetes管理-命令行语法 在Kubernetes中的很多操作都是用kubectl来完成，通过其命令可以管理Deployment、Replicaset、ReplicationController、Pod等，进行操作、扩容、删除等全生命周期操作，同时可以对管理对象进行查看或者监控资源使用情况。
kubectl的语法
kubectl [command] [TYPElNAME] [flags] Command：指定你希望进行的操作，如create，get，describe，delete等。 TYPE：指定操作对象的类型，如deployment，pod，service等。 hiPnNAME：指定对象的名字。hidhwyun flags:可选的标志位。
Kubernetes管理-yaml示例 ·kubernetes中的对象可以使用YAML描述（如果您对YAML格式不了解，可以参考YAML语法少，也可以使用JSON。其内容可以分为如下四个部分： typeMeta：对象类型的元信息，声明对象使用哪个API版本，哪个类型的对象。 objectMeta：对象的元信息，包括对象名称、使用的标签等。 spec：对象的期望状态，例如对象使用什么镜像、有多少副本等。 status：对象的实际状态，只能在对象创建后看到，创建对象时无需指定。"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-06-06T00:54:55+08:00"><meta property="article:modified_time" content="2025-06-06T00:54:55+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Kubernetes k8s"><meta name=twitter:description content="Kubernetes k8s 描述什么是Kubernetes 描述Kubernetes的基本架构及核心概念 描述Kubernetes的应用编排方法 使用华为云CCE创建简单工作负载
容器编排技术 容器（如Docker）以及周边生态系统提供了很多工具来实现容器生命周期管理，能够满足在单台宿主机管理容器的需求。但越来越多企业开始使用容器，对容器技术的进一步发展提出了以下新的诉求： □高效的容器管理及编排。 □容器的跨主机部署及调度。 □容器的存储、网络、运维、安全等能力的拓展。 统一的容器编排管理工具
容器编排的价值 容器编排是指自动化容器的部署、管理、扩展和联网，可为企业带来以下价值： 灵活的资源管理及调度 自动化部署及服务发现 高效的监控及运维 弹性扩展及高可用
大规模容器集群管理工具，从Borg到Kubernetes ·Kubernetes起源于Google内部的Borg项目，它对计算资源进行了更高层次的抽象，通过将容器进行细致的组合，将最终的应用服务交给用户。它的目标是管理大规模的容器，提供基本的部署、维护以及应用伸缩等功能，其主要实现语言为Go语言。 ·Kubernetes作为容器集群管理工具，于2015年7月22日迭代到v1.0并正式对外公布。与此同时，谷歌联合Linux基金会及其他合作伙伴共同成立了CNCF基金会（CloudNativeComputingFoundation），并将Kuberentes作为首个编入CNCF管理体系的开源项目，助力容器技术生态的发展进步。
Kubernetes架构 ·一个基础的Kubernetes集群（Cluster）通常包含一个Master节点和多个Node节点。每个节点可以是一台物理机，也可以是一台虚拟机。
pod最小容器（container）
Kubernetes核心概念-Pod Pod是Kubernetes中最重要最基本的概念，Pod是Kubernetes最小工作单元。每一个Pod包含一个或多个相关容器，Kubernetes将Pod看做一个整体进行调度。 引入Pod的目的： 将联系紧密的容器封装在一个Pod单元内，以Pod整体进行调度、扩展和实现生命周期管理。 Pod内所有容器使用相同的网络Namespace和共享存储。即Pod内容器拥有相同IP地址和Port空间，容器间直接使用localhost通信。当挂载volume到Pod，即可实现将volume挂载到Pod中的每个容器。
Kubernetes核心概念-Controller ·工作负载是在Pod之上的一层抽象，我们可以通过控制器（controller）实现一系列基于Pod的高级特性，比如节点故障时Pod的自动迁移，Pod多副本横向扩展，应用滚动升级等。我们通常使用controller来做应用的真正的管理，而Pod是组成工作负载最小的单元
Kubernetes核心概念-Label ·当资源变得非常多的时候，如何分类管理就非常重要了，Kubernetes提供了一种机制来为资源分类，那就是Label（标签）。Label非常简单，但是却很强大，Kubernetes中几乎所有资源都可以用Label来组织。Label的具体形式是key-value的标记对，可以在创建资源的时候设置，也可以在后期添加和修改。
Kubernetes核心概念-Namespace ·命名空间（Namespace）是对一组资源和对象的抽象整合。在同一个集群内可创建不同的命名空间，不同命名空间中的数据彼此隔离。使得它们既可以共享同一个集群的服务，也能够互不干扰。 kube-public kube-system kube-node-lease default
Kubernetes核心概念-Service ·在Kubernetes中，Pod副本发生迁移或者伸缩的时候会发生变化，IP也是变化的。Kubernetes中的Service是一种抽象概念，它定义了一个Pod逻辑集合以及访问它们的策略。Service定义了外界访问一组特定Pod的方式。Service有自己的IP和端口，Service为Pod提供了负载均衡。
Kubernetes核心概念-Volume ·Volume用来管理Kubernetes存储，是用来声明在Pod中的容器可以访问的文件目录，含义如下： 声明在Pod中的容器可以访问的文件目录。 可以被挂载在Pod中一个或多个容器的指定路径下。 支持多种后端存储（本地存储、分布式存储、云存储等）。
Kubernetes管理-Kubectl ·Kubectl是Kubernetes的命令行工具。通过kubectl，用户能对集群进行管理，并在集群上进行容器化应用的安装部署。
Kubectl支持以下对象管理方式： 指令式：通过kubectl内置的驱动命令，如:kubectl +create/scale/delete/..+参数的形式， 直接快速创建、更新和删除Kubernetes对象。
声明式：使用kubectlapply创建指定目录中配置文件所定义的所有对象。通常，此配置文件 采用yaml进行描述。
Kubernetes管理-命令行语法 在Kubernetes中的很多操作都是用kubectl来完成，通过其命令可以管理Deployment、Replicaset、ReplicationController、Pod等，进行操作、扩容、删除等全生命周期操作，同时可以对管理对象进行查看或者监控资源使用情况。
kubectl的语法
kubectl [command] [TYPElNAME] [flags] Command：指定你希望进行的操作，如create，get，describe，delete等。 TYPE：指定操作对象的类型，如deployment，pod，service等。 hiPnNAME：指定对象的名字。hidhwyun flags:可选的标志位。
Kubernetes管理-yaml示例 ·kubernetes中的对象可以使用YAML描述（如果您对YAML格式不了解，可以参考YAML语法少，也可以使用JSON。其内容可以分为如下四个部分： typeMeta：对象类型的元信息，声明对象使用哪个API版本，哪个类型的对象。 objectMeta：对象的元信息，包括对象名称、使用的标签等。 spec：对象的期望状态，例如对象使用什么镜像、有多少副本等。 status：对象的实际状态，只能在对象创建后看到，创建对象时无需指定。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://qfsyso.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Kubernetes k8s","item":"https://qfsyso.github.io/posts/kubernetes-k8s/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Kubernetes k8s","name":"Kubernetes k8s","description":"Kubernetes k8s 描述什么是Kubernetes 描述Kubernetes的基本架构及核心概念 描述Kubernetes的应用编排方法 使用华为云CCE创建简单工作负载\n容器编排技术 容器（如Docker）以及周边生态系统提供了很多工具来实现容器生命周期管理，能够满足在单台宿主机管理容器的需求。但越来越多企业开始使用容器，对容器技术的进一步发展提出了以下新的诉求： □高效的容器管理及编排。 □容器的跨主机部署及调度。 □容器的存储、网络、运维、安全等能力的拓展。 统一的容器编排管理工具\n容器编排的价值 容器编排是指自动化容器的部署、管理、扩展和联网，可为企业带来以下价值： 灵活的资源管理及调度 自动化部署及服务发现 高效的监控及运维 弹性扩展及高可用\n大规模容器集群管理工具，从Borg到Kubernetes ·Kubernetes起源于Google内部的Borg项目，它对计算资源进行了更高层次的抽象，通过将容器进行细致的组合，将最终的应用服务交给用户。它的目标是管理大规模的容器，提供基本的部署、维护以及应用伸缩等功能，其主要实现语言为Go语言。 ·Kubernetes作为容器集群管理工具，于2015年7月22日迭代到v1.0并正式对外公布。与此同时，谷歌联合Linux基金会及其他合作伙伴共同成立了CNCF基金会（CloudNativeComputingFoundation），并将Kuberentes作为首个编入CNCF管理体系的开源项目，助力容器技术生态的发展进步。\nKubernetes架构 ·一个基础的Kubernetes集群（Cluster）通常包含一个Master节点和多个Node节点。每个节点可以是一台物理机，也可以是一台虚拟机。\npod最小容器（container）\nKubernetes核心概念-Pod Pod是Kubernetes中最重要最基本的概念，Pod是Kubernetes最小工作单元。每一个Pod包含一个或多个相关容器，Kubernetes将Pod看做一个整体进行调度。 引入Pod的目的： 将联系紧密的容器封装在一个Pod单元内，以Pod整体进行调度、扩展和实现生命周期管理。 Pod内所有容器使用相同的网络Namespace和共享存储。即Pod内容器拥有相同IP地址和Port空间，容器间直接使用localhost通信。当挂载volume到Pod，即可实现将volume挂载到Pod中的每个容器。\nKubernetes核心概念-Controller ·工作负载是在Pod之上的一层抽象，我们可以通过控制器（controller）实现一系列基于Pod的高级特性，比如节点故障时Pod的自动迁移，Pod多副本横向扩展，应用滚动升级等。我们通常使用controller来做应用的真正的管理，而Pod是组成工作负载最小的单元\nKubernetes核心概念-Label ·当资源变得非常多的时候，如何分类管理就非常重要了，Kubernetes提供了一种机制来为资源分类，那就是Label（标签）。Label非常简单，但是却很强大，Kubernetes中几乎所有资源都可以用Label来组织。Label的具体形式是key-value的标记对，可以在创建资源的时候设置，也可以在后期添加和修改。\nKubernetes核心概念-Namespace ·命名空间（Namespace）是对一组资源和对象的抽象整合。在同一个集群内可创建不同的命名空间，不同命名空间中的数据彼此隔离。使得它们既可以共享同一个集群的服务，也能够互不干扰。 kube-public kube-system kube-node-lease default\nKubernetes核心概念-Service ·在Kubernetes中，Pod副本发生迁移或者伸缩的时候会发生变化，IP也是变化的。Kubernetes中的Service是一种抽象概念，它定义了一个Pod逻辑集合以及访问它们的策略。Service定义了外界访问一组特定Pod的方式。Service有自己的IP和端口，Service为Pod提供了负载均衡。\nKubernetes核心概念-Volume ·Volume用来管理Kubernetes存储，是用来声明在Pod中的容器可以访问的文件目录，含义如下： 声明在Pod中的容器可以访问的文件目录。 可以被挂载在Pod中一个或多个容器的指定路径下。 支持多种后端存储（本地存储、分布式存储、云存储等）。\nKubernetes管理-Kubectl ·Kubectl是Kubernetes的命令行工具。通过kubectl，用户能对集群进行管理，并在集群上进行容器化应用的安装部署。\nKubectl支持以下对象管理方式： 指令式：通过kubectl内置的驱动命令，如:kubectl +create/scale/delete/..+参数的形式， 直接快速创建、更新和删除Kubernetes对象。\n声明式：使用kubectlapply创建指定目录中配置文件所定义的所有对象。通常，此配置文件 采用yaml进行描述。\nKubernetes管理-命令行语法 在Kubernetes中的很多操作都是用kubectl来完成，通过其命令可以管理Deployment、Replicaset、ReplicationController、Pod等，进行操作、扩容、删除等全生命周期操作，同时可以对管理对象进行查看或者监控资源使用情况。\nkubectl的语法\nkubectl [command] [TYPElNAME] [flags] Command：指定你希望进行的操作，如create，get，describe，delete等。 TYPE：指定操作对象的类型，如deployment，pod，service等。 hiPnNAME：指定对象的名字。hidhwyun flags:可选的标志位。\nKubernetes管理-yaml示例 ·kubernetes中的对象可以使用YAML描述（如果您对YAML格式不了解，可以参考YAML语法少，也可以使用JSON。其内容可以分为如下四个部分： typeMeta：对象类型的元信息，声明对象使用哪个API版本，哪个类型的对象。 objectMeta：对象的元信息，包括对象名称、使用的标签等。 spec：对象的期望状态，例如对象使用什么镜像、有多少副本等。 status：对象的实际状态，只能在对象创建后看到，创建对象时无需指定。","keywords":[],"articleBody":"Kubernetes k8s 描述什么是Kubernetes 描述Kubernetes的基本架构及核心概念 描述Kubernetes的应用编排方法 使用华为云CCE创建简单工作负载\n容器编排技术 容器（如Docker）以及周边生态系统提供了很多工具来实现容器生命周期管理，能够满足在单台宿主机管理容器的需求。但越来越多企业开始使用容器，对容器技术的进一步发展提出了以下新的诉求： □高效的容器管理及编排。 □容器的跨主机部署及调度。 □容器的存储、网络、运维、安全等能力的拓展。 统一的容器编排管理工具\n容器编排的价值 容器编排是指自动化容器的部署、管理、扩展和联网，可为企业带来以下价值： 灵活的资源管理及调度 自动化部署及服务发现 高效的监控及运维 弹性扩展及高可用\n大规模容器集群管理工具，从Borg到Kubernetes ·Kubernetes起源于Google内部的Borg项目，它对计算资源进行了更高层次的抽象，通过将容器进行细致的组合，将最终的应用服务交给用户。它的目标是管理大规模的容器，提供基本的部署、维护以及应用伸缩等功能，其主要实现语言为Go语言。 ·Kubernetes作为容器集群管理工具，于2015年7月22日迭代到v1.0并正式对外公布。与此同时，谷歌联合Linux基金会及其他合作伙伴共同成立了CNCF基金会（CloudNativeComputingFoundation），并将Kuberentes作为首个编入CNCF管理体系的开源项目，助力容器技术生态的发展进步。\nKubernetes架构 ·一个基础的Kubernetes集群（Cluster）通常包含一个Master节点和多个Node节点。每个节点可以是一台物理机，也可以是一台虚拟机。\npod最小容器（container）\nKubernetes核心概念-Pod Pod是Kubernetes中最重要最基本的概念，Pod是Kubernetes最小工作单元。每一个Pod包含一个或多个相关容器，Kubernetes将Pod看做一个整体进行调度。 引入Pod的目的： 将联系紧密的容器封装在一个Pod单元内，以Pod整体进行调度、扩展和实现生命周期管理。 Pod内所有容器使用相同的网络Namespace和共享存储。即Pod内容器拥有相同IP地址和Port空间，容器间直接使用localhost通信。当挂载volume到Pod，即可实现将volume挂载到Pod中的每个容器。\nKubernetes核心概念-Controller ·工作负载是在Pod之上的一层抽象，我们可以通过控制器（controller）实现一系列基于Pod的高级特性，比如节点故障时Pod的自动迁移，Pod多副本横向扩展，应用滚动升级等。我们通常使用controller来做应用的真正的管理，而Pod是组成工作负载最小的单元\nKubernetes核心概念-Label ·当资源变得非常多的时候，如何分类管理就非常重要了，Kubernetes提供了一种机制来为资源分类，那就是Label（标签）。Label非常简单，但是却很强大，Kubernetes中几乎所有资源都可以用Label来组织。Label的具体形式是key-value的标记对，可以在创建资源的时候设置，也可以在后期添加和修改。\nKubernetes核心概念-Namespace ·命名空间（Namespace）是对一组资源和对象的抽象整合。在同一个集群内可创建不同的命名空间，不同命名空间中的数据彼此隔离。使得它们既可以共享同一个集群的服务，也能够互不干扰。 kube-public kube-system kube-node-lease default\nKubernetes核心概念-Service ·在Kubernetes中，Pod副本发生迁移或者伸缩的时候会发生变化，IP也是变化的。Kubernetes中的Service是一种抽象概念，它定义了一个Pod逻辑集合以及访问它们的策略。Service定义了外界访问一组特定Pod的方式。Service有自己的IP和端口，Service为Pod提供了负载均衡。\nKubernetes核心概念-Volume ·Volume用来管理Kubernetes存储，是用来声明在Pod中的容器可以访问的文件目录，含义如下： 声明在Pod中的容器可以访问的文件目录。 可以被挂载在Pod中一个或多个容器的指定路径下。 支持多种后端存储（本地存储、分布式存储、云存储等）。\nKubernetes管理-Kubectl ·Kubectl是Kubernetes的命令行工具。通过kubectl，用户能对集群进行管理，并在集群上进行容器化应用的安装部署。\nKubectl支持以下对象管理方式： 指令式：通过kubectl内置的驱动命令，如:kubectl +create/scale/delete/..+参数的形式， 直接快速创建、更新和删除Kubernetes对象。\n声明式：使用kubectlapply创建指定目录中配置文件所定义的所有对象。通常，此配置文件 采用yaml进行描述。\nKubernetes管理-命令行语法 在Kubernetes中的很多操作都是用kubectl来完成，通过其命令可以管理Deployment、Replicaset、ReplicationController、Pod等，进行操作、扩容、删除等全生命周期操作，同时可以对管理对象进行查看或者监控资源使用情况。\nkubectl的语法\nkubectl [command] [TYPElNAME] [flags] Command：指定你希望进行的操作，如create，get，describe，delete等。 TYPE：指定操作对象的类型，如deployment，pod，service等。 hiPnNAME：指定对象的名字。hidhwyun flags:可选的标志位。\nKubernetes管理-yaml示例 ·kubernetes中的对象可以使用YAML描述（如果您对YAML格式不了解，可以参考YAML语法少，也可以使用JSON。其内容可以分为如下四个部分： typeMeta：对象类型的元信息，声明对象使用哪个API版本，哪个类型的对象。 objectMeta：对象的元信息，包括对象名称、使用的标签等。 spec：对象的期望状态，例如对象使用什么镜像、有多少副本等。 status：对象的实际状态，只能在对象创建后看到，创建对象时无需指定。\napiVersion: apps/v1 kind: Deployment metadata: name: nginx labels: app: nginx spec: selector: matchLabels: app: nginx replicas: 3 template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:alpine resources: requests: cpu: 100m memory: 200Mi limits: cpu: 100m memory: 200Mi imagePullSecrets: - name: default-secret status: {} Kubernetes应用编排-工作负载类型 无状态工作负载：管理的Pod集合是相互等价的，需要的时候可以被替换。 Deployment ReplicaSet\n有状态工作负载：为每个Pod维护了一个唯一的ID，能够保证Pod的顺序性和唯一性，每个Pod是不 可替代的。可使用持久存储来保存服务产生的状态。 StatefulSet\n守护进程工作负载：保证每个节点上运行着这样一个守护进程。 DaemonSet\n批处理工作负载：一次性的任务 Job CronJob 事件调度\nDeployment概述 Deployment是一组不具有唯一标识的多个Pod的集合。一个Deployment可以包含一个或多个Pod副本，每个Pod副本的角色相同，通过Service为Deployment的多个Pod副本分发请求。 Deployment具备以下功能: 确保集群中有期望数量的Pod运行。 提供多种升级策略以及一键回滚能力。 提供暂停/恢复的能力。\n典型使用场景： WebServer等无状态应用。\n特征： 在Deployment中，所有Pod地位都是平等的，当一个Pod因故障被替换后，新的容器与其余所有Pod依然相同，因此无论请求发送到哪个Pod，返回的结果都是一致的。或者 Pod被删除后，里面的数据也随之消失。这种特性一般称其为“无状态”。\nDeployment管理-使用命令行创建Deployment 创建一个简单的deployment:\nkubectl create deployment mydep--image=nginx --replicas=3 使用如下语句查看deployment的创建情况：\nkubectl get deployment 回显 NAME\tREADY\tUP-TO-DATE\tAVAILABLE\tAGE mydep\t1/1\t1\t1\t2m3s\nDeployment管理-使用yaml创建Deployment （更多） 创建一个yaml文件：\nvi nginx.yaml 从yaml文件创建deployment:\nkubectl apply -f nginx.yaml 查看创建结果：\nkubectl get deployment Deployment管理-副本管理 ·扩容/缩容Deployment指增加或减少它的副本数。最 简单的方式是更新其yaml中的replicas字段。 ·Deployment的副本机制是通过ReplicaSet实现的。\nDeployment管理-应用升级 ·在实际应用中，升级是一个常见的场景，Deployment能够很方便的支撑应用升级。 Deployment可以设置不同的升级策略，有如下两种。 RollingUpdate：滚动升级，即逐步创建新Pod再删除日Pod，为默认策略。 Recreate：替换升级，即先把当前Pod删掉再重新创建Pod。\nDeployment的升级方式：\nkubectl edit deploy/nginx kubectl set image deploy/nginx nginx=nginx:1.9.1 kubectl apply -f nginx.yaml 查看Deployment滚动更新情况/历史:\nkubectl rollout status deploy/nginx kubectl rollout history deploy/nginx 修改完成后再查询ReplicaSet和Pod，发现创建了一个新的ReplicaSet，Pod也重新创建了。\nDeployment管理-应用回滚 ·回滚也称为回退，即当发现升级出现问题时，让应用回到老的版本。Deployment可以非常方便的回滚到老版本。 Deployment回滚：\nkubectl rollout undo deployment/nginx --to-revision=2 #不指定的话默认回滚到上一个版本 Deployment之所以能如此容易的做到回滚，是因为Deployment是通过ReplicaSet控制Pod的，升级后先前的ReplicaSet仍然存在，Deployment回滚做的就是使用之前的ReplicaSet再次把Pod创建出来。\nStatefulSet-创建有状态应用 创建HeadlessService，服务没有固定IP，通过DNS可以将请求直接发送至Pod。 创建StatefulSet，用于有序的Pod管理。 PVC用于提供稳定持久的存储。如果后端用动态方式可以不用预先创建PV，否则需要在准备阶段完成PV创建工作。\nStatefulSet-创建Headless服务 ·创建Headless服务需注意以下几点： 服务名称和StatefulSet中的定义一致; 选择器要指向正确的Pod标签； 指定clusterIP：None。 …创建步骤： □编辑headless.yaml，创建Headless Service:\n$ vi headless.yaml $ kubectl create -f headless.yaml 查询Service:\n$ kubectl get svc apiVersion: v1 kind: Service metadata: name: nginx labels: app: nginx spec: ports: - name: nginx port: 80 selector: app: nginx clusterIP: None hidhw StatefulSet-创建StatefulSet(1)\n·创建一个yaml文件，后从yaml文件创建StatefulSet:\nvi web.yaml kubectl apply -f web.yaml idhwjen创建完成后，可看到Pod名称按序号排序：\nkubectl get pod apiVersion: apps/v1 kind: StatefulSet metadata: name: web spec: # 保持原有内容不变... template: # 保持原有内容不变... volumeClaimTemplates: - metadata: name: www annotations: everest.io/disk-volume-type: SAS spec: accessModes: - ReadWriteOnce resources: requests: storage: 1Gi storageClassName: csi-disk 后台已创建三个PVC，名称相同，以序号排序，依次和PV做绑定\nkubectl get PVC 使用nslookup查看DNS记录，可以看到对该服务的访问直接指向Pod\nStatefulSet-副本管理 ·扩容/缩容StatefulSet指增加或减少它的副本数。这可以 通过更新replicas字段完成。 当缩容StatefulSet时，可以看到Pod停止的顺序为从序号最高的开始降序终止，并且只有在前一个pod被完全终止后，下一个才开始终止。升级时，也是以相同顺序处理。 StatefulSet的副本管理由StatefulSet控制器实现的。这一点可通过查看对应Pod的ownerReference字段查看。\nDaemonSet概述 ·DaemonSet是这样一种对象（守护进程），它在集群的每个节点上运行个Pod，且保证只有一个Pod，“这非常适合一些系统层面的应 用，例如日志收集、资源监控等，这类应用需要每个节点都运行，且不需要太多实例，一个比较好的例子就是Kubernetes的kube-proxy。 DaemonSet跟节点相关,“如果节点异常，也不会在其他节点重新创建。它具备以下特点： 确保每一个节点或者期望的节点（通过nodeSelector实现）上运行一个Pod。 新增节点时自动部署一个Pod。 移除节点时自动删除Pod。\nDaemonSet管理-创建DaemonSet ·通过yaml创建DaemonSet的方式与创建Deployment的方式相似，区别在于： □kind选择DaemonSet。不需要规定replicas项。 DaemonSet创建完成后可以在Node1和Node2上分别看到一个pod:\nkubectl get pod -o wide apiVersion: apps/v1 kind: DaemonSet metadata: name: nginx-daemonset spec: selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.7.9 ports: - containerPort: 80 DaemonSet管理-使用DaemonSet 如将其中一个pod强制删除，DaemonSet会自动启动一个新的pod\nJobs概述 ·Jobs主要处理一些短暂的一次性任务，并具备以下特点\n保证指定数量Pod成功运行结束。 支持并发执行。 支持错误自动重试。 支持暂停/恢复Jobs。\n·典型使用场景： 计算以及训练任务，如批量计算，A训练任务等。\nCronJob概述 ·CronJob主要处理周期性或者重复性的任务： 基于Crontab格式的时间调度。\n可以暂停/恢复CronJob。 ·典型的使用场景： 周期性的数据分析服务。 口周期性的资源回收服务。\nJob-创建Job ·Job执行一次性任务： kind：选择Job。 completions：当前的任务需要执行的Pod数量。 parallelism：表示最多有多少个并发执行的任务。 restartPolicy:只能选择Never或OnFailure。 backoffLimit：参数指定job失败后进行重试的次数。\napiVersion: batch/v1 kind: Job metadata: name: pi spec: completions: 1 parallelism: 1 template: spec: containers: - name: pi image: perl:latest command: [\"perl\", \"-Mbignum=bpi\", \"-wle\", \"print bpi(2000)\"] restartPolicy: OnFailure backoffLimit: 4 kubectl get job CronoJob管理-创建CronJob ·CronJob是一种特殊的Job，它能够按照时间对任 务进行调度，与我们熟悉的crontab非常相似。 我们可以使用Cron格式快速指定任务的调度时间： 在给定时间点只运行一次。 在给定时间点周期性地运行。 min\thour\tday\tmonth\tdayofweek\napiVersion: batch/v1beta1 kind: CronJob metadata: name: pi spec: schedule: \"*/1 * * * *\" jobTemplate: spec: completions: 3 parallelism: 1 template: spec: containers: - name: pi image: perl command: [\"perl\", \"-Mbignum=bpi\", \"-wle\", \"print bpi(2000)\"] restartPolicy: OnFailure kubectl get cronjob --watch kubectl get job --watch 云容器引|擎（Cloud Container Engine，简称CCE） CCE集群：丰富异构、高性能、安全、统一调度的容器基础设施产品\n可以通过CCE控制台、Kubectl命令行、KubernetesAPI使用云容器引l擎服务。\n使用IAM账号需要授权\n创建集群 CCE集群 Turbo集群 鯤鹏集群\n部署工作负载 选择镜像部署 选择模板部署 YAML部署\n云容器引|擎CCE支持通过CloudShell或kubectl客户端主机的方式连接和管理CCE集群。\nTest KubernetesMaster节点包含组件 kube-scheduler etcd\n2ubernetes的管理对象，从小到大的管理逻辑为 容器","wordCount":"1587","inLanguage":"en","datePublished":"2025-06-06T00:54:55+08:00","dateModified":"2025-06-06T00:54:55+08:00","author":{"@type":"Person","name":"dwd"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://qfsyso.github.io/posts/kubernetes-k8s/"},"publisher":{"@type":"Organization","name":"MLOG","logo":{"@type":"ImageObject","url":"https://qfsyso.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://qfsyso.github.io/ accesskey=h title="MLOG (Alt + H)">MLOG</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://qfsyso.github.io/posts/ title=Archive><span>Archive</span></a></li><li><a href=https://qfsyso.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://qfsyso.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Kubernetes k8s</h1><div class=post-meta><span title='2025-06-06 00:54:55 +0800 +0800'>June 6, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;dwd</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#kubernetes-k8s aria-label="Kubernetes k8s">Kubernetes k8s</a><ul><li><a href=#%e5%ae%b9%e5%99%a8%e7%bc%96%e6%8e%92%e6%8a%80%e6%9c%af aria-label=容器编排技术>容器编排技术</a></li><li><a href=#%e5%ae%b9%e5%99%a8%e7%bc%96%e6%8e%92%e7%9a%84%e4%bb%b7%e5%80%bc aria-label=容器编排的价值>容器编排的价值</a></li><li><a href=#%e5%a4%a7%e8%a7%84%e6%a8%a1%e5%ae%b9%e5%99%a8%e9%9b%86%e7%be%a4%e7%ae%a1%e7%90%86%e5%b7%a5%e5%85%b7%e4%bb%8eborg%e5%88%b0kubernetes aria-label=大规模容器集群管理工具，从Borg到Kubernetes>大规模容器集群管理工具，从Borg到Kubernetes</a></li><li><a href=#kubernetes%e6%9e%b6%e6%9e%84 aria-label=Kubernetes架构>Kubernetes架构</a></li><li><a href=#kubernetes%e6%a0%b8%e5%bf%83%e6%a6%82%e5%bf%b5-pod aria-label=Kubernetes核心概念-Pod>Kubernetes核心概念-Pod</a></li><li><a href=#kubernetes%e6%a0%b8%e5%bf%83%e6%a6%82%e5%bf%b5-controller aria-label=Kubernetes核心概念-Controller>Kubernetes核心概念-Controller</a></li><li><a href=#kubernetes%e6%a0%b8%e5%bf%83%e6%a6%82%e5%bf%b5-label aria-label=Kubernetes核心概念-Label>Kubernetes核心概念-Label</a></li><li><a href=#kubernetes%e6%a0%b8%e5%bf%83%e6%a6%82%e5%bf%b5-namespace aria-label=Kubernetes核心概念-Namespace>Kubernetes核心概念-Namespace</a></li><li><a href=#kubernetes%e6%a0%b8%e5%bf%83%e6%a6%82%e5%bf%b5-service aria-label=Kubernetes核心概念-Service>Kubernetes核心概念-Service</a></li><li><a href=#kubernetes%e6%a0%b8%e5%bf%83%e6%a6%82%e5%bf%b5-volume aria-label=Kubernetes核心概念-Volume>Kubernetes核心概念-Volume</a></li><li><a href=#kubernetes%e7%ae%a1%e7%90%86-kubectl aria-label=Kubernetes管理-Kubectl>Kubernetes管理-Kubectl</a><ul><li><a href=#kubectl%e6%94%af%e6%8c%81%e4%bb%a5%e4%b8%8b%e5%af%b9%e8%b1%a1%e7%ae%a1%e7%90%86%e6%96%b9%e5%bc%8f aria-label=Kubectl支持以下对象管理方式：>Kubectl支持以下对象管理方式：</a></li><li><a href=#kubernetes%e7%ae%a1%e7%90%86-%e5%91%bd%e4%bb%a4%e8%a1%8c%e8%af%ad%e6%b3%95 aria-label=Kubernetes管理-命令行语法>Kubernetes管理-命令行语法</a></li><li><a href=#kubernetes%e7%ae%a1%e7%90%86-yaml%e7%a4%ba%e4%be%8b aria-label=Kubernetes管理-yaml示例>Kubernetes管理-yaml示例</a></li><li><a href=#kubernetes%e5%ba%94%e7%94%a8%e7%bc%96%e6%8e%92-%e5%b7%a5%e4%bd%9c%e8%b4%9f%e8%bd%bd%e7%b1%bb%e5%9e%8b aria-label=Kubernetes应用编排-工作负载类型>Kubernetes应用编排-工作负载类型</a></li><li><a href=#deployment%e6%a6%82%e8%bf%b0 aria-label=Deployment概述>Deployment概述</a></li><li><a href=#deployment%e7%ae%a1%e7%90%86-%e4%bd%bf%e7%94%a8%e5%91%bd%e4%bb%a4%e8%a1%8c%e5%88%9b%e5%bb%badeployment aria-label=Deployment管理-使用命令行创建Deployment>Deployment管理-使用命令行创建Deployment</a></li><li><a href=#deployment%e7%ae%a1%e7%90%86-%e4%bd%bf%e7%94%a8yaml%e5%88%9b%e5%bb%badeployment-%e6%9b%b4%e5%a4%9a aria-label="Deployment管理-使用yaml创建Deployment （更多）">Deployment管理-使用yaml创建Deployment （更多）</a></li><li><a href=#deployment%e7%ae%a1%e7%90%86-%e5%89%af%e6%9c%ac%e7%ae%a1%e7%90%86 aria-label=Deployment管理-副本管理>Deployment管理-副本管理</a></li><li><a href=#deployment%e7%ae%a1%e7%90%86-%e5%ba%94%e7%94%a8%e5%8d%87%e7%ba%a7 aria-label=Deployment管理-应用升级>Deployment管理-应用升级</a></li><li><a href=#statefulset-%e5%88%9b%e5%bb%ba%e6%9c%89%e7%8a%b6%e6%80%81%e5%ba%94%e7%94%a8 aria-label=StatefulSet-创建有状态应用>StatefulSet-创建有状态应用</a></li><li><a href=#statefulset-%e5%88%9b%e5%bb%baheadless%e6%9c%8d%e5%8a%a1 aria-label=StatefulSet-创建Headless服务>StatefulSet-创建Headless服务</a></li><li><a href=#hidhw aria-label=hidhw>hidhw</a></li><li><a href=#daemonset%e6%a6%82%e8%bf%b0 aria-label=DaemonSet概述>DaemonSet概述</a></li><li><a href=#daemonset%e7%ae%a1%e7%90%86-%e5%88%9b%e5%bb%badaemonset aria-label=DaemonSet管理-创建DaemonSet>DaemonSet管理-创建DaemonSet</a></li><li><a href=#jobs%e6%a6%82%e8%bf%b0 aria-label=Jobs概述>Jobs概述</a></li><li><a href=#cronjob%e6%a6%82%e8%bf%b0 aria-label=CronJob概述>CronJob概述</a></li><li><a href=#job-%e5%88%9b%e5%bb%bajob aria-label=Job-创建Job>Job-创建Job</a></li><li><a href=#%e4%ba%91%e5%ae%b9%e5%99%a8%e5%bc%95%e6%93%8ecloud-container-engine%e7%ae%80%e7%a7%b0cce aria-label="云容器引|擎（Cloud Container Engine，简称CCE）">云容器引|擎（Cloud Container Engine，简称CCE）</a></li></ul></li><li><a href=#test aria-label=Test>Test</a></li></ul></li><li><a href=#%e7%8e%af%e5%a2%83%e6%90%ad%e5%bb%ba%e4%b8%8e-kubernetes-%e7%bb%84%e4%bb%b6%e5%ae%9e%e6%93%8d%e6%8c%87%e5%8d%97 aria-label="环境搭建与 Kubernetes 组件实操指南">环境搭建与 Kubernetes 组件实操指南</a><ul><ul><li><a href=#11-%e8%b4%ad%e4%b9%b0%e4%ba%91%e5%ae%b9%e5%99%a8%e5%bc%95%e6%93%8e%e6%9c%8d%e5%8a%a1-cce aria-label="1.1 购买云容器引擎服务 CCE">1.1 购买云容器引擎服务 CCE</a></li><li><a href=#12-%e8%b4%ad%e4%b9%b0%e5%bc%b9%e6%80%a7%e4%ba%91%e6%9c%8d%e5%8a%a1%e5%99%a8 aria-label="1.2 购买弹性云服务器">1.2 购买弹性云服务器</a></li><li><a href=#13-%e7%99%bb%e5%bd%95%e5%bc%b9%e6%80%a7%e4%ba%91%e6%9c%8d%e5%8a%a1%e5%99%a8 aria-label="1.3 登录弹性云服务器">1.3 登录弹性云服务器</a></li><li><a href=#14-%e5%ae%89%e8%a3%85-kubernetes-%e5%ae%a2%e6%88%b7%e7%ab%afkubectl aria-label="1.4 安装 Kubernetes 客户端（kubectl）">1.4 安装 Kubernetes 客户端（kubectl）</a></li><li><a href=#15-%e4%bd%bf%e7%94%a8-kubectl-%e5%b8%ae%e5%8a%a9%e5%91%bd%e4%bb%a4 aria-label="1.5 使用 kubectl 帮助命令">1.5 使用 kubectl 帮助命令</a></li><li><a href=#21-%e6%9f%a5%e7%9c%8b-kubernetes-%e7%8a%b6%e6%80%81 aria-label="2.1 查看 Kubernetes 状态">2.1 查看 Kubernetes 状态</a></li><li><a href=#31-%e8%bf%90%e8%a1%8c%e7%ac%ac%e4%b8%80%e4%b8%aa-deployment aria-label="3.1 运行第一个 Deployment">3.1 运行第一个 Deployment</a></li><li><a href=#32-%e4%bd%bf%e7%94%a8-kubectl-%e5%91%bd%e4%bb%a4%e8%a1%8c%e5%b7%a5%e5%85%b7%e6%9f%a5%e7%9c%8b%e5%af%b9%e8%b1%a1 aria-label="3.2 使用 kubectl 命令行工具查看对象">3.2 使用 kubectl 命令行工具查看对象</a></li><li><a href=#33-%e5%88%9b%e5%bb%ba%e8%87%aa%e5%ae%9a%e4%b9%89-deployment aria-label="3.3 创建自定义 Deployment">3.3 创建自定义 Deployment</a></li><li><a href=#34-%e5%bc%b9%e6%80%a7%e4%bc%b8%e7%bc%a9-deployment aria-label="3.4 弹性伸缩 Deployment">3.4 弹性伸缩 Deployment</a></li><li><a href=#41-%e4%bd%bf%e7%94%a8-daemonset aria-label="4.1 使用 DaemonSet">4.1 使用 DaemonSet</a></li><li><a href=#42-daemonset-%e8%87%aa%e5%8a%a8%e6%81%a2%e5%a4%8d aria-label="4.2 DaemonSet 自动恢复">4.2 DaemonSet 自动恢复</a></li></ul></ul></li><li><a href=#cce-k8s%e7%bd%91%e7%bb%9c%e4%b8%8e%e6%8c%81%e4%b9%85%e5%8c%96%e5%ad%98%e5%82%a8 aria-label="CCE K8s网络与持久化存储">CCE K8s网络与持久化存储</a><ul><li><a href=#cri-cni-csi aria-label="CRI CNI CSI">CRI CNI CSI</a></li><li><a href=#loadbalancer%e6%a8%a1%e5%9e%8b aria-label=LoadBalancer模型>LoadBalancer模型</a></li><li><a href=#ingress%e6%a6%82%e8%bf%b0 aria-label=Ingress概述>Ingress概述</a></li><li><a href=#k8s%e5%ad%98%e5%82%a8%e7%ae%a1%e7%90%86 aria-label=K8s存储管理>K8s存储管理</a><ul><li><a href=#volume%e6%a6%82%e8%bf%b0 aria-label=Volume概述>Volume概述</a></li><li><a href=#volume%e7%b1%bb%e5%9e%8b aria-label=Volume类型>Volume类型</a></li><li><a href=#volume%e7%ae%a1%e7%90%86 aria-label=Volume管理>Volume管理</a></li><li><a href=#emptydir%e7%ae%80%e4%bb%8b aria-label=EmptyDir简介>EmptyDir简介</a></li><li><a href=#hostpath%e7%ae%80%e4%bb%8b aria-label=HostPath简介>HostPath简介</a></li><li><a href=#configmap%e7%ae%80%e4%bb%8b aria-label=ConfigMap简介>ConfigMap简介</a></li><li><a href=#secret%e7%ae%80%e4%bb%8b aria-label=Secret简介>Secret简介</a></li><li><a href=#pvpvcsc%e6%a6%82%e5%bf%b5%e4%bb%8b%e7%bb%8d aria-label=PV/PVC/SC概念介绍>PV/PVC/SC概念介绍</a></li><li><a href=#pv%e5%92%8cpvc%e5%88%9b%e5%bb%ba%e5%92%8c%e7%bb%91%e5%ae%9a aria-label=PV和PVC创建和绑定>PV和PVC创建和绑定</a></li><li><a href=#%e4%bb%80%e4%b9%88%e6%98%af%e4%ba%91%e5%ae%b9%e5%99%a8%e5%bc%95%e6%93%8ecce aria-label=什么是云容器引擎CCE>什么是云容器引擎CCE</a></li><li><a href=#cce%e4%b8%8ekubernetes%e5%85%b3%e7%b3%bb aria-label=CCE与Kubernetes关系>CCE与Kubernetes关系</a></li></ul></li></ul></li><li><a href=#cce-%e5%8f%8a-kubernetes-%e7%8e%af%e5%a2%83%e6%90%ad%e5%bb%ba%e4%b8%8e%e9%85%8d%e7%bd%ae aria-label="CCE 及 Kubernetes 环境搭建与配置">CCE 及 Kubernetes 环境搭建与配置</a><ul><li><a href=#1%e5%88%9b%e5%bb%bacce%e9%9b%86%e7%be%a4 aria-label=1.创建CCE集群>1.创建CCE集群</a></li><li><a href=#21-%e7%99%bb%e5%bd%95%e5%bc%b9%e6%80%a7%e4%ba%91%e6%9c%8d%e5%8a%a1%e5%99%a8ecs aria-label="2.1 登录弹性云服务器ECS">2.1 登录弹性云服务器ECS</a></li><li><a href=#22-%e4%b8%8b%e8%bd%bdkubectl%e9%85%8d%e7%bd%ae aria-label="2.2 下载kubectl配置">2.2 下载kubectl配置</a></li><li><a href=#23-%e9%85%8d%e7%bd%aekubeconfig aria-label="2.3 配置kubeconfig">2.3 配置kubeconfig</a></li><li><a href=#24-%e9%aa%8c%e8%af%81%e5%ae%89%e8%a3%85 aria-label="2.4 验证安装">2.4 验证安装</a></li><li><a href=#31-node%e4%b8%8epod%e9%80%9a%e4%bf%a1 aria-label="3.1 Node与Pod通信">3.1 Node与Pod通信</a></li><li><a href=#32-pod%e9%97%b4%e9%80%9a%e4%bf%a1 aria-label="3.2 Pod间通信">3.2 Pod间通信</a></li><li><a href=#41-%e4%bd%bf%e7%94%a8emptydir aria-label="4.1 使用emptyDir">4.1 使用emptyDir</a></li><li><a href=#42-emptydir%e5%ae%b9%e9%87%8f%e9%99%90%e5%88%b6 aria-label="4.2 emptyDir容量限制">4.2 emptyDir容量限制</a></li><li><a href=#43-%e4%bd%bf%e7%94%a8hostpath aria-label="4.3 使用hostPath">4.3 使用hostPath</a></li><li><a href=#51-%e5%88%9b%e5%bb%baheadless-service aria-label="5.1 创建Headless Service">5.1 创建Headless Service</a></li><li><a href=#52-%e9%83%a8%e7%bd%b2statefulset aria-label="5.2 部署StatefulSet">5.2 部署StatefulSet</a></li><li><a href=#53-%e9%aa%8c%e8%af%81pod-dns aria-label="5.3 验证Pod DNS">5.3 验证Pod DNS</a></li><li><a href=#54-statefulset%e6%95%b0%e6%8d%ae%e6%8c%81%e4%b9%85%e5%8c%96 aria-label="5.4 StatefulSet数据持久化">5.4 StatefulSet数据持久化</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=kubernetes-k8s>Kubernetes k8s<a hidden class=anchor aria-hidden=true href=#kubernetes-k8s>#</a></h1><p>描述什么是Kubernetes
描述Kubernetes的基本架构及核心概念
描述Kubernetes的应用编排方法
使用华为云CCE创建简单工作负载</p><h2 id=容器编排技术>容器编排技术<a hidden class=anchor aria-hidden=true href=#容器编排技术>#</a></h2><p>容器（如Docker）以及周边生态系统提供了很多工具来实现容器生命周期管理，能够满足在单台宿主机管理容器的需求。但越来越多企业开始使用容器，对容器技术的进一步发展提出了以下新的诉求：
□高效的容器管理及编排。
□容器的跨主机部署及调度。
□容器的存储、网络、运维、安全等能力的拓展。
统一的容器编排管理工具</p><h2 id=容器编排的价值>容器编排的价值<a hidden class=anchor aria-hidden=true href=#容器编排的价值>#</a></h2><p>容器编排是指自动化容器的部署、管理、扩展和联网，可为企业带来以下价值：
灵活的资源管理及调度
自动化部署及服务发现
高效的监控及运维
弹性扩展及高可用</p><h2 id=大规模容器集群管理工具从borg到kubernetes>大规模容器集群管理工具，从Borg到Kubernetes<a hidden class=anchor aria-hidden=true href=#大规模容器集群管理工具从borg到kubernetes>#</a></h2><p>·Kubernetes起源于Google内部的Borg项目，它对计算资源进行了更高层次的抽象，通过将容器进行细致的组合，将最终的应用服务交给用户。它的目标是管理大规模的容器，提供基本的部署、维护以及应用伸缩等功能，其主要实现语言为Go语言。
·Kubernetes作为容器集群管理工具，于2015年7月22日迭代到v1.0并正式对外公布。与此同时，谷歌联合Linux基金会及其他合作伙伴共同成立了CNCF基金会（CloudNativeComputingFoundation），并将Kuberentes作为首个编入CNCF管理体系的开源项目，助力容器技术生态的发展进步。</p><h2 id=kubernetes架构>Kubernetes架构<a hidden class=anchor aria-hidden=true href=#kubernetes架构>#</a></h2><p>·一个基础的Kubernetes集群（Cluster）通常包含一个Master节点和多个Node节点。每个节点可以是一台物理机，也可以是一台虚拟机。</p><p>pod最小容器（container）</p><h2 id=kubernetes核心概念-pod>Kubernetes核心概念-Pod<a hidden class=anchor aria-hidden=true href=#kubernetes核心概念-pod>#</a></h2><p>Pod是Kubernetes中最重要最基本的概念，Pod是Kubernetes最小工作单元。每一个Pod包含一个或多个相关容器，Kubernetes将Pod看做一个整体进行调度。
引入Pod的目的：
将联系紧密的容器封装在一个Pod单元内，以Pod整体进行调度、扩展和实现生命周期管理。
Pod内所有容器使用相同的网络Namespace和共享存储。即Pod内容器拥有相同IP地址和Port空间，容器间直接使用localhost通信。当挂载volume到Pod，即可实现将volume挂载到Pod中的每个容器。</p><h2 id=kubernetes核心概念-controller>Kubernetes核心概念-Controller<a hidden class=anchor aria-hidden=true href=#kubernetes核心概念-controller>#</a></h2><p>·工作负载是在Pod之上的一层抽象，我们可以通过控制器（controller）实现一系列基于Pod的高级特性，比如节点故障时Pod的自动迁移，Pod多副本横向扩展，应用滚动升级等。我们通常使用controller来做应用的真正的管理，而Pod是组成工作负载最小的单元</p><h2 id=kubernetes核心概念-label>Kubernetes核心概念-Label<a hidden class=anchor aria-hidden=true href=#kubernetes核心概念-label>#</a></h2><p>·当资源变得非常多的时候，如何分类管理就非常重要了，Kubernetes提供了一种机制来为资源分类，那就是Label（标签）。Label非常简单，但是却很强大，Kubernetes中几乎所有资源都可以用Label来组织。Label的具体形式是key-value的标记对，可以在创建资源的时候设置，也可以在后期添加和修改。</p><h2 id=kubernetes核心概念-namespace>Kubernetes核心概念-Namespace<a hidden class=anchor aria-hidden=true href=#kubernetes核心概念-namespace>#</a></h2><p>·命名空间（Namespace）是对一组资源和对象的抽象整合。在同一个集群内可创建不同的命名空间，不同命名空间中的数据彼此隔离。使得它们既可以共享同一个集群的服务，也能够互不干扰。
kube-public kube-system kube-node-lease default</p><h2 id=kubernetes核心概念-service>Kubernetes核心概念-Service<a hidden class=anchor aria-hidden=true href=#kubernetes核心概念-service>#</a></h2><p>·在Kubernetes中，Pod副本发生迁移或者伸缩的时候会发生变化，IP也是变化的。Kubernetes中的Service是一种抽象概念，它定义了一个Pod逻辑集合以及访问它们的策略。Service定义了外界访问一组特定Pod的方式。Service有自己的IP和端口，Service为Pod提供了负载均衡。</p><h2 id=kubernetes核心概念-volume>Kubernetes核心概念-Volume<a hidden class=anchor aria-hidden=true href=#kubernetes核心概念-volume>#</a></h2><p>·Volume用来管理Kubernetes存储，是用来声明在Pod中的容器可以访问的文件目录，含义如下：
声明在Pod中的容器可以访问的文件目录。
可以被挂载在Pod中一个或多个容器的指定路径下。
支持多种后端存储（本地存储、分布式存储、云存储等）。</p><h2 id=kubernetes管理-kubectl>Kubernetes管理-Kubectl<a hidden class=anchor aria-hidden=true href=#kubernetes管理-kubectl>#</a></h2><p>·Kubectl是Kubernetes的命令行工具。通过kubectl，用户能对集群进行管理，并在集群上进行容器化应用的安装部署。</p><h3 id=kubectl支持以下对象管理方式>Kubectl支持以下对象管理方式：<a hidden class=anchor aria-hidden=true href=#kubectl支持以下对象管理方式>#</a></h3><p>指令式：通过kubectl内置的驱动命令，如:kubectl +create/scale/delete/..+参数的形式，
直接快速创建、更新和删除Kubernetes对象。</p><p>声明式：使用kubectlapply创建指定目录中配置文件所定义的所有对象。通常，此配置文件
采用yaml进行描述。</p><h3 id=kubernetes管理-命令行语法>Kubernetes管理-命令行语法<a hidden class=anchor aria-hidden=true href=#kubernetes管理-命令行语法>#</a></h3><p>在Kubernetes中的很多操作都是用kubectl来完成，通过其命令可以管理Deployment、Replicaset、ReplicationController、Pod等，进行操作、扩容、删除等全生命周期操作，同时可以对管理对象进行查看或者监控资源使用情况。</p><p>kubectl的语法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl <span style=color:#f92672>[</span>command<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>TYPElNAME<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>flags<span style=color:#f92672>]</span>
</span></span></code></pre></div><p>Command：指定你希望进行的操作，如create，get，describe，delete等。
TYPE：指定操作对象的类型，如deployment，pod，service等。
hiPnNAME：指定对象的名字。hidhwyun
flags:可选的标志位。</p><h3 id=kubernetes管理-yaml示例>Kubernetes管理-yaml示例<a hidden class=anchor aria-hidden=true href=#kubernetes管理-yaml示例>#</a></h3><p>·kubernetes中的对象可以使用YAML描述（如果您对YAML格式不了解，可以参考YAML语法少，也可以使用JSON。其内容可以分为如下四个部分：
typeMeta：对象类型的元信息，声明对象使用哪个API版本，哪个类型的对象。
objectMeta：对象的元信息，包括对象名称、使用的标签等。
spec：对象的期望状态，例如对象使用什么镜像、有多少副本等。
status：对象的实际状态，只能在对象创建后看到，创建对象时无需指定。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>
</span></span><span style=display:flex><span>apiVersion: apps/v1
</span></span><span style=display:flex><span>kind: Deployment
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: nginx
</span></span><span style=display:flex><span>  labels:
</span></span><span style=display:flex><span>    app: nginx
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  selector:
</span></span><span style=display:flex><span>    matchLabels:
</span></span><span style=display:flex><span>      app: nginx
</span></span><span style=display:flex><span>  replicas: <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>  template:
</span></span><span style=display:flex><span>    metadata:
</span></span><span style=display:flex><span>      labels:
</span></span><span style=display:flex><span>        app: nginx
</span></span><span style=display:flex><span>    spec:
</span></span><span style=display:flex><span>      containers:
</span></span><span style=display:flex><span>      - name: nginx
</span></span><span style=display:flex><span>        image: nginx:alpine
</span></span><span style=display:flex><span>        resources:
</span></span><span style=display:flex><span>          requests:
</span></span><span style=display:flex><span>            cpu: 100m
</span></span><span style=display:flex><span>            memory: 200Mi
</span></span><span style=display:flex><span>          limits:
</span></span><span style=display:flex><span>            cpu: 100m
</span></span><span style=display:flex><span>            memory: 200Mi
</span></span><span style=display:flex><span>      imagePullSecrets:
</span></span><span style=display:flex><span>      - name: default-secret
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>status: <span style=color:#f92672>{}</span>
</span></span></code></pre></div><h3 id=kubernetes应用编排-工作负载类型>Kubernetes应用编排-工作负载类型<a hidden class=anchor aria-hidden=true href=#kubernetes应用编排-工作负载类型>#</a></h3><p>无状态工作负载：管理的Pod集合是相互等价的，需要的时候可以被替换。
Deployment
ReplicaSet</p><p>有状态工作负载：为每个Pod维护了一个唯一的ID，能够保证Pod的顺序性和唯一性，每个Pod是不
可替代的。可使用持久存储来保存服务产生的状态。
StatefulSet</p><p>守护进程工作负载：保证每个节点上运行着这样一个守护进程。
DaemonSet</p><p>批处理工作负载：一次性的任务
Job
CronJob 事件调度</p><h3 id=deployment概述>Deployment概述<a hidden class=anchor aria-hidden=true href=#deployment概述>#</a></h3><p>Deployment是一组不具有唯一标识的多个Pod的集合。一个Deployment可以包含一个或多个Pod副本，每个Pod副本的角色相同，通过Service为Deployment的多个Pod副本分发请求。
Deployment具备以下功能:
确保集群中有期望数量的Pod运行。
提供多种升级策略以及一键回滚能力。
提供暂停/恢复的能力。</p><p>典型使用场景：
WebServer等无状态应用。</p><p>特征：
在Deployment中，所有Pod地位都是平等的，当一个Pod因故障被替换后，新的容器与其余所有Pod依然相同，因此无论请求发送到哪个Pod，返回的结果都是一致的。或者
Pod被删除后，里面的数据也随之消失。这种特性一般称其为“无状态”。</p><h3 id=deployment管理-使用命令行创建deployment>Deployment管理-使用命令行创建Deployment<a hidden class=anchor aria-hidden=true href=#deployment管理-使用命令行创建deployment>#</a></h3><p>创建一个简单的deployment:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl create deployment mydep--image<span style=color:#f92672>=</span>nginx --replicas<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span>
</span></span></code></pre></div><p>使用如下语句查看deployment的创建情况：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get deployment
</span></span></code></pre></div><p>回显
NAME READY UP-TO-DATE AVAILABLE AGE
mydep 1/1 1 1 2m3s</p><h3 id=deployment管理-使用yaml创建deployment-更多>Deployment管理-使用yaml创建Deployment （更多）<a hidden class=anchor aria-hidden=true href=#deployment管理-使用yaml创建deployment-更多>#</a></h3><p>创建一个yaml文件：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>vi nginx.yaml
</span></span></code></pre></div><p>从yaml文件创建deployment:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span> kubectl apply -f nginx.yaml
</span></span></code></pre></div><p>查看创建结果：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get deployment
</span></span></code></pre></div><h3 id=deployment管理-副本管理>Deployment管理-副本管理<a hidden class=anchor aria-hidden=true href=#deployment管理-副本管理>#</a></h3><p>·扩容/缩容Deployment指增加或减少它的副本数。最
简单的方式是更新其yaml中的replicas字段。
·Deployment的副本机制是通过ReplicaSet实现的。</p><h3 id=deployment管理-应用升级>Deployment管理-应用升级<a hidden class=anchor aria-hidden=true href=#deployment管理-应用升级>#</a></h3><p>·在实际应用中，升级是一个常见的场景，Deployment能够很方便的支撑应用升级。
Deployment可以设置不同的升级策略，有如下两种。
RollingUpdate：滚动升级，即逐步创建新Pod再删除日Pod，为默认策略。
Recreate：替换升级，即先把当前Pod删掉再重新创建Pod。</p><p>Deployment的升级方式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl edit deploy/nginx
</span></span><span style=display:flex><span>kubectl set image deploy/nginx nginx<span style=color:#f92672>=</span>nginx:1.9.1
</span></span><span style=display:flex><span>kubectl apply -f nginx.yaml
</span></span></code></pre></div><p>查看Deployment滚动更新情况/历史:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span> kubectl rollout status deploy/nginx
</span></span><span style=display:flex><span> kubectl rollout history deploy/nginx
</span></span></code></pre></div><p>修改完成后再查询ReplicaSet和Pod，发现创建了一个新的ReplicaSet，Pod也重新创建了。</p><p>Deployment管理-应用回滚
·回滚也称为回退，即当发现升级出现问题时，让应用回到老的版本。Deployment可以非常方便的回滚到老版本。
Deployment回滚：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl rollout undo deployment/nginx --to-revision<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#不指定的话默认回滚到上一个版本</span>
</span></span></code></pre></div><p>Deployment之所以能如此容易的做到回滚，是因为Deployment是通过ReplicaSet控制Pod的，升级后先前的ReplicaSet仍然存在，Deployment回滚做的就是使用之前的ReplicaSet再次把Pod创建出来。</p><h3 id=statefulset-创建有状态应用>StatefulSet-创建有状态应用<a hidden class=anchor aria-hidden=true href=#statefulset-创建有状态应用>#</a></h3><p>创建HeadlessService，服务没有固定IP，通过DNS可以将请求直接发送至Pod。
创建StatefulSet，用于有序的Pod管理。
PVC用于提供稳定持久的存储。如果后端用动态方式可以不用预先创建PV，否则需要在准备阶段完成PV创建工作。</p><h3 id=statefulset-创建headless服务>StatefulSet-创建Headless服务<a hidden class=anchor aria-hidden=true href=#statefulset-创建headless服务>#</a></h3><p>·创建Headless服务需注意以下几点：
服务名称和StatefulSet中的定义一致;
选择器要指向正确的Pod标签；
指定clusterIP：None。
…创建步骤：
□编辑headless.yaml，创建Headless Service:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ vi headless.yaml
</span></span><span style=display:flex><span>$ kubectl create -f headless.yaml
</span></span></code></pre></div><p>查询Service:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl get svc
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Service</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>app</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>port</span>: <span style=color:#ae81ff>80</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>selector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>app</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>clusterIP</span>: <span style=color:#ae81ff>None</span>
</span></span></code></pre></div><h3 id=hidhw>hidhw<a hidden class=anchor aria-hidden=true href=#hidhw>#</a></h3><p>StatefulSet-创建StatefulSet(1)</p><p>·创建一个yaml文件，后从yaml文件创建StatefulSet:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span> vi web.yaml
</span></span><span style=display:flex><span> kubectl apply -f web.yaml
</span></span></code></pre></div><p>idhwjen创建完成后，可看到Pod名称按序号排序：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get pod
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>StatefulSet</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>web</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#75715e># 保持原有内容不变...</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e># 保持原有内容不变...</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>volumeClaimTemplates</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>www</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>annotations</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>everest.io/disk-volume-type</span>: <span style=color:#ae81ff>SAS</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>accessModes</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>ReadWriteOnce</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>resources</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>requests</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>storage</span>: <span style=color:#ae81ff>1Gi</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>storageClassName</span>: <span style=color:#ae81ff>csi-disk</span>
</span></span></code></pre></div><p>后台已创建三个PVC，名称相同，以序号排序，依次和PV做绑定</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get PVC
</span></span></code></pre></div><p>使用nslookup查看DNS记录，可以看到对该服务的访问直接指向Pod</p><p>StatefulSet-副本管理
·扩容/缩容StatefulSet指增加或减少它的副本数。这可以
通过更新replicas字段完成。
当缩容StatefulSet时，可以看到Pod停止的顺序为从序号最高的开始降序终止，并且只有在前一个pod被完全终止后，下一个才开始终止。升级时，也是以相同顺序处理。
StatefulSet的副本管理由StatefulSet控制器实现的。这一点可通过查看对应Pod的ownerReference字段查看。</p><h3 id=daemonset概述>DaemonSet概述<a hidden class=anchor aria-hidden=true href=#daemonset概述>#</a></h3><p>·DaemonSet是这样一种对象（守护进程），它在集群的每个节点上运行个Pod，且保证只有一个Pod，“这非常适合一些系统层面的应
用，例如日志收集、资源监控等，这类应用需要每个节点都运行，且不需要太多实例，一个比较好的例子就是Kubernetes的kube-proxy。
DaemonSet跟节点相关,“如果节点异常，也不会在其他节点重新创建。它具备以下特点：
确保每一个节点或者期望的节点（通过nodeSelector实现）上运行一个Pod。
新增节点时自动部署一个Pod。
移除节点时自动删除Pod。</p><h3 id=daemonset管理-创建daemonset>DaemonSet管理-创建DaemonSet<a hidden class=anchor aria-hidden=true href=#daemonset管理-创建daemonset>#</a></h3><p>·通过yaml创建DaemonSet的方式与创建Deployment的方式相似，区别在于：
□kind选择DaemonSet。不需要规定replicas项。
DaemonSet创建完成后可以在Node1和Node2上分别看到一个pod:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get pod -o wide
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>DaemonSet</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx-daemonset</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>selector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>matchLabels</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>app</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>app</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>image</span>: <span style=color:#ae81ff>nginx:1.7.9</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>containerPort</span>: <span style=color:#ae81ff>80</span>
</span></span></code></pre></div><p>DaemonSet管理-使用DaemonSet
如将其中一个pod强制删除，DaemonSet会自动启动一个新的pod</p><h3 id=jobs概述>Jobs概述<a hidden class=anchor aria-hidden=true href=#jobs概述>#</a></h3><p>·Jobs主要处理一些短暂的一次性任务，并具备以下特点</p><p>保证指定数量Pod成功运行结束。
支持并发执行。
支持错误自动重试。
支持暂停/恢复Jobs。</p><p>·典型使用场景：
计算以及训练任务，如批量计算，A训练任务等。</p><h3 id=cronjob概述>CronJob概述<a hidden class=anchor aria-hidden=true href=#cronjob概述>#</a></h3><p>·CronJob主要处理周期性或者重复性的任务：
基于Crontab格式的时间调度。</p><p>可以暂停/恢复CronJob。
·典型的使用场景：
周期性的数据分析服务。
口周期性的资源回收服务。</p><h3 id=job-创建job>Job-创建Job<a hidden class=anchor aria-hidden=true href=#job-创建job>#</a></h3><p>·Job执行一次性任务：
kind：选择Job。
completions：当前的任务需要执行的Pod数量。
parallelism：表示最多有多少个并发执行的任务。
restartPolicy:只能选择Never或OnFailure。
backoffLimit：参数指定job失败后进行重试的次数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>batch/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Job</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>pi</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>completions</span>: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>parallelism</span>: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>pi</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>image</span>: <span style=color:#ae81ff>perl:latest</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>command</span>: [<span style=color:#e6db74>&#34;perl&#34;</span>, <span style=color:#e6db74>&#34;-Mbignum=bpi&#34;</span>, <span style=color:#e6db74>&#34;-wle&#34;</span>, <span style=color:#e6db74>&#34;print bpi(2000)&#34;</span>]
</span></span><span style=display:flex><span>      <span style=color:#f92672>restartPolicy</span>: <span style=color:#ae81ff>OnFailure</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>backoffLimit</span>: <span style=color:#ae81ff>4</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get job
</span></span></code></pre></div><p>CronoJob管理-创建CronJob
·CronJob是一种特殊的Job，它能够按照时间对任
务进行调度，与我们熟悉的crontab非常相似。
我们可以使用Cron格式快速指定任务的调度时间：
在给定时间点只运行一次。
在给定时间点周期性地运行。
min hour day month dayofweek</p><hr><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>apiVersion: batch/v1beta1
</span></span><span style=display:flex><span>kind: CronJob
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: pi
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  schedule: <span style=color:#e6db74>&#34;*/1 * * * *&#34;</span> 
</span></span><span style=display:flex><span>  jobTemplate:
</span></span><span style=display:flex><span>    spec:
</span></span><span style=display:flex><span>      completions: <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>      parallelism: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>      template:
</span></span><span style=display:flex><span>        spec:
</span></span><span style=display:flex><span>          containers:
</span></span><span style=display:flex><span>          - name: pi
</span></span><span style=display:flex><span>            image: perl
</span></span><span style=display:flex><span>            command: <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;perl&#34;</span>, <span style=color:#e6db74>&#34;-Mbignum=bpi&#34;</span>, <span style=color:#e6db74>&#34;-wle&#34;</span>, <span style=color:#e6db74>&#34;print bpi(2000)&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>          restartPolicy: OnFailure
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get cronjob --watch
</span></span><span style=display:flex><span>kubectl get job --watch
</span></span></code></pre></div><h3 id=云容器引擎cloud-container-engine简称cce>云容器引|擎（Cloud Container Engine，简称CCE）<a hidden class=anchor aria-hidden=true href=#云容器引擎cloud-container-engine简称cce>#</a></h3><p>CCE集群：丰富异构、高性能、安全、统一调度的容器基础设施产品</p><p>可以通过CCE控制台、Kubectl命令行、KubernetesAPI使用云容器引l擎服务。</p><p>使用IAM账号需要授权</p><p>创建集群
CCE集群
Turbo集群
鯤鹏集群</p><p>部署工作负载
选择镜像部署
选择模板部署
YAML部署</p><p>云容器引|擎CCE支持通过CloudShell或kubectl客户端主机的方式连接和管理CCE集群。</p><h2 id=test>Test<a hidden class=anchor aria-hidden=true href=#test>#</a></h2><p>KubernetesMaster节点包含组件
kube-scheduler
etcd</p><p>2ubernetes的管理对象，从小到大的管理逻辑为
容器&lt;Pod&lt;ReplicaSet&lt;Deployment</p><h1 id=环境搭建与-kubernetes-组件实操指南>环境搭建与 Kubernetes 组件实操指南<a hidden class=anchor aria-hidden=true href=#环境搭建与-kubernetes-组件实操指南>#</a></h1><h3 id=11-购买云容器引擎服务-cce>1.1 购买云容器引擎服务 CCE<a hidden class=anchor aria-hidden=true href=#11-购买云容器引擎服务-cce>#</a></h3><p><strong>登录与进入控制台</strong>登录后，依次点击左侧菜单栏 “服务列表”→“容器”→“云容器引擎 CCE”，进入 CCE 控制台。</p><p><strong>创建 CCE Standard 集群</strong></p><ul><li><p>点击 “创建”，配置参数如下：</p><ul><li><strong>计费模式</strong>：按需计费</li><li><strong>集群名称</strong>：cce01</li><li><strong>集群版本</strong>：推荐版本</li><li><strong>集群规模</strong>：50 节点</li><li><strong>集群 master 实例数</strong>：单实例</li><li><strong>虚拟私有云</strong>：预置环境 VPC</li><li><strong>控制节点子网</strong>：预置子网（选 VPC 后可见）</li><li><strong>节点默认安全组</strong>：选择 “sg-hce” 并勾选声明</li><li><strong>网络模型</strong>：容器隧道网络</li><li><strong>容器网段</strong>：自动设置</li></ul></li><li><p>取消勾选 “云原生监控插件” 和 “云原生日志采集插件”，点击 “提交”。
<strong>创建节点</strong></p></li><li><p>集群创建完成后，点击 “创建节点”，配置参数：</p><ul><li><strong>计费模式</strong>：按需计费</li><li><strong>可用区</strong>：随机分配</li><li><strong>节点类型</strong>：弹性云服务器 - 虚拟机</li><li><strong>节点规格</strong>：c7.xlarge.2</li><li><strong>容器引擎</strong>：Containerd</li><li><strong>操作系统</strong>：EulerOS 2.9 5</li><li><strong>节点名称</strong>：cce01-node1</li><li><strong>系统盘 / 数据盘</strong>：高 IO 50G/100G</li><li><strong>弹性公网 IP</strong>：自动创建（5M 全动态 BGP）</li></ul></li><li><p>勾选协议后点击 “提交”，等待 3-5 分钟节点池创建完成。</p></li></ul><h3 id=12-购买弹性云服务器>1.2 购买弹性云服务器<a hidden class=anchor aria-hidden=true href=#12-购买弹性云服务器>#</a></h3><p><strong>进入 ECS 控制台</strong>点击左侧菜单栏 “服务列表”→“计算”→“弹性云服务器 ECS”。
2. <strong>购买 ECS 实例</strong></p><ul><li><p><strong>基础配置</strong>：</p><ul><li>计费模式：按需计费</li><li>区域：北京四</li><li>规格：通用计算增强型 c7.large.2（2vCPU/4GiB）</li><li>镜像：CentOS 7.6 64bit（10GB）</li><li>系统盘：高 IO 40G</li></ul></li><li><p><strong>网络配置</strong>：</p><ul><li><p>网络：与 CCE 集群同 VPC</p></li><li><p>安全组：sg-hce</p></li><li><p>弹性公网 IP：按流量计费（5MB）</p></li><li><p>名称：ecs-k8s</p></li></ul></li><li><p>确认配置后点击 “立即购买”，状态为 “运行中” 即创建完成。</p></li></ul><h3 id=13-登录弹性云服务器>1.3 登录弹性云服务器<a hidden class=anchor aria-hidden=true href=#13-登录弹性云服务器>#</a></h3><p><strong>安全组配置</strong></p><ul><li>进入 “安全组”，选择 “sg-hce”→“配置规则”→“入方向规则”→“一键放通常用端口”。
<strong>远程登录</strong></li><li>打开 “Xfce 终端”，输入命令（替换【EIP】为 ECS 公网 IP）：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ssh root@EIP
</span></span></code></pre></div><ul><li>输入 “yes” 接受密钥，输入创建 ECS 时设置的密码（输入不显示，回车确认）。</li></ul><h3 id=14-安装-kubernetes-客户端kubectl>1.4 安装 Kubernetes 客户端（kubectl）<a hidden class=anchor aria-hidden=true href=#14-安装-kubernetes-客户端kubectl>#</a></h3><p><strong>下载配置文件</strong></p><ul><li>进入 CCE 集群信息页面，在 “连接信息” 中点击 kubectl “配置”，选择有效期和 JSON 格式后下载 “kubeconfig.json”。</li><li>通过 scp 命令上传配置文件到 ECS：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>scp /home/user/Desktop/cce01-kubeconfig.json root@EIP:/root
</span></span></code></pre></div><p><strong>安装与配置 kubectl</strong></p><ul><li>登录 ECS 后执行以下命令：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cd <span style=color:#ae81ff>\~</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>wget https://sandbox-expriment-files.obs.cn-north-1.myhuaweicloud.com:443/20221021/kubernetes-client-linux-amd64.tar.gz
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>tar -zxvf kubernetes-client-linux-amd64.tar.gz
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cp /root/kubernetes/client/bin/kubectl /home/
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cp cce01-kubeconfig.json /home/
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cd /home
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>chmod +x kubectl
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mv kubectl /usr/local/bin
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mkdir <span style=color:#ae81ff>\$</span>HOME/.kube
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cp cce01-kubeconfig.json <span style=color:#ae81ff>\$</span>HOME/.kube/config
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl config use-context internal
</span></span></code></pre></div><p><strong>验证安装</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl cluster-info
</span></span></code></pre></div><p>回显
Kubernetes master is running at https://192.168.0.34:5443
CoreDNS is running at https://192.168.0.34:5443/api/v1/namespaces/kube-system/services/coredns:dns/proxy</p><h3 id=15-使用-kubectl-帮助命令>1.5 使用 kubectl 帮助命令<a hidden class=anchor aria-hidden=true href=#15-使用-kubectl-帮助命令>#</a></h3><ul><li>查看可用命令：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl --help
</span></span></code></pre></div><ul><li>查看具体命令说明（如 get 命令）：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get --help
</span></span></code></pre></div><p>二、Kubernetes 组件实操</p><h3 id=21-查看-kubernetes-状态>2.1 查看 Kubernetes 状态<a hidden class=anchor aria-hidden=true href=#21-查看-kubernetes-状态>#</a></h3><p><strong>查看节点状态</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get node
</span></span></code></pre></div><p><strong>查看命名空间</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get namespace
</span></span></code></pre></div><p><strong>创建 / 删除命名空间</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl create namespace new-namespace  <span style=color:#75715e># 创建</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl delete namespace new-namespace  <span style=color:#75715e># 删除</span>
</span></span></code></pre></div><p>三、Deployment 实验</p><h3 id=31-运行第一个-deployment>3.1 运行第一个 Deployment<a hidden class=anchor aria-hidden=true href=#31-运行第一个-deployment>#</a></h3><p><strong>创建 Deployment</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl create deployment mydep --image<span style=color:#f92672>=</span>nginx
</span></span></code></pre></div><p><strong>查看 Deployment</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get deploy
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl describe deployment mydep  <span style=color:#75715e># 详细信息</span>
</span></span></code></pre></div><p><strong>CCE 控制台验证</strong>：进入 “工作负载”→“无状态负载” 查看 mydep。</p><p>Kubernetes 资源-工作负载</p><h3 id=32-使用-kubectl-命令行工具查看对象>3.2 使用 kubectl 命令行工具查看对象<a hidden class=anchor aria-hidden=true href=#32-使用-kubectl-命令行工具查看对象>#</a></h3><ul><li>查看所有对象：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get all
</span></span></code></pre></div><ul><li>查看指定命名空间对象：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get all -n kube-system
</span></span></code></pre></div><ul><li>交互模式查看变化（按 Ctrl+C 退出）：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get deployment -w
</span></span></code></pre></div><ul><li>查看完整信息：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get deployment -o wide
</span></span></code></pre></div><h3 id=33-创建自定义-deployment>3.3 创建自定义 Deployment<a hidden class=anchor aria-hidden=true href=#33-创建自定义-deployment>#</a></h3><p><strong>创建配置文件目录</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cd /
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mkdir labfile/deployfile
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cd labfile/deployfile
</span></span></code></pre></div><p><strong>编写 nginx-deployment.yaml</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>apiVersion: apps/v1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kind: Deployment
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  name: nginx-deployment
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  labels:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    app: nginx
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  replicas: <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  selector:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    matchLabels:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      app: nginx
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  template:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    metadata:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      labels:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        app: nginx
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    spec:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      containers:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      name: nginx
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        image: nginx:1.7.9
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ports:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        containerPort: <span style=color:#ae81ff>80</span>
</span></span></code></pre></div><p><strong>部署与验证</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl apply -f nginx-deployment.yaml
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl get deployment/pod  <span style=color:#75715e># 等待2分钟查看Pod状态</span>
</span></span></code></pre></div><h3 id=34-弹性伸缩-deployment>3.4 弹性伸缩 Deployment<a hidden class=anchor aria-hidden=true href=#34-弹性伸缩-deployment>#</a></h3><p><strong>修改副本数</strong>：编辑 yaml 文件，将<code>replicas: 3</code>改为<code>replicas: 5</code>。</p><p><strong>应用变更</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl apply -f nginx-deployment.yaml
</span></span></code></pre></div><p><strong>验证 Pod 数量</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get pod
</span></span></code></pre></div><p><strong>删除 Deployment</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl delete deployment nginx-deployment
</span></span></code></pre></div><p>四、DaemonSet 实验</p><h3 id=41-使用-daemonset>4.1 使用 DaemonSet<a hidden class=anchor aria-hidden=true href=#41-使用-daemonset>#</a></h3><p><strong>创建配置文件目录</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mkdir /labfile/daemonfile
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cd /labfile/daemonfile
</span></span></code></pre></div><p><strong>编写 DaemonSet.yaml</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>apiVersion: apps/v1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kind: DaemonSet
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  name: nginx-daemonset
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  namespace: kube-system
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  labels:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    k8s-app: nginx-daemonset
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  selector:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    matchLabels:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      name: nginx-daemonset
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  template:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    metadata:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      labels:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        name: nginx-daemonset
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    spec:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      containers:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      name: nginx-daemonset
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        image: nginx:alpine
</span></span></code></pre></div><p><strong>部署与验证</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl apply -f DaemonSet.yaml
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl get daemonset/pod --namespace<span style=color:#f92672>=</span>kube-system  <span style=color:#75715e># 指定命名空间</span>
</span></span></code></pre></div><h3 id=42-daemonset-自动恢复>4.2 DaemonSet 自动恢复<a hidden class=anchor aria-hidden=true href=#42-daemonset-自动恢复>#</a></h3><p><strong>删除 Pod</strong>（替换【Pod 名称】为实际名称）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl delete pod 【Pod名称】 --namespace<span style=color:#f92672>=</span>kube-system
</span></span></code></pre></div><p><strong>验证自动恢复</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get pod --namespace<span style=color:#f92672>=</span>kube-system
</span></span></code></pre></div><p><strong>退出 ECS</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>exit
</span></span></code></pre></div><h1 id=cce-k8s网络与持久化存储>CCE K8s网络与持久化存储<a hidden class=anchor aria-hidden=true href=#cce-k8s网络与持久化存储>#</a></h1><p>描述Kubernetes的核心概念与架构掌握
通过Service访问Pod
掌握Kubernetes存储管理</p><h2 id=cri-cni-csi>CRI CNI CSI<a hidden class=anchor aria-hidden=true href=#cri-cni-csi>#</a></h2><p>runtime network storage</p><p>##Service管理-创建可供外部访问的Service NodePort
如果需要Service可供外部进行访问，可以使用NodePort的方式。
。编辑yaml文件时，添加type参数。
。可以在使用nodePort字段指定对外服务端口，如果不进行指定系统会自动分配空闲端口。
。访问时通过访问“节点IP地址:端口“进行服务使用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Service</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>httpd-svc</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>type</span>: <span style=color:#ae81ff>NodePort</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>selector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>app</span>: <span style=color:#ae81ff>httpd</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>protocol</span>: <span style=color:#ae81ff>TCP</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>port</span>: <span style=color:#ae81ff>8080</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>targetPort</span>: <span style=color:#ae81ff>80</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>nodePort</span>: <span style=color:#ae81ff>30144</span>
</span></span></code></pre></div><p>k get service</p><h2 id=loadbalancer模型>LoadBalancer模型<a hidden class=anchor aria-hidden=true href=#loadbalancer模型>#</a></h2><p>·负载均衡（LoadBalancer）
可以通过弹性负载均衡从公网访问到工作负载，与NodePort加公网IP的方式相比提供了高可靠的保障。
·LoadBalancerI此功能由集群外部负载均衡器提供商提供。</p><p>通过kubectl命令行创建Service的yaml配置示例
在创建工作负载时通过kubectl命令行设置Service访问方式。以nginx为例，说明kubectl命令实现负载均衡(LoadBalancer)访问的方法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Service</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>annotations</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>kubernetes.io/elb.id</span>: <span style=color:#e6db74>&#34;5083f225-9bf8-48fa-9c8b-67bd9693c4c0&#34;</span>  <span style=color:#75715e># ELBID，替换为实际值</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>kubernetes.io/elb.class</span>: <span style=color:#ae81ff>performance </span> <span style=color:#75715e># 负载均衡器类型</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>service0</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>port</span>: <span style=color:#ae81ff>80</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>protocol</span>: <span style=color:#ae81ff>TCP</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>targetPort</span>: <span style=color:#ae81ff>80</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>selector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>app</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>type</span>: <span style=color:#ae81ff>LoadBalancer</span>
</span></span></code></pre></div><h2 id=ingress概述>Ingress概述<a hidden class=anchor aria-hidden=true href=#ingress概述>#</a></h2><p>·Service是基于四层TCP和UDP协议转发的，而在实际使用场景中，四层Service无法满足应用层存在的大量HTTP/HTTPS访问需求，因此需要使用七层负载均衡（Ingress）来暴露服务。
·Ingress可基于七层的HTTP和HTTPS协议进行转发，它是Kubernetes集群中一种独立的资源，制定了集群外部访问流量的转发规则。这些转发规则可根据域名和路径进行自定义，IngressController根据这些规则将流量分配到一个或多个Service，完成对访问流量的细
粒度划分。</p><h2 id=k8s存储管理>K8s存储管理<a hidden class=anchor aria-hidden=true href=#k8s存储管理>#</a></h2><h3 id=volume概述>Volume概述<a hidden class=anchor aria-hidden=true href=#volume概述>#</a></h3><p>·Volume的核心是一个目录，其中可能存有数据，Pod中的容器可以访问该目录中的数据用户创建Volume时选择的卷类型将决定该目录如何形成，使用何种介质保存数据，以及规定目录中存放的内容。
Volume的生命周期与挂载它的Pod相同，但是Volume里面的文件可能在Volume消失后仍然存在，这取决于卷的类型。如当Pod不再存在时，Kubernetes也会销毁临时卷，但并不会销毁持久卷。</p><h3 id=volume类型>Volume类型<a hidden class=anchor aria-hidden=true href=#volume类型>#</a></h3><p>·Kubernetes支持多种卷类型，常用的类型有：
emptyDir：一种简单的空目录，主要用于临时存储。
hostPath：将主机（节点）某个目录挂载到容器中，适用于读取主机上的数据。
ConfigMap：特殊类型，将Kubernetes特定的对象类型挂载到容器。
wyunSecret：特殊类型，将Kubernetes特定的对象类型挂载到容器。
PVC:PersistentVolumeClaim，用来挂载PersistentVolume（持久化卷），提供可靠的存储来保存应用的持久化数据。</p><h3 id=volume管理>Volume管理<a hidden class=anchor aria-hidden=true href=#volume管理>#</a></h3><p>·Kubernetes的Volume是Pod的一部分，并不是单独的对象，不能独立创建，只能在Pod中定义。
·如hostPath类yaml示例，在.spec.containers[*].volumeMounts字段中声明卷在容器中的挂载位置；在.spec.volumes字段中设置为Pod提供的卷的信息。</p><p>创建hostPath类volume的yaml示例</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>test-pd</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>image</span>: <span style=color:#ae81ff>k8s.gcr.io/test-webserver</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>test-container</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>mountPath</span>: <span style=color:#ae81ff>/test-pd</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>name</span>: <span style=color:#ae81ff>test-volume</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>test-volume</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>hostPath</span>:
</span></span><span style=display:flex><span>        <span style=color:#75715e># 此字段根据volume类型可选</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>path</span>: <span style=color:#ae81ff>/data</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>type</span>: <span style=color:#ae81ff>Directory</span>
</span></span></code></pre></div><h3 id=emptydir简介>EmptyDir简介<a hidden class=anchor aria-hidden=true href=#emptydir简介>#</a></h3><p>·特征:
当Pod指定到某个节点上时，首先创建的是一个emptyDir卷，并且只要Pod在该节点上运行，卷就一直存在，卷最初是空的。尽管Pod中的容器挂载emptyDir卷的路径可能相同也可能不同，但是这些容器都可以读写emptyDir卷中相同的文件。当Pod因为某些原因被从节点上删除时，emptyDir卷中的数据也会永久删除。</p><h3 id=hostpath简介>HostPath简介<a hidden class=anchor aria-hidden=true href=#hostpath简介>#</a></h3><p>特征:
hostPath卷能将主机节点文件系统上的文件或目录挂载到Pod中。
·使用场景：
运行需要访问Docker内部文件的容器：使用/var/lib/docker的hostPath。
在容器中运行cAdvisora使用/sys/fs/cgroup的hostPathoyun
其他使用到宿主机文件的场景。</p><p>EmptyDir</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>image</span>: <span style=color:#ae81ff>nginx:alpine</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>test-container</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>mountPath</span>: <span style=color:#ae81ff>/cache</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>name</span>: <span style=color:#ae81ff>cache-volume</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>cache-volume</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>emptyDir</span>: {}
</span></span></code></pre></div><p>hostPath</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>test-hostpath</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>image</span>: <span style=color:#ae81ff>nginx:alpine</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>hostpath-container</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>mountPath</span>: <span style=color:#ae81ff>/test-pd</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>name</span>: <span style=color:#ae81ff>test-volume</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>test-volume</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>hostPath</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>path</span>: <span style=color:#ae81ff>/data</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># type 字段是可选的，可以根据需要添加，例如：</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># type: Directory</span>
</span></span></code></pre></div><h3 id=configmap简介>ConfigMap简介<a hidden class=anchor aria-hidden=true href=#configmap简介>#</a></h3><p>。特征:
ConfigMap用于容器的配置文件管理，在被Pod引l用前需单独定义。它作为多个properties文件的应用，类似一个专门存储配置文件的目录，里面存放着各种配置文件。
·应用场景：
ConfigMap最为常见的使用方式就是在环境变量和Volume中引l用，能够实现image和应用程序的配置文件、命令行参数和环境变量等信息解耦。</p><h3 id=secret简介>Secret简介<a hidden class=anchor aria-hidden=true href=#secret简介>#</a></h3><p>Secret是一种包含少量敏感信息例如密码、token或key的对象。
在创建、查看和编辑Pod的流程中Secret暴露风险较小。
·特征:
系统会对Secret对象采取额外的预防措施，例如避免将其写入磁盘。
只有Pod请求的Secret在其容器中才是可见的，一个Pod不能访问另一个Pod的Secret。hidhwyun
·应用场景：
Secret与ConfigMap非常像，都是key-value键值对形式，使用方式也相同，不同的是Secret会加密存储，所以适用于存储敏感信息。</p><h3 id=pvpvcsc概念介绍>PV/PVC/SC概念介绍<a hidden class=anchor aria-hidden=true href=#pvpvcsc概念介绍>#</a></h3><p>·PersistentVolume：持久化存储，简称PV，是Kubernetes对存储资源的抽象，属于集群资源，可以由管理员事先创建，或者使用存储类（StorageClass）实现动态供应。
·PersistentVolumeClaim：持久化存储声明，简称pvC，是用户对存储卷（Pv）的申请，属于Namespace中的资源。
StorageClass：存储类，简称sc，为管理员提供了描述存储“类”的方法，通过相应的存储插件（CSI）实现，可根据用户提出的PVC动态提供不同性质的PV。</p><h3 id=pv和pvc创建和绑定>PV和PVC创建和绑定<a hidden class=anchor aria-hidden=true href=#pv和pvc创建和绑定>#</a></h3><p>创建这个PV</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl create -f pv.yaml
</span></span><span style=display:flex><span>persistentvolume/pv-example created
</span></span></code></pre></div><p>创建PVC</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl create -f pvc.yaml
</span></span><span style=display:flex><span>persistentvolumeclaim/pvc-example created
</span></span></code></pre></div><p>PVC可以绑定一个PV</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>PersistentVolumeClaim</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>pvc-example</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>accessModes</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>ReadWriteMany</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>resources</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>requests</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>storage</span>: <span style=color:#ae81ff>10Gi </span> <span style=color:#75715e># 声明存储的大小</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>volumeName</span>: <span style=color:#ae81ff>pv-example </span> <span style=color:#75715e># PV的名称</span>
</span></span></code></pre></div><h3 id=什么是云容器引擎cce>什么是云容器引擎CCE<a hidden class=anchor aria-hidden=true href=#什么是云容器引擎cce>#</a></h3><p>·云容器引|擎（Cloud ContainerEngine，简称CCE），是基于开源Kubernetes、Docker技术的企业级容器服务。
·借助云容器引擎，用户可以在华为云上轻松部署、管理和扩展容器化应用程序。</p><h3 id=cce与kubernetes关系>CCE与Kubernetes关系<a hidden class=anchor aria-hidden=true href=#cce与kubernetes关系>#</a></h3><p>·云容器引擎（CloudContainerEngine，简称CCE）是基于开源Kubernetes的云服务产品，提供高度可扩展的、高性能的企业级Kubernetes集群，支持运行Docker容器的环境。借助云容器引擎，可以在华为云上轻松部署、管理和扩展容器化应用。
·华为云CCE是全球首批Kubernetes认证服务提供商（KubernetesCertifiedServiceProvider，KCSP），是国内最早投入Kubernetes社区的厂商，是容器开源社区主要贡献者和容器生态领导者
·华为也是CNCF云原生计算基金会的创始成员及白金会员，CCE是全球首批通过CNCF基金会的
Kubernetes一致性认证的容器服务。</p><h1 id=cce-及-kubernetes-环境搭建与配置>CCE 及 Kubernetes 环境搭建与配置<a hidden class=anchor aria-hidden=true href=#cce-及-kubernetes-环境搭建与配置>#</a></h1><p>已登录云控制台界面，鼠标移动到云桌面浏览器页面中左侧菜单栏，点击“服务列表”->“容器”->“云容器引擎CCE”，进入云容器引擎CCE控制台。</p><h2 id=1创建cce集群>1.创建CCE集群<a hidden class=anchor aria-hidden=true href=#1创建cce集群>#</a></h2><p>集群配置参数
集群类型：CCE Standard 集群</p><p>计费模式：按需计费</p><p>集群名称：cce01</p><p>集群版本：推荐版本</p><p>集群规模：50节点</p><p>集群masters实例数：单实例</p><p>虚拟私有云：选择预置VPC</p><p>控制节点子网：选择预置子网</p><p>节点默认安全组：保持默认</p><p>容器网络模型：容器隧道网络</p><p>容器网段：自动设置</p><p>操作步骤
点击“购买集群”按钮进入购买页面</p><p>取消所有插件勾选 → 点击“下一步：规格确认”</p><p>勾选“我已阅读并知晓上述使用说明” → 提交创建（耗时3-5分钟）</p><p>集群创建完成后点击“创建节点”</p><p>安装Kubernetes客户端</p><h2 id=21-登录弹性云服务器ecs>2.1 登录弹性云服务器ECS<a hidden class=anchor aria-hidden=true href=#21-登录弹性云服务器ecs>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ssh root@EIP  <span style=color:#75715e># 替换EIP为ecs-k8s公网IP</span>
</span></span></code></pre></div><h2 id=22-下载kubectl配置>2.2 下载kubectl配置<a hidden class=anchor aria-hidden=true href=#22-下载kubectl配置>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>wget https://dl.k8s.io/v1.28.8/kubernetes-client-linux-amd64.tar.gz
</span></span><span style=display:flex><span>tar -zxvf kubernetes-client-linux-amd64.tar.gz
</span></span><span style=display:flex><span>cp kubernetes/client/bin/kubectl /usr/local/bin/
</span></span></code></pre></div><h2 id=23-配置kubeconfig>2.3 配置kubeconfig<a hidden class=anchor aria-hidden=true href=#23-配置kubeconfig>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mkdir $HOME/.kube
</span></span><span style=display:flex><span>mv cce01-kubeconfig.yaml $HOME/.kube/config
</span></span><span style=display:flex><span>kubectl config use-context internal
</span></span></code></pre></div><h2 id=24-验证安装>2.4 验证安装<a hidden class=anchor aria-hidden=true href=#24-验证安装>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl cluster-info  <span style=color:#75715e># 成功显示集群信息</span>
</span></span></code></pre></div><p>Kubernetes网络</p><h2 id=31-node与pod通信>3.1 Node与Pod通信<a hidden class=anchor aria-hidden=true href=#31-node与pod通信>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl run nginx --image<span style=color:#f92672>=</span>nginx --port<span style=color:#f92672>=</span><span style=color:#ae81ff>80</span>  <span style=color:#75715e># 创建nginx Pod</span>
</span></span><span style=display:flex><span>kubectl get pods -o wide                   <span style=color:#75715e># 记录Pod IP</span>
</span></span><span style=display:flex><span>ssh cce01-node1-IP                         <span style=color:#75715e># 登录CCE节点</span>
</span></span><span style=display:flex><span>curl Pod-IP                                <span style=color:#75715e># 验证节点与Pod通信</span>
</span></span></code></pre></div><h2 id=32-pod间通信>3.2 Pod间通信<a hidden class=anchor aria-hidden=true href=#32-pod间通信>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl run -it busybox --image<span style=color:#f92672>=</span>busybox  <span style=color:#75715e># 创建busybox Pod</span>
</span></span><span style=display:flex><span>kubectl get pods -o wide                 <span style=color:#75715e># 获取nginx和busybox Pod IP</span>
</span></span></code></pre></div><p>在busybox Pod中执行：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>telnet Pod-IP <span style=color:#ae81ff>80</span>                         <span style=color:#75715e># 验证Pod间通信</span>
</span></span><span style=display:flex><span>kubectl delete pod busybox nginx         <span style=color:#75715e># 删除测试Pod</span>
</span></span></code></pre></div><p>Kubernetes存储</p><h2 id=41-使用emptydir>4.1 使用emptyDir<a hidden class=anchor aria-hidden=true href=#41-使用emptydir>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl run em --image<span style=color:#f92672>=</span>ubuntu --dry-run<span style=color:#f92672>=</span>client -o yaml &gt; empty-pod.yaml  <span style=color:#75715e># 生成Pod配置</span>
</span></span><span style=display:flex><span>kubectl apply -f empty-pod.yaml
</span></span><span style=display:flex><span>kubectl exec em -it /bin/sh  <span style=color:#75715e># 进入容器创建文件</span>
</span></span><span style=display:flex><span>cat &gt; hello.file <span style=color:#e6db74>&lt;&lt;EOF
</span></span></span><span style=display:flex><span><span style=color:#e6db74>hello
</span></span></span><span style=display:flex><span><span style=color:#e6db74>world
</span></span></span><span style=display:flex><span><span style=color:#e6db74>EOF</span>
</span></span><span style=display:flex><span>exit
</span></span><span style=display:flex><span>kubectl delete pod em      <span style=color:#75715e># 删除Pod后节点目录清空</span>
</span></span></code></pre></div><h2 id=42-emptydir容量限制>4.2 emptyDir容量限制<a hidden class=anchor aria-hidden=true href=#42-emptydir容量限制>#</a></h2><p>limit-pod.yaml</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span><span style=color:#f92672>name</span>: <span style=color:#ae81ff>test-container2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>ubuntu</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span><span style=color:#f92672>name</span>: <span style=color:#ae81ff>cache-volume</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>mountPath</span>: <span style=color:#ae81ff>/cache</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>command</span>: [<span style=color:#e6db74>&#34;sleep&#34;</span>, <span style=color:#e6db74>&#34;3600&#34;</span>]
</span></span><span style=display:flex><span>  <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span><span style=color:#f92672>name</span>: <span style=color:#ae81ff>cache-volume</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>emptyDir</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>sizeLimit</span>: <span style=color:#ae81ff>1Gi</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl apply -f limit-pod.yaml  <span style=color:#75715e># 容器因超限进入Error状态</span>
</span></span></code></pre></div><h2 id=43-使用hostpath>4.3 使用hostPath<a hidden class=anchor aria-hidden=true href=#43-使用hostpath>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ssh cce01-node1-IP <span style=color:#e6db74>&#34;mkdir /testdir&#34;</span>  <span style=color:#75715e># 在节点创建目录</span>
</span></span><span style=display:flex><span>kubectl run hppod --image<span style=color:#f92672>=</span>ubuntu --dry-run<span style=color:#f92672>=</span>client -o yaml &gt; hostPath-pod.yaml  <span style=color:#75715e># 生成配置</span>
</span></span><span style=display:flex><span>kubectl apply -f hostPath-pod.yaml
</span></span><span style=display:flex><span>kubectl exec hppod -it /bin/sh  <span style=color:#75715e># 写入文件</span>
</span></span><span style=display:flex><span>cat &gt; hello2 <span style=color:#e6db74>&lt;&lt;EOF
</span></span></span><span style=display:flex><span><span style=color:#e6db74>hello
</span></span></span><span style=display:flex><span><span style=color:#e6db74>again
</span></span></span><span style=display:flex><span><span style=color:#e6db74>EOF</span>
</span></span><span style=display:flex><span>exit
</span></span><span style=display:flex><span>kubectl delete pod hppod      <span style=color:#75715e># 删除Pod后节点文件保留</span>
</span></span></code></pre></div><p>有状态负载(StatefulSet)</p><h2 id=51-创建headless-service>5.1 创建Headless Service<a hidden class=anchor aria-hidden=true href=#51-创建headless-service>#</a></h2><p>headless-service.yaml</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Service</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>headless</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>clusterIP</span>: <span style=color:#ae81ff>None</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>selector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>app</span>: <span style=color:#ae81ff>tomcat</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span><span style=color:#f92672>port</span>: <span style=color:#ae81ff>80</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>targetPort</span>: <span style=color:#ae81ff>8080</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl apply -f headless-service.yaml
</span></span><span style=display:flex><span>kubectl get svc  <span style=color:#75715e># 查看Service状态</span>
</span></span></code></pre></div><h2 id=52-部署statefulset>5.2 部署StatefulSet<a hidden class=anchor aria-hidden=true href=#52-部署statefulset>#</a></h2><p>tomcat-statefulset.yaml</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>StatefulSet</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>tomcat-statefulset</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>serviceName</span>: <span style=color:#ae81ff>headless</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>replicas</span>: <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>selector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>matchLabels</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>app</span>: <span style=color:#ae81ff>tomcat</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>app</span>: <span style=color:#ae81ff>tomcat</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span><span style=color:#f92672>name</span>: <span style=color:#ae81ff>tomcat</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>image</span>: <span style=color:#ae81ff>tomcat</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span><span style=color:#f92672>containerPort</span>: <span style=color:#ae81ff>8080</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span><span style=color:#f92672>name</span>: <span style=color:#ae81ff>www-storage</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>mountPath</span>: <span style=color:#ae81ff>/usr/local/tomcat/webapps</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>volumeClaimTemplates</span>:
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>www-storage</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>accessModes</span>: [ <span style=color:#e6db74>&#34;ReadWriteOnce&#34;</span> ]
</span></span><span style=display:flex><span>      <span style=color:#f92672>resources</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>requests</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>storage</span>: <span style=color:#ae81ff>1Gi</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl apply -f tomcat-statefulset.yaml
</span></span><span style=display:flex><span>kubectl get pods -w  <span style=color:#75715e># 观察Pod有序创建</span>
</span></span></code></pre></div><h2 id=53-验证pod-dns>5.3 验证Pod DNS<a hidden class=anchor aria-hidden=true href=#53-验证pod-dns>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl run dnsutils --image<span style=color:#f92672>=</span>tutum/dnsutils -- sleep infinity
</span></span><span style=display:flex><span>kubectl exec dnsutils -- nslookup headless.default.svc.cluster.local  <span style=color:#75715e># 验证DNS解析</span>
</span></span></code></pre></div><h2 id=54-statefulset数据持久化>5.4 StatefulSet数据持久化<a hidden class=anchor aria-hidden=true href=#54-statefulset数据持久化>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl exec -it tomcat-statefulset-0 -- touch /usr/local/tomcat/webapps/hello.txt  <span style=color:#75715e># 创建测试文件</span>
</span></span><span style=display:flex><span>kubectl delete pod tomcat-statefulset-0  <span style=color:#75715e># 删除Pod</span>
</span></span><span style=display:flex><span>kubectl get pods -w  <span style=color:#75715e># 观察Pod重建后名称不变</span>
</span></span><span style=display:flex><span>kubectl exec -it tomcat-statefulset-0 -- ls /usr/local/tomcat/webapps  <span style=color:#75715e># 验证文件保留</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://qfsyso.github.io/posts/proxmox-virtual-environment-debian/><span class=title>« Prev</span><br><span>Proxmox Virtual Environment Debian</span>
</a><a class=next href=https://qfsyso.github.io/posts/docker-devops/><span class=title>Next »</span><br><span>Docker DevOps</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Kubernetes k8s on x" href="https://x.com/intent/tweet/?text=Kubernetes%20k8s&amp;url=https%3a%2f%2fqfsyso.github.io%2fposts%2fkubernetes-k8s%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kubernetes k8s on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fqfsyso.github.io%2fposts%2fkubernetes-k8s%2f&amp;title=Kubernetes%20k8s&amp;summary=Kubernetes%20k8s&amp;source=https%3a%2f%2fqfsyso.github.io%2fposts%2fkubernetes-k8s%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kubernetes k8s on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fqfsyso.github.io%2fposts%2fkubernetes-k8s%2f&title=Kubernetes%20k8s"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kubernetes k8s on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fqfsyso.github.io%2fposts%2fkubernetes-k8s%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kubernetes k8s on whatsapp" href="https://api.whatsapp.com/send?text=Kubernetes%20k8s%20-%20https%3a%2f%2fqfsyso.github.io%2fposts%2fkubernetes-k8s%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kubernetes k8s on telegram" href="https://telegram.me/share/url?text=Kubernetes%20k8s&amp;url=https%3a%2f%2fqfsyso.github.io%2fposts%2fkubernetes-k8s%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Kubernetes k8s on ycombinator" href="https://news.ycombinator.com/submitlink?t=Kubernetes%20k8s&u=https%3a%2f%2fqfsyso.github.io%2fposts%2fkubernetes-k8s%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><div class=wtime><div class=wtime2>CST<span id=beijingTime></span> GMT <span id=londonTime></span> EST <span id=newYorkTime></span> PST<span id=losAngelesTime></span></div><div class=wtime2 style=display:none>东京<span id=tokyoTime></span></div><div class=wtime2 style=display:none>欧洲-巴黎<span id=parisTime></span></div><div class=wtime2 style=display:none>UTC<span id=utcTime></span></div></div><span>&copy; 2025 <a href=https://qfsyso.github.io/>MLOG</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span><script type=text/javascript>const timeZoneOffsets={beijing:8,tokyo:9,paris:[1,2],london:[0,1],newYork:[-5,-4],losAngeles:[-8,-7]};function padZero(e){return e<10?"0"+e:e}function formatTime(e){const t=e.getFullYear(),n=padZero(e.getMonth()+1),s=padZero(e.getDate()),o=padZero(e.getHours()),i=padZero(e.getMinutes()),a=padZero(e.getSeconds());return`${t}-${n}-${s} ${o}:${i}:${a}`}function isDaylightSavingTime(e,t){const o=e.getMonth(),n=new Date(e.getFullYear(),3,8,2,0,0),s=new Date(e.getFullYear(),10,1,2,0,0);return(t==="paris"||t==="london"||t==="newYork"||t==="losAngeles")&&e>=n&&e<s}function updateTime(){const e=new Date,t=new Date(e.getUTCFullYear(),e.getUTCMonth(),e.getUTCDate(),e.getUTCHours(),e.getUTCMinutes(),e.getUTCSeconds()),n=formatTime(t);document.getElementById("utcTime").innerHTML=n;for(const n in timeZoneOffsets){const e=timeZoneOffsets[n];let s;Array.isArray(e)?s=isDaylightSavingTime(t,n)?e[1]:e[0]:s=e;const o=new Date(t.getTime()+s*60*60*1e3);document.getElementById(n+"Time").innerHTML=formatTime(o)}setTimeout(updateTime,1e3)}window.onload=function(){updateTime()};function notfound(e){var n=e.src,t=n.split("/"),s=t[t.length-1];e.src="https://47.115.223.75:8080/group1/v2/"+s+"?timestamp="+Date.now(),e.onerror=null}</script></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>