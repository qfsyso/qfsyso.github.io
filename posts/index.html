<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | MLOG</title>
<meta name=keywords content><meta name=description content="Posts - MLOG"><meta name=author content="dwd"><link rel=canonical href=https://qfsyso.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://qfsyso.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://qfsyso.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://qfsyso.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://qfsyso.github.io/apple-touch-icon.png><link rel=mask-icon href=https://qfsyso.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://qfsyso.github.io/posts/index.xml><link rel=alternate hreflang=en href=https://qfsyso.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://qfsyso.github.io/posts/"><meta property="og:site_name" content="MLOG"><meta property="og:title" content="Posts"><meta property="og:description" content="A simple blog "><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content="A simple blog "><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://qfsyso.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://qfsyso.github.io/ accesskey=h title="MLOG (Alt + H)">MLOG</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://qfsyso.github.io/posts/ title=Archive><span class=active>Archive</span></a></li><li><a href=https://qfsyso.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://qfsyso.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>API Signature</h2></header><div class=entry-content><p>接口签名核心知识点总结 1. ​​核心原理：验证完整性与身份​​ 接口签名（API Signature）是一种通过加密机制确保API请求的​​数据完整性​​和​​来源合法性​​的技术。客户端使用密钥（Secret Key）对请求内容生成签名，服务端用相同密钥和算法重新计算签名并比对，匹配则通过验证。
2. ​​签名生成的关键步骤​​ ​​参数排序​​：按参数名的ASCII码升序排列（如 a=1&amp;b=2&amp;c=3），确保顺序一致性。 ​​拼接字符串​​：将排序后的参数拼接为待签名字符串（如 key1=value1&amp;key2=value2）。 ​​添加密钥​​：在字符串末尾附加密钥（如 待签名字符串&amp;key=API_SECRET）。 ​​加密生成签名​​：使用算法（如HMAC-SHA256、MD5）生成签名，并附加到请求中。
3. ​​核心参数设计​​ ​​appid​​：应用标识，与密钥配对使用。 ​​timestamp​​：请求时间戳（推荐UTC时间），服务端验证是否在有效窗口内（如±5分钟）。 ​​nonce​​：唯一随机数，防止重放攻击（需服务端缓存校验）。 ​​signature​​：加密生成的签名值。
4. ​​常见问题与解决方案​​ ​​签名不一致​​： 原因：参数顺序/编码不一致、密钥错误、时间戳不同步。 解决：统一序列化规则（禁用JSON缩进）、同步UTC时间、校验密钥。 ​​重放攻击​​： 原因：nonce重复使用。 解决：服务端用缓存（如内存缓存）记录已使用的nonce。 ​​时区导致时间戳失效​​： 解决：客户端同步服务端时间（如NTP校准），或服务端放宽时间窗口。
5. ​​四大安全价值​​ ​​防伪装​​：验证请求来源（依赖密钥保密性）。 ​​防篡改​​：签名变化即提示数据被篡改。 ​​防重放​​：通过nonce和timestamp拦截重复请求。 ​​防泄露​​：敏感参数可加密传输（如结合RSA）。
6. ​​最佳实践​​ ​​算法选择​​：优先HMAC-SHA256（比MD5更安全）。 ​​密钥管理​​：避免硬编码，使用环境变量或密钥管理系统。 ​​调试工具​​： 客户端/服务端打印签名字符串对比差异。 使用在线工具（如HMAC生成器）交叉验证。
实战 实现一个API接口， 对客户端请求进行签名验证。
在C#服务端： 创建一个API控制器（如SignController），包含一个处理请求的Action（如Post）。 在Action中，按照以下步骤进行验证： a. 检查时间戳是否在有效期内（例如5分钟内）。 b. 检查nonce是否在内存缓存中存在，如果存在则拒绝（重放攻击），否则将nonce存入缓存（设置过期时间，例如5分钟）。 c. 验证配置版本号，如果和服务器最新版本一致，则返回304（NotModified）。 d. 重新计算签名，并与请求中的sign比对，如果不一致则返回401。 使用HMAC-SHA256算法计算签名，注意签名生成规则：对请求参数（除sign外）按照键名字典序排序，然后序列化为规范的JSON字符串（确保键的顺序一致），然后使用密钥进行HMAC-SHA256计算。
具体代码实现如下： C#服务端代码（.NET Core） 创建SignController 使用MemoryCache来存储nonce Node.js测试客户端代码 使用axios发送请求 使用crypto模块计算HMAC-SHA256签名 我们假设服务端的最新配置版本为"1.0.3"（为了测试，可以硬编码，实际中可能从配置文件中读取）。
错误码： 时间戳过期：401 nonce重复（重放攻击）：403 配置版本一致：304 签名不匹配：401 成功：200...</p></div><footer class=entry-footer><span title='2025-06-28 21:24:17 +0800 +0800'>June 28, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to API Signature" href=https://qfsyso.github.io/posts/api-signature/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Proxmox Virtual Environment Debian</h2></header><div class=entry-content><p>安装 Proxmox VE（PVE）前的准备
1. 下载 PVE 镜像 访问官网：https://www.proxmox.com/en/downloads
下载最新版的 Proxmox VE ISO Installer（例如：proxmox-ve_8.x.iso）
2. 制作启动U盘 使用工具制作启动盘（推荐）：
Ventoy（推荐）：支持多镜像启动，简单拖入 ISO 即可。 官网：https://www.ventoy.net/
或者使用 Rufus：
打开 Rufus，插入U盘（建议 8GB 以上）
选择 ISO 镜像
分区类型：推荐 MBR（兼容性更好）或根据你 BIOS 设置为 UEFI/GPT
点击“开始”制作启动盘
安装 PVE 设置 BIOS 启动项 插入U盘，重启电脑
在开机画面按下启动快捷键（如 F12, Esc, F2, Del，不同厂商略有不同）
选择从 U盘启动
安装 启动后选择 Install Proxmox VE
阅读并接受许可协议
选择硬盘（注意：会格式化此硬盘）
设置地区、时区和键盘布局
设置管理员密码与邮箱
设置管理 IP（如默认DHCP，建议改为静态IP以方便局域网访问）
等待安装完成
安装完成后 安装完成后，拔掉U盘并重启
启动后，系统会提示你使用浏览器访问管理界面：
https://ip-address:8006 注意：此为 https，浏览器会提示不安全连接，选择“继续前往”即可
使用建议 推荐使用 局域网静态 IP，便于访问和远程管理...</p></div><footer class=entry-footer><span title='2025-06-21 02:08:58 +0800 +0800'>June 21, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to Proxmox Virtual Environment Debian" href=https://qfsyso.github.io/posts/proxmox-virtual-environment-debian/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Kubernetes k8s</h2></header><div class=entry-content><p>Kubernetes k8s 描述什么是Kubernetes 描述Kubernetes的基本架构及核心概念 描述Kubernetes的应用编排方法 使用华为云CCE创建简单工作负载
容器编排技术 容器（如Docker）以及周边生态系统提供了很多工具来实现容器生命周期管理，能够满足在单台宿主机管理容器的需求。但越来越多企业开始使用容器，对容器技术的进一步发展提出了以下新的诉求： □高效的容器管理及编排。 □容器的跨主机部署及调度。 □容器的存储、网络、运维、安全等能力的拓展。 统一的容器编排管理工具
容器编排的价值 容器编排是指自动化容器的部署、管理、扩展和联网，可为企业带来以下价值： 灵活的资源管理及调度 自动化部署及服务发现 高效的监控及运维 弹性扩展及高可用
大规模容器集群管理工具，从Borg到Kubernetes ·Kubernetes起源于Google内部的Borg项目，它对计算资源进行了更高层次的抽象，通过将容器进行细致的组合，将最终的应用服务交给用户。它的目标是管理大规模的容器，提供基本的部署、维护以及应用伸缩等功能，其主要实现语言为Go语言。 ·Kubernetes作为容器集群管理工具，于2015年7月22日迭代到v1.0并正式对外公布。与此同时，谷歌联合Linux基金会及其他合作伙伴共同成立了CNCF基金会（CloudNativeComputingFoundation），并将Kuberentes作为首个编入CNCF管理体系的开源项目，助力容器技术生态的发展进步。
Kubernetes架构 ·一个基础的Kubernetes集群（Cluster）通常包含一个Master节点和多个Node节点。每个节点可以是一台物理机，也可以是一台虚拟机。
pod最小容器（container）
Kubernetes核心概念-Pod Pod是Kubernetes中最重要最基本的概念，Pod是Kubernetes最小工作单元。每一个Pod包含一个或多个相关容器，Kubernetes将Pod看做一个整体进行调度。 引入Pod的目的： 将联系紧密的容器封装在一个Pod单元内，以Pod整体进行调度、扩展和实现生命周期管理。 Pod内所有容器使用相同的网络Namespace和共享存储。即Pod内容器拥有相同IP地址和Port空间，容器间直接使用localhost通信。当挂载volume到Pod，即可实现将volume挂载到Pod中的每个容器。
Kubernetes核心概念-Controller ·工作负载是在Pod之上的一层抽象，我们可以通过控制器（controller）实现一系列基于Pod的高级特性，比如节点故障时Pod的自动迁移，Pod多副本横向扩展，应用滚动升级等。我们通常使用controller来做应用的真正的管理，而Pod是组成工作负载最小的单元
Kubernetes核心概念-Label ·当资源变得非常多的时候，如何分类管理就非常重要了，Kubernetes提供了一种机制来为资源分类，那就是Label（标签）。Label非常简单，但是却很强大，Kubernetes中几乎所有资源都可以用Label来组织。Label的具体形式是key-value的标记对，可以在创建资源的时候设置，也可以在后期添加和修改。
Kubernetes核心概念-Namespace ·命名空间（Namespace）是对一组资源和对象的抽象整合。在同一个集群内可创建不同的命名空间，不同命名空间中的数据彼此隔离。使得它们既可以共享同一个集群的服务，也能够互不干扰。 kube-public kube-system kube-node-lease default
Kubernetes核心概念-Service ·在Kubernetes中，Pod副本发生迁移或者伸缩的时候会发生变化，IP也是变化的。Kubernetes中的Service是一种抽象概念，它定义了一个Pod逻辑集合以及访问它们的策略。Service定义了外界访问一组特定Pod的方式。Service有自己的IP和端口，Service为Pod提供了负载均衡。
Kubernetes核心概念-Volume ·Volume用来管理Kubernetes存储，是用来声明在Pod中的容器可以访问的文件目录，含义如下： 声明在Pod中的容器可以访问的文件目录。 可以被挂载在Pod中一个或多个容器的指定路径下。 支持多种后端存储（本地存储、分布式存储、云存储等）。
Kubernetes管理-Kubectl ·Kubectl是Kubernetes的命令行工具。通过kubectl，用户能对集群进行管理，并在集群上进行容器化应用的安装部署。
Kubectl支持以下对象管理方式： 指令式：通过kubectl内置的驱动命令，如:kubectl +create/scale/delete/..+参数的形式， 直接快速创建、更新和删除Kubernetes对象。
声明式：使用kubectlapply创建指定目录中配置文件所定义的所有对象。通常，此配置文件 采用yaml进行描述。
Kubernetes管理-命令行语法 在Kubernetes中的很多操作都是用kubectl来完成，通过其命令可以管理Deployment、Replicaset、ReplicationController、Pod等，进行操作、扩容、删除等全生命周期操作，同时可以对管理对象进行查看或者监控资源使用情况。
kubectl的语法
kubectl [command] [TYPElNAME] [flags] Command：指定你希望进行的操作，如create，get，describe，delete等。 TYPE：指定操作对象的类型，如deployment，pod，service等。 hiPnNAME：指定对象的名字。hidhwyun flags:可选的标志位。
Kubernetes管理-yaml示例 ·kubernetes中的对象可以使用YAML描述（如果您对YAML格式不了解，可以参考YAML语法少，也可以使用JSON。其内容可以分为如下四个部分： typeMeta：对象类型的元信息，声明对象使用哪个API版本，哪个类型的对象。 objectMeta：对象的元信息，包括对象名称、使用的标签等。 spec：对象的期望状态，例如对象使用什么镜像、有多少副本等。 status：对象的实际状态，只能在对象创建后看到，创建对象时无需指定。...</p></div><footer class=entry-footer><span title='2025-06-06 00:54:55 +0800 +0800'>June 6, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to Kubernetes k8s" href=https://qfsyso.github.io/posts/kubernetes-k8s/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Docker DevOps</h2></header><div class=entry-content><p>云原生应用十二要素原则解析表 原则 核心价值 实现方法 技术案例 1. 基准代码 快速交付；合理划分边界 单一代码库+多环境部署，版本控制统一管理 Git仓库管理，Kubernetes多集群部署 2. 依赖 提升开发效率；排除意外风险 显式声明依赖+隔离环境（容器化） Docker镜像打包依赖，Helm Chart管理应用包 3. 配置 软件发布管理；环境无差别 配置与代码分离→环境变量注入 Kubernetes ConfigMap/Secret动态加载 4. 后端服务 弹性/敏捷；解耦状态管理 将慢速进程（如DB/队列）转为RESTful服务 Redis缓存服务，消息队列(Kafka)独立部署 5. 构建发布运行 持续交付；流水线自动化 CI/CD全流程自动化（构建→测试→部署） Jenkins/GitLab CI流水线，K8s Rolling Update 6. 进程 云兼容性；无状态设计 应用无状态化，会话数据外置后端服务 会话存储Redis，文件存储OSS 7. 端口绑定 自包含服务；独立暴露接口 服务直接监听端口，不依赖Web服务器转发 Spring Boot内嵌Tomcat，gRPC直连 8. 并发 自动弹性伸缩 水平扩展替代垂直扩展，依赖云平台弹性能力 Kubernetes HPA自动扩缩容 9. 易处理 快速故障恢复 断路器模式+优雅终止，进程可随时启停 Istio服务熔断，K8s Liveness探针 10. 环境等价 可靠性；开发与生产环境一致 容器化保证环境一致性，禁用环境特殊配置 Docker跨环境运行，开发环境Minikube 11. 日志 实时系统监控 日志作为事件流→集中式管理 EFK栈(Elasticsearch+Fluentd+Kibana) 12. 管理进程 运维效率；运营解耦 管理任务（如DB迁移）作为独立进程，与主应用隔离 K8s Job/CronJob执行批处理任务 特性 云原生应用 传统应用 可预测性 符合弹性框架，通过容器编排和微服务实现可预测行为 不可预测，批量发布易引发单点故障，扩展能力有限 操作系统依赖 抽象化（容器技术隔离OS依赖，实现跨平台运行） 强依赖（需特定OS环境，迁移困难） 资源调度 弹性伸缩（按需自动分配资源，利用率＞70%） 冗余静态（预留资源应对峰值，利用率＜40%） 团队协作 DevOps驱动（开发运维一体化，自动化流水线） 部门墙隔离（开发/测试/运维独立，沟通成本高） 开发模式 敏捷迭代（CI/CD支持每日多次部署） 瀑布模型（数月/年周期发布，变更困难） 服务架构 微服务（独立部署、高内聚低耦合） 单体架构（模块紧耦合，牵一发而动全身） 运维能力 自动化（K8s实现自愈、监控、扩缩容） 手动操作（人工监控、故障排查效率低） 故障恢复 秒级恢复（容器快速重启+服务网格流量调度） 小时级恢复（依赖备份还原，流程复杂） 云原生架构模式:微服务架构 云原生架构演进原则 01....</p></div><footer class=entry-footer><span title='2025-06-05 20:23:33 +0800 +0800'>June 5, 2025</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to Docker DevOps" href=https://qfsyso.github.io/posts/docker-devops/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Information Recognition</h2></header><div class=entry-content><p>智能信息过滤和图片鉴别 智能信息过滤，屏蔽网上的色情、暴力、反动等不良信息，让上网的环境更干净。
文字信息过滤 智能策略定制，高效过滤色情、广告、涉政、暴恐等多类垃圾文字及敏感词、违禁变种。
图像信息过滤 领先图像识别算法，精准过滤涉黄、推广、暴恐、涉政、其他个性化定义的违规图片。 函数工作流
文字应用场景 1.有效拦截聊天中含有涉黄、暴恐等违法内容。 2.识别用户昵称、签名等违规内容。 3.识别论坛灌水、广告等垃圾内容: 4.电商评论中文字筛查
图像应用场景 1.识别用户头像中的违规内容 2.电商评论中图片筛查
实现智能信息过滤所需的技术 1.分布式消息服务Kafka: 创建Kafka实例，并创建对应主题，记录实例基本信息中的连接地址信息，用来后面推送消息使用。 2.函数工作流:创建函数，为函数创建触发器，通过轮询的方式，获取Kafka实例中的对应信息。 3.对象存储服务OBS:创建OBS桶用来保存程序包。 4.统一身份认证服务IAM:创建委托，给FunctionGraph函数赋权，确保函数能够访问到Kafka对应资源。
分布式消息服务Kafka概述 分布式消息服务Kafka是一个高吞吐、高可用的消息中间件服务，，适用于构建实时数据管道、流式数据处理、第三方解耦、流量削峰去谷等场景，具有大规模、高可靠、高并发访问、可扩展且完全托管的特点，是分布式应用上云必不可少的重要组件。 Topic 生产者 消费者 节点 分区 副本
分布式消息服务Kafka与智能信息过滤 使用分布式消息服务Kafka，提供用户发送消息的平台
创建Kafka实例 ->用于信息过滤 ->创建Kafka主题 ->完成Topic创建
函数工作流概述 函数工作流(FunctionGraph)是华为云提供的一款无服务器(Serverless)计算服务，无服务器计算是一种托管服务，服务提供商会实时为你分配充足的资源，而不需要预留专用的服务器或容量，真正按实际使用付费。
函数工作流使用流程: 开始 创建函数 创建工作流触发器 创建工作流 生成事件触发工作流执行 查看步骤执行的详细信息 结束
函数工作流与智能信息过滤 创建函数:提供信息处理的软件加上计算资源。 创建触发器:通过创建触发器实现添加Kafka事件源，将函数与Kafka关联函数可以获取Kafka中的对应信息。 通过对读取信息进行处理，判断信息是否敏感，是否符合发布。
创建函数 创建触发器 事件源触发 信息处理
对象存储服务OBS 对象存储服务(Object Storage Service，OBS)是一个基于对象的海量存储服务，为客户提供海量、安全、高可靠、低成本的数据存储能力。 对象object: 是OBS中数据存储的基本单位，用户上传至OBS的数据都以对象的形式保存在桶中。 桶Bucket: 是OBS中存储对象的容器
块存储服务 相当于硬盘，速度快，共享性差。 文件存储 共享性快，速度慢。
对象存储原理是创建一个哈希环，每个文件数据创建索引，通过索引快速找到。
对象存储服务OBS与智能信息过滤 创建函数时，上传ZIP包的大小限制为不超过50M，如果超过50M，需要将程序包上传至OBS桶，从OBS桶中引用。所以需要创建OBS桶用来保存程序包。 在文字信息过滤中， OBS存储的程序包中包含触发函数运行的敏感信息Kafka的生产者发布的消息会触发函数，函数会读取信息并处理。同样的在图片鉴别中，OBS除了存储程序包，还是触发图片处理函数运行的事件源。...</p></div><footer class=entry-footer><span title='2025-06-03 02:57:43 +0800 +0800'>June 3, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to Information Recognition" href=https://qfsyso.github.io/posts/information-recognition/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>HM dev tips</h2></header><div class=entry-content><p>红枫人像模式 【干货1：光影通透感】 打开相机→人像模式→选择「红枫原色滤镜」，搭配F1.4可变光圈（光线暗时自动开大），Live House也能拍出电影感！皮肤质感直接提升50%！ 【干货2：微距彩蛋】 长焦镜头不仅能拍远景，切换「超级微距」模式，2.5cm怼脸拍睫毛根根分明，美妆博主都直呼内行！
光斑选「旋焦」！逆光秒变星芒氛围 👉 人像模式→点顶部「光斑」→选「旋焦」拍侧脸： ✓ 背景玻璃反光变旋转星环，发丝自带金边，原图直出不用修！ ✓ 普通虚化像贴纸，旋焦让背景有「呼吸感」，随手拍都是电影截图
电影模式藏得深！鎏金滤镜封神 👉 左滑到「更多」→开「电影模式」选「鎏金」： 暖黄颗粒感直接拉满！拍复古小店/蛋糕摆拍，秒变90年代老电影质感，发朋友圈被问“在哪拍的微电影”～
动态追焦拍视频！端盘子不糊片 👉 长按对焦框锁定物体： 拍vlog端蛋糕走动，镜头全程锁食物，奶油晃动细节超清晰！拍店员拉花，奶泡上的字放大都不模糊～
懒人公式：逆光+旋焦光斑+鎏金滤镜，随手拍都是封面！ 华为Nova14Pro 拍照神器
**打工人必薅！Nova14 Pro 5个效率神技 （封面：手机分屏显示文档+微信，桌面浮着「智慧识屏」按钮）
长按屏幕2秒→合同转Word！ 👉 智慧识屏提取图片文字，表格/手写都能认，地铁10分钟搞定文件编辑，老板夸“反应快”～
三指上滑分屏！开会摸鱼两不误 👉 左腾讯文档开会，右微信回消息，侧边栏拖淘宝变悬浮窗比价，摸鱼工作无缝切换（嘘～）
备忘录扫描→纸质笔记变电子档！ 拍3页手写会议纪要，自动识别文字+排版，准确率99%，导出PDF直接发群，省掉半小时狂记时间！
花 48mm F/2.2 1/100s & 200s ISO200 人 72mm F2.4 1/50s ISO320 ISO600
相册 编辑 AI移图
雨 M 测光点 ISO 400 S 1/100 F AF-C AWB 白平衡调至4200K 拍雨滴：快门S：1/1000 ISO：1600 拍雨丝：快门S：1/100 ISO：100 拍雨条：快门S：1/10 ISO：50</p></div><footer class=entry-footer><span title='2025-06-02 00:30:27 +0800 +0800'>June 2, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to HM dev tips" href=https://qfsyso.github.io/posts/hm-dev-tips/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Docker Cloud Native</h2></header><div class=entry-content><p>云原生技术实践 一、云计算技术发展历程 时间 关键技术 说明 2001 VMware虚拟化 商业虚拟化技术兴起 2010 开源IaaS/PaaS OpenStack等开源平台出现 2013 容器技术 Docker等技术开始流行 2015 云原生（Cloud Native） CNCF成立，云原生概念正式确立 现状：70%用户已采用微服务架构
云原生技术体系 核心技术要素 容器：轻量级应用封装 服务网格：微服务治理 微服务：功能解耦 不可变基础设施：通过镜像保证一致性 声明式API：简化资源配置管理 技术优势 灵活性：跨环境一致性部署 可维护性：简化系统运维 敏捷性：快速迭代能力 开源生态：以Kubernetes为中心的开放标准 三、容器技术详解 1. 容器 vs 虚拟机 特性 容器 虚拟机 资源隔离 共享OS内核 独立OS 启动速度 秒级 分钟级 密度 单机支持1000+容器 通常10-20台VM/物理机 典型场景 微服务/DevOps 传统多租户隔离 2. Docker技术栈 架构组成 Docker Client → Docker Daemon → Container Runtime
核心组件 Docker Engine：C/S架构客户端-服务端 Docker CLI：命令行交互工具 Docker Daemon：后台服务进程 Containerd：OCI兼容运行时 3....</p></div><footer class=entry-footer><span title='2025-05-30 04:13:40 +0800 +0800'>May 30, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to Docker Cloud Native" href=https://qfsyso.github.io/posts/docker-cloud-native/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>HarmonyOS Run</h2></header><div class=entry-content><p>HarmonyOS5.0真机调试 1.开发者选线打开 类似安卓点击版本 软件版本 5次开启 重启
2.设置-系统-开发者-USB调试 连上 DevEco对即可调试
uniapp HarmonyOS 真机调试 小三角 运行 运行到鸿蒙
申请证书 尚未完成开发者注册 数字证书是由华为的 AppGallery Connect 服务系统（简称 AGC）颁发的，开发者首先需要在 AGC 中完成开发者注册，才能申请数字证书。
未找到包名为 xx 的应用 登录 AGC 之后，进入【证书、APP ID 和 Profile】中的【APP ID】页面，为指定的包名创建应用，然后才能为该应用申请证书。 https://uniapp.dcloud.net.cn/tutorial/harmony/runbuild.html#signing-configs
https://developer.huawei.com/consumer/cn/service/josp/agc/index.html#/
等待插件下载 等待编译页面 .hap
如果没问题，就可以运行到真机了 注意：证书，云关联
注意 性能和包体积，均不及发行模式
鸿蒙整体处于发展初期，能用，有坑，大部分坑有规避方案。 但开发者应建议其领导、客户、质量部门降低期望，不能严格比照Android和iOS的验收标准要求鸿蒙。
Setup APK 安装apk 传文件得到.apk.1 改名apk 桌易通传文件 识别安装
学堂 https://developer.huawei.com/consumer/cn/training/
社区问答 https://developer.huawei.com/consumer/cn/forum/
flutter 当前可以通过flutter create/biuld去生成对应的ohos工程，flutter的代码通过引擎编译后会生成可运行的鸿蒙工程。 参考链接：https://gitee.com/openharmony-sig/flutter_flutter/tree/dev/ 可以直接打包,并集成到项目中。 可以通过flutter build har指令打包成har包，将har作为模块，集成到项目中。 har包使用方法参考：https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V13/har-package-V13?catalogVersion=V13
RN 4 HM https://gitee.com/openharmony-sig/ohos_react_native/blob/0.72.5-ohos-5.0-release/docs/zh-cn/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.md</p></div><footer class=entry-footer><span title='2025-05-27 00:58:49 +0800 +0800'>May 27, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to HarmonyOS Run" href=https://qfsyso.github.io/posts/harmonyos-run/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>NodeRed Test YTB Change NetWrok</h2></header><div class=entry-content><p>Setup Node-RED 一、前提条件：安装 Node.js Node-RED 需要 Node.js 环境，需先安装 Node.js。
打开 Node.js 官网：https://nodejs.org/ 下载并安装 LTS（长期支持）版本 安装完成后打开终端（Win + X → 终端），输入以下命令检查是否安装成功： node -v npm -v 二、全局安装 Node-RED 在命令行中执行以下命令安装 Node-RED：
npm install -g --unsafe-perm node-red 说明：
-g：表示全局安装 --unsafe-perm：解决某些系统中权限问题 三、启动 Node-RED 安装完成后，在终端中运行：
node-red 输出类似以下内容：
Server now running at http://127.0.0.1:1880/ 四、访问 Node-RED 编辑器 打开浏览器访问：
http://localhost:1880 即可进入图形化流程编辑界面。
🛠️ 五、可选：创建桌面快捷方式（.bat 启动脚本） 创建一个文本文件，内容如下：
@echo off title Node-RED node-red pause 保存为 node-red.bat
双击即可启动 Node-RED
六、（可选）将 Node-RED 作为后台服务运行 你可以使用如下工具实现后台服务：
pm2（推荐）：适用于 Node....</p></div><footer class=entry-footer><span title='2025-05-25 13:07:23 +0800 +0800'>May 25, 2025</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to NodeRed Test YTB Change NetWrok" href=https://qfsyso.github.io/posts/nodered-test-ytb-change-netwrok/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Snapdrop</h2></header><div class=entry-content><p>Snapdrop：开源浏览器版 AirDrop 文件传输工具 Snapdrop 是一个纯浏览器实现的开源局域网文件传输工具，基于 WebRTC 和 WebSocket 技术，提供类似 Apple AirDrop 的跨平台即时文件共享体验。
🚀 Snapdrop 的优势 设备自动发现：同一局域网内自动识别设备，无需手动连接或配对。 无平台限制：只要能打开浏览器（Chrome / Safari / Edge / Firefox 等）即可使用。 匿名上传与下载：无需登录，匿名操作保障隐私。 端到端加密：基于 WebRTC 的 DTLS 和 SDES 协议，确保传输安全。 PWA 支持：可添加到手机主屏，像 App 一样快捷打开。 ⚙️ 快速使用方式 在线使用 直接访问 https://snapdrop.net 确保设备处于同一 Wi-Fi 或局域网 浏览器打开 Snapdrop 网页 选择设备 → 上传文件 → 对方点击下载即可 自托管部署（增强隐私） 方式一：手动部署 git clone https://github.com/Snapdrop/Snapdrop.git cd Snapdrop npm install npm start 访问：http://localhost:3000
方式二：使用 Docker 一键部署 docker run -d --name=snapdrop -p 80:80 -p 443:443 \ -v /path/to/config:/config \ lscr....</p></div><footer class=entry-footer><span title='2025-05-23 00:31:40 +0800 +0800'>May 23, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to Snapdrop" href=https://qfsyso.github.io/posts/snapdrop/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://qfsyso.github.io/posts/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><div class=wtime><div class=wtime2>CST<span id=beijingTime></span> GMT <span id=londonTime></span> EST <span id=newYorkTime></span> PST<span id=losAngelesTime></span></div><div class=wtime2 style=display:none>东京<span id=tokyoTime></span></div><div class=wtime2 style=display:none>欧洲-巴黎<span id=parisTime></span></div><div class=wtime2 style=display:none>UTC<span id=utcTime></span></div></div><span>&copy; 2025 <a href=https://qfsyso.github.io/>MLOG</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span><script type=text/javascript>const timeZoneOffsets={beijing:8,tokyo:9,paris:[1,2],london:[0,1],newYork:[-5,-4],losAngeles:[-8,-7]};function padZero(e){return e<10?"0"+e:e}function formatTime(e){const t=e.getFullYear(),n=padZero(e.getMonth()+1),s=padZero(e.getDate()),o=padZero(e.getHours()),i=padZero(e.getMinutes()),a=padZero(e.getSeconds());return`${t}-${n}-${s} ${o}:${i}:${a}`}function isDaylightSavingTime(e,t){const o=e.getMonth(),n=new Date(e.getFullYear(),3,8,2,0,0),s=new Date(e.getFullYear(),10,1,2,0,0);return(t==="paris"||t==="london"||t==="newYork"||t==="losAngeles")&&e>=n&&e<s}function updateTime(){const e=new Date,t=new Date(e.getUTCFullYear(),e.getUTCMonth(),e.getUTCDate(),e.getUTCHours(),e.getUTCMinutes(),e.getUTCSeconds()),n=formatTime(t);document.getElementById("utcTime").innerHTML=n;for(const n in timeZoneOffsets){const e=timeZoneOffsets[n];let s;Array.isArray(e)?s=isDaylightSavingTime(t,n)?e[1]:e[0]:s=e;const o=new Date(t.getTime()+s*60*60*1e3);document.getElementById(n+"Time").innerHTML=formatTime(o)}setTimeout(updateTime,1e3)}window.onload=function(){updateTime()};function notfound(e){var n=e.src,t=n.split("/"),s=t[t.length-1];e.src="https://47.115.223.75:8080/group1/v2/"+s+"?timestamp="+Date.now(),e.onerror=null}</script></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>