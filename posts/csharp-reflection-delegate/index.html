<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>csharp reflection delegate | MLOG</title>
<meta name=keywords content="c#,.NET"><meta name=description content='Reflection 反射 动态加载和创建对象： 反射可以在运行时加载程序集，并基于类型信息创建对象实例，而无需在编译时知道具体的类型。 这对于实现插件系统、动态加载模块或在不同版本的库之间提供兼容性非常有用。
反射可以获取有关类型（如类、接口、结构体等）及其成员（如字段、属性、方法等）的详细信息。 这对于生成文档、进行代码分析或创建序列化/反序列化机制等任务非常有用。
class Program { static void Main(string[] args) { // 加载包含类型的程序集 Assembly assembly = Assembly.LoadFrom("ReflectionExample.dll"); // 获取类型信息 Type type = assembly.GetType("ReflectionExample.MyClass"); // 创建对象实例 object instance = Activator.CreateInstance(type); // 获取方法信息 MethodInfo methodInfo = type.GetMethod("MyMethod"); // 调用方法 methodInfo.Invoke(instance, new object[] { "Hello, Reflection!" }); } } public class MyClass { public void MyMethod(string message) { Console.WriteLine(message); } } Delegate 委托 委托是一种类型安全的函数指针，可以用来引用一个或多个具有相同签名的方法。 委托（Delegate）是一种特殊的类型，它代表对具有特定参数列表和返回类型的函数的引用。委托可以用来封装静态方法或实例方法，并且可以在运行时像普通变量一样传递。这使得委托成为一种强大的工具，用于实现回调函数、事件处理以及其他需要函数作为参数传递的场景。
委托的基本特性 类型安全：委托是类型安全的，因为它们在声明时会指定一个方法签名，只有与这个签名匹配的方法才能被委托引用。 多播能力：大多数委托支持多播，即一个委托实例可以引用多个方法。当调用该委托时，所有引用的方法都会被依次调用。 灵活性：委托可以用来引用类的实例方法或静态方法，也可以引用匿名方法（使用lambda表达式）。 定义委托 委托可以通过delegate关键字定义。定义时需要指定返回类型和参数列表。 有访问修饰符，delegate，返回值类型，委托名称，参数-可选。可以在类内部，可以在外部。'><meta name=author content="dwd"><link rel=canonical href=https://qfsyso.github.io/posts/csharp-reflection-delegate/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://qfsyso.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://qfsyso.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://qfsyso.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://qfsyso.github.io/apple-touch-icon.png><link rel=mask-icon href=https://qfsyso.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://qfsyso.github.io/posts/csharp-reflection-delegate/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://qfsyso.github.io/posts/csharp-reflection-delegate/"><meta property="og:site_name" content="MLOG"><meta property="og:title" content="csharp reflection delegate"><meta property="og:description" content='Reflection 反射 动态加载和创建对象： 反射可以在运行时加载程序集，并基于类型信息创建对象实例，而无需在编译时知道具体的类型。 这对于实现插件系统、动态加载模块或在不同版本的库之间提供兼容性非常有用。
反射可以获取有关类型（如类、接口、结构体等）及其成员（如字段、属性、方法等）的详细信息。 这对于生成文档、进行代码分析或创建序列化/反序列化机制等任务非常有用。
class Program { static void Main(string[] args) { // 加载包含类型的程序集 Assembly assembly = Assembly.LoadFrom("ReflectionExample.dll"); // 获取类型信息 Type type = assembly.GetType("ReflectionExample.MyClass"); // 创建对象实例 object instance = Activator.CreateInstance(type); // 获取方法信息 MethodInfo methodInfo = type.GetMethod("MyMethod"); // 调用方法 methodInfo.Invoke(instance, new object[] { "Hello, Reflection!" }); } } public class MyClass { public void MyMethod(string message) { Console.WriteLine(message); } } Delegate 委托 委托是一种类型安全的函数指针，可以用来引用一个或多个具有相同签名的方法。 委托（Delegate）是一种特殊的类型，它代表对具有特定参数列表和返回类型的函数的引用。委托可以用来封装静态方法或实例方法，并且可以在运行时像普通变量一样传递。这使得委托成为一种强大的工具，用于实现回调函数、事件处理以及其他需要函数作为参数传递的场景。
委托的基本特性 类型安全：委托是类型安全的，因为它们在声明时会指定一个方法签名，只有与这个签名匹配的方法才能被委托引用。 多播能力：大多数委托支持多播，即一个委托实例可以引用多个方法。当调用该委托时，所有引用的方法都会被依次调用。 灵活性：委托可以用来引用类的实例方法或静态方法，也可以引用匿名方法（使用lambda表达式）。 定义委托 委托可以通过delegate关键字定义。定义时需要指定返回类型和参数列表。 有访问修饰符，delegate，返回值类型，委托名称，参数-可选。可以在类内部，可以在外部。'><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-24T17:36:50+00:00"><meta property="article:modified_time" content="2024-11-24T17:36:50+00:00"><meta property="article:tag" content="C#"><meta property="article:tag" content=".NET"><meta name=twitter:card content="summary"><meta name=twitter:title content="csharp reflection delegate"><meta name=twitter:description content='Reflection 反射 动态加载和创建对象： 反射可以在运行时加载程序集，并基于类型信息创建对象实例，而无需在编译时知道具体的类型。 这对于实现插件系统、动态加载模块或在不同版本的库之间提供兼容性非常有用。
反射可以获取有关类型（如类、接口、结构体等）及其成员（如字段、属性、方法等）的详细信息。 这对于生成文档、进行代码分析或创建序列化/反序列化机制等任务非常有用。
class Program { static void Main(string[] args) { // 加载包含类型的程序集 Assembly assembly = Assembly.LoadFrom("ReflectionExample.dll"); // 获取类型信息 Type type = assembly.GetType("ReflectionExample.MyClass"); // 创建对象实例 object instance = Activator.CreateInstance(type); // 获取方法信息 MethodInfo methodInfo = type.GetMethod("MyMethod"); // 调用方法 methodInfo.Invoke(instance, new object[] { "Hello, Reflection!" }); } } public class MyClass { public void MyMethod(string message) { Console.WriteLine(message); } } Delegate 委托 委托是一种类型安全的函数指针，可以用来引用一个或多个具有相同签名的方法。 委托（Delegate）是一种特殊的类型，它代表对具有特定参数列表和返回类型的函数的引用。委托可以用来封装静态方法或实例方法，并且可以在运行时像普通变量一样传递。这使得委托成为一种强大的工具，用于实现回调函数、事件处理以及其他需要函数作为参数传递的场景。
委托的基本特性 类型安全：委托是类型安全的，因为它们在声明时会指定一个方法签名，只有与这个签名匹配的方法才能被委托引用。 多播能力：大多数委托支持多播，即一个委托实例可以引用多个方法。当调用该委托时，所有引用的方法都会被依次调用。 灵活性：委托可以用来引用类的实例方法或静态方法，也可以引用匿名方法（使用lambda表达式）。 定义委托 委托可以通过delegate关键字定义。定义时需要指定返回类型和参数列表。 有访问修饰符，delegate，返回值类型，委托名称，参数-可选。可以在类内部，可以在外部。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://qfsyso.github.io/posts/"},{"@type":"ListItem","position":2,"name":"csharp reflection delegate","item":"https://qfsyso.github.io/posts/csharp-reflection-delegate/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"csharp reflection delegate","name":"csharp reflection delegate","description":"Reflection 反射 动态加载和创建对象： 反射可以在运行时加载程序集，并基于类型信息创建对象实例，而无需在编译时知道具体的类型。 这对于实现插件系统、动态加载模块或在不同版本的库之间提供兼容性非常有用。\n反射可以获取有关类型（如类、接口、结构体等）及其成员（如字段、属性、方法等）的详细信息。 这对于生成文档、进行代码分析或创建序列化/反序列化机制等任务非常有用。\nclass Program { static void Main(string[] args) { // 加载包含类型的程序集 Assembly assembly = Assembly.LoadFrom(\u0026#34;ReflectionExample.dll\u0026#34;); // 获取类型信息 Type type = assembly.GetType(\u0026#34;ReflectionExample.MyClass\u0026#34;); // 创建对象实例 object instance = Activator.CreateInstance(type); // 获取方法信息 MethodInfo methodInfo = type.GetMethod(\u0026#34;MyMethod\u0026#34;); // 调用方法 methodInfo.Invoke(instance, new object[] { \u0026#34;Hello, Reflection!\u0026#34; }); } } public class MyClass { public void MyMethod(string message) { Console.WriteLine(message); } } Delegate 委托 委托是一种类型安全的函数指针，可以用来引用一个或多个具有相同签名的方法。 委托（Delegate）是一种特殊的类型，它代表对具有特定参数列表和返回类型的函数的引用。委托可以用来封装静态方法或实例方法，并且可以在运行时像普通变量一样传递。这使得委托成为一种强大的工具，用于实现回调函数、事件处理以及其他需要函数作为参数传递的场景。\n委托的基本特性 类型安全：委托是类型安全的，因为它们在声明时会指定一个方法签名，只有与这个签名匹配的方法才能被委托引用。 多播能力：大多数委托支持多播，即一个委托实例可以引用多个方法。当调用该委托时，所有引用的方法都会被依次调用。 灵活性：委托可以用来引用类的实例方法或静态方法，也可以引用匿名方法（使用lambda表达式）。 定义委托 委托可以通过delegate关键字定义。定义时需要指定返回类型和参数列表。 有访问修饰符，delegate，返回值类型，委托名称，参数-可选。可以在类内部，可以在外部。","keywords":["c#",".NET"],"articleBody":"Reflection 反射 动态加载和创建对象： 反射可以在运行时加载程序集，并基于类型信息创建对象实例，而无需在编译时知道具体的类型。 这对于实现插件系统、动态加载模块或在不同版本的库之间提供兼容性非常有用。\n反射可以获取有关类型（如类、接口、结构体等）及其成员（如字段、属性、方法等）的详细信息。 这对于生成文档、进行代码分析或创建序列化/反序列化机制等任务非常有用。\nclass Program { static void Main(string[] args) { // 加载包含类型的程序集 Assembly assembly = Assembly.LoadFrom(\"ReflectionExample.dll\"); // 获取类型信息 Type type = assembly.GetType(\"ReflectionExample.MyClass\"); // 创建对象实例 object instance = Activator.CreateInstance(type); // 获取方法信息 MethodInfo methodInfo = type.GetMethod(\"MyMethod\"); // 调用方法 methodInfo.Invoke(instance, new object[] { \"Hello, Reflection!\" }); } } public class MyClass { public void MyMethod(string message) { Console.WriteLine(message); } } Delegate 委托 委托是一种类型安全的函数指针，可以用来引用一个或多个具有相同签名的方法。 委托（Delegate）是一种特殊的类型，它代表对具有特定参数列表和返回类型的函数的引用。委托可以用来封装静态方法或实例方法，并且可以在运行时像普通变量一样传递。这使得委托成为一种强大的工具，用于实现回调函数、事件处理以及其他需要函数作为参数传递的场景。\n委托的基本特性 类型安全：委托是类型安全的，因为它们在声明时会指定一个方法签名，只有与这个签名匹配的方法才能被委托引用。 多播能力：大多数委托支持多播，即一个委托实例可以引用多个方法。当调用该委托时，所有引用的方法都会被依次调用。 灵活性：委托可以用来引用类的实例方法或静态方法，也可以引用匿名方法（使用lambda表达式）。 定义委托 委托可以通过delegate关键字定义。定义时需要指定返回类型和参数列表。 有访问修饰符，delegate，返回值类型，委托名称，参数-可选。可以在类内部，可以在外部。\n本质 底层是个特殊类(强类型)， 继承运行时的MulticastDelegate\npublic delegate void MyDelegate(string message); // 返回类型为void，接受一个字符串参数 ``` 使用委托 创建委托实例 可以通过委托的构造函数或者new关键字创建委托实例，并将它绑定到具体的方法上。 ```Csharp public class MyClass { public void MyMethod(string message) { Console.WriteLine(message); } } public class Program { public static void StaticMethod(string message) { Console.WriteLine(\"Static: \" + message); } public static void Main() { MyClass instance = new MyClass(); MyDelegate del1 = new MyDelegate(instance.MyMethod); MyDelegate del2 = new MyDelegate(StaticMethod); // 调用委托 del1(\"Hello from instance method\"); del2(\"Hello from static method\"); } } ``` 多播委托 如果 定义的委托不是void返回类型，那么当委托指向多个方法时，只有最后一个方法的返回值会被返回。对于返回类型为void的委托，所有方法都会被执行。 ```Csharp public class Program { public static void Method1(string message) { Console.WriteLine(\"Method1: \" + message); } public static void Method2(string message) { Console.WriteLine(\"Method2: \" + message); } public static void Main() { MyDelegate del1 = new MyDelegate(Method1); MyDelegate del2 = new MyDelegate(Method2); MyDelegate combined = del1 + del2; // 组合两个委托 combined(\"Hello multi-cast delegate\"); // 调用组合后的委托 } } ``` 使用Lambda表达式 从C# 3.0开始， 可以使用lambda表达式来创建委托，这使得代码更加简洁。 ```Csharp public class Program { public static void Main() { MyDelegate del = message =\u003e Console.WriteLine(\"Lambda: \" + message); del(\"Hello lambda expression\"); } } ``` ## 参数传递委托 ```csharp namespace ConsoleApp1T1 { public delegate void NoReOutClass(); public class MyDele { public delegate void NoReP(); public delegate void NoRePn(int x, int y); public delegate int WithReP(); public delegate int WithRePn(int x,ref int y); public void show() { //NoReP mh1 = new NoReP(DoNothing); NoReP methodhander1 = DoNothing;//语法糖 //methodhander1.Invoke();//执行委托 //old dotnet ver BeginInvoke //本质是类的实例 可以做为参数传递 ExDele(methodhander1);//类似容器 把一段函数-业务逻辑 传递到不同的地方 ////使用 // MyDele myDele = new MyDele(); // myDele.show(); } public void ExDele(NoReP de) { de.Invoke(); } public void DoNothing() { Console.WriteLine(\"do nothing\"); } public void DoObj() { Console.WriteLine(\"do obj\"); } } } ``` ## 通用的 TryCatchWrapper 函数 通用的静态工具方法，让它接收一个 Func 委托，然后内部执行 try-catch： ```csharp // public static class TryCatchHelper { public static T TryCatch(Func func, T defaultValue = default) { try { return func(); } catch (Exception ex) { Console.WriteLine(ex.Message); return defaultValue; } } } ``` 调用方式： ```csharp int rsint = TryCatchHelper.TryCatch(() =\u003e mq.UpdateIMUserStrCk(strid)); //也可以设置默认值： int rsint = TryCatchHelper.TryCatch(() =\u003e mq.UpdateIMUserStrCk(strid), -1); ``` # 事件 事件是基于订阅-发布模式的一种机制，用于实现对象之间的解耦。 ```Csharp public class Publisher { public event EventHandler CustomEvent; protected virtual void OnCustomEvent(EventArgs e) { CustomEvent?.Invoke(this, e); } public void TriggerEvent() { OnCustomEvent(EventArgs.Empty); } } public class Subscriber { public void OnCustomEvent(object sender, EventArgs e) { Console.WriteLine(\"Event received.\"); } } public class Program { public static void Main() { Publisher publisher = new Publisher(); Subscriber subscriber = new Subscriber(); publisher.CustomEvent += subscriber.OnCustomEvent; publisher.TriggerEvent(); } } ``` 在 .NET 中，事件是一种特殊的委托类型（委托的一个变量），用于实现发布-订阅模式。事件允许一个对象（发布者）通知其他对象（订阅者）发生了某些事情。下面是一个简单的 .NET 事件的例子，我们将创建一个简单的计数器类 Counter，当计数达到特定值时触发事件。 定义事件 首先，我们需要定义一个事件处理器委托，然后在 Counter 类中声明一个事件。 ```Csharp using System; // 定义一个事件处理程序委托 public delegate void ReachedEventHandler(object source, EventArgs e); // 计数器类 public class Counter { // 定义一个事件 public event ReachedEventHandler Reached; private int _count; // 增加计数的方法 public void Increment() { _count++; Console.WriteLine($\"Count is now {_count}\"); // 当计数达到某个值时触发事件 if (_count \u003e= 5) { OnReached(); } } // 触发事件的方法 protected virtual void OnReached() { Reached?.Invoke(this, EventArgs.Empty); } } ``` 使用事件 接下来，我们将在主程序中创建 Counter 类的实例，并订阅其 Reached 事件。 ```Csharp class Program { static void Main(string[] args) { var counter = new Counter(); // 订阅事件 counter.Reached += Counter_Reached; // 模拟增加计数 for (int i = 0; i \u003c 6; i++) { counter.Increment(); } } // 事件处理方法 private static void Counter_Reached(object source, EventArgs e) { Console.WriteLine(\"The count has reached the limit!\"); } } ``` 在这个例子中，每当计数器的值达到5时，就会触发 Reached 事件。订阅了此事件的对象将接收到通知，并可以执行相应的操作。在这个例子中，我们的主程序订阅了这个事件，并定义了一个事件处理方法 Counter_Reached，该方法会在事件被触发时输出一条消息。 这是一个非常基础的示例，实际应用中事件可以携带更多的信息，例如通过自定义的事件参数类来传递数据给事件处理方法。 # 泛型 泛型允许 在定义方法、类或接口时不指定具体的类型，而是在使用的时候再指定。这样可以提高代码的复用性和类型安全性。 ```Csharp public class Box { private T item; public Box(T item) { this.item = item; } public T GetItem() { return item; } } // 使用示例 Box\u003cstring\u003e stringBox = new Box\u003cstring\u003e(\"Hello World\"); string content = stringBox.GetItem(); Console.WriteLine(content); ``` ","wordCount":"634","inLanguage":"en","datePublished":"2024-11-24T17:36:50Z","dateModified":"2024-11-24T17:36:50Z","author":{"@type":"Person","name":"dwd"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://qfsyso.github.io/posts/csharp-reflection-delegate/"},"publisher":{"@type":"Organization","name":"MLOG","logo":{"@type":"ImageObject","url":"https://qfsyso.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://qfsyso.github.io/ accesskey=h title="MLOG (Alt + H)">MLOG</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://qfsyso.github.io/posts/ title=Archive><span>Archive</span></a></li><li><a href=https://qfsyso.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://qfsyso.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">csharp reflection delegate</h1><div class=post-meta><span title='2024-11-24 17:36:50 +0000 UTC'>November 24, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;dwd</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#reflection aria-label=Reflection>Reflection</a></li><li><a href=#delegate aria-label=Delegate>Delegate</a></li></ul></div></details></div><div class=post-content><h1 id=reflection>Reflection<a hidden class=anchor aria-hidden=true href=#reflection>#</a></h1><p>反射
动态加载和创建对象：
反射可以在运行时加载程序集，并基于类型信息创建对象实例，而无需在编译时知道具体的类型。
这对于实现插件系统、动态加载模块或在不同版本的库之间提供兼容性非常有用。</p><p>反射可以获取有关类型（如类、接口、结构体等）及其成员（如字段、属性、方法等）的详细信息。
这对于生成文档、进行代码分析或创建序列化/反序列化机制等任务非常有用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>  class Program
</span></span><span style=display:flex><span>    <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        static void Main<span style=color:#f92672>(</span>string<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            // 加载包含类型的程序集
</span></span><span style=display:flex><span>            Assembly assembly <span style=color:#f92672>=</span> Assembly.LoadFrom<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;ReflectionExample.dll&#34;</span><span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>            // 获取类型信息
</span></span><span style=display:flex><span>            Type type <span style=color:#f92672>=</span> assembly.GetType<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;ReflectionExample.MyClass&#34;</span><span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>            // 创建对象实例
</span></span><span style=display:flex><span>            object instance <span style=color:#f92672>=</span> Activator.CreateInstance<span style=color:#f92672>(</span>type<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>            // 获取方法信息
</span></span><span style=display:flex><span>            MethodInfo methodInfo <span style=color:#f92672>=</span> type.GetMethod<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;MyMethod&#34;</span><span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>            // 调用方法
</span></span><span style=display:flex><span>            methodInfo.Invoke<span style=color:#f92672>(</span>instance, new object<span style=color:#f92672>[]</span> <span style=color:#f92672>{</span> <span style=color:#e6db74>&#34;Hello, Reflection!&#34;</span> <span style=color:#f92672>})</span>;
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    public class MyClass
</span></span><span style=display:flex><span>    <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        public void MyMethod<span style=color:#f92672>(</span>string message<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            Console.WriteLine<span style=color:#f92672>(</span>message<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span></code></pre></div><h1 id=delegate>Delegate<a hidden class=anchor aria-hidden=true href=#delegate>#</a></h1><p><strong>委托</strong>
委托是一种类型安全的函数指针，可以用来引用一个或多个具有相同签名的方法。
委托（Delegate）是一种特殊的类型，它代表对具有特定参数列表和返回类型的函数的引用。委托可以用来封装静态方法或实例方法，并且可以在运行时像普通变量一样传递。这使得委托成为一种强大的工具，用于实现回调函数、事件处理以及其他需要函数作为参数传递的场景。</p><p><strong>委托的基本特性</strong>
类型安全：委托是类型安全的，因为它们在声明时会指定一个方法签名，只有与这个签名匹配的方法才能被委托引用。
多播能力：大多数委托支持多播，即一个委托实例可以引用多个方法。当调用该委托时，所有引用的方法都会被依次调用。
灵活性：委托可以用来引用类的实例方法或静态方法，也可以引用匿名方法（使用lambda表达式）。
定义委托
委托可以通过delegate关键字定义。定义时需要指定返回类型和参数列表。
有访问修饰符，delegate，返回值类型，委托名称，参数-可选。可以在类内部，可以在外部。</p><p><strong>本质</strong>
底层是个特殊类(强类型)， 继承运行时的MulticastDelegate</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Csharp data-lang=Csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>delegate</span> <span style=color:#66d9ef>void</span> MyDelegate(<span style=color:#66d9ef>string</span> message); <span style=color:#75715e>// 返回类型为void，接受一个字符串参数</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>```</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>使用委托</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>创建委托实例</span>
</span></span><span style=display:flex><span> <span style=color:#960050;background-color:#1e0010>可以通过委托的构造函数或者</span>new关键字创建委托实例<span style=color:#960050;background-color:#1e0010>，并将它绑定到具体的方法上。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>```</span>Csharp
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyClass</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> MyMethod(<span style=color:#66d9ef>string</span> message)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Console.WriteLine(message);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> StaticMethod(<span style=color:#66d9ef>string</span> message)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#e6db74>&#34;Static: &#34;</span> + message);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        MyClass instance = <span style=color:#66d9ef>new</span> MyClass();
</span></span><span style=display:flex><span>        MyDelegate del1 = <span style=color:#66d9ef>new</span> MyDelegate(instance.MyMethod);
</span></span><span style=display:flex><span>        MyDelegate del2 = <span style=color:#66d9ef>new</span> MyDelegate(StaticMethod);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 调用委托</span>
</span></span><span style=display:flex><span>        del1(<span style=color:#e6db74>&#34;Hello from instance method&#34;</span>);
</span></span><span style=display:flex><span>        del2(<span style=color:#e6db74>&#34;Hello from static method&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>```</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>多播委托</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>如果</span> <span style=color:#960050;background-color:#1e0010>定义的委托不是</span>void返回类型<span style=color:#960050;background-color:#1e0010>，那么当委托指向多个方法时，只有最后一个方法的返回值会被返回。对于返回类型为</span>void的委托<span style=color:#960050;background-color:#1e0010>，所有方法都会被执行。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>```</span>Csharp
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Method1(<span style=color:#66d9ef>string</span> message)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#e6db74>&#34;Method1: &#34;</span> + message);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Method2(<span style=color:#66d9ef>string</span> message)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#e6db74>&#34;Method2: &#34;</span> + message);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        MyDelegate del1 = <span style=color:#66d9ef>new</span> MyDelegate(Method1);
</span></span><span style=display:flex><span>        MyDelegate del2 = <span style=color:#66d9ef>new</span> MyDelegate(Method2);
</span></span><span style=display:flex><span>        MyDelegate combined = del1 + del2; <span style=color:#75715e>// 组合两个委托</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        combined(<span style=color:#e6db74>&#34;Hello multi-cast delegate&#34;</span>); <span style=color:#75715e>// 调用组合后的委托</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>```</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>使用</span>Lambda表达式
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>从</span>C<span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#ae81ff>3.0</span><span style=color:#960050;background-color:#1e0010>开始，</span> <span style=color:#960050;background-color:#1e0010>可以使用</span>lambda表达式来创建委托<span style=color:#960050;background-color:#1e0010>，这使得代码更加简洁。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>```</span>Csharp
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        MyDelegate del = message =&gt; Console.WriteLine(<span style=color:#e6db74>&#34;Lambda: &#34;</span> + message);
</span></span><span style=display:flex><span>        del(<span style=color:#e6db74>&#34;Hello lambda expression&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>```</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>##</span> <span style=color:#960050;background-color:#1e0010>参数传递委托</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>```</span>csharp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> ConsoleApp1T1
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>delegate</span> <span style=color:#66d9ef>void</span> NoReOutClass();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyDele</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>delegate</span> <span style=color:#66d9ef>void</span> NoReP();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>delegate</span> <span style=color:#66d9ef>void</span> NoRePn(<span style=color:#66d9ef>int</span> x, <span style=color:#66d9ef>int</span> y);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>delegate</span> <span style=color:#66d9ef>int</span> WithReP();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>delegate</span> <span style=color:#66d9ef>int</span> WithRePn(<span style=color:#66d9ef>int</span> x,<span style=color:#66d9ef>ref</span>  <span style=color:#66d9ef>int</span> y);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> show()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#75715e>//NoReP mh1 = new NoReP(DoNothing);</span>
</span></span><span style=display:flex><span>            NoReP methodhander1 = DoNothing;<span style=color:#75715e>//语法糖</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>//methodhander1.Invoke();//执行委托 //old dotnet ver BeginInvoke</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>//本质是类的实例  可以做为参数传递 </span>
</span></span><span style=display:flex><span>            ExDele(methodhander1);<span style=color:#75715e>//类似容器 把一段函数-业务逻辑 传递到不同的地方</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>////使用 </span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>//    MyDele myDele = new MyDele();</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>//    myDele.show();</span>
</span></span><span style=display:flex><span>         }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> ExDele(NoReP de)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            de.Invoke();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> DoNothing()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Console.WriteLine(<span style=color:#e6db74>&#34;do nothing&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> DoObj()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Console.WriteLine(<span style=color:#e6db74>&#34;do obj&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>```</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>##</span> <span style=color:#960050;background-color:#1e0010>通用的</span> TryCatchWrapper <span style=color:#960050;background-color:#1e0010>函数</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>通用的静态工具方法，让它接收一个</span> Func&lt;T&gt; <span style=color:#960050;background-color:#1e0010>委托，然后内部执行</span> <span style=color:#66d9ef>try</span>-<span style=color:#66d9ef>catch</span><span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>```</span>csharp
</span></span><span style=display:flex><span><span style=color:#75715e>//</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TryCatchHelper</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> T TryCatch&lt;T&gt;(Func&lt;T&gt; func, T defaultValue = <span style=color:#66d9ef>default</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> func();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>catch</span> (Exception ex)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Console.WriteLine(ex.Message);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> defaultValue;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>```</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>调用方式：</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>```</span>csharp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> rsint = TryCatchHelper.TryCatch(() =&gt; mq.UpdateIMUserStrCk(strid));
</span></span><span style=display:flex><span><span style=color:#75715e>//也可以设置默认值：</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> rsint = TryCatchHelper.TryCatch(() =&gt; mq.UpdateIMUserStrCk(strid), -<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>```</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#960050;background-color:#1e0010>事件</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>事件是基于订阅</span>-<span style=color:#960050;background-color:#1e0010>发布模式的一种机制，用于实现对象之间的解耦。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>```</span>Csharp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Publisher</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>event</span> EventHandler CustomEvent;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> OnCustomEvent(EventArgs e)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        CustomEvent?.Invoke(<span style=color:#66d9ef>this</span>, e);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> TriggerEvent()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        OnCustomEvent(EventArgs.Empty);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Subscriber</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnCustomEvent(<span style=color:#66d9ef>object</span> sender, EventArgs e)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#e6db74>&#34;Event received.&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Publisher publisher = <span style=color:#66d9ef>new</span> Publisher();
</span></span><span style=display:flex><span>        Subscriber subscriber = <span style=color:#66d9ef>new</span> Subscriber();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        publisher.CustomEvent += subscriber.OnCustomEvent;
</span></span><span style=display:flex><span>        publisher.TriggerEvent();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>```</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>在</span> .NET <span style=color:#960050;background-color:#1e0010>中，事件是一种特殊的委托类型（委托的一个变量），用于实现发布</span>-<span style=color:#960050;background-color:#1e0010>订阅模式。事件允许一个对象（发布者）通知其他对象（订阅者）发生了某些事情。下面是一个简单的</span> .NET <span style=color:#960050;background-color:#1e0010>事件的例子，我们将创建一个简单的计数器类</span> Counter<span style=color:#960050;background-color:#1e0010>，当计数达到特定值时触发事件。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>定义事件</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>首先，我们需要定义一个事件处理器委托，然后在</span> Counter <span style=color:#960050;background-color:#1e0010>类中声明一个事件。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>```</span>Csharp
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 定义一个事件处理程序委托</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>delegate</span> <span style=color:#66d9ef>void</span> ReachedEventHandler(<span style=color:#66d9ef>object</span> source, EventArgs e);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 计数器类</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Counter</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 定义一个事件</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>event</span> ReachedEventHandler Reached;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> _count;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 增加计数的方法</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Increment()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _count++;
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#e6db74>$&#34;Count is now {_count}&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 当计数达到某个值时触发事件</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (_count &gt;= <span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            OnReached();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 触发事件的方法</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> OnReached()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Reached?.Invoke(<span style=color:#66d9ef>this</span>, EventArgs.Empty);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>```</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>使用事件</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>接下来，我们将在主程序中创建</span> Counter <span style=color:#960050;background-color:#1e0010>类的实例，并订阅其</span> Reached <span style=color:#960050;background-color:#1e0010>事件。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>```</span>Csharp
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main(<span style=color:#66d9ef>string</span>[] args)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> counter = <span style=color:#66d9ef>new</span> Counter();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 订阅事件</span>
</span></span><span style=display:flex><span>        counter.Reached += Counter_Reached;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 模拟增加计数</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; <span style=color:#ae81ff>6</span>; i++)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            counter.Increment();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 事件处理方法</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Counter_Reached(<span style=color:#66d9ef>object</span> source, EventArgs e)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Console.WriteLine(<span style=color:#e6db74>&#34;The count has reached the limit!&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>```</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>在这个例子中，每当计数器的值达到</span><span style=color:#ae81ff>5</span><span style=color:#960050;background-color:#1e0010>时，就会触发</span> Reached <span style=color:#960050;background-color:#1e0010>事件。订阅了此事件的对象将接收到通知，并可以执行相应的操作。在这个例子中，我们的主程序订阅了这个事件，并定义了一个事件处理方法</span> Counter_Reached<span style=color:#960050;background-color:#1e0010>，该方法会在事件被触发时输出一条消息。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>这是一个非常基础的示例，实际应用中事件可以携带更多的信息，例如通过自定义的事件参数类来传递数据给事件处理方法。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#960050;background-color:#1e0010>泛型</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>泛型允许</span> <span style=color:#960050;background-color:#1e0010>在定义方法、类或接口时不指定具体的类型，而是在使用的时候再指定。这样可以提高代码的复用性和类型安全性。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>```</span>Csharp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Box</span>&lt;T&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> T item;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Box(T item)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.item = item;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> T GetItem()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> item;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 使用示例</span>
</span></span><span style=display:flex><span>Box&lt;<span style=color:#66d9ef>string</span>&gt; stringBox = <span style=color:#66d9ef>new</span> Box&lt;<span style=color:#66d9ef>string</span>&gt;(<span style=color:#e6db74>&#34;Hello World&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>string</span> content = stringBox.GetItem();
</span></span><span style=display:flex><span>Console.WriteLine(content);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>```</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://qfsyso.github.io/tags/c%23/>C#</a></li><li><a href=https://qfsyso.github.io/tags/.net/>.NET</a></li></ul><nav class=paginav><a class=prev href=https://qfsyso.github.io/posts/packet-splicing/><span class=title>« Prev</span><br><span>packet splicing</span>
</a><a class=next href=https://qfsyso.github.io/posts/redis-sentinel-cluster/><span class=title>Next »</span><br><span>redis sentinel cluster</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share csharp reflection delegate on x" href="https://x.com/intent/tweet/?text=csharp%20reflection%20delegate&amp;url=https%3a%2f%2fqfsyso.github.io%2fposts%2fcsharp-reflection-delegate%2f&amp;hashtags=c%23%2c.NET"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share csharp reflection delegate on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fqfsyso.github.io%2fposts%2fcsharp-reflection-delegate%2f&amp;title=csharp%20reflection%20delegate&amp;summary=csharp%20reflection%20delegate&amp;source=https%3a%2f%2fqfsyso.github.io%2fposts%2fcsharp-reflection-delegate%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share csharp reflection delegate on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fqfsyso.github.io%2fposts%2fcsharp-reflection-delegate%2f&title=csharp%20reflection%20delegate"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share csharp reflection delegate on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fqfsyso.github.io%2fposts%2fcsharp-reflection-delegate%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share csharp reflection delegate on whatsapp" href="https://api.whatsapp.com/send?text=csharp%20reflection%20delegate%20-%20https%3a%2f%2fqfsyso.github.io%2fposts%2fcsharp-reflection-delegate%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share csharp reflection delegate on telegram" href="https://telegram.me/share/url?text=csharp%20reflection%20delegate&amp;url=https%3a%2f%2fqfsyso.github.io%2fposts%2fcsharp-reflection-delegate%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share csharp reflection delegate on ycombinator" href="https://news.ycombinator.com/submitlink?t=csharp%20reflection%20delegate&u=https%3a%2f%2fqfsyso.github.io%2fposts%2fcsharp-reflection-delegate%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><div class=wtime><div class=wtime2>CST<span id=beijingTime></span> GMT <span id=londonTime></span> EST <span id=newYorkTime></span> PST<span id=losAngelesTime></span></div><div class=wtime2 style=display:none>东京<span id=tokyoTime></span></div><div class=wtime2 style=display:none>欧洲-巴黎<span id=parisTime></span></div><div class=wtime2 style=display:none>UTC<span id=utcTime></span></div></div><span>&copy; 2025 <a href=https://qfsyso.github.io/>MLOG</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span><script type=text/javascript>const timeZoneOffsets={beijing:8,tokyo:9,paris:[1,2],london:[0,1],newYork:[-5,-4],losAngeles:[-8,-7]};function padZero(e){return e<10?"0"+e:e}function formatTime(e){const t=e.getFullYear(),n=padZero(e.getMonth()+1),s=padZero(e.getDate()),o=padZero(e.getHours()),i=padZero(e.getMinutes()),a=padZero(e.getSeconds());return`${t}-${n}-${s} ${o}:${i}:${a}`}function isDaylightSavingTime(e,t){const o=e.getMonth(),n=new Date(e.getFullYear(),3,8,2,0,0),s=new Date(e.getFullYear(),10,1,2,0,0);return(t==="paris"||t==="london"||t==="newYork"||t==="losAngeles")&&e>=n&&e<s}function updateTime(){const e=new Date,t=new Date(e.getUTCFullYear(),e.getUTCMonth(),e.getUTCDate(),e.getUTCHours(),e.getUTCMinutes(),e.getUTCSeconds()),n=formatTime(t);document.getElementById("utcTime").innerHTML=n;for(const n in timeZoneOffsets){const e=timeZoneOffsets[n];let s;Array.isArray(e)?s=isDaylightSavingTime(t,n)?e[1]:e[0]:s=e;const o=new Date(t.getTime()+s*60*60*1e3);document.getElementById(n+"Time").innerHTML=formatTime(o)}setTimeout(updateTime,1e3)}window.onload=function(){updateTime()};function notfound(e){var n=e.src,t=n.split("/"),s=t[t.length-1];e.src="https://47.115.223.75:8080/group1/v2/"+s+"?timestamp="+Date.now(),e.onerror=null}</script></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>