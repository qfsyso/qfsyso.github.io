<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>DotNetty ByteBuffer | MLOG</title>
<meta name=keywords content=".NET,Netty"><meta name=description content="DotNetty是一个高性能的.NET网络通信框架，基于Netty，支持TCP、UDP、HTTP、WebSocket等协议。适用于高并发、低延迟场景，如实时通信、游戏服务器、IoT应用及大型分布式系统，通过异步I/O、零拷贝等技术提升性能，具备易用性、可扩展性。 架构上，围绕Channel、EventLoop、ChannelPipeline、ChannelHandlerContext设计，包含Transport、Codec、Handler等模块，简化网络编程，加速数据传输处理。
ByteBuffer 用于高效处理字节数据，固定容量，通过allocate或wrap创建。涉及position和limit追踪读写位置，提供get/put等读写方法，flip切换读写模式，clear清空缓冲区，compact移动数据并准备下一轮读写，适用于高性能IO与网络通信。.
优点 零拷贝通过复合缓冲区实现。 动态容量增长。 无需flip切换读写模式。 分离读写索引。 内置引用计数。 支持缓冲区池化。 优化网络通信中的字节处理。
结构 readerIndex 读取，随读增。 writerIndex 写入，随写增。 capacity容量。
ByteBuffer属性 readIndex：下一个读位 writeIndex：下一个写位置 capacity：容量 0：缓冲区开始位置
已经读取的区域：[0,readerindex) 可读取的区域：[readerindex,writerIndex) 可写的区域: [writerIndex,capacity) 读写独立索引，操作命名区分（read/write自动进，get/set不影响索引）。 支持设定最大容量，超限写操作将抛异常，默认上限Integer.MAX_VALUE。 readerIndex writerIndex 本质为灵活高效字节容器
堆缓冲区 最常用的 ByteBuffer 模式是将数据存储在堆空间中。这种模式被称为支撑数组（backing array），它能在没有使用池化的情况下提供快速的分配和释放。可以由 hasArray() 来判断检查 ByteBuffer是否由数组支撑。如果不是，则这是一个直接缓冲区。
直接缓冲区 直接缓冲区是另外一种 ByteBuffer 模式。 直接缓冲区的主要缺点是，相对于基于堆的缓冲区，它们的分配和释放都较为昂贵。
复合缓冲区 复合缓冲区 CompositeByteBuf，它为多个 ByteBuffer提供一个聚合视图。比如 HTTP 协议， 分为消息头和消息体，这两部分可能由应用程序的不同模块产生，各有各的 ByteBuffer，将会在消息被发送的时候组装为一个 ByteBuffer，此时可以将这两个 ByteBuffer聚合为一个 CompositeByteBuf，然后使用统一和通用的 ByteBuffer API 来操作。
如何在的程序中获得 ByteBuf 的实例，并使用它呢？Netty 提供了两种方式
ByteBufAllocator 接口 ByteBufAllocator 分配任意类型的 ByteBuffer 实例。
buffer(): 基于堆/直接内存ByteBuffer。 heapBuffer(): 仅堆内存。 directBuffer(): 仅直接内存。 compositeBuffer(): 可组合多个缓冲区，支持堆/直接内存。 ioBuffer(): 适配I/O操作，优先直接内存(需Unsafe支持)。 ByteBufAllocator： Channel ChannelHandlerContext"><meta name=author content="dwd"><link rel=canonical href=https://qfsyso.github.io/posts/dotnetty-bytebuffer/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://qfsyso.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://qfsyso.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://qfsyso.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://qfsyso.github.io/apple-touch-icon.png><link rel=mask-icon href=https://qfsyso.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://qfsyso.github.io/posts/dotnetty-bytebuffer/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://qfsyso.github.io/posts/dotnetty-bytebuffer/"><meta property="og:site_name" content="MLOG"><meta property="og:title" content="DotNetty ByteBuffer"><meta property="og:description" content="DotNetty是一个高性能的.NET网络通信框架，基于Netty，支持TCP、UDP、HTTP、WebSocket等协议。适用于高并发、低延迟场景，如实时通信、游戏服务器、IoT应用及大型分布式系统，通过异步I/O、零拷贝等技术提升性能，具备易用性、可扩展性。 架构上，围绕Channel、EventLoop、ChannelPipeline、ChannelHandlerContext设计，包含Transport、Codec、Handler等模块，简化网络编程，加速数据传输处理。
ByteBuffer 用于高效处理字节数据，固定容量，通过allocate或wrap创建。涉及position和limit追踪读写位置，提供get/put等读写方法，flip切换读写模式，clear清空缓冲区，compact移动数据并准备下一轮读写，适用于高性能IO与网络通信。.
优点 零拷贝通过复合缓冲区实现。 动态容量增长。 无需flip切换读写模式。 分离读写索引。 内置引用计数。 支持缓冲区池化。 优化网络通信中的字节处理。
结构 readerIndex 读取，随读增。 writerIndex 写入，随写增。 capacity容量。
ByteBuffer属性 readIndex：下一个读位 writeIndex：下一个写位置 capacity：容量 0：缓冲区开始位置
已经读取的区域：[0,readerindex) 可读取的区域：[readerindex,writerIndex) 可写的区域: [writerIndex,capacity) 读写独立索引，操作命名区分（read/write自动进，get/set不影响索引）。 支持设定最大容量，超限写操作将抛异常，默认上限Integer.MAX_VALUE。 readerIndex writerIndex 本质为灵活高效字节容器
堆缓冲区 最常用的 ByteBuffer 模式是将数据存储在堆空间中。这种模式被称为支撑数组（backing array），它能在没有使用池化的情况下提供快速的分配和释放。可以由 hasArray() 来判断检查 ByteBuffer是否由数组支撑。如果不是，则这是一个直接缓冲区。
直接缓冲区 直接缓冲区是另外一种 ByteBuffer 模式。 直接缓冲区的主要缺点是，相对于基于堆的缓冲区，它们的分配和释放都较为昂贵。
复合缓冲区 复合缓冲区 CompositeByteBuf，它为多个 ByteBuffer提供一个聚合视图。比如 HTTP 协议， 分为消息头和消息体，这两部分可能由应用程序的不同模块产生，各有各的 ByteBuffer，将会在消息被发送的时候组装为一个 ByteBuffer，此时可以将这两个 ByteBuffer聚合为一个 CompositeByteBuf，然后使用统一和通用的 ByteBuffer API 来操作。
如何在的程序中获得 ByteBuf 的实例，并使用它呢？Netty 提供了两种方式
ByteBufAllocator 接口 ByteBufAllocator 分配任意类型的 ByteBuffer 实例。
buffer(): 基于堆/直接内存ByteBuffer。 heapBuffer(): 仅堆内存。 directBuffer(): 仅直接内存。 compositeBuffer(): 可组合多个缓冲区，支持堆/直接内存。 ioBuffer(): 适配I/O操作，优先直接内存(需Unsafe支持)。 ByteBufAllocator： Channel ChannelHandlerContext"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-05-23T21:47:10+00:00"><meta property="article:modified_time" content="2024-05-23T21:47:10+00:00"><meta property="article:tag" content=".NET"><meta property="article:tag" content="Netty"><meta name=twitter:card content="summary"><meta name=twitter:title content="DotNetty ByteBuffer"><meta name=twitter:description content="DotNetty是一个高性能的.NET网络通信框架，基于Netty，支持TCP、UDP、HTTP、WebSocket等协议。适用于高并发、低延迟场景，如实时通信、游戏服务器、IoT应用及大型分布式系统，通过异步I/O、零拷贝等技术提升性能，具备易用性、可扩展性。 架构上，围绕Channel、EventLoop、ChannelPipeline、ChannelHandlerContext设计，包含Transport、Codec、Handler等模块，简化网络编程，加速数据传输处理。
ByteBuffer 用于高效处理字节数据，固定容量，通过allocate或wrap创建。涉及position和limit追踪读写位置，提供get/put等读写方法，flip切换读写模式，clear清空缓冲区，compact移动数据并准备下一轮读写，适用于高性能IO与网络通信。.
优点 零拷贝通过复合缓冲区实现。 动态容量增长。 无需flip切换读写模式。 分离读写索引。 内置引用计数。 支持缓冲区池化。 优化网络通信中的字节处理。
结构 readerIndex 读取，随读增。 writerIndex 写入，随写增。 capacity容量。
ByteBuffer属性 readIndex：下一个读位 writeIndex：下一个写位置 capacity：容量 0：缓冲区开始位置
已经读取的区域：[0,readerindex) 可读取的区域：[readerindex,writerIndex) 可写的区域: [writerIndex,capacity) 读写独立索引，操作命名区分（read/write自动进，get/set不影响索引）。 支持设定最大容量，超限写操作将抛异常，默认上限Integer.MAX_VALUE。 readerIndex writerIndex 本质为灵活高效字节容器
堆缓冲区 最常用的 ByteBuffer 模式是将数据存储在堆空间中。这种模式被称为支撑数组（backing array），它能在没有使用池化的情况下提供快速的分配和释放。可以由 hasArray() 来判断检查 ByteBuffer是否由数组支撑。如果不是，则这是一个直接缓冲区。
直接缓冲区 直接缓冲区是另外一种 ByteBuffer 模式。 直接缓冲区的主要缺点是，相对于基于堆的缓冲区，它们的分配和释放都较为昂贵。
复合缓冲区 复合缓冲区 CompositeByteBuf，它为多个 ByteBuffer提供一个聚合视图。比如 HTTP 协议， 分为消息头和消息体，这两部分可能由应用程序的不同模块产生，各有各的 ByteBuffer，将会在消息被发送的时候组装为一个 ByteBuffer，此时可以将这两个 ByteBuffer聚合为一个 CompositeByteBuf，然后使用统一和通用的 ByteBuffer API 来操作。
如何在的程序中获得 ByteBuf 的实例，并使用它呢？Netty 提供了两种方式
ByteBufAllocator 接口 ByteBufAllocator 分配任意类型的 ByteBuffer 实例。
buffer(): 基于堆/直接内存ByteBuffer。 heapBuffer(): 仅堆内存。 directBuffer(): 仅直接内存。 compositeBuffer(): 可组合多个缓冲区，支持堆/直接内存。 ioBuffer(): 适配I/O操作，优先直接内存(需Unsafe支持)。 ByteBufAllocator： Channel ChannelHandlerContext"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://qfsyso.github.io/posts/"},{"@type":"ListItem","position":2,"name":"DotNetty ByteBuffer","item":"https://qfsyso.github.io/posts/dotnetty-bytebuffer/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"DotNetty ByteBuffer","name":"DotNetty ByteBuffer","description":"DotNetty是一个高性能的.NET网络通信框架，基于Netty，支持TCP、UDP、HTTP、WebSocket等协议。适用于高并发、低延迟场景，如实时通信、游戏服务器、IoT应用及大型分布式系统，通过异步I/O、零拷贝等技术提升性能，具备易用性、可扩展性。 架构上，围绕Channel、EventLoop、ChannelPipeline、ChannelHandlerContext设计，包含Transport、Codec、Handler等模块，简化网络编程，加速数据传输处理。\nByteBuffer 用于高效处理字节数据，固定容量，通过allocate或wrap创建。涉及position和limit追踪读写位置，提供get/put等读写方法，flip切换读写模式，clear清空缓冲区，compact移动数据并准备下一轮读写，适用于高性能IO与网络通信。.\n优点 零拷贝通过复合缓冲区实现。 动态容量增长。 无需flip切换读写模式。 分离读写索引。 内置引用计数。 支持缓冲区池化。 优化网络通信中的字节处理。\n结构 readerIndex 读取，随读增。 writerIndex 写入，随写增。 capacity容量。\nByteBuffer属性 readIndex：下一个读位 writeIndex：下一个写位置 capacity：容量 0：缓冲区开始位置\n已经读取的区域：[0,readerindex) 可读取的区域：[readerindex,writerIndex) 可写的区域: [writerIndex,capacity) 读写独立索引，操作命名区分（read/write自动进，get/set不影响索引）。 支持设定最大容量，超限写操作将抛异常，默认上限Integer.MAX_VALUE。 readerIndex writerIndex 本质为灵活高效字节容器\n堆缓冲区 最常用的 ByteBuffer 模式是将数据存储在堆空间中。这种模式被称为支撑数组（backing array），它能在没有使用池化的情况下提供快速的分配和释放。可以由 hasArray() 来判断检查 ByteBuffer是否由数组支撑。如果不是，则这是一个直接缓冲区。\n直接缓冲区 直接缓冲区是另外一种 ByteBuffer 模式。 直接缓冲区的主要缺点是，相对于基于堆的缓冲区，它们的分配和释放都较为昂贵。\n复合缓冲区 复合缓冲区 CompositeByteBuf，它为多个 ByteBuffer提供一个聚合视图。比如 HTTP 协议， 分为消息头和消息体，这两部分可能由应用程序的不同模块产生，各有各的 ByteBuffer，将会在消息被发送的时候组装为一个 ByteBuffer，此时可以将这两个 ByteBuffer聚合为一个 CompositeByteBuf，然后使用统一和通用的 ByteBuffer API 来操作。\n如何在的程序中获得 ByteBuf 的实例，并使用它呢？Netty 提供了两种方式\nByteBufAllocator 接口 ByteBufAllocator 分配任意类型的 ByteBuffer 实例。\nbuffer(): 基于堆/直接内存ByteBuffer。 heapBuffer(): 仅堆内存。 directBuffer(): 仅直接内存。 compositeBuffer(): 可组合多个缓冲区，支持堆/直接内存。 ioBuffer(): 适配I/O操作，优先直接内存(需Unsafe支持)。 ByteBufAllocator： Channel ChannelHandlerContext","keywords":[".NET","Netty"],"articleBody":"DotNetty是一个高性能的.NET网络通信框架，基于Netty，支持TCP、UDP、HTTP、WebSocket等协议。适用于高并发、低延迟场景，如实时通信、游戏服务器、IoT应用及大型分布式系统，通过异步I/O、零拷贝等技术提升性能，具备易用性、可扩展性。 架构上，围绕Channel、EventLoop、ChannelPipeline、ChannelHandlerContext设计，包含Transport、Codec、Handler等模块，简化网络编程，加速数据传输处理。\nByteBuffer 用于高效处理字节数据，固定容量，通过allocate或wrap创建。涉及position和limit追踪读写位置，提供get/put等读写方法，flip切换读写模式，clear清空缓冲区，compact移动数据并准备下一轮读写，适用于高性能IO与网络通信。.\n优点 零拷贝通过复合缓冲区实现。 动态容量增长。 无需flip切换读写模式。 分离读写索引。 内置引用计数。 支持缓冲区池化。 优化网络通信中的字节处理。\n结构 readerIndex 读取，随读增。 writerIndex 写入，随写增。 capacity容量。\nByteBuffer属性 readIndex：下一个读位 writeIndex：下一个写位置 capacity：容量 0：缓冲区开始位置\n已经读取的区域：[0,readerindex) 可读取的区域：[readerindex,writerIndex) 可写的区域: [writerIndex,capacity) 读写独立索引，操作命名区分（read/write自动进，get/set不影响索引）。 支持设定最大容量，超限写操作将抛异常，默认上限Integer.MAX_VALUE。 readerIndex writerIndex 本质为灵活高效字节容器\n堆缓冲区 最常用的 ByteBuffer 模式是将数据存储在堆空间中。这种模式被称为支撑数组（backing array），它能在没有使用池化的情况下提供快速的分配和释放。可以由 hasArray() 来判断检查 ByteBuffer是否由数组支撑。如果不是，则这是一个直接缓冲区。\n直接缓冲区 直接缓冲区是另外一种 ByteBuffer 模式。 直接缓冲区的主要缺点是，相对于基于堆的缓冲区，它们的分配和释放都较为昂贵。\n复合缓冲区 复合缓冲区 CompositeByteBuf，它为多个 ByteBuffer提供一个聚合视图。比如 HTTP 协议， 分为消息头和消息体，这两部分可能由应用程序的不同模块产生，各有各的 ByteBuffer，将会在消息被发送的时候组装为一个 ByteBuffer，此时可以将这两个 ByteBuffer聚合为一个 CompositeByteBuf，然后使用统一和通用的 ByteBuffer API 来操作。\n如何在的程序中获得 ByteBuf 的实例，并使用它呢？Netty 提供了两种方式\nByteBufAllocator 接口 ByteBufAllocator 分配任意类型的 ByteBuffer 实例。\nbuffer(): 基于堆/直接内存ByteBuffer。 heapBuffer(): 仅堆内存。 directBuffer(): 仅直接内存。 compositeBuffer(): 可组合多个缓冲区，支持堆/直接内存。 ioBuffer(): 适配I/O操作，优先直接内存(需Unsafe支持)。 ByteBufAllocator： Channel ChannelHandlerContext\nUnpooled 缓冲区\nUnpooled工具类助创ByteBuffer buffer()：堆内存ByteBuffer directBuffer()：直接内存ByteBuffer wrappedBuffer()：包装数据的ByteBuffer copiedBuffer()：复制数据的ByteBuffer 适用范围广泛，不仅限于Netty网络项目。\nIByteBuffer byteBuf = Unpooled.CopiedBuffer(\"hello,world!\", Encoding.UTF8); ByteBuf访问/读写 索引从0开始至capacity()-1。 随机访问（get/set）不改索引，需显式调用readerIndex()/writerIndex()移动。 顺序访问分两类： get/set：固定索引，读写数据不移位。 read/write：自动调整readerIndex/writerIndex。\nisReadable() 如果至少有一个字节可供读取，则返回 true isWritable() 如果至少有一个字节可被写入，则返回 true readableBytes() 返回可被读取的字节数 writableBytes() 返回可被写入的字节数 capacity() 返回 ByteBuffer 可容纳的字节数。在此之后，它会尝试再次扩展直到达到 maxCapacity() maxCapacity() 返回 ByteBuffer 可以容纳的最大字节数 hasArray() 如果 ByteBuffer 由一个字节数组支撑，则返回 true array() 如果 ByteBuffer 由一个字节数组支撑则返回该数组\n可丢弃字节 读操作后，字节积累在\"可丢弃\"段，始于readerIndex。 discardReadBytes()释放已读字节，回收空间，可能导致之前数据移动。 此操作可能涉及内存复制，谨慎使用。\n可读字节：存储实际数据，新缓冲区默认从readerIndex=0开始。 可写字节：空白区域待写入，新缓冲区writerIndex初设0，写操作后自动递增。\n资源释放 处理Netty入站ByteBuffer ，可选自动释放：用SimpleChannelInboundHandler，或在channelRead()末手动调用ReferenceCountUtil.release(msg)确保资源管理。\nusing DotNetty.Buffers; using DotNetty.Transport.Channels; public class CommanChannelInboundHandler : SimpleChannelInboundHandler\u003cobject\u003e { protected override void ChannelRead(IChannelHandlerContext context, object message) { bool shouldRelease = true; try { if (IsMessageAcceptable(message)) { ChannelRead0(context, message); } else { shouldRelease = false; context.FireChannelRead(message); } } finally { if (AutoRelease \u0026\u0026 shouldRelease) { ResourceUtil.Release(message); } } } private bool IsMessageAcceptable(object msg) { return msg is IByteBuffer; // 假设只处理IByteBuffer类型的消息 } protected virtual void ChannelRead0(IChannelHandlerContext context, object message) { //IByteBuffer ... } private bool AutoRelease { get; set; } = true; } 对于出站请求，不管 ByteBuffer 是否由我们的业务创建的，当调用了 write 或者 writeAndFlush 方法后，Netty 会自动替我们释放，不需要我们业务代码自行释放。\n// 创建ByteBuf对象，初始容量为1，内部动态扩容以容纳更多数据 IByteBuffer byteBuf = Unpooled.Buffer(1); Console.WriteLine(\"byteBuf=\" + byteBuf); for (int i = 0; i \u003c 8; i++) { byteBuf.WriteByte(i); } Console.WriteLine(\"byteBuf=\" + byteBuf); for (int i = 0; i \u003c 5; i++) { Console.WriteLine(byteBuf.GetByte(i)); } Console.WriteLine(\"byteBuf=\" + byteBuf); for (int i = 0; i \u003c 5; i++) { Console.WriteLine(byteBuf.ReadByte()); } Console.WriteLine(\"byteBuf=\" + byteBuf); //byteBuf2 // 使用Unpooled工具类创建ByteBuf，内容为\"hello,world!\" IByteBuffer byteBuf2 = Unpooled.CopiedBuffer(\"hello,world!\", Encoding.UTF8); // Unpooled.CopiedBuffer(\"hello,world!\", Encoding.UTF8); // 使用相关的方法 if (byteBuf2.HasArray) // if (byteBuf2.HasArray) { byte[] content = byteBuf2.Array; // 将content转成字符串 Console.WriteLine(Encoding.UTF8.GetString(content)); Console.WriteLine(\"byteBuf2=\" + byteBuf2); Console.WriteLine(byteBuf2.GetByte(0)); // 获取数组0这个位置的字符'h'的ASCII码，h=104 int len = byteBuf2.ReadableBytes; // 可读的字节数 12 Console.WriteLine(\"len=\" + len); // 使用for取出各个字节并转换为对应的字符打印 for (int i = 0; i \u003c len; i++) { Console.WriteLine((char)byteBuf2.GetByte(i)); } // 范围读取 Console.WriteLine(byteBuf2.GetCharSequence(0, 6, Encoding.UTF8)); Console.WriteLine(byteBuf2.GetCharSequence(6, 6, Encoding.UTF8)); } //byteBuf3 WrappedBuffer var str1 = Encoding.UTF8.GetBytes(\"hello,world!\"); var byteBuf3 = Unpooled.WrappedBuffer(str1); if (byteBuf3.HasArray) // if (byteBuf2.HasArray) { byte[] content = byteBuf3.Array; // 将content转成字符串 Console.WriteLine(Encoding.UTF8.GetString(content)); Console.WriteLine(\"byteBuf3=\" + byteBuf3); Console.WriteLine(byteBuf3.GetByte(0)); // 获取数组0这个位置的字符'h'的ASCII码，h=104 int len = byteBuf3.ReadableBytes; // 可读的字节数 12 Console.WriteLine(\"len=\" + len); // 使用for取出各个字节并转换为对应的字符打印 for (int i = 0; i \u003c len; i++) { Console.WriteLine((char)byteBuf3.GetByte(i)); } // 范围读取 Console.WriteLine(byteBuf3.GetCharSequence(0, 6, Encoding.UTF8)); Console.WriteLine(byteBuf3.GetCharSequence(6, 6, Encoding.UTF8)); } 结果得出 get操作 readerIndex 不变，read操作使其移动。\nEnd\n","wordCount":"414","inLanguage":"en","datePublished":"2024-05-23T21:47:10Z","dateModified":"2024-05-23T21:47:10Z","author":{"@type":"Person","name":"dwd"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://qfsyso.github.io/posts/dotnetty-bytebuffer/"},"publisher":{"@type":"Organization","name":"MLOG","logo":{"@type":"ImageObject","url":"https://qfsyso.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://qfsyso.github.io/ accesskey=h title="MLOG (Alt + H)">MLOG</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://qfsyso.github.io/posts/ title=Archive><span>Archive</span></a></li><li><a href=https://qfsyso.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://qfsyso.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">DotNetty ByteBuffer</h1><div class=post-meta><span title='2024-05-23 21:47:10 +0000 UTC'>May 23, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;dwd</div></header><div class=post-content><p><strong>DotNetty</strong>是一个高性能的.NET网络通信框架，基于Netty，支持TCP、UDP、HTTP、WebSocket等协议。适用于高并发、低延迟场景，如实时通信、游戏服务器、IoT应用及大型分布式系统，通过异步I/O、零拷贝等技术提升性能，具备易用性、可扩展性。
架构上，围绕Channel、EventLoop、ChannelPipeline、ChannelHandlerContext设计，包含Transport、Codec、Handler等模块，简化网络编程，加速数据传输处理。</p><p><strong>ByteBuffer</strong> 用于高效处理字节数据，固定容量，通过allocate或wrap创建。涉及position和limit追踪读写位置，提供get/put等读写方法，flip切换读写模式，clear清空缓冲区，compact移动数据并准备下一轮读写，适用于高性能IO与网络通信。.</p><p><strong>优点</strong>
零拷贝通过复合缓冲区实现。
动态容量增长。
无需flip切换读写模式。
分离读写索引。
内置引用计数。
支持缓冲区池化。
优化网络通信中的字节处理。</p><p><strong>结构</strong>
readerIndex 读取，随读增。
writerIndex 写入，随写增。
capacity容量。</p><p><strong>ByteBuffer属性</strong>
readIndex：下一个读位
writeIndex：下一个写位置
capacity：容量
0：缓冲区开始位置</p><p>已经读取的区域：[0,readerindex)
可读取的区域：[readerindex,writerIndex)
可写的区域: [writerIndex,capacity)
读写独立索引，操作命名区分（read/write自动进，get/set不影响索引）。
支持设定最大容量，超限写操作将抛异常，默认上限Integer.MAX_VALUE。
readerIndex writerIndex 本质为灵活高效字节容器</p><p><strong>堆缓冲区</strong>
最常用的 ByteBuffer 模式是将数据存储在堆空间中。这种模式被称为支撑数组（backing array），它能在没有使用池化的情况下提供快速的分配和释放。可以由 hasArray() 来判断检查 ByteBuffer是否由数组支撑。如果不是，则这是一个直接缓冲区。</p><p><strong>直接缓冲区</strong>
直接缓冲区是另外一种 ByteBuffer 模式。
直接缓冲区的主要缺点是，相对于基于堆的缓冲区，它们的分配和释放都较为昂贵。</p><p><strong>复合缓冲区</strong>
复合缓冲区 CompositeByteBuf，它为多个 ByteBuffer提供一个聚合视图。比如 HTTP 协议， 分为消息头和消息体，这两部分可能由应用程序的不同模块产生，各有各的 ByteBuffer，将会在消息被发送的时候组装为一个 ByteBuffer，此时可以将这两个 ByteBuffer聚合为一个 CompositeByteBuf，然后使用统一和通用的 ByteBuffer API 来操作。</p><p>如何在的程序中获得 ByteBuf 的实例，并使用它呢？Netty 提供了两种方式</p><p><strong>ByteBufAllocator 接口</strong>
ByteBufAllocator 分配任意类型的 ByteBuffer 实例。</p><p>buffer(): 基于堆/直接内存ByteBuffer。
heapBuffer(): 仅堆内存。
directBuffer(): 仅直接内存。
compositeBuffer(): 可组合多个缓冲区，支持堆/直接内存。
ioBuffer(): 适配I/O操作，优先直接内存(需Unsafe支持)。
ByteBufAllocator：
Channel ChannelHandlerContext</p><p><strong>Unpooled 缓冲区</strong></p><p>Unpooled工具类助创ByteBuffer
buffer()：堆内存ByteBuffer
directBuffer()：直接内存ByteBuffer
wrappedBuffer()：包装数据的ByteBuffer
copiedBuffer()：复制数据的ByteBuffer 适用范围广泛，不仅限于Netty网络项目。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span> IByteBuffer byteBuf = Unpooled.CopiedBuffer(<span style=color:#e6db74>&#34;hello,world!&#34;</span>, Encoding.UTF8); 
</span></span></code></pre></div><p><strong>ByteBuf访问/读写</strong>
索引从0开始至capacity()-1。
随机访问（get/set）不改索引，需显式调用readerIndex()/writerIndex()移动。
顺序访问分两类：
get/set：固定索引，读写数据不移位。
read/write：自动调整readerIndex/writerIndex。</p><p>isReadable() 如果至少有一个字节可供读取，则返回 true
isWritable() 如果至少有一个字节可被写入，则返回 true
readableBytes() 返回可被读取的字节数
writableBytes() 返回可被写入的字节数
capacity() 返回 ByteBuffer 可容纳的字节数。在此之后，它会尝试再次扩展直到达到
maxCapacity()
maxCapacity() 返回 ByteBuffer 可以容纳的最大字节数
hasArray() 如果 ByteBuffer 由一个字节数组支撑，则返回 true
array() 如果 ByteBuffer 由一个字节数组支撑则返回该数组</p><p><strong>可丢弃字节</strong>
读操作后，字节积累在"可丢弃"段，始于readerIndex。
discardReadBytes()释放已读字节，回收空间，可能导致之前数据移动。
此操作可能涉及内存复制，谨慎使用。</p><p><strong>可读字节</strong>：存储实际数据，新缓冲区默认从readerIndex=0开始。
<strong>可写字节</strong>：空白区域待写入，新缓冲区writerIndex初设0，写操作后自动递增。</p><p><strong>资源释放</strong>
处理Netty入站ByteBuffer ，可选自动释放：用SimpleChannelInboundHandler，或在channelRead()末手动调用ReferenceCountUtil.release(msg)确保资源管理。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>using</span> DotNetty.Buffers;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> DotNetty.Transport.Channels;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CommanChannelInboundHandler</span> : SimpleChannelInboundHandler&lt;<span style=color:#66d9ef>object</span>&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> ChannelRead(IChannelHandlerContext context, <span style=color:#66d9ef>object</span> message)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> shouldRelease = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (IsMessageAcceptable(message))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                ChannelRead0(context, message);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                shouldRelease = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                context.FireChannelRead(message);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>finally</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (AutoRelease &amp;&amp; shouldRelease)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                ResourceUtil.Release(message);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>bool</span> IsMessageAcceptable(<span style=color:#66d9ef>object</span> msg)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>       
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> msg <span style=color:#66d9ef>is</span> IByteBuffer; <span style=color:#75715e>// 假设只处理IByteBuffer类型的消息</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> ChannelRead0(IChannelHandlerContext context, <span style=color:#66d9ef>object</span> message)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//IByteBuffer ...</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>bool</span> AutoRelease { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; } = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>对于<strong>出站请求</strong>，不管 ByteBuffer 是否由我们的业务创建的，当调用了 write 或者 writeAndFlush 方法后，Netty 会自动替我们释放，不需要我们业务代码自行释放。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>   <span style=color:#75715e>// 创建ByteBuf对象，初始容量为1，内部动态扩容以容纳更多数据</span>
</span></span><span style=display:flex><span>   IByteBuffer byteBuf = Unpooled.Buffer(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>   Console.WriteLine(<span style=color:#e6db74>&#34;byteBuf=&#34;</span> + byteBuf);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; <span style=color:#ae81ff>8</span>; i++)
</span></span><span style=display:flex><span>   {
</span></span><span style=display:flex><span>       byteBuf.WriteByte(i);
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>   Console.WriteLine(<span style=color:#e6db74>&#34;byteBuf=&#34;</span> + byteBuf);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; <span style=color:#ae81ff>5</span>; i++)
</span></span><span style=display:flex><span>   {
</span></span><span style=display:flex><span>       Console.WriteLine(byteBuf.GetByte(i));
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>   Console.WriteLine(<span style=color:#e6db74>&#34;byteBuf=&#34;</span> + byteBuf);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; <span style=color:#ae81ff>5</span>; i++)
</span></span><span style=display:flex><span>   {
</span></span><span style=display:flex><span>       Console.WriteLine(byteBuf.ReadByte());
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>   Console.WriteLine(<span style=color:#e6db74>&#34;byteBuf=&#34;</span> + byteBuf);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#75715e>//byteBuf2</span>
</span></span><span style=display:flex><span>   <span style=color:#75715e>// 使用Unpooled工具类创建ByteBuf，内容为&#34;hello,world!&#34;</span>
</span></span><span style=display:flex><span>   IByteBuffer byteBuf2 = Unpooled.CopiedBuffer(<span style=color:#e6db74>&#34;hello,world!&#34;</span>, Encoding.UTF8); <span style=color:#75715e>// Unpooled.CopiedBuffer(&#34;hello,world!&#34;, Encoding.UTF8);</span>
</span></span><span style=display:flex><span>   <span style=color:#75715e>// 使用相关的方法</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> (byteBuf2.HasArray) <span style=color:#75715e>// if (byteBuf2.HasArray)</span>
</span></span><span style=display:flex><span>   {
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>byte</span>[] content = byteBuf2.Array;
</span></span><span style=display:flex><span>       <span style=color:#75715e>// 将content转成字符串</span>
</span></span><span style=display:flex><span>       Console.WriteLine(Encoding.UTF8.GetString(content));
</span></span><span style=display:flex><span>       Console.WriteLine(<span style=color:#e6db74>&#34;byteBuf2=&#34;</span> + byteBuf2);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       Console.WriteLine(byteBuf2.GetByte(<span style=color:#ae81ff>0</span>)); <span style=color:#75715e>// 获取数组0这个位置的字符&#39;h&#39;的ASCII码，h=104</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>int</span> len = byteBuf2.ReadableBytes; <span style=color:#75715e>// 可读的字节数 12</span>
</span></span><span style=display:flex><span>       Console.WriteLine(<span style=color:#e6db74>&#34;len=&#34;</span> + len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       <span style=color:#75715e>// 使用for取出各个字节并转换为对应的字符打印</span>
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; len; i++)
</span></span><span style=display:flex><span>       {
</span></span><span style=display:flex><span>           Console.WriteLine((<span style=color:#66d9ef>char</span>)byteBuf2.GetByte(i));
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       <span style=color:#75715e>// 范围读取</span>
</span></span><span style=display:flex><span>       Console.WriteLine(byteBuf2.GetCharSequence(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>6</span>, Encoding.UTF8));
</span></span><span style=display:flex><span>       Console.WriteLine(byteBuf2.GetCharSequence(<span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>6</span>, Encoding.UTF8));
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#75715e>//byteBuf3 WrappedBuffer</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>var</span> str1 = Encoding.UTF8.GetBytes(<span style=color:#e6db74>&#34;hello,world!&#34;</span>);
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>var</span> byteBuf3 = Unpooled.WrappedBuffer(str1);
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> (byteBuf3.HasArray) <span style=color:#75715e>// if (byteBuf2.HasArray)</span>
</span></span><span style=display:flex><span>   {
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>byte</span>[] content = byteBuf3.Array;
</span></span><span style=display:flex><span>       <span style=color:#75715e>// 将content转成字符串</span>
</span></span><span style=display:flex><span>       Console.WriteLine(Encoding.UTF8.GetString(content));
</span></span><span style=display:flex><span>       Console.WriteLine(<span style=color:#e6db74>&#34;byteBuf3=&#34;</span> + byteBuf3);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       Console.WriteLine(byteBuf3.GetByte(<span style=color:#ae81ff>0</span>)); <span style=color:#75715e>// 获取数组0这个位置的字符&#39;h&#39;的ASCII码，h=104</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>int</span> len = byteBuf3.ReadableBytes; <span style=color:#75715e>// 可读的字节数 12</span>
</span></span><span style=display:flex><span>       Console.WriteLine(<span style=color:#e6db74>&#34;len=&#34;</span> + len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       <span style=color:#75715e>// 使用for取出各个字节并转换为对应的字符打印</span>
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; len; i++)
</span></span><span style=display:flex><span>       {
</span></span><span style=display:flex><span>           Console.WriteLine((<span style=color:#66d9ef>char</span>)byteBuf3.GetByte(i));
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       <span style=color:#75715e>// 范围读取</span>
</span></span><span style=display:flex><span>       Console.WriteLine(byteBuf3.GetCharSequence(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>6</span>, Encoding.UTF8));
</span></span><span style=display:flex><span>       Console.WriteLine(byteBuf3.GetCharSequence(<span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>6</span>, Encoding.UTF8));
</span></span><span style=display:flex><span>   }
</span></span></code></pre></div><p>结果得出 get操作 readerIndex 不变，read操作使其移动。</p><p>End</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://qfsyso.github.io/tags/.net/>.NET</a></li><li><a href=https://qfsyso.github.io/tags/netty/>Netty</a></li></ul><nav class=paginav><a class=prev href=https://qfsyso.github.io/posts/harmonyos-interface-router-arkts-arkui/><span class=title>« Prev</span><br><span>HarmonyOS Interface Router ArkTS ArkUI</span>
</a><a class=next href=https://qfsyso.github.io/posts/.net-fileupload/><span class=title>Next »</span><br><span>.NET FileUpload</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share DotNetty ByteBuffer on x" href="https://x.com/intent/tweet/?text=DotNetty%20ByteBuffer&amp;url=https%3a%2f%2fqfsyso.github.io%2fposts%2fdotnetty-bytebuffer%2f&amp;hashtags=.NET%2cNetty"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share DotNetty ByteBuffer on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fqfsyso.github.io%2fposts%2fdotnetty-bytebuffer%2f&amp;title=DotNetty%20ByteBuffer&amp;summary=DotNetty%20ByteBuffer&amp;source=https%3a%2f%2fqfsyso.github.io%2fposts%2fdotnetty-bytebuffer%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share DotNetty ByteBuffer on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fqfsyso.github.io%2fposts%2fdotnetty-bytebuffer%2f&title=DotNetty%20ByteBuffer"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share DotNetty ByteBuffer on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fqfsyso.github.io%2fposts%2fdotnetty-bytebuffer%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share DotNetty ByteBuffer on whatsapp" href="https://api.whatsapp.com/send?text=DotNetty%20ByteBuffer%20-%20https%3a%2f%2fqfsyso.github.io%2fposts%2fdotnetty-bytebuffer%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share DotNetty ByteBuffer on telegram" href="https://telegram.me/share/url?text=DotNetty%20ByteBuffer&amp;url=https%3a%2f%2fqfsyso.github.io%2fposts%2fdotnetty-bytebuffer%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share DotNetty ByteBuffer on ycombinator" href="https://news.ycombinator.com/submitlink?t=DotNetty%20ByteBuffer&u=https%3a%2f%2fqfsyso.github.io%2fposts%2fdotnetty-bytebuffer%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><div class=wtime><div class=wtime2>CST<span id=beijingTime></span> GMT <span id=londonTime></span> EST <span id=newYorkTime></span> PST<span id=losAngelesTime></span></div><div class=wtime2 style=display:none>东京<span id=tokyoTime></span></div><div class=wtime2 style=display:none>欧洲-巴黎<span id=parisTime></span></div><div class=wtime2 style=display:none>UTC<span id=utcTime></span></div></div><span>&copy; 2025 <a href=https://qfsyso.github.io/>MLOG</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span><script type=text/javascript>const timeZoneOffsets={beijing:8,tokyo:9,paris:[1,2],london:[0,1],newYork:[-5,-4],losAngeles:[-8,-7]};function padZero(e){return e<10?"0"+e:e}function formatTime(e){const t=e.getFullYear(),n=padZero(e.getMonth()+1),s=padZero(e.getDate()),o=padZero(e.getHours()),i=padZero(e.getMinutes()),a=padZero(e.getSeconds());return`${t}-${n}-${s} ${o}:${i}:${a}`}function isDaylightSavingTime(e,t){const o=e.getMonth(),n=new Date(e.getFullYear(),3,8,2,0,0),s=new Date(e.getFullYear(),10,1,2,0,0);return(t==="paris"||t==="london"||t==="newYork"||t==="losAngeles")&&e>=n&&e<s}function updateTime(){const e=new Date,t=new Date(e.getUTCFullYear(),e.getUTCMonth(),e.getUTCDate(),e.getUTCHours(),e.getUTCMinutes(),e.getUTCSeconds()),n=formatTime(t);document.getElementById("utcTime").innerHTML=n;for(const n in timeZoneOffsets){const e=timeZoneOffsets[n];let s;Array.isArray(e)?s=isDaylightSavingTime(t,n)?e[1]:e[0]:s=e;const o=new Date(t.getTime()+s*60*60*1e3);document.getElementById(n+"Time").innerHTML=formatTime(o)}setTimeout(updateTime,1e3)}window.onload=function(){updateTime()};function notfound(e){var n=e.src,t=n.split("/"),s=t[t.length-1];e.src="https://47.115.223.75:8080/group1/v2/"+s+"?timestamp="+Date.now(),e.onerror=null}</script></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>