<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Docker DevOps | MLOG</title>
<meta name=keywords content><meta name=description content="云原生应用十二要素原则解析表 原则 核心价值 实现方法 技术案例 1. 基准代码 快速交付；合理划分边界 单一代码库+多环境部署，版本控制统一管理 Git仓库管理，Kubernetes多集群部署 2. 依赖 提升开发效率；排除意外风险 显式声明依赖+隔离环境（容器化） Docker镜像打包依赖，Helm Chart管理应用包 3. 配置 软件发布管理；环境无差别 配置与代码分离→环境变量注入 Kubernetes ConfigMap/Secret动态加载 4. 后端服务 弹性/敏捷；解耦状态管理 将慢速进程（如DB/队列）转为RESTful服务 Redis缓存服务，消息队列(Kafka)独立部署 5. 构建发布运行 持续交付；流水线自动化 CI/CD全流程自动化（构建→测试→部署） Jenkins/GitLab CI流水线，K8s Rolling Update 6. 进程 云兼容性；无状态设计 应用无状态化，会话数据外置后端服务 会话存储Redis，文件存储OSS 7. 端口绑定 自包含服务；独立暴露接口 服务直接监听端口，不依赖Web服务器转发 Spring Boot内嵌Tomcat，gRPC直连 8. 并发 自动弹性伸缩 水平扩展替代垂直扩展，依赖云平台弹性能力 Kubernetes HPA自动扩缩容 9. 易处理 快速故障恢复 断路器模式+优雅终止，进程可随时启停 Istio服务熔断，K8s Liveness探针 10. 环境等价 可靠性；开发与生产环境一致 容器化保证环境一致性，禁用环境特殊配置 Docker跨环境运行，开发环境Minikube 11. 日志 实时系统监控 日志作为事件流→集中式管理 EFK栈(Elasticsearch+Fluentd+Kibana) 12. 管理进程 运维效率；运营解耦 管理任务（如DB迁移）作为独立进程，与主应用隔离 K8s Job/CronJob执行批处理任务 特性 云原生应用 传统应用 可预测性 符合弹性框架，通过容器编排和微服务实现可预测行为 不可预测，批量发布易引发单点故障，扩展能力有限 操作系统依赖 抽象化（容器技术隔离OS依赖，实现跨平台运行） 强依赖（需特定OS环境，迁移困难） 资源调度 弹性伸缩（按需自动分配资源，利用率＞70%） 冗余静态（预留资源应对峰值，利用率＜40%） 团队协作 DevOps驱动（开发运维一体化，自动化流水线） 部门墙隔离（开发/测试/运维独立，沟通成本高） 开发模式 敏捷迭代（CI/CD支持每日多次部署） 瀑布模型（数月/年周期发布，变更困难） 服务架构 微服务（独立部署、高内聚低耦合） 单体架构（模块紧耦合，牵一发而动全身） 运维能力 自动化（K8s实现自愈、监控、扩缩容） 手动操作（人工监控、故障排查效率低） 故障恢复 秒级恢复（容器快速重启+服务网格流量调度） 小时级恢复（依赖备份还原，流程复杂） 云原生架构模式:微服务架构 云原生架构演进原则 01."><meta name=author content="dwd"><link rel=canonical href=https://qfsyso.github.io/posts/docker-devops/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://qfsyso.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://qfsyso.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://qfsyso.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://qfsyso.github.io/apple-touch-icon.png><link rel=mask-icon href=https://qfsyso.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://qfsyso.github.io/posts/docker-devops/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://qfsyso.github.io/posts/docker-devops/"><meta property="og:site_name" content="MLOG"><meta property="og:title" content="Docker DevOps"><meta property="og:description" content="云原生应用十二要素原则解析表 原则 核心价值 实现方法 技术案例 1. 基准代码 快速交付；合理划分边界 单一代码库+多环境部署，版本控制统一管理 Git仓库管理，Kubernetes多集群部署 2. 依赖 提升开发效率；排除意外风险 显式声明依赖+隔离环境（容器化） Docker镜像打包依赖，Helm Chart管理应用包 3. 配置 软件发布管理；环境无差别 配置与代码分离→环境变量注入 Kubernetes ConfigMap/Secret动态加载 4. 后端服务 弹性/敏捷；解耦状态管理 将慢速进程（如DB/队列）转为RESTful服务 Redis缓存服务，消息队列(Kafka)独立部署 5. 构建发布运行 持续交付；流水线自动化 CI/CD全流程自动化（构建→测试→部署） Jenkins/GitLab CI流水线，K8s Rolling Update 6. 进程 云兼容性；无状态设计 应用无状态化，会话数据外置后端服务 会话存储Redis，文件存储OSS 7. 端口绑定 自包含服务；独立暴露接口 服务直接监听端口，不依赖Web服务器转发 Spring Boot内嵌Tomcat，gRPC直连 8. 并发 自动弹性伸缩 水平扩展替代垂直扩展，依赖云平台弹性能力 Kubernetes HPA自动扩缩容 9. 易处理 快速故障恢复 断路器模式+优雅终止，进程可随时启停 Istio服务熔断，K8s Liveness探针 10. 环境等价 可靠性；开发与生产环境一致 容器化保证环境一致性，禁用环境特殊配置 Docker跨环境运行，开发环境Minikube 11. 日志 实时系统监控 日志作为事件流→集中式管理 EFK栈(Elasticsearch+Fluentd+Kibana) 12. 管理进程 运维效率；运营解耦 管理任务（如DB迁移）作为独立进程，与主应用隔离 K8s Job/CronJob执行批处理任务 特性 云原生应用 传统应用 可预测性 符合弹性框架，通过容器编排和微服务实现可预测行为 不可预测，批量发布易引发单点故障，扩展能力有限 操作系统依赖 抽象化（容器技术隔离OS依赖，实现跨平台运行） 强依赖（需特定OS环境，迁移困难） 资源调度 弹性伸缩（按需自动分配资源，利用率＞70%） 冗余静态（预留资源应对峰值，利用率＜40%） 团队协作 DevOps驱动（开发运维一体化，自动化流水线） 部门墙隔离（开发/测试/运维独立，沟通成本高） 开发模式 敏捷迭代（CI/CD支持每日多次部署） 瀑布模型（数月/年周期发布，变更困难） 服务架构 微服务（独立部署、高内聚低耦合） 单体架构（模块紧耦合，牵一发而动全身） 运维能力 自动化（K8s实现自愈、监控、扩缩容） 手动操作（人工监控、故障排查效率低） 故障恢复 秒级恢复（容器快速重启+服务网格流量调度） 小时级恢复（依赖备份还原，流程复杂） 云原生架构模式:微服务架构 云原生架构演进原则 01."><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-06-05T20:23:33+08:00"><meta property="article:modified_time" content="2025-06-05T20:23:33+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Docker DevOps"><meta name=twitter:description content="云原生应用十二要素原则解析表 原则 核心价值 实现方法 技术案例 1. 基准代码 快速交付；合理划分边界 单一代码库+多环境部署，版本控制统一管理 Git仓库管理，Kubernetes多集群部署 2. 依赖 提升开发效率；排除意外风险 显式声明依赖+隔离环境（容器化） Docker镜像打包依赖，Helm Chart管理应用包 3. 配置 软件发布管理；环境无差别 配置与代码分离→环境变量注入 Kubernetes ConfigMap/Secret动态加载 4. 后端服务 弹性/敏捷；解耦状态管理 将慢速进程（如DB/队列）转为RESTful服务 Redis缓存服务，消息队列(Kafka)独立部署 5. 构建发布运行 持续交付；流水线自动化 CI/CD全流程自动化（构建→测试→部署） Jenkins/GitLab CI流水线，K8s Rolling Update 6. 进程 云兼容性；无状态设计 应用无状态化，会话数据外置后端服务 会话存储Redis，文件存储OSS 7. 端口绑定 自包含服务；独立暴露接口 服务直接监听端口，不依赖Web服务器转发 Spring Boot内嵌Tomcat，gRPC直连 8. 并发 自动弹性伸缩 水平扩展替代垂直扩展，依赖云平台弹性能力 Kubernetes HPA自动扩缩容 9. 易处理 快速故障恢复 断路器模式+优雅终止，进程可随时启停 Istio服务熔断，K8s Liveness探针 10. 环境等价 可靠性；开发与生产环境一致 容器化保证环境一致性，禁用环境特殊配置 Docker跨环境运行，开发环境Minikube 11. 日志 实时系统监控 日志作为事件流→集中式管理 EFK栈(Elasticsearch+Fluentd+Kibana) 12. 管理进程 运维效率；运营解耦 管理任务（如DB迁移）作为独立进程，与主应用隔离 K8s Job/CronJob执行批处理任务 特性 云原生应用 传统应用 可预测性 符合弹性框架，通过容器编排和微服务实现可预测行为 不可预测，批量发布易引发单点故障，扩展能力有限 操作系统依赖 抽象化（容器技术隔离OS依赖，实现跨平台运行） 强依赖（需特定OS环境，迁移困难） 资源调度 弹性伸缩（按需自动分配资源，利用率＞70%） 冗余静态（预留资源应对峰值，利用率＜40%） 团队协作 DevOps驱动（开发运维一体化，自动化流水线） 部门墙隔离（开发/测试/运维独立，沟通成本高） 开发模式 敏捷迭代（CI/CD支持每日多次部署） 瀑布模型（数月/年周期发布，变更困难） 服务架构 微服务（独立部署、高内聚低耦合） 单体架构（模块紧耦合，牵一发而动全身） 运维能力 自动化（K8s实现自愈、监控、扩缩容） 手动操作（人工监控、故障排查效率低） 故障恢复 秒级恢复（容器快速重启+服务网格流量调度） 小时级恢复（依赖备份还原，流程复杂） 云原生架构模式:微服务架构 云原生架构演进原则 01."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://qfsyso.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Docker DevOps","item":"https://qfsyso.github.io/posts/docker-devops/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Docker DevOps","name":"Docker DevOps","description":"云原生应用十二要素原则解析表 原则 核心价值 实现方法 技术案例 1. 基准代码 快速交付；合理划分边界 单一代码库+多环境部署，版本控制统一管理 Git仓库管理，Kubernetes多集群部署 2. 依赖 提升开发效率；排除意外风险 显式声明依赖+隔离环境（容器化） Docker镜像打包依赖，Helm Chart管理应用包 3. 配置 软件发布管理；环境无差别 配置与代码分离→环境变量注入 Kubernetes ConfigMap/Secret动态加载 4. 后端服务 弹性/敏捷；解耦状态管理 将慢速进程（如DB/队列）转为RESTful服务 Redis缓存服务，消息队列(Kafka)独立部署 5. 构建发布运行 持续交付；流水线自动化 CI/CD全流程自动化（构建→测试→部署） Jenkins/GitLab CI流水线，K8s Rolling Update 6. 进程 云兼容性；无状态设计 应用无状态化，会话数据外置后端服务 会话存储Redis，文件存储OSS 7. 端口绑定 自包含服务；独立暴露接口 服务直接监听端口，不依赖Web服务器转发 Spring Boot内嵌Tomcat，gRPC直连 8. 并发 自动弹性伸缩 水平扩展替代垂直扩展，依赖云平台弹性能力 Kubernetes HPA自动扩缩容 9. 易处理 快速故障恢复 断路器模式+优雅终止，进程可随时启停 Istio服务熔断，K8s Liveness探针 10. 环境等价 可靠性；开发与生产环境一致 容器化保证环境一致性，禁用环境特殊配置 Docker跨环境运行，开发环境Minikube 11. 日志 实时系统监控 日志作为事件流→集中式管理 EFK栈(Elasticsearch+Fluentd+Kibana) 12. 管理进程 运维效率；运营解耦 管理任务（如DB迁移）作为独立进程，与主应用隔离 K8s Job/CronJob执行批处理任务 特性 云原生应用 传统应用 可预测性 符合弹性框架，通过容器编排和微服务实现可预测行为 不可预测，批量发布易引发单点故障，扩展能力有限 操作系统依赖 抽象化（容器技术隔离OS依赖，实现跨平台运行） 强依赖（需特定OS环境，迁移困难） 资源调度 弹性伸缩（按需自动分配资源，利用率＞70%） 冗余静态（预留资源应对峰值，利用率＜40%） 团队协作 DevOps驱动（开发运维一体化，自动化流水线） 部门墙隔离（开发/测试/运维独立，沟通成本高） 开发模式 敏捷迭代（CI/CD支持每日多次部署） 瀑布模型（数月/年周期发布，变更困难） 服务架构 微服务（独立部署、高内聚低耦合） 单体架构（模块紧耦合，牵一发而动全身） 运维能力 自动化（K8s实现自愈、监控、扩缩容） 手动操作（人工监控、故障排查效率低） 故障恢复 秒级恢复（容器快速重启+服务网格流量调度） 小时级恢复（依赖备份还原，流程复杂） 云原生架构模式:微服务架构 云原生架构演进原则 01.","keywords":[],"articleBody":"云原生应用十二要素原则解析表 原则 核心价值 实现方法 技术案例 1. 基准代码 快速交付；合理划分边界 单一代码库+多环境部署，版本控制统一管理 Git仓库管理，Kubernetes多集群部署 2. 依赖 提升开发效率；排除意外风险 显式声明依赖+隔离环境（容器化） Docker镜像打包依赖，Helm Chart管理应用包 3. 配置 软件发布管理；环境无差别 配置与代码分离→环境变量注入 Kubernetes ConfigMap/Secret动态加载 4. 后端服务 弹性/敏捷；解耦状态管理 将慢速进程（如DB/队列）转为RESTful服务 Redis缓存服务，消息队列(Kafka)独立部署 5. 构建发布运行 持续交付；流水线自动化 CI/CD全流程自动化（构建→测试→部署） Jenkins/GitLab CI流水线，K8s Rolling Update 6. 进程 云兼容性；无状态设计 应用无状态化，会话数据外置后端服务 会话存储Redis，文件存储OSS 7. 端口绑定 自包含服务；独立暴露接口 服务直接监听端口，不依赖Web服务器转发 Spring Boot内嵌Tomcat，gRPC直连 8. 并发 自动弹性伸缩 水平扩展替代垂直扩展，依赖云平台弹性能力 Kubernetes HPA自动扩缩容 9. 易处理 快速故障恢复 断路器模式+优雅终止，进程可随时启停 Istio服务熔断，K8s Liveness探针 10. 环境等价 可靠性；开发与生产环境一致 容器化保证环境一致性，禁用环境特殊配置 Docker跨环境运行，开发环境Minikube 11. 日志 实时系统监控 日志作为事件流→集中式管理 EFK栈(Elasticsearch+Fluentd+Kibana) 12. 管理进程 运维效率；运营解耦 管理任务（如DB迁移）作为独立进程，与主应用隔离 K8s Job/CronJob执行批处理任务 特性 云原生应用 传统应用 可预测性 符合弹性框架，通过容器编排和微服务实现可预测行为 不可预测，批量发布易引发单点故障，扩展能力有限 操作系统依赖 抽象化（容器技术隔离OS依赖，实现跨平台运行） 强依赖（需特定OS环境，迁移困难） 资源调度 弹性伸缩（按需自动分配资源，利用率＞70%） 冗余静态（预留资源应对峰值，利用率＜40%） 团队协作 DevOps驱动（开发运维一体化，自动化流水线） 部门墙隔离（开发/测试/运维独立，沟通成本高） 开发模式 敏捷迭代（CI/CD支持每日多次部署） 瀑布模型（数月/年周期发布，变更困难） 服务架构 微服务（独立部署、高内聚低耦合） 单体架构（模块紧耦合，牵一发而动全身） 运维能力 自动化（K8s实现自愈、监控、扩缩容） 手动操作（人工监控、故障排查效率低） 故障恢复 秒级恢复（容器快速重启+服务网格流量调度） 小时级恢复（依赖备份还原，流程复杂） 云原生架构模式:微服务架构 云原生架构演进原则 01.弹性 微服务采用无状态设计支持按需使用、自动水平伸缩;实例快速启动，并在不影响业务的前提下优雅中止。\n02.分布式 应用分布式:业务逻辑与数据解耦、业务逻辑与会话解耦;数鶼習揿僥髦据分布式:去中心、自均衡、最终一致性;跨可用区的部署与调度。\n03.高可用 基于不可靠、可抛弃的资源设计高可用、反脆弱系统，应用任意(微)服务实例失效，系统能够快速发现、隔离并自动恢复;云基础设施和平台服务发生任意单点故障不影响系统整体可用性。 04. 自动化 系统能够自动化部署、升级和扩综容，支持自动化监控、告警、故障的定界定位和故障自愈。 05 自服务 服务可被其他应用或开发猼联蒼晴菋捯笥鐸耐蔡顢錚穩助发现，自助按需获取，自助使用并计量，自助服务管理。\n云原生应用架构思考:单体架构的局限性 单体架构的问题不在于不可拆分上，在于无法隔离和自治。应用规模越大，局限性越明显\n云原生架构模式:微服务架构\n微服务独立性和敏捷性更好，架构持续演进更容易，更适合云原生应用\n云原生架构模式:Serverless架构 Serverless(无服务器架构)指的是由开发者实现的服务端逻辑运行在无状态的计算容器中，它由事件触发，完全被第三方管理，Serverless是在传统容器技术和服务网格上发展起来，更侧重让使用者只关注自己的业务逻辑即可。\nServerless方案业务价值 更轻量化:用户专注于业务创新和代码开发，代码运行环境由云平台提供，无需管理基础设施资源。 更快弹性:根据请求的并发数量自动调度资源运行函数，毫秒级弹性伸缩，高效应对业务峰值。 更低成本:根据函数调用次数、运行时长和节点转换次数计费，函数不运行时不产生费用，更加节省成本。\nServerless与微服务的关系:微服务向Serverless演进，并长期共存。\n容器资源管理 Docker容器实现原理 Docker容器通过namespace技术实现进程隔离，通过cgroup技术实现容器进程可用资源的限制。 Docker启动一个容器时，实际是创建了包含多个namespace参数的进程。\nNamespace Namespace:命名空间 作用:资源隔离。 原理:namespace将内核的全局资源进行封装，使得每个namespace都有一份独立的资源。因此不同进程在各自namespace内对同一种资源的使用不会相互干扰。\nLinux Namespace 类型整理 Namespace 类型 系统调用参数 隔离内容 引入的内核版本 PID Namespace CLONE_NEWPID 进程空间（进程 ID） Linux 2.6.24 Mount Namespace CLONE_NEWNS 文件系统挂载点 Linux 2.6.19 Network Namespace CLONE_NEWNET 网络资源（网络设备、端口等） 始于 Linux 2.6.24，完成于 2.6.29 User Namespace CLONE_NEWUSER 用户 ID 和用户组 ID 始于 Linux 2.6.23，完成于 Linux 3.8 UTS Namespace CLONE_NEWUTS 主机名和域名 Linux 2.6.19 IPC Namespace CLONE_NEWIPC 信号量、消息队列和共享内存 Linux 2.6.19 Cgroups Cgroups: Linux Control Group。 作用:限制一个进程组对系统资源的使用上限，包括CPU、内存、BlockI/O等。 Cgroups还可以设置进程优先级，对进程进行挂起和恢复等操作。 原理:将一组进程放在一个Cgroup中，通过给这个Cgroup分配指定的可用资源，达到控制这一组进程可用资源的目的实现:在Linux中，Cgroups以文件和目录的方式组织在操作系统的/sys/fs/cgroup路径下。该路径中所有的资源种类均可被Cgroup限制。\n内存限额 容器可使用的内存包括两个部分:物理内存和swap。Docker通过两组参数来控制容器内存的使用量: -m或-memory:设置内存的使用限额。 –memory-swap:设置内存+swap的使用限额。\nCPU限额 默认设置下，所有容器可以平等地使用host CPU资源并且没有限制。Docker可以通过-c或–cpu-shares设置容器使用CPU的权重。\nBlock lO带宽限额 默认情况下，所有容器能平等地读写磁盘，可以通过设置–blkio-weight参数来改变容器block 10的优先级。\n容器网络与存储 ##Docker原生网络 Docker提供如下5种原生的Network drivers。\n模型 说明 None (dk安装时) none 网络中的容器不能与外部通信。 Host (dk安装时) 容器加入到宿主机的 Network Namespace，容器直接使用宿主机网络。 Bridge (dk安装时) 默认网络驱动程序。主要用于多个容器在同一个 Docker 宿主机上通信。 Overlay 基于 Linux 网桥和 VXLAN，可实现跨主机的容器通信。 Macvlan 通过为容器分配物理网卡的 MAC 地址，适用于需要与物理网络通信的场景。 Host网络 挂在host网络上的容器共享宿主机的network namespace。即容器的网络配置与host网络配置完全一样。 容器创建时，可以通过–network=host指定使用host网络。\nBridge网络 Bridge网络是docker使用最广泛、也是默认的网络。 Docker安装时会创建一个名为docker0的linuxbridge。如果不指定–network，创建的容器默认都会挂到docker0上。docker0网络创建时已默认配置了subnet子网。\nUser-defined网络 除了自动创建的none、host、bridge三个网络，用户可按需创建user-defined网络。Docker提供三种user-defined bridge网络驱动:bridge、oyerlay和macvlan。我们可以通过bridge驱动创建类似前面默认的bridge网络。\n容器数据卷 卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File system提供一些用于持续存储或共享数据的特性。卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷. 启动容器的时候直接使用-v命令就可以进行数据卷的挂载。 还可以在Dockerfile中使用VOLUME指令来给镜像添加一个或多个数据卷。\nVolume Volume由docker管理，是将特定目录挂载给容器。Docker会在指定路径/var/lib/docker/volumes下为每个volume生成一个目录作为mount源。 Volume创建过程: 容器启动时，简单的告诉docker:“我需要一个volume存放数据，帮我mount到目录/abc”。 Docker在/var/lib/docker/volumes 中生成一个随机目录作为mount源。 如果/abc已经存在，则将数据复制到mount源。 将volume mount到/abc。 docker volume ls\nBind mount Bind mount是将宿主机上已有的目录或文件mount到容器中。\nTmpfs mount Volumes和bind mounts是在容器和宿主机之间做数据共享，将数据持久化到宿主机上。 tmpfs mounts是将文件创建在容器可写层之外，实际落在宿主机的内存中。 使用tmpfs mounts的限制: 宿主机OS是Linux。 无法向volumes和bind mounts一样，在容器之间共享文件。\n容器与Host共享数据 两种类型的 data volume均可实现在容器与 host 之间共享数据，但方式有所不同。 bind mount: 直接将要共享的目录mount到容器。 volume: 由于volume位于host中的目录，是在容器启动时才生成，所以需要将共享数据拷贝到volume中。使用docker cp命令在容器与Host之间复制数据。使用cp命令将需要共享的数据copy到该volume的目录下。\n容器之间共享数据 bind mount:将Host上的目录或文件mount到多个容器中。 volume:将volume挂载到多个容器中。 volume container:先通过volume或bind mount将数据挂载到一个container中，其他容器再引用这个container中的数据。 data-packed volume container:将数据打包到镜像中，然后volume 共享。\n云原生解决方案 云原生基础设施底座 容器引擎 容器网络 容器存储 30秒创建1000个容器\n基于云原生基础设施的多云管理解决方案 多集群、多区域、多云统一应用管理能力，实现更大规模业务支撑能力，更灵活的弹性与容灾能力。 多云容器平台（MCP）：基于多集群联邦技术完成多个不同区域、不同云的K8s集群与应用统一管理。 应用服务网络（ASM）：完成多个不同区域、不同云的Kubernetes集群上所部属应用的全局治理。\n高性价比 统一计算平台，业务混合部署，集群 利用率平均提升30% 昇腾，鲲鹏－高性价比异构算力\n极致性能 Volcano智能调度，批量任务效率平均 提升30% 30秒发放1000容器，满足极速弹性要求\n高效运维 Serverless服务，基础设施NoOps 自动+自定义指标弹性伸缩\n云原生未来发展趋势 云原生未来发展趋势 Kubernetes编排统一化，编排对象不断扩展延伸。 Kubernetes的编排对象持扩展\n应用侧围绕Kubernetes生态加速演。 服务治理Mesh化，加速传统应用转型。 服务治理与业务逻辑解耦。\n异构系统的统一治理。 应用服务Serverless化，更加聚焦业务的核心价值。 聚焦核心业务逻辑，极大提升应用开发效率。\n云原生服务部署形态多元化，多云将成为主流。 多云、多集群部署渐成为常态，未来将是编程式多云管理服务的时代。\n通过容器资源管理与容器网络和存储的操作 借助cgroup限制容器CPU利用率。 搭建容器bridge网络。 创建容器存储卷。\n容器网络 2.1 容器网络模型 前置步骤：配置镜像仓库\nyum -y install docker vi /etc/docker/daemon.json 按 “i” 键，添加如下内容：\n{ \"registry-mirrors\": \\[ \"https://docker.mirrors.ustc.edu.cn\" ] } 按 Esc 键 → 输入 “:wq!” → 按回车键保存退出。\n查看镜像源有无修改\nsystemctl restart docker docker info ① 运行容器（host 网络模型）并验证 docker run -itd --network=host hub.c.163.com/library/centos 替换 “容器 ID” 后进入容器：\ndocker exec -it 容器ID bash 在容器内安装工具并查看网络信息：\ncurl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo yum install iproute -y ip addr 退出容器后，在宿主机验证网络信息：\nexit ip addr 说明：容器与宿主机共享网络 namespace，网络信息完全一致。\n保存容器镜像\ndocker commit 容器ID centos-iproute ② 运行容器（bridge 网络模型）并验证 docker run -itd --network=bridge centos-iproute # --network=bridge可省略（默认网桥为docker0） 替换 “容器 ID” 后进入容器查看网络信息：\ndocker exec -it 容器ID bash ip addr ③ 查看 docker0 网桥信息 exit docker network inspect bridge docker0 ④ 删除实验容器 docker container ls docker rm 容器ID -f 2.2 Docker bridge 网络 ① 创建用户自定义网桥 docker network create --driver bridge --subnet 173.18.0.0/16 --gateway 173.18.0.1 servicebridge01 查看网桥信息（替换 “网络 ID”）：\ndocker network inspect 网络ID ② 运行容器并挂载到自定义网桥 docker run -itd --network=servicebridge01 centos-iproute 查看容器网络配置（替换 “容器 ID”）：\ndocker inspect 容器ID ③ 容器挂载双网桥（默认 docker0 + 自定义网桥） docker run -itd centos-iproute # 先挂载默认docker0网桥 将容器添加到自定义网桥（替换 “网络 ID” 和 “容器 ID”）：\ndocker network connect 网络ID 容器ID docker exec -it 容器ID bash ip addr ④ 验证容器互通性 ping 容器IP # 替换为步骤②中容器的IP地址 按 Ctrl+C 终止进程。\n⑤ 删除实验容器 exit docker container ls docker rm 容器ID -f 云容器快速搭建 容器为app提供独立的受控的运行环境 ，轻量级的虚拟化操作系统。sandbox\n集装箱 容器 对比维度 物理集装箱 容器（软件容器） 打包对象 几乎支持所有类型的货物（如工业品、农产品等） 任何软件及其依赖（代码、运行环境、库文件等） 标准化 - 标准化尺寸（如 20 英尺、40 英尺）- 统一交接方式（起重机装卸） - 无需修改即可运行于多平台（虚拟机、物理机、公有云、私有云）- 遵循标准化镜像格式（如 Docker Image） 硬件 / 环境依赖 依赖运输工具（货船、火车、货车）及装卸设备 无底层硬件依赖，通过虚拟化技术抽象资源 隔离性 - 物理隔离货物，避免碰撞、污染- 可堆叠运输，互不影响 - 资源隔离（CPU、内存、存储）- 网络隔离与依赖隔离，避免组件冲突 自动化 标准化流程支持自动化装载、卸货、转运 - 标准操作指令（如docker run）- 支持 CI/CD、自动化测试、一键部署 高效性 减少货物拆箱 / 重装耗时，提升运输效率 - 轻量级（启动秒级）- 高移植性（镜像可快速迁移至不同环境） 操控性 点对点运输，无需开箱即可整体移动 镜像化部署，支持快速启停、迁移、扩展 职责分工 - 发货人：关注货物本身- 托运人：关注运输与装卸 - 开发者：聚焦代码逻辑- 运维人员：聚焦基础设施管理 Docker-容器技术的代名词 ·Docker是目前使用最广泛的容器技术，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器 ·利用该技术，您可以将一款软件打包成一个标准化的软件开发单元，其中包括软件运行所需的全部内容：代码、运行时间、系统工具和系统库等。Docker使您能够在任何环境下快速、可靠、一致地部署应用程序。\n基本架构 Docker客户端（Client) Docker客户端通过命令行或者其他工具使用 Docker API与 Docker的守护进程通信。\nDocker主机 （Host） 一个物理或者虚拟的机器用于执行Docker守护进程和容器。\nDocker镜像(Images) V Docker镜像是用于创建Docker容器的模板。\nDocker容器（Container) V 容器是独立运行的─个或一组应用。\nDocker Daemon 服务端守护进程，负责接收客户端的指令，并处理这些请求（创建、运行、分发容器）。\nDocker仓库（Registry) V Docker仓库用来保存镜像，可以理解为代码控制中的代码仓库。 DockerHub提供了庞大的镜像集合供使用。\nCCE应用场景 传统IT架构渐进式转型\n提升业务上线效率\n业务负荷波动明显\n节省资源降低成本\n快速搭建 Step1：资源/环境 Step2：创建RDS Step3：创建CCE Step4:\t创建 Step5:\t访问 Step6:\t弹性伸缩\n《利用华为云资源搭建 WordPress 及弹性伸缩设置》 步骤 2：创建虚拟私有云 VPC **什么是安全组？**安全组是一种虚拟防火墙，用于控制虚拟私有云（VPC）内实例的入站和出站流量，通过配置允许或拒绝规则实现网络访问控制。\n创建 VPC 操作步骤： 进入控制台，在 “服务列表” 下点击 “网络 \u003e 虚拟私有云”，进入网络控制台页面。\n点击 “创建虚拟私有云”，按以下信息配置：\n基本信息\n当前区域：华北 - 北京四\n名称：myvpc\n网段：192.168.0.0/16\n默认子网\n名称：subnet-myvpc\n其余配置保持默认\n返回 “虚拟私有云” 界面，确认已创建的 myvpc。\n在网络控制台左侧菜单栏点击 “访问控制\u003e 安全组”，进入安全组页面，选择 default 默认安全组右侧的【配置规则】。\n点击 “添加规则”，为 default 安全组添加入方向规则，放通 3306 及 80 端口。\n步骤 3：创建 RDS 关系型数据库 **什么是 RDS（华为云关系型数据库）？**RDS 是华为云提供的关系型数据库服务，支持 MySQL、SQL Server 等引擎，提供弹性扩展、高可用性等功能，简化数据库管理。\n创建 RDS 实例操作步骤： 打开控制台，在 “服务列表” 下选择 “数据库 \u003e 云数据库 RDS”，点击 “购买数据库实例”。\n配置实例参数：\n计费模式：按需计费\n区域：华北 - 北京四\n数据库引擎：MySQL\n数据库版本：5.7\n实例类型：单机\n性能规格：通用型 | 2 核 | 4GB（如售罄选相似规格）\n存储空间：40GB\n实例名称：rds-web\n管理员密码：自行设置（后续需用）\n虚拟私有云：选择 myvpc 及 subnet-myvpc\n数据库端口：3306\n安全组：选择 default\n时区：北京，其余默认\n点击 “立即购买” 并 “提交”，实例创建需 6-10 分钟。\n等待期间可同步进行步骤 4，创建完成后记录数据库实例的内网地址。\n进入数据库管理界面，在 “账号管理” 创建账号（主机 IP 输入 %），在 “数据库管理” 创建数据库并授权。\n步骤 4：在 CCE 上创建集群并添加节点 **什么是 CCE（华为云容器引擎）？**CCE 是华为云提供的容器引擎服务，支持 Kubernetes 集群管理，用于部署、扩展和管理容器化应用。\n创建集群及节点操作步骤： 返回控制台，在 “服务列表” 下选择 “容器 \u003e 云容器引擎 CCE”，进入 CCE 页面。\n选择购买 CCE Standard 集群，配置参数：\n计费模式：按需计费\n集群名称：test\n版本：v1.30 或推荐版本\n集群规模：50 节点\n网络模型：容器隧道网络\n虚拟私有云：选择 myvpc\n控制节点子网：选择 subnet-myvpc\n其余配置默认\n依次完成插件选择（默认）、规格确认，提交创建集群（约 5 分钟）。\n集群创建完成后，点击 “创建节点”，配置参数：\n计费方式：按需计费\n节点规格：通用型 | s6.xlarge.2|4 核 | 8GB（若售罄选相近规格）\n操作系统：EulerOS 2.9\n登录方式：密码（自行设置）\n虚拟私有云：myvpc\n节点子网：subnet-myvpc\n弹性公网 IP：自动创建（按流量计费，带宽 5M）\n节点数量：2 台，其余默认\n确认规格后提交，节点创建需 4 分钟，确认状态为 “运行中”。 步骤 5：创建 wordpress 工作负载 操作步骤： 在 CCE 集群中进入 “工作负载” 界面，点击 “创建负载”。\n配置基本信息：\n负载类型：无状态负载\n名称：wordpress\n实例数量：1\n镜像选择：镜像中心搜索 wordpress，版本 php7.3\n添加环境变量（需提前完成 RDS 账号及数据库创建）： WORDPRESS_DB_HOST：RDS 内网地址：3306\nWORDPRESS_DB_NAME：RDS 创建的数据库名称\nWORDPRESS_DB_USER：RDS 创建的账号名称\nWORDPRESS_DB_PASSWORD：RDS 账号密码\n服务配置： Service 名称：wordpress\n访问类型：负载均衡\n端口配置：TCP，容器端口 80，服务端口 80\n负载均衡器：共享型，自动创建（名称 wordpress）\n确认后创建工作负载，状态变为 “运行中” 后，获取外部访问地址。\n访问地址完成 wordpress 安装配置（语言简体中文，设置站点标题、用户名、密码等）。\n步骤 6：配置网站应用弹性伸缩 操作步骤： 进入 CCE test 集群，选择 “工作负载\u003e wordpress”。\n手动扩容：调整实例个数为 3，确认实例数扩容至 3 个。\n弹性伸缩策略配置：\n进入 “弹性伸缩”，安装 CustomedHPA 插件（保持默认设置）。\n创建 CustomedHPA 策略：\n实例范围：1-3\n冷却时间：1 分钟\n触发条件：CPU 利用率 \u003c 50%\n执行操作：减少 1 个实例\n确认策略创建成功（状态 “已启用”），等待 2 分钟观察实例自动缩减。\n利用公有镜像搭建 wordpress 并完成伸缩设置。\n","wordCount":"882","inLanguage":"en","datePublished":"2025-06-05T20:23:33+08:00","dateModified":"2025-06-05T20:23:33+08:00","author":{"@type":"Person","name":"dwd"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://qfsyso.github.io/posts/docker-devops/"},"publisher":{"@type":"Organization","name":"MLOG","logo":{"@type":"ImageObject","url":"https://qfsyso.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://qfsyso.github.io/ accesskey=h title="MLOG (Alt + H)">MLOG</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://qfsyso.github.io/posts/ title=Archive><span>Archive</span></a></li><li><a href=https://qfsyso.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://qfsyso.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Docker DevOps</h1><div class=post-meta><span title='2025-06-05 20:23:33 +0800 +0800'>June 5, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;dwd</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%ba%91%e5%8e%9f%e7%94%9f%e5%ba%94%e7%94%a8%e5%8d%81%e4%ba%8c%e8%a6%81%e7%b4%a0%e5%8e%9f%e5%88%99%e8%a7%a3%e6%9e%90%e8%a1%a8 aria-label=云原生应用十二要素原则解析表>云原生应用十二要素原则解析表</a></li><li><a href=#%e4%ba%91%e5%8e%9f%e7%94%9f%e6%9e%b6%e6%9e%84%e6%a8%a1%e5%bc%8f%e5%be%ae%e6%9c%8d%e5%8a%a1%e6%9e%b6%e6%9e%84 aria-label=云原生架构模式:微服务架构>云原生架构模式:微服务架构</a><ul><li><a href=#%e4%ba%91%e5%8e%9f%e7%94%9f%e6%9e%b6%e6%9e%84%e6%bc%94%e8%bf%9b%e5%8e%9f%e5%88%99 aria-label=云原生架构演进原则>云原生架构演进原则</a></li></ul></li><li><a href=#%e5%ae%b9%e5%99%a8%e8%b5%84%e6%ba%90%e7%ae%a1%e7%90%86 aria-label=容器资源管理>容器资源管理</a><ul><li><a href=#docker%e5%ae%b9%e5%99%a8%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86 aria-label=Docker容器实现原理>Docker容器实现原理</a></li><li><a href=#namespace aria-label=Namespace>Namespace</a></li><li><a href=#linux-namespace-%e7%b1%bb%e5%9e%8b%e6%95%b4%e7%90%86 aria-label="Linux Namespace 类型整理">Linux Namespace 类型整理</a></li><li><a href=#cgroups aria-label=Cgroups>Cgroups</a></li><li><a href=#%e5%86%85%e5%ad%98%e9%99%90%e9%a2%9d aria-label=内存限额>内存限额</a></li><li><a href=#cpu%e9%99%90%e9%a2%9d aria-label=CPU限额>CPU限额</a></li><li><a href=#block-lo%e5%b8%a6%e5%ae%bd%e9%99%90%e9%a2%9d aria-label="Block lO带宽限额">Block lO带宽限额</a></li></ul></li><li><a href=#%e5%ae%b9%e5%99%a8%e7%bd%91%e7%bb%9c%e4%b8%8e%e5%ad%98%e5%82%a8 aria-label=容器网络与存储>容器网络与存储</a><ul><li><a href=#host%e7%bd%91%e7%bb%9c aria-label=Host网络>Host网络</a></li><li><a href=#bridge%e7%bd%91%e7%bb%9c aria-label=Bridge网络>Bridge网络</a></li><li><a href=#user-defined%e7%bd%91%e7%bb%9c aria-label=User-defined网络>User-defined网络</a></li><li><a href=#%e5%ae%b9%e5%99%a8%e6%95%b0%e6%8d%ae%e5%8d%b7 aria-label=容器数据卷>容器数据卷</a></li><li><a href=#volume aria-label=Volume>Volume</a></li><li><a href=#bind-mount aria-label="Bind mount">Bind mount</a></li><li><a href=#tmpfs-mount aria-label="Tmpfs mount">Tmpfs mount</a></li></ul></li><li><a href=#%e4%ba%91%e5%8e%9f%e7%94%9f%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88 aria-label=云原生解决方案>云原生解决方案</a><ul><li><a href=#%e4%ba%91%e5%8e%9f%e7%94%9f%e5%9f%ba%e7%a1%80%e8%ae%be%e6%96%bd%e5%ba%95%e5%ba%a7 aria-label=云原生基础设施底座>云原生基础设施底座</a></li><li><a href=#%e5%9f%ba%e4%ba%8e%e4%ba%91%e5%8e%9f%e7%94%9f%e5%9f%ba%e7%a1%80%e8%ae%be%e6%96%bd%e7%9a%84%e5%a4%9a%e4%ba%91%e7%ae%a1%e7%90%86%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88 aria-label=基于云原生基础设施的多云管理解决方案>基于云原生基础设施的多云管理解决方案</a></li></ul></li><li><a href=#%e4%ba%91%e5%8e%9f%e7%94%9f%e6%9c%aa%e6%9d%a5%e5%8f%91%e5%b1%95%e8%b6%8b%e5%8a%bf aria-label=云原生未来发展趋势>云原生未来发展趋势</a></li><li><a href=#%e9%80%9a%e8%bf%87%e5%ae%b9%e5%99%a8%e8%b5%84%e6%ba%90%e7%ae%a1%e7%90%86%e4%b8%8e%e5%ae%b9%e5%99%a8%e7%bd%91%e7%bb%9c%e5%92%8c%e5%ad%98%e5%82%a8%e7%9a%84%e6%93%8d%e4%bd%9c aria-label=通过容器资源管理与容器网络和存储的操作>通过容器资源管理与容器网络和存储的操作</a></li><li><a href=#%e4%ba%91%e5%ae%b9%e5%99%a8%e5%bf%ab%e9%80%9f%e6%90%ad%e5%bb%ba aria-label=云容器快速搭建>云容器快速搭建</a><ul><li><a href=#%e9%9b%86%e8%a3%85%e7%ae%b1-%e5%ae%b9%e5%99%a8 aria-label="集装箱 容器">集装箱 容器</a></li><li><a href=#docker-%e5%ae%b9%e5%99%a8%e6%8a%80%e6%9c%af%e7%9a%84%e4%bb%a3%e5%90%8d%e8%af%8d aria-label=Docker-容器技术的代名词>Docker-容器技术的代名词</a></li><li><a href=#%e5%9f%ba%e6%9c%ac%e6%9e%b6%e6%9e%84 aria-label=基本架构>基本架构</a></li><li><a href=#cce%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af aria-label=CCE应用场景>CCE应用场景</a></li><li><a href=#%e5%bf%ab%e9%80%9f%e6%90%ad%e5%bb%ba aria-label=快速搭建>快速搭建</a></li></ul></li><li><a href=#%e5%88%a9%e7%94%a8%e5%8d%8e%e4%b8%ba%e4%ba%91%e8%b5%84%e6%ba%90%e6%90%ad%e5%bb%ba-wordpress-%e5%8f%8a%e5%bc%b9%e6%80%a7%e4%bc%b8%e7%bc%a9%e8%ae%be%e7%bd%ae aria-label="《利用华为云资源搭建 WordPress 及弹性伸缩设置》">《利用华为云资源搭建 WordPress 及弹性伸缩设置》</a><ul><ul><li><a href=#%e6%ad%a5%e9%aa%a4-2%e5%88%9b%e5%bb%ba%e8%99%9a%e6%8b%9f%e7%a7%81%e6%9c%89%e4%ba%91-vpc aria-label="步骤 2：创建虚拟私有云 VPC">步骤 2：创建虚拟私有云 VPC</a><ul><li><a href=#%e5%88%9b%e5%bb%ba-vpc-%e6%93%8d%e4%bd%9c%e6%ad%a5%e9%aa%a4 aria-label="创建 VPC 操作步骤：">创建 VPC 操作步骤：</a></li></ul></li><li><a href=#%e6%ad%a5%e9%aa%a4-3%e5%88%9b%e5%bb%ba-rds-%e5%85%b3%e7%b3%bb%e5%9e%8b%e6%95%b0%e6%8d%ae%e5%ba%93 aria-label="步骤 3：创建 RDS 关系型数据库">步骤 3：创建 RDS 关系型数据库</a><ul><li><a href=#%e5%88%9b%e5%bb%ba-rds-%e5%ae%9e%e4%be%8b%e6%93%8d%e4%bd%9c%e6%ad%a5%e9%aa%a4 aria-label="创建 RDS 实例操作步骤：">创建 RDS 实例操作步骤：</a></li></ul></li><li><a href=#%e6%ad%a5%e9%aa%a4-4%e5%9c%a8-cce-%e4%b8%8a%e5%88%9b%e5%bb%ba%e9%9b%86%e7%be%a4%e5%b9%b6%e6%b7%bb%e5%8a%a0%e8%8a%82%e7%82%b9 aria-label="步骤 4：在 CCE 上创建集群并添加节点">步骤 4：在 CCE 上创建集群并添加节点</a><ul><li><a href=#%e5%88%9b%e5%bb%ba%e9%9b%86%e7%be%a4%e5%8f%8a%e8%8a%82%e7%82%b9%e6%93%8d%e4%bd%9c%e6%ad%a5%e9%aa%a4 aria-label=创建集群及节点操作步骤：>创建集群及节点操作步骤：</a></li></ul></li><li><a href=#%e6%ad%a5%e9%aa%a4-5%e5%88%9b%e5%bb%ba-wordpress-%e5%b7%a5%e4%bd%9c%e8%b4%9f%e8%bd%bd aria-label="步骤 5：创建 wordpress 工作负载">步骤 5：创建 wordpress 工作负载</a><ul><li><a href=#%e6%93%8d%e4%bd%9c%e6%ad%a5%e9%aa%a4 aria-label=操作步骤：>操作步骤：</a></li></ul></li><li><a href=#%e6%ad%a5%e9%aa%a4-6%e9%85%8d%e7%bd%ae%e7%bd%91%e7%ab%99%e5%ba%94%e7%94%a8%e5%bc%b9%e6%80%a7%e4%bc%b8%e7%bc%a9 aria-label="步骤 6：配置网站应用弹性伸缩">步骤 6：配置网站应用弹性伸缩</a><ul><li><a href=#%e6%93%8d%e4%bd%9c%e6%ad%a5%e9%aa%a4-1 aria-label=操作步骤：>操作步骤：</a></li></ul></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=云原生应用十二要素原则解析表>云原生应用十二要素原则解析表<a hidden class=anchor aria-hidden=true href=#云原生应用十二要素原则解析表>#</a></h1><table><thead><tr><th><strong>原则</strong></th><th><strong>核心价值</strong></th><th><strong>实现方法</strong></th><th><strong>技术案例</strong></th></tr></thead><tbody><tr><td><strong>1. 基准代码</strong></td><td>快速交付；合理划分边界</td><td>单一代码库+多环境部署，版本控制统一管理</td><td>Git仓库管理，Kubernetes多集群部署</td></tr><tr><td><strong>2. 依赖</strong></td><td>提升开发效率；排除意外风险</td><td>显式声明依赖+隔离环境（容器化）</td><td>Docker镜像打包依赖，Helm Chart管理应用包</td></tr><tr><td><strong>3. 配置</strong></td><td>软件发布管理；环境无差别</td><td>配置与代码分离→环境变量注入</td><td>Kubernetes ConfigMap/Secret动态加载</td></tr><tr><td><strong>4. 后端服务</strong></td><td>弹性/敏捷；解耦状态管理</td><td>将慢速进程（如DB/队列）转为RESTful服务</td><td>Redis缓存服务，消息队列(Kafka)独立部署</td></tr><tr><td><strong>5. 构建发布运行</strong></td><td>持续交付；流水线自动化</td><td>CI/CD全流程自动化（构建→测试→部署）</td><td>Jenkins/GitLab CI流水线，K8s Rolling Update</td></tr><tr><td><strong>6. 进程</strong></td><td>云兼容性；无状态设计</td><td>应用无状态化，会话数据外置后端服务</td><td>会话存储Redis，文件存储OSS</td></tr><tr><td><strong>7. 端口绑定</strong></td><td>自包含服务；独立暴露接口</td><td>服务直接监听端口，不依赖Web服务器转发</td><td>Spring Boot内嵌Tomcat，gRPC直连</td></tr><tr><td><strong>8. 并发</strong></td><td>自动弹性伸缩</td><td>水平扩展替代垂直扩展，依赖云平台弹性能力</td><td>Kubernetes HPA自动扩缩容</td></tr><tr><td><strong>9. 易处理</strong></td><td>快速故障恢复</td><td>断路器模式+优雅终止，进程可随时启停</td><td>Istio服务熔断，K8s Liveness探针</td></tr><tr><td><strong>10. 环境等价</strong></td><td>可靠性；开发与生产环境一致</td><td>容器化保证环境一致性，禁用环境特殊配置</td><td>Docker跨环境运行，开发环境Minikube</td></tr><tr><td><strong>11. 日志</strong></td><td>实时系统监控</td><td>日志作为事件流→集中式管理</td><td>EFK栈(Elasticsearch+Fluentd+Kibana)</td></tr><tr><td><strong>12. 管理进程</strong></td><td>运维效率；运营解耦</td><td>管理任务（如DB迁移）作为独立进程，与主应用隔离</td><td>K8s Job/CronJob执行批处理任务</td></tr></tbody></table><table><thead><tr><th>特性</th><th>云原生应用</th><th>传统应用</th></tr></thead><tbody><tr><td><strong>可预测性</strong></td><td>符合弹性框架，通过容器编排和微服务实现可预测行为</td><td>不可预测，批量发布易引发单点故障，扩展能力有限</td></tr><tr><td><strong>操作系统依赖</strong></td><td>抽象化（容器技术隔离OS依赖，实现跨平台运行）</td><td>强依赖（需特定OS环境，迁移困难）</td></tr><tr><td><strong>资源调度</strong></td><td>弹性伸缩（按需自动分配资源，利用率＞70%）</td><td>冗余静态（预留资源应对峰值，利用率＜40%）</td></tr><tr><td><strong>团队协作</strong></td><td>DevOps驱动（开发运维一体化，自动化流水线）</td><td>部门墙隔离（开发/测试/运维独立，沟通成本高）</td></tr><tr><td><strong>开发模式</strong></td><td>敏捷迭代（CI/CD支持每日多次部署）</td><td>瀑布模型（数月/年周期发布，变更困难）</td></tr><tr><td><strong>服务架构</strong></td><td>微服务（独立部署、高内聚低耦合）</td><td>单体架构（模块紧耦合，牵一发而动全身）</td></tr><tr><td><strong>运维能力</strong></td><td>自动化（K8s实现自愈、监控、扩缩容）</td><td>手动操作（人工监控、故障排查效率低）</td></tr><tr><td><strong>故障恢复</strong></td><td>秒级恢复（容器快速重启+服务网格流量调度）</td><td>小时级恢复（依赖备份还原，流程复杂）</td></tr></tbody></table><h1 id=云原生架构模式微服务架构>云原生架构模式:微服务架构<a hidden class=anchor aria-hidden=true href=#云原生架构模式微服务架构>#</a></h1><h2 id=云原生架构演进原则>云原生架构演进原则<a hidden class=anchor aria-hidden=true href=#云原生架构演进原则>#</a></h2><p>01.弹性
微服务采用无状态设计支持按需使用、自动水平伸缩;实例快速启动，并在不影响业务的前提下优雅中止。</p><p>02.分布式
应用分布式:业务逻辑与数据解耦、业务逻辑与会话解耦;数鶼習揿僥髦据分布式:去中心、自均衡、最终一致性;跨可用区的部署与调度。</p><p>03.高可用
基于不可靠、可抛弃的资源设计高可用、反脆弱系统，应用任意(微)服务实例失效，系统能够快速发现、隔离并自动恢复;云基础设施和平台服务发生任意单点故障不影响系统整体可用性。
04.
自动化
系统能够自动化部署、升级和扩综容，支持自动化监控、告警、故障的定界定位和故障自愈。
05
自服务
服务可被其他应用或开发猼联蒼晴菋捯笥鐸耐蔡顢錚穩助发现，自助按需获取，自助使用并计量，自助服务管理。</p><p>云原生应用架构思考:单体架构的局限性
单体架构的问题不在于不可拆分上，在于无法隔离和自治。应用规模越大，局限性越明显</p><p>云原生架构模式:微服务架构</p><p>微服务独立性和敏捷性更好，架构持续演进更容易，更适合云原生应用</p><p>云原生架构模式:Serverless架构
Serverless(无服务器架构)指的是由开发者实现的服务端逻辑运行在无状态的计算容器中，它由事件触发，完全被第三方管理，Serverless是在传统容器技术和服务网格上发展起来，更侧重让使用者只关注自己的业务逻辑即可。</p><p>Serverless方案业务价值
更轻量化:用户专注于业务创新和代码开发，代码运行环境由云平台提供，无需管理基础设施资源。
更快弹性:根据请求的并发数量自动调度资源运行函数，毫秒级弹性伸缩，高效应对业务峰值。
更低成本:根据函数调用次数、运行时长和节点转换次数计费，函数不运行时不产生费用，更加节省成本。</p><p>Serverless与微服务的关系:微服务向Serverless演进，并长期共存。</p><h1 id=容器资源管理>容器资源管理<a hidden class=anchor aria-hidden=true href=#容器资源管理>#</a></h1><h2 id=docker容器实现原理>Docker容器实现原理<a hidden class=anchor aria-hidden=true href=#docker容器实现原理>#</a></h2><p>Docker容器通过namespace技术实现进程隔离，通过cgroup技术实现容器进程可用资源的限制。
Docker启动一个容器时，实际是创建了包含多个namespace参数的进程。</p><h2 id=namespace>Namespace<a hidden class=anchor aria-hidden=true href=#namespace>#</a></h2><p>Namespace:命名空间
作用:资源隔离。
原理:namespace将内核的全局资源进行封装，使得每个namespace都有一份独立的资源。因此不同进程在各自namespace内对同一种资源的使用不会相互干扰。</p><h2 id=linux-namespace-类型整理>Linux Namespace 类型整理<a hidden class=anchor aria-hidden=true href=#linux-namespace-类型整理>#</a></h2><table><thead><tr><th>Namespace 类型</th><th>系统调用参数</th><th>隔离内容</th><th>引入的内核版本</th></tr></thead><tbody><tr><td>PID Namespace</td><td>CLONE_NEWPID</td><td>进程空间（进程 ID）</td><td>Linux 2.6.24</td></tr><tr><td>Mount Namespace</td><td>CLONE_NEWNS</td><td>文件系统挂载点</td><td>Linux 2.6.19</td></tr><tr><td>Network Namespace</td><td>CLONE_NEWNET</td><td>网络资源（网络设备、端口等）</td><td>始于 Linux 2.6.24，完成于 2.6.29</td></tr><tr><td>User Namespace</td><td>CLONE_NEWUSER</td><td>用户 ID 和用户组 ID</td><td>始于 Linux 2.6.23，完成于 Linux 3.8</td></tr><tr><td>UTS Namespace</td><td>CLONE_NEWUTS</td><td>主机名和域名</td><td>Linux 2.6.19</td></tr><tr><td>IPC Namespace</td><td>CLONE_NEWIPC</td><td>信号量、消息队列和共享内存</td><td>Linux 2.6.19</td></tr></tbody></table><h2 id=cgroups>Cgroups<a hidden class=anchor aria-hidden=true href=#cgroups>#</a></h2><p>Cgroups: Linux Control Group。
作用:限制一个进程组对系统资源的使用上限，包括CPU、内存、BlockI/O等。
Cgroups还可以设置进程优先级，对进程进行挂起和恢复等操作。
原理:将一组进程放在一个Cgroup中，通过给这个Cgroup分配指定的可用资源，达到控制这一组进程可用资源的目的实现:在Linux中，Cgroups以文件和目录的方式组织在操作系统的/sys/fs/cgroup路径下。该路径中所有的资源种类均可被Cgroup限制。</p><h2 id=内存限额>内存限额<a hidden class=anchor aria-hidden=true href=#内存限额>#</a></h2><p>容器可使用的内存包括两个部分:物理内存和swap。Docker通过两组参数来控制容器内存的使用量:
-m或-memory:设置内存的使用限额。
&ndash;memory-swap:设置内存+swap的使用限额。</p><h2 id=cpu限额>CPU限额<a hidden class=anchor aria-hidden=true href=#cpu限额>#</a></h2><p>默认设置下，所有容器可以平等地使用host CPU资源并且没有限制。Docker可以通过-c或&ndash;cpu-shares设置容器使用CPU的权重。</p><h2 id=block-lo带宽限额>Block lO带宽限额<a hidden class=anchor aria-hidden=true href=#block-lo带宽限额>#</a></h2><p>默认情况下，所有容器能平等地读写磁盘，可以通过设置&ndash;blkio-weight参数来改变容器block 10的优先级。</p><h1 id=容器网络与存储>容器网络与存储<a hidden class=anchor aria-hidden=true href=#容器网络与存储>#</a></h1><p>##Docker原生网络
Docker提供如下5种原生的Network drivers。</p><table><thead><tr><th>模型</th><th>说明</th></tr></thead><tbody><tr><td>None (dk安装时)</td><td><code>none</code> 网络中的容器不能与外部通信。</td></tr><tr><td>Host (dk安装时)</td><td>容器加入到宿主机的 Network Namespace，容器直接使用宿主机网络。</td></tr><tr><td>Bridge (dk安装时)</td><td>默认网络驱动程序。主要用于多个容器在同一个 Docker 宿主机上通信。</td></tr><tr><td>Overlay</td><td>基于 Linux 网桥和 VXLAN，可实现<strong>跨主机</strong>的容器通信。</td></tr><tr><td>Macvlan</td><td>通过为容器分配物理网卡的 MAC 地址，适用于需要与物理网络通信的场景。</td></tr></tbody></table><h2 id=host网络>Host网络<a hidden class=anchor aria-hidden=true href=#host网络>#</a></h2><p>挂在host网络上的容器共享宿主机的network namespace。即容器的网络配置与host网络配置完全一样。
容器创建时，可以通过&ndash;network=host指定使用host网络。</p><h2 id=bridge网络>Bridge网络<a hidden class=anchor aria-hidden=true href=#bridge网络>#</a></h2><p>Bridge网络是docker使用最广泛、也是默认的网络。
Docker安装时会创建一个名为docker0的linuxbridge。如果不指定&ndash;network，创建的容器默认都会挂到docker0上。docker0网络创建时已默认配置了subnet子网。</p><h2 id=user-defined网络>User-defined网络<a hidden class=anchor aria-hidden=true href=#user-defined网络>#</a></h2><p>除了自动创建的none、host、bridge三个网络，用户可按需创建user-defined网络。Docker提供三种user-defined bridge网络驱动:bridge、oyerlay和macvlan。我们可以通过bridge驱动创建类似前面默认的bridge网络。</p><h2 id=容器数据卷>容器数据卷<a hidden class=anchor aria-hidden=true href=#容器数据卷>#</a></h2><p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File system提供一些用于持续存储或共享数据的特性。卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷.
启动容器的时候直接使用-v命令就可以进行数据卷的挂载。
还可以在Dockerfile中使用VOLUME指令来给镜像添加一个或多个数据卷。</p><h2 id=volume>Volume<a hidden class=anchor aria-hidden=true href=#volume>#</a></h2><p>Volume由docker管理，是将特定目录挂载给容器。Docker会在指定路径/var/lib/docker/volumes下为每个volume生成一个目录作为mount源。
Volume创建过程:
容器启动时，简单的告诉docker:&ldquo;我需要一个volume存放数据，帮我mount到目录/abc&rdquo;。
Docker在/var/lib/docker/volumes 中生成一个随机目录作为mount源。
如果/abc已经存在，则将数据复制到mount源。
将volume mount到/abc。
docker volume ls</p><h2 id=bind-mount>Bind mount<a hidden class=anchor aria-hidden=true href=#bind-mount>#</a></h2><p>Bind mount是将宿主机上已有的目录或文件mount到容器中。</p><h2 id=tmpfs-mount>Tmpfs mount<a hidden class=anchor aria-hidden=true href=#tmpfs-mount>#</a></h2><p>Volumes和bind mounts是在容器和宿主机之间做数据共享，将数据持久化到宿主机上。
tmpfs mounts是将文件创建在容器可写层之外，实际落在宿主机的内存中。
使用tmpfs mounts的限制:
宿主机OS是Linux。
无法向volumes和bind mounts一样，在容器之间共享文件。</p><p>容器与Host共享数据
两种类型的 data volume均可实现在容器与 host 之间共享数据，但方式有所不同。
bind mount: 直接将要共享的目录mount到容器。
volume: 由于volume位于host中的目录，是在容器启动时才生成，所以需要将共享数据拷贝到volume中。使用docker cp命令在容器与Host之间复制数据。使用cp命令将需要共享的数据copy到该volume的目录下。</p><p>容器之间共享数据
bind mount:将Host上的目录或文件mount到多个容器中。
volume:将volume挂载到多个容器中。
volume container:先通过volume或bind mount将数据挂载到一个container中，其他容器再引用这个container中的数据。
data-packed volume container:将数据打包到镜像中，然后volume 共享。</p><h1 id=云原生解决方案>云原生解决方案<a hidden class=anchor aria-hidden=true href=#云原生解决方案>#</a></h1><h2 id=云原生基础设施底座>云原生基础设施底座<a hidden class=anchor aria-hidden=true href=#云原生基础设施底座>#</a></h2><p>容器引擎 容器网络 容器存储
30秒创建1000个容器</p><h2 id=基于云原生基础设施的多云管理解决方案>基于云原生基础设施的多云管理解决方案<a hidden class=anchor aria-hidden=true href=#基于云原生基础设施的多云管理解决方案>#</a></h2><p>多集群、多区域、多云统一应用管理能力，实现更大规模业务支撑能力，更灵活的弹性与容灾能力。
多云容器平台（MCP）：基于多集群联邦技术完成多个不同区域、不同云的K8s集群与应用统一管理。
应用服务网络（ASM）：完成多个不同区域、不同云的Kubernetes集群上所部属应用的全局治理。</p><p>高性价比
统一计算平台，业务混合部署，集群
利用率平均提升30%
昇腾，鲲鹏－高性价比异构算力</p><p>极致性能
Volcano智能调度，批量任务效率平均
提升30%
30秒发放1000容器，满足极速弹性要求</p><p>高效运维
Serverless服务，基础设施NoOps
自动+自定义指标弹性伸缩</p><h1 id=云原生未来发展趋势>云原生未来发展趋势<a hidden class=anchor aria-hidden=true href=#云原生未来发展趋势>#</a></h1><p>云原生未来发展趋势
Kubernetes编排统一化，编排对象不断扩展延伸。
Kubernetes的编排对象持扩展</p><p>应用侧围绕Kubernetes生态加速演。
服务治理Mesh化，加速传统应用转型。
服务治理与业务逻辑解耦。</p><p>异构系统的统一治理。
应用服务Serverless化，更加聚焦业务的核心价值。
聚焦核心业务逻辑，极大提升应用开发效率。</p><p>云原生服务部署形态多元化，多云将成为主流。
多云、多集群部署渐成为常态，未来将是编程式多云管理服务的时代。</p><h1 id=通过容器资源管理与容器网络和存储的操作>通过容器资源管理与容器网络和存储的操作<a hidden class=anchor aria-hidden=true href=#通过容器资源管理与容器网络和存储的操作>#</a></h1><p>借助cgroup限制容器CPU利用率。
搭建容器bridge网络。
创建容器存储卷。</p><h3 id=容器网络xa>容器网络</h3><h4 id=21-容器网络模型xa>2.1 容器网络模型</h4><p><strong>前置步骤：配置镜像仓库</strong></p><pre tabindex=0><code>yum -y install docker
</code></pre><pre tabindex=0><code>vi /etc/docker/daemon.json
</code></pre><p>按 “i” 键，添加如下内容：</p><pre tabindex=0><code>{


      &#34;registry-mirrors&#34;: \[

    
          &#34;https://docker.mirrors.ustc.edu.cn&#34;


       ]


}
</code></pre><p>按 Esc 键 → 输入 “:wq!” → 按回车键保存退出。</p><p><strong>查看镜像源有无修改</strong></p><pre tabindex=0><code>systemctl restart docker


docker info
</code></pre><h5 id=-运行容器host-网络模型并验证xa>① 运行容器（host 网络模型）并验证</h5><pre tabindex=0><code>docker run -itd --network=host hub.c.163.com/library/centos
</code></pre><p>替换 “容器 ID” 后进入容器：</p><pre tabindex=0><code>docker exec -it 容器ID bash
</code></pre><p>在容器内安装工具并查看网络信息：</p><pre tabindex=0><code>curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo


yum install iproute -y


ip addr
</code></pre><p>退出容器后，在宿主机验证网络信息：</p><pre tabindex=0><code>exit


ip addr
</code></pre><p><strong>说明</strong>：容器与宿主机共享网络 namespace，网络信息完全一致。</p><p><strong>保存容器镜像</strong></p><pre tabindex=0><code>docker commit 容器ID centos-iproute
</code></pre><h5 id=-运行容器bridge-网络模型并验证xa>② 运行容器（bridge 网络模型）并验证</h5><pre tabindex=0><code>docker run -itd --network=bridge centos-iproute  # --network=bridge可省略（默认网桥为docker0）
</code></pre><p>替换 “容器 ID” 后进入容器查看网络信息：</p><pre tabindex=0><code>docker exec -it 容器ID bash


ip addr
</code></pre><h5 id=-查看-docker0-网桥信息xa>③ 查看 docker0 网桥信息</h5><pre tabindex=0><code>exit


docker network inspect bridge docker0
</code></pre><h5 id=-删除实验容器xa>④ 删除实验容器</h5><pre tabindex=0><code>docker container ls


docker rm 容器ID -f
</code></pre><h4 id=22-docker-bridge-网络xa>2.2 Docker bridge 网络</h4><h5 id=-创建用户自定义网桥xa>① 创建用户自定义网桥</h5><pre tabindex=0><code>docker network create --driver bridge --subnet 173.18.0.0/16 --gateway 173.18.0.1 servicebridge01
</code></pre><p><strong>查看网桥信息</strong>（替换 “网络 ID”）：</p><pre tabindex=0><code>docker network inspect 网络ID
</code></pre><h5 id=-运行容器并挂载到自定义网桥xa>② 运行容器并挂载到自定义网桥</h5><pre tabindex=0><code>docker run -itd --network=servicebridge01 centos-iproute
</code></pre><p>查看容器网络配置（替换 “容器 ID”）：</p><pre tabindex=0><code>docker inspect 容器ID
</code></pre><h5 id=-容器挂载双网桥默认-docker0--自定义网桥xa>③ 容器挂载双网桥（默认 docker0 + 自定义网桥）</h5><pre tabindex=0><code>docker run -itd centos-iproute  # 先挂载默认docker0网桥
</code></pre><p>将容器添加到自定义网桥（替换 “网络 ID” 和 “容器 ID”）：</p><pre tabindex=0><code>docker network connect 网络ID 容器ID


docker exec -it 容器ID bash


ip addr
</code></pre><h5 id=-验证容器互通性xa>④ 验证容器互通性</h5><pre tabindex=0><code>ping 容器IP  # 替换为步骤②中容器的IP地址
</code></pre><p>按 Ctrl+C 终止进程。</p><h5 id=-删除实验容器xa-1>⑤ 删除实验容器</h5><pre tabindex=0><code>exit


docker container ls


docker rm 容器ID -f
</code></pre><h1 id=云容器快速搭建>云容器快速搭建<a hidden class=anchor aria-hidden=true href=#云容器快速搭建>#</a></h1><p>容器为app提供独立的受控的运行环境 ，轻量级的虚拟化操作系统。sandbox</p><h2 id=集装箱-容器>集装箱 容器<a hidden class=anchor aria-hidden=true href=#集装箱-容器>#</a></h2><table><thead><tr><th><strong>对比维度</strong></th><th><strong>物理集装箱</strong></th><th><strong>容器（软件容器）</strong></th></tr></thead><tbody><tr><td><strong>打包对象</strong></td><td>几乎支持所有类型的货物（如工业品、农产品等）</td><td>任何软件及其依赖（代码、运行环境、库文件等）</td></tr><tr><td><strong>标准化</strong></td><td>- 标准化尺寸（如 20 英尺、40 英尺）- 统一交接方式（起重机装卸）</td><td>- 无需修改即可运行于多平台（虚拟机、物理机、公有云、私有云）- 遵循标准化镜像格式（如 Docker Image）</td></tr><tr><td><strong>硬件 / 环境依赖</strong></td><td>依赖运输工具（货船、火车、货车）及装卸设备</td><td>无底层硬件依赖，通过虚拟化技术抽象资源</td></tr><tr><td><strong>隔离性</strong></td><td>- 物理隔离货物，避免碰撞、污染- 可堆叠运输，互不影响</td><td>- 资源隔离（CPU、内存、存储）- 网络隔离与依赖隔离，避免组件冲突</td></tr><tr><td><strong>自动化</strong></td><td>标准化流程支持自动化装载、卸货、转运</td><td>- 标准操作指令（如<code>docker run</code>）- 支持 CI/CD、自动化测试、一键部署</td></tr><tr><td><strong>高效性</strong></td><td>减少货物拆箱 / 重装耗时，提升运输效率</td><td>- 轻量级（启动秒级）- 高移植性（镜像可快速迁移至不同环境）</td></tr><tr><td><strong>操控性</strong></td><td>点对点运输，无需开箱即可整体移动</td><td>镜像化部署，支持快速启停、迁移、扩展</td></tr><tr><td><strong>职责分工</strong></td><td>- 发货人：关注货物本身- 托运人：关注运输与装卸</td><td>- 开发者：聚焦代码逻辑- 运维人员：聚焦基础设施管理</td></tr></tbody></table><h2 id=docker-容器技术的代名词>Docker-容器技术的代名词<a hidden class=anchor aria-hidden=true href=#docker-容器技术的代名词>#</a></h2><p>·Docker是目前使用最广泛的容器技术，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器
·利用该技术，您可以将一款软件打包成一个标准化的软件开发单元，其中包括软件运行所需的全部内容：代码、运行时间、系统工具和系统库等。Docker使您能够在任何环境下快速、可靠、一致地部署应用程序。</p><h2 id=基本架构>基本架构<a hidden class=anchor aria-hidden=true href=#基本架构>#</a></h2><p>Docker客户端（Client)
Docker客户端通过命令行或者其他工具使用
Docker API与 Docker的守护进程通信。</p><p>Docker主机 （Host）
一个物理或者虚拟的机器用于执行Docker守护进程和容器。</p><p>Docker镜像(Images) V
Docker镜像是用于创建Docker容器的模板。</p><p>Docker容器（Container) V
容器是独立运行的─个或一组应用。</p><p>Docker Daemon
服务端守护进程，负责接收客户端的指令，并处理这些请求（创建、运行、分发容器）。</p><p>Docker仓库（Registry) V
Docker仓库用来保存镜像，可以理解为代码控制中的代码仓库。
DockerHub提供了庞大的镜像集合供使用。</p><h2 id=cce应用场景>CCE应用场景<a hidden class=anchor aria-hidden=true href=#cce应用场景>#</a></h2><p>传统IT架构渐进式转型</p><p>提升业务上线效率</p><p>业务负荷波动明显</p><p>节省资源降低成本</p><h2 id=快速搭建>快速搭建<a hidden class=anchor aria-hidden=true href=#快速搭建>#</a></h2><p>Step1：资源/环境
Step2：创建RDS
Step3：创建CCE
Step4: 创建
Step5: 访问
Step6: 弹性伸缩</p><h1 id=利用华为云资源搭建-wordpress-及弹性伸缩设置>《利用华为云资源搭建 WordPress 及弹性伸缩设置》<a hidden class=anchor aria-hidden=true href=#利用华为云资源搭建-wordpress-及弹性伸缩设置>#</a></h1><h3 id=步骤-2创建虚拟私有云-vpc>步骤 2：创建虚拟私有云 VPC<a hidden class=anchor aria-hidden=true href=#步骤-2创建虚拟私有云-vpc>#</a></h3><p>**什么是安全组？**安全组是一种虚拟防火墙，用于控制虚拟私有云（VPC）内实例的入站和出站流量，通过配置允许或拒绝规则实现网络访问控制。</p><h4 id=创建-vpc-操作步骤>创建 VPC 操作步骤：<a hidden class=anchor aria-hidden=true href=#创建-vpc-操作步骤>#</a></h4><ol><li><p>进入控制台，在 “服务列表” 下点击 “网络 > 虚拟私有云”，进入网络控制台页面。</p></li><li><p>点击 “创建虚拟私有云”，按以下信息配置：</p></li></ol><ul><li><p><strong>基本信息</strong></p><ul><li><p>当前区域：华北 - 北京四</p></li><li><p>名称：myvpc</p></li><li><p>网段：192.168.0.0/16</p></li></ul></li><li><p><strong>默认子网</strong></p><ul><li><p>名称：subnet-myvpc</p></li><li><p>其余配置保持默认</p></li></ul></li></ul><ol><li><p>返回 “虚拟私有云” 界面，确认已创建的 myvpc。</p></li><li><p>在网络控制台左侧菜单栏点击 “访问控制> 安全组”，进入安全组页面，选择 default 默认安全组右侧的【配置规则】。</p></li><li><p>点击 “添加规则”，为 default 安全组添加入方向规则，放通 3306 及 80 端口。</p></li></ol><h3 id=步骤-3创建-rds-关系型数据库>步骤 3：创建 RDS 关系型数据库<a hidden class=anchor aria-hidden=true href=#步骤-3创建-rds-关系型数据库>#</a></h3><p>**什么是 RDS（华为云关系型数据库）？**RDS 是华为云提供的关系型数据库服务，支持 MySQL、SQL Server 等引擎，提供弹性扩展、高可用性等功能，简化数据库管理。</p><h4 id=创建-rds-实例操作步骤>创建 RDS 实例操作步骤：<a hidden class=anchor aria-hidden=true href=#创建-rds-实例操作步骤>#</a></h4><ol><li><p>打开控制台，在 “服务列表” 下选择 “数据库 > 云数据库 RDS”，点击 “购买数据库实例”。</p></li><li><p>配置实例参数：</p></li></ol><ul><li><p>计费模式：按需计费</p></li><li><p>区域：华北 - 北京四</p></li><li><p>数据库引擎：MySQL</p></li><li><p>数据库版本：5.7</p></li><li><p>实例类型：单机</p></li><li><p>性能规格：通用型 | 2 核 | 4GB（如售罄选相似规格）</p></li><li><p>存储空间：40GB</p></li><li><p>实例名称：rds-web</p></li><li><p>管理员密码：自行设置（后续需用）</p></li><li><p>虚拟私有云：选择 myvpc 及 subnet-myvpc</p></li><li><p>数据库端口：3306</p></li><li><p>安全组：选择 default</p></li><li><p>时区：北京，其余默认</p></li></ul><ol><li><p>点击 “立即购买” 并 “提交”，实例创建需 6-10 分钟。</p></li><li><p>等待期间可同步进行步骤 4，创建完成后记录数据库实例的内网地址。</p></li><li><p>进入数据库管理界面，在 “账号管理” 创建账号（主机 IP 输入 %），在 “数据库管理” 创建数据库并授权。</p></li></ol><h3 id=步骤-4在-cce-上创建集群并添加节点>步骤 4：在 CCE 上创建集群并添加节点<a hidden class=anchor aria-hidden=true href=#步骤-4在-cce-上创建集群并添加节点>#</a></h3><p>**什么是 CCE（华为云容器引擎）？**CCE 是华为云提供的容器引擎服务，支持 Kubernetes 集群管理，用于部署、扩展和管理容器化应用。</p><h4 id=创建集群及节点操作步骤>创建集群及节点操作步骤：<a hidden class=anchor aria-hidden=true href=#创建集群及节点操作步骤>#</a></h4><ol><li><p>返回控制台，在 “服务列表” 下选择 “容器 > 云容器引擎 CCE”，进入 CCE 页面。</p></li><li><p>选择购买 CCE Standard 集群，配置参数：</p></li></ol><ul><li><p>计费模式：按需计费</p></li><li><p>集群名称：test</p></li><li><p>版本：v1.30 或推荐版本</p></li><li><p>集群规模：50 节点</p></li><li><p>网络模型：容器隧道网络</p></li><li><p>虚拟私有云：选择 myvpc</p></li><li><p>控制节点子网：选择 subnet-myvpc</p></li><li><p>其余配置默认</p></li></ul><ol><li><p>依次完成插件选择（默认）、规格确认，提交创建集群（约 5 分钟）。</p></li><li><p>集群创建完成后，点击 “创建节点”，配置参数：</p></li></ol><ul><li><p>计费方式：按需计费</p></li><li><p>节点规格：通用型 | s6.xlarge.2|4 核 | 8GB（若售罄选相近规格）</p></li><li><p>操作系统：EulerOS 2.9</p></li><li><p>登录方式：密码（自行设置）</p></li><li><p>虚拟私有云：myvpc</p></li><li><p>节点子网：subnet-myvpc</p></li><li><p>弹性公网 IP：自动创建（按流量计费，带宽 5M）</p></li><li><p>节点数量：2 台，其余默认</p></li></ul><ol><li>确认规格后提交，节点创建需 4 分钟，确认状态为 “运行中”。</li></ol><h3 id=步骤-5创建-wordpress-工作负载>步骤 5：创建 wordpress 工作负载<a hidden class=anchor aria-hidden=true href=#步骤-5创建-wordpress-工作负载>#</a></h3><h4 id=操作步骤>操作步骤：<a hidden class=anchor aria-hidden=true href=#操作步骤>#</a></h4><ol><li><p>在 CCE 集群中进入 “工作负载” 界面，点击 “创建负载”。</p></li><li><p>配置基本信息：</p></li></ol><ul><li><p>负载类型：无状态负载</p></li><li><p>名称：wordpress</p></li><li><p>实例数量：1</p></li><li><p>镜像选择：镜像中心搜索 wordpress，版本 php7.3</p></li></ul><ol><li>添加环境变量（需提前完成 RDS 账号及数据库创建）：</li></ol><ul><li><p>WORDPRESS_DB_HOST：RDS 内网地址：3306</p></li><li><p>WORDPRESS_DB_NAME：RDS 创建的数据库名称</p></li><li><p>WORDPRESS_DB_USER：RDS 创建的账号名称</p></li><li><p>WORDPRESS_DB_PASSWORD：RDS 账号密码</p></li></ul><ol><li>服务配置：</li></ol><ul><li><p>Service 名称：wordpress</p></li><li><p>访问类型：负载均衡</p></li><li><p>端口配置：TCP，容器端口 80，服务端口 80</p></li><li><p>负载均衡器：共享型，自动创建（名称 wordpress）</p></li></ul><ol><li><p>确认后创建工作负载，状态变为 “运行中” 后，获取外部访问地址。</p></li><li><p>访问地址完成 wordpress 安装配置（语言简体中文，设置站点标题、用户名、密码等）。</p></li></ol><h3 id=步骤-6配置网站应用弹性伸缩>步骤 6：配置网站应用弹性伸缩<a hidden class=anchor aria-hidden=true href=#步骤-6配置网站应用弹性伸缩>#</a></h3><h4 id=操作步骤-1>操作步骤：<a hidden class=anchor aria-hidden=true href=#操作步骤-1>#</a></h4><ol><li><p>进入 CCE test 集群，选择 “工作负载> wordpress”。</p></li><li><p>手动扩容：调整实例个数为 3，确认实例数扩容至 3 个。</p></li><li><p>弹性伸缩策略配置：</p></li></ol><ul><li><p>进入 “弹性伸缩”，安装 CustomedHPA 插件（保持默认设置）。</p></li><li><p>创建 CustomedHPA 策略：</p><ul><li><p>实例范围：1-3</p></li><li><p>冷却时间：1 分钟</p></li><li><p>触发条件：CPU 利用率 &lt; 50%</p></li><li><p>执行操作：减少 1 个实例</p></li></ul></li></ul><p>确认策略创建成功（状态 “已启用”），等待 2 分钟观察实例自动缩减。</p><p>利用公有镜像搭建 wordpress 并完成伸缩设置。</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://qfsyso.github.io/posts/kubernetes-k8s/><span class=title>« Prev</span><br><span>Kubernetes k8s</span>
</a><a class=next href=https://qfsyso.github.io/posts/information-recognition/><span class=title>Next »</span><br><span>Information Recognition</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker DevOps on x" href="https://x.com/intent/tweet/?text=Docker%20DevOps&amp;url=https%3a%2f%2fqfsyso.github.io%2fposts%2fdocker-devops%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker DevOps on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fqfsyso.github.io%2fposts%2fdocker-devops%2f&amp;title=Docker%20DevOps&amp;summary=Docker%20DevOps&amp;source=https%3a%2f%2fqfsyso.github.io%2fposts%2fdocker-devops%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker DevOps on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fqfsyso.github.io%2fposts%2fdocker-devops%2f&title=Docker%20DevOps"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker DevOps on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fqfsyso.github.io%2fposts%2fdocker-devops%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker DevOps on whatsapp" href="https://api.whatsapp.com/send?text=Docker%20DevOps%20-%20https%3a%2f%2fqfsyso.github.io%2fposts%2fdocker-devops%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker DevOps on telegram" href="https://telegram.me/share/url?text=Docker%20DevOps&amp;url=https%3a%2f%2fqfsyso.github.io%2fposts%2fdocker-devops%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker DevOps on ycombinator" href="https://news.ycombinator.com/submitlink?t=Docker%20DevOps&u=https%3a%2f%2fqfsyso.github.io%2fposts%2fdocker-devops%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><div class=wtime><div class=wtime2>CST<span id=beijingTime></span> GMT <span id=londonTime></span> EST <span id=newYorkTime></span> PST<span id=losAngelesTime></span></div><div class=wtime2 style=display:none>东京<span id=tokyoTime></span></div><div class=wtime2 style=display:none>欧洲-巴黎<span id=parisTime></span></div><div class=wtime2 style=display:none>UTC<span id=utcTime></span></div></div><span>&copy; 2025 <a href=https://qfsyso.github.io/>MLOG</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span><script type=text/javascript>const timeZoneOffsets={beijing:8,tokyo:9,paris:[1,2],london:[0,1],newYork:[-5,-4],losAngeles:[-8,-7]};function padZero(e){return e<10?"0"+e:e}function formatTime(e){const t=e.getFullYear(),n=padZero(e.getMonth()+1),s=padZero(e.getDate()),o=padZero(e.getHours()),i=padZero(e.getMinutes()),a=padZero(e.getSeconds());return`${t}-${n}-${s} ${o}:${i}:${a}`}function isDaylightSavingTime(e,t){const o=e.getMonth(),n=new Date(e.getFullYear(),3,8,2,0,0),s=new Date(e.getFullYear(),10,1,2,0,0);return(t==="paris"||t==="london"||t==="newYork"||t==="losAngeles")&&e>=n&&e<s}function updateTime(){const e=new Date,t=new Date(e.getUTCFullYear(),e.getUTCMonth(),e.getUTCDate(),e.getUTCHours(),e.getUTCMinutes(),e.getUTCSeconds()),n=formatTime(t);document.getElementById("utcTime").innerHTML=n;for(const n in timeZoneOffsets){const e=timeZoneOffsets[n];let s;Array.isArray(e)?s=isDaylightSavingTime(t,n)?e[1]:e[0]:s=e;const o=new Date(t.getTime()+s*60*60*1e3);document.getElementById(n+"Time").innerHTML=formatTime(o)}setTimeout(updateTime,1e3)}window.onload=function(){updateTime()};function notfound(e){var n=e.src,t=n.split("/"),s=t[t.length-1];e.src="https://47.115.223.75:8080/group1/v2/"+s+"?timestamp="+Date.now(),e.onerror=null}</script></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>