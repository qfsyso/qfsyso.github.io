<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Go on MLOG</title><link>https://qfsyso.github.io/tags/go/</link><description>Recent content in Go on MLOG</description><generator>Hugo -- 0.126.3</generator><language>zh-CN</language><lastBuildDate>Sat, 23 Aug 2025 01:42:55 +0800</lastBuildDate><atom:link href="https://qfsyso.github.io/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>Go File Manager</title><link>https://qfsyso.github.io/posts/go-file-manager/</link><pubDate>Sat, 23 Aug 2025 01:42:55 +0800</pubDate><guid>https://qfsyso.github.io/posts/go-file-manager/</guid><description>Go-React 文件存储管理 📋 项目概述 这是一个完整的文件存储管理系统，采用 Go 后端 + React 前端的现代化架构。系统提供了用户认证、文件管理、共享功能和管理员控制等核心功能。
🏗 系统架构 ┌─────────────────┐ HTTP API ┌─────────────────┐ │ React 前端 │ ◄──────────── │ Go 后端 │ │ │ │ │ │ - 用户界面 │ │ - RESTful API │ │ - 状态管理 │ │ - 文件处理 │ │ - 路由控制 │ │ - 用户认证 │ └─────────────────┘ └─────────────────┘ │ ▼ ┌─────────────────┐ │ 文件系统 │ │ │ │ - 文件存储 │ │ - 元数据管理 │ │ - 用户数据 │ └─────────────────┘ 🔧 技术栈 后端 (Go) 语言: Go 1.</description></item><item><title>Ipa Share</title><link>https://qfsyso.github.io/posts/ipa-share/</link><pubDate>Sat, 23 Aug 2025 01:33:06 +0800</pubDate><guid>https://qfsyso.github.io/posts/ipa-share/</guid><description>Debian 服务器上部署 ipashare。
部署前准备 服务器环境要求
操作系统：Debian12
网络：确保服务器能正常访问 Docker 镜像仓库及 Apple App Store Connect API。
域名建议已绑定并正确解析到该服务器，支持 HTTPS（可通过 Nginx + Certbot 实现）。
系统依赖工具安装
执行以下命令安装 Docker 及 Docker Compose：
sudo apt update sudo apt install -y docker.io docker-compose sudo systemctl enable --now docker 获取 Apple API 凭证
登录 App Store Connect 创建 API 密钥，包括：
Issuer ID
Key ID
.p8 文件
这些是项目调用 App Store Connect API 必需项。
使用 Docker Compose 部署 官方提供 docker-compose.yml 示例，可在服务器上创建并自定义：</description></item><item><title> win bilud go 4 linux</title><link>https://qfsyso.github.io/posts/win-bilud-go-4-linux/</link><pubDate>Mon, 26 Aug 2024 00:58:39 +0000</pubDate><guid>https://qfsyso.github.io/posts/win-bilud-go-4-linux/</guid><description>1. 安装必要的工具和依赖 首先，确保你已经安装了Go编译器和VS Code。如果还没有安装Go，可以从官方网站下载并安装。
2. 配置Go环境 打开VS Code，按 Ctrl + Shift + P 打开命令面板，输入 &amp;ldquo;shell&amp;rdquo; 选择 &amp;ldquo;Shell: Windows&amp;rdquo; 或 &amp;ldquo;Shell: Linux&amp;rdquo;
创建一个新的Go项目 在VS Code中创建一个新的文件夹作为你的Go项目目录，然后在终端中导航到该目录并初始化一个新的Go项目：
mkdir my-go-app cd my-go-app go mod init my-go-app touch main.go 4. 编写Go程序 在 main.go 文件中编写一个简单的Hello World程序：
package main import &amp;#34;fmt&amp;#34; func main() { fmt.Println(&amp;#34;Hello, World!&amp;#34;) } 5. 安装交叉编译工具 ⭐ Go提供了一些工具来进行跨平台编译。你可以使用以下命令来安装这些工具：
go install github.com/golang/tools/cmd/goimports@latest go install golang.org/x/lint/golint@latest go install github.com/cweill/gotests/...@latest 6. 配置VS Code以使用Linux环境 你需要一个Linux环境来进行交叉编译。Windows Subsystem for Linux (WSL)来实现。 (https://learn.</description></item><item><title> Go Background</title><link>https://qfsyso.github.io/posts/go-background/</link><pubDate>Mon, 05 Aug 2024 01:44:01 +0000</pubDate><guid>https://qfsyso.github.io/posts/go-background/</guid><description>debian go程序 后台运行 要在Debian系统上将Go程序设置为后台运行，使用nohup命令和&amp;amp;符号。
编译Go程序，生成可执行文件。
go build -o myapp main.go 使用nohup将程序放到后台运行，并将输出重定向到nohup.out文件。
nohup ./myapp &amp;amp; 如果您想要程序在系统启动时自动运行，可以创建一个systemd服务文件。
创建一个名为myapp.service的文件：
sudo nano /etc/systemd/system/myapp.service 在编辑器中添加以下内容：
[Unit] Description=My Go Application After=network.target [Service] Type=simple ExecStart=/path/to/your/myapp Restart=on-failure RestartSec=5 [Install] WantedBy=multi-user.target 保存并退出编辑器。
启用并启动服务：
sudo systemctl enable myapp.service sudo systemctl start myapp.service Go程序就会在Debian系统上作为服务后台运行。
c# run~ sudo nohup dotnet run /root/socketa/TcpSk &amp;gt; output20240805.log 2&amp;gt;&amp;amp;1 &amp;amp; sudo nohup dotnet run /root/netser/xx &amp;gt; output1.log 2&amp;gt;&amp;amp;1 &amp;amp; ps -ef | grep nohup kill</description></item><item><title> Gofastdfs whitelist</title><link>https://qfsyso.github.io/posts/gofastdfs-whitelist/</link><pubDate>Thu, 25 Jul 2024 23:46:59 +0000</pubDate><guid>https://qfsyso.github.io/posts/gofastdfs-whitelist/</guid><description>在go-fastdfs项目中，要实现IP白名单限制上传功能，你需要在处理上传请求的地方进行检查。根据你提供的代码，上传逻辑主要在server.go文件中的HttpHandler的ServeHTTP方法里通过调用mux.ServeHTTP(res, req)来分发请求到不同的处理函数。
IP白名单限制 定义白名单：首先需要定义一个变量来存储允许的IP地址。可以在server.go的Server结构体中添加一个字段来存储这个白名单。
type Server struct { // ... 其他字段 ... allowedIPs map[string]struct{} } func NewServer() *Server { server := &amp;amp;Server{ // ... 初始化其他字段 ... allowedIPs: make(map[string]struct{}), } // 假设允许的IP是 &amp;#34;192.168.1.1&amp;#34; 和 &amp;#34;10.12.188.85&amp;#34; server.allowedIPs[&amp;#34;192.168.1.1&amp;#34;] = struct{}{} server.allowedIPs[&amp;#34;10.12.188.85&amp;#34;] = struct{}{} return server } 修改HttpHandler：在HttpHandler的ServeHTTP方法中添加一个检查逻辑，以确定请求的IP是否在白名单中。
func (httpHandler *HttpHandler) ServeHTTP(res http.ResponseWriter, req *http.Request) { if !server.isIPAllowed(req) { http.Error(res, &amp;#34;Access denied&amp;#34;, http.StatusForbidden) return } // 原有的处理逻辑 mux.ServeHTTP(res, req) } func (server *Server) isIPAllowed(req *http.</description></item><item><title>Go-fastdfs</title><link>https://qfsyso.github.io/posts/go-fastdfs/</link><pubDate>Wed, 19 Jun 2024 23:58:46 +0000</pubDate><guid>https://qfsyso.github.io/posts/go-fastdfs/</guid><description>go-fastdfs Go-fastdfs 是简单、可靠、高效的分布式文件系统。
安装 https://sjqzhang.github.io/go-fastdfs/#character
or https://github.com/sjqzhang/go-fastdfs/releases
启动 ./fileserver server docker部署 docker run --network=host --name fastdfs -v /data/fastdfs_data:/data -p 8080:8080 -e GO_FASTDFS_DIR=/data sjqzhang/go-fastdfs .NET 参考java实现 https://sjqzhang.github.io/go-fastdfs/usage.html#java
private static readonly string UPLOAD_PATH2 = &amp;#34;go-fastdfs地址XXX:XX&amp;#34;; [HttpPost(&amp;#34;FormFile&amp;#34;)] public async Task&amp;lt;string&amp;gt; UploadGo(IFormFile file) { if (file == null || file.Length == 0) { return &amp;#34;File is empty&amp;#34;; } string result = string.Empty; try { using (var httpClient = new HttpClient()) { using (var form = new MultipartFormDataContent()) { var streamContent = new StreamContent(file.</description></item><item><title>Golang Web Base</title><link>https://qfsyso.github.io/posts/golang-web-base/</link><pubDate>Fri, 14 Jun 2024 05:53:14 +0000</pubDate><guid>https://qfsyso.github.io/posts/golang-web-base/</guid><description>setup windows环境安装 windows环境下，go安装包安装成功后，会自动将go添加到path目录下，所以不需要再向Path环境变量中添加go
GOROOT设置：Go安装路径
“我的电脑”=》“属性”=》“高级系统设置”=》“环境变量”=》“系统环境变量”，新增GOROOT环境变量
web package main import ( &amp;#34;fmt&amp;#34; &amp;#34;net/http&amp;#34; ) func main() { http.HandleFunc(&amp;#34;/&amp;#34;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, &amp;#34;Hello, m requested: %s\n&amp;#34;, r.URL.Path) }) http.ListenAndServe(&amp;#34;:24612&amp;#34;, nil) } Http Server static
http.HandleFunc(&amp;#34;/&amp;#34;, func (w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, &amp;#34;Welcome !&amp;#34;) }) fs := http.FileServer(http.Dir(&amp;#34;static/&amp;#34;)) http.Handle(&amp;#34;/static/&amp;#34;, http.StripPrefix(&amp;#34;/static/&amp;#34;, fs)) http.ListenAndServe(&amp;#34;:24612&amp;#34;, nil) gorilla/mux router
go get github.com/gorilla/mux package main import ( &amp;#34;fmt&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;github.com/gorilla/mux&amp;#34; ) func main() { r := mux.</description></item></channel></rss>