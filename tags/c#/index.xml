<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>C# on MLOG</title><link>https://qfsyso.github.io/tags/c%23/</link><description>Recent content in C# on MLOG</description><generator>Hugo -- 0.126.3</generator><language>zh-CN</language><lastBuildDate>Sun, 24 Nov 2024 17:36:50 +0000</lastBuildDate><atom:link href="https://qfsyso.github.io/tags/c%23/index.xml" rel="self" type="application/rss+xml"/><item><title>csharp reflection delegate</title><link>https://qfsyso.github.io/posts/csharp-reflection-delegate/</link><pubDate>Sun, 24 Nov 2024 17:36:50 +0000</pubDate><guid>https://qfsyso.github.io/posts/csharp-reflection-delegate/</guid><description>Reflection 反射 动态加载和创建对象： 反射可以在运行时加载程序集，并基于类型信息创建对象实例，而无需在编译时知道具体的类型。 这对于实现插件系统、动态加载模块或在不同版本的库之间提供兼容性非常有用。
反射可以获取有关类型（如类、接口、结构体等）及其成员（如字段、属性、方法等）的详细信息。 这对于生成文档、进行代码分析或创建序列化/反序列化机制等任务非常有用。
class Program { static void Main(string[] args) { // 加载包含类型的程序集 Assembly assembly = Assembly.LoadFrom(&amp;#34;ReflectionExample.dll&amp;#34;); // 获取类型信息 Type type = assembly.GetType(&amp;#34;ReflectionExample.MyClass&amp;#34;); // 创建对象实例 object instance = Activator.CreateInstance(type); // 获取方法信息 MethodInfo methodInfo = type.GetMethod(&amp;#34;MyMethod&amp;#34;); // 调用方法 methodInfo.Invoke(instance, new object[] { &amp;#34;Hello, Reflection!&amp;#34; }); } } public class MyClass { public void MyMethod(string message) { Console.WriteLine(message); } } Delegate 委托 委托是一种类型安全的函数指针，可以用来引用一个或多个具有相同签名的方法。 委托（Delegate）是一种特殊的类型，它代表对具有特定参数列表和返回类型的函数的引用。委托可以用来封装静态方法或实例方法，并且可以在运行时像普通变量一样传递。这使得委托成为一种强大的工具，用于实现回调函数、事件处理以及其他需要函数作为参数传递的场景。
委托的基本特性 类型安全：委托是类型安全的，因为它们在声明时会指定一个方法签名，只有与这个签名匹配的方法才能被委托引用。 多播能力：大多数委托支持多播，即一个委托实例可以引用多个方法。当调用该委托时，所有引用的方法都会被依次调用。 灵活性：委托可以用来引用类的实例方法或静态方法，也可以引用匿名方法（使用lambda表达式）。 定义委托 委托可以通过delegate关键字定义。定义时需要指定返回类型和参数列表。 有访问修饰符，delegate，返回值类型，委托名称，参数-可选。可以在类内部，可以在外部。</description></item><item><title>C# keep alive</title><link>https://qfsyso.github.io/posts/c%23-keep-alive/</link><pubDate>Mon, 05 Aug 2024 00:38:00 +0000</pubDate><guid>https://qfsyso.github.io/posts/c%23-keep-alive/</guid><description>在C#中，想让一个控制台应用程序保持运行而不依赖 Cnsole.ReadKey()，可以通过多种方式实现。
1. 使用事件循环 可以使用 EventWaitHandle 或者其他类似的同步原语来创建一个事件循环，让程序保持在等待状态。
using System; using System.Threading; class Program { static void Main() { // 创建一个自动重置的事件对象 EventWaitHandle waitHandle = new EventWaitHandle(false, EventResetMode.AutoReset); Console.WriteLine(&amp;#34;Press any key to exit...&amp;#34;); // 等待事件被设置，如果没有接收到信号，则保持等待状态 waitHandle.WaitOne(); Console.Clear(); } } 使用无限循环 你可以创建一个无限循环，直到你手动终止程序。
//cpu占用高~ using System; class Program { static void Main() { while (true) { // 程序在这里保持运行状态，等待事件或其他中断。 Console.WriteLine(&amp;#34;The program is running. Press CTRL+C to exit.&amp;#34;); } } } 3. 使用定时器 创建一个定时器，定期执行某些任务，或者用于控制程序行为。
using System; using System.</description></item><item><title>c# run nodejs</title><link>https://qfsyso.github.io/posts/c%23-run-nodejs/</link><pubDate>Mon, 20 May 2024 21:13:27 +0000</pubDate><guid>https://qfsyso.github.io/posts/c%23-run-nodejs/</guid><description>在C#中调用Node.js时，一种常见的方法是使用进程间通信（Inter-Process Communication，IPC），例如使用子进程。 可以使用C#中的Process类来启动Node.js进程，并通过标准输入输出与其进行通信。
C# run nodejs // n.js // 监听来自标准输入的消息 process.stdin.on(&amp;#39;data&amp;#39;, function (data) { // 收到消息后，在控制台输出并回复消息 console.log(&amp;#34;Message from C#: &amp;#34; + data.toString()); process.stdout.write(&amp;#34;Hello from Node.js!&amp;#34;); }); ProcessStartInfo startInfo = new ProcessStartInfo(); startInfo.FileName = &amp;#34;node&amp;#34;; // Node.js可执行文件路径，如果已在系统路径中，则不需要提供完整路径 startInfo.Arguments = &amp;#34;n.js&amp;#34;; // 执行的Node.js脚本文件路径 startInfo.UseShellExecute = false; startInfo.RedirectStandardInput = true; startInfo.RedirectStandardOutput = true; Process nodeProcess = new Process(); nodeProcess.StartInfo = startInfo; // 启动进程 nodeProcess.Start(); // 与Node.js进程进行通信 using (var writer = nodeProcess.StandardInput) { if (writer.</description></item></channel></rss>