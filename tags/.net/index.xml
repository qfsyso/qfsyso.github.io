<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>.NET on MLOG</title><link>https://qfsyso.github.io/tags/.net/</link><description>Recent content in .NET on MLOG</description><generator>Hugo -- 0.126.3</generator><language>zh-CN</language><lastBuildDate>Mon, 17 Mar 2025 00:43:26 +0000</lastBuildDate><atom:link href="https://qfsyso.github.io/tags/.net/index.xml" rel="self" type="application/rss+xml"/><item><title>.NET dump</title><link>https://qfsyso.github.io/posts/.net-dump/</link><pubDate>Mon, 17 Mar 2025 00:43:26 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-dump/</guid><description>dotnet-dump dotnet-dump 是一个用于 收集和分析 .NET 进程内存转储 的工具，适用于 排查内存占用过高、GC 问题、内存泄漏 等问题。
1. 安装 dotnet-dump 如果的系统没有 dotnet-dump，可以安装：
dotnet tool install --global dotnet-dump 如果已经安装，但命令找不到，可能需要 更新环境变量：
export PATH=&amp;#34;$HOME/.dotnet/tools:$PATH&amp;#34; 然后检查是否安装成功：
dotnet-dump --help 2. 收集 dotnet 进程的内存转储 步骤 1：找到 dotnet 进程 ID ps aux | grep dotnet 例如：
root 134609 106 6.0 276010852 242112 pts/3 Sl 10:10 0:04 dotnet /root/nets4/IM.dll 这里的 134609 就是 dotnet 进程的 PID。
步骤 2：收集转储 dotnet-dump collect -p 134609 它会生成一个 .dmp 文件，例如：
Writing full dump to file /root/core_134609.</description></item><item><title> .NET Runtime Param</title><link>https://qfsyso.github.io/posts/.net-runtime-param/</link><pubDate>Sun, 16 Mar 2025 02:40:38 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-runtime-param/</guid><description>在C#中，根据不同的环境（例如测试环境、发布环境）改变程序行为是一种常见的需求。通常，可以通过配置文件、环境变量或者预编译指令来实现这一需求。
1. 使用预编译指令 预编译指令（如#if, #define）允许你在编译时根据不同的条件编译不同的代码块。这种方法通常用于编译时确定环境。
首先，在项目属性中定义宏：
打开项目属性（右键点击项目 -&amp;gt; 属性）。
转到“构建”选项卡。
在“条件编译符号”中输入宏名称，例如TEST或RELEASE。
然后，在代码中使用这些宏：
#define TEST class Program { static void Main(string[] args) { #if TEST Console.WriteLine(&amp;#34;This is the test environment.&amp;#34;); #else Console.WriteLine(&amp;#34;This is the release environment.&amp;#34;); #endif } } 2. 使用配置文件 另一种常见的方法是使用配置文件（如appsettings.json或app.config），并通过代码读取这些配置来决定程序的行为。这种方法更适合于运行时的环境切换。
首先，在appsettings.json中添加环境配置：
{ &amp;#34;Environment&amp;#34;: &amp;#34;Test&amp;#34; } 然后，在C#代码中读取这些配置：
using Microsoft.Extensions.Configuration; using System; using System.IO; class Program { static void Main(string[] args) { var builder = new ConfigurationBuilder() .SetBasePath(Directory.GetCurrentDirectory()) .AddJsonFile(&amp;#34;appsettings.json&amp;#34;, optional: true, reloadOnChange: true); IConfigurationRoot configuration = builder.</description></item><item><title>.NET9 lock Aspire UUID JsonSerializerOptions</title><link>https://qfsyso.github.io/posts/.net9-lock-aspire-uuid-jsonserializeroptions/</link><pubDate>Thu, 02 Jan 2025 00:05:49 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net9-lock-aspire-uuid-jsonserializeroptions/</guid><description>.NET9 迄今为止最高效、最现代、最安全、最智能、性能最高的.NET版本
dotnet --list-sdks # 指令查看是否以安装.NET9。 下载.NET9 SDK安装 or
IDE Visual Studio 更新
Lock 引入 System.Threading.Lock 是 .NET 提供的一个更优雅的锁定机制，可以替代传统的基于 Monitor 的锁定方式。以下是新锁定机制的特点及示例代码：
using System; using System.Threading; class Program { private static readonly Lock _lock = new(); static void Main() { // 使用新锁定机制 using (_lock.EnterScope()) { Console.WriteLine(&amp;#34;这是线程安全的代码块&amp;#34;); // 在这里执行线程安全的操作 } // 演示多线程场景 Thread thread1 = new(() =&amp;gt; AccessResource(&amp;#34;线程1&amp;#34;)); Thread thread2 = new(() =&amp;gt; AccessResource(&amp;#34;线程2&amp;#34;)); thread1.Start(); thread2.Start(); thread1.Join(); thread2.Join(); } static void AccessResource(string threadName) { using (_lock.</description></item><item><title>gRPC</title><link>https://qfsyso.github.io/posts/grpc/</link><pubDate>Mon, 09 Dec 2024 23:18:09 +0000</pubDate><guid>https://qfsyso.github.io/posts/grpc/</guid><description>gRPC（Google Remote Procedure Call） 是一个高性能、开源和通用的RPC框架，最初由Google开发。它使用HTTP/2作为传输协议，并默认采用Protocol Buffers作为接口定义语言（IDL）和消息格式。gRPC支持多种编程语言，包括但不限于C++、Java、Python、Go、Ruby、C#、Node.js、PHP等。
gRPC 特点： 高效的数据交换：通过使用Protocol Buffers（Protobuf），gRPC能够以二进制形式序列化和反序列化数据，这比JSON或XML等文本格式更紧凑、更快。 双向流式通信：gRPC支持四种不同的调用类型：简单RPC、服务器端流式RPC、客户端流式RPC以及双向流式RPC。这使得开发者可以灵活选择最适合其应用场景的通信模式。 HTTP/2：gRPC基于HTTP/2构建，这意味着它可以利用HTTP/2提供的特性，如多路复用、头部压缩、流量控制等，来提高性能和可靠性。 跨平台支持：gRPC可以在多种环境中运行，包括云服务、本地部署、移动端等，并且对各种编程语言都有良好的支持，便于构建跨平台的应用程序。 插件系统：gRPC提供了一个插件系统，允许用户自定义代码生成逻辑，或者添加额外的功能，如认证、日志记录、监控等。 强大的社区和生态系统：由于它是Google的产品并且被广泛采用，因此拥有一个活跃的社区和丰富的第三方库与工具生态系统。
gRPC 场景： gRPC的使用场景非常广泛，尤其适用于需要高效、可靠和高性能通信的应用程序。以下是gRPC的一些典型使用场景：
1. 微服务架构 服务间通信：在微服务架构中，不同的服务可能使用不同的编程语言实现，并且需要高效地相互交流。gRPC以其跨语言支持和高效的二进制协议（Protocol Buffers），成为构建微服务之间通信层的理想选择。 负载均衡：gRPC原生支持客户端负载均衡，可以帮助分散请求到多个服务实例上，提高系统的可用性和性能。
2. 实时应用程序 双向流式通信：gRPC的双向流特性非常适合用于实时应用程序，如聊天应用、在线游戏、视频会议等，其中客户端和服务端需要持续地交换数据。 实时数据推送：对于需要从服务器向客户端推送实时更新的应用，例如股票行情、社交媒体通知、物联网设备状态更新等，gRPC的服务端流式RPC可以有效地实现这一需求。
3. 移动应用与后端通信 轻量级性能：由于其高效的序列化机制和较低的网络开销，gRPC特别适合移动应用与后端服务器之间的通信，特别是在网络条件不佳的情况下，能够减少电量消耗并提高响应速度。 快速开发：gRPC自动生成客户端和服务端代码的能力，大大简化了开发流程，尤其是在多平台开发环境中，减少了重复劳动。
4. 跨语言通信 多语言环境：gRPC支持多种编程语言，使得它非常适合用于跨语言通信的场景。不同团队或项目可以使用各自熟悉的技术栈，同时通过gRPC进行无缝集成。 异构系统集成：当需要将遗留系统与现代应用集成时，gRPC的跨语言能力可以帮助桥接这些系统，促进信息的流动和交互。
5. 分布式系统 节点间通信：在分布式系统中，各节点之间的通信是至关重要的。gRPC提供的高效率和可靠性使其成为分布式计算、任务分发、集群管理等场景下的首选通信框架。 数据同步：gRPC可以用来实现实时的数据同步，确保分布式系统中的所有节点都拥有最新的数据副本。
6. 容器化环境 服务发现：在Kubernetes等容器编排平台上，gRPC可以通过服务发现机制自动找到其他服务，简化了容器间的通信配置。 轻量级部署：gRPC的轻量级特性和对多语言的支持，使其非常适合容器化部署，有助于提升资源利用率和服务扩展性。
7. API后端服务 高性能API：许多大型互联网公司使用gRPC来构建其API后端服务，因为它提供了高性能、可扩展性和易于维护的方式来处理客户端请求。 类型安全：gRPC的IDL（接口定义语言）定义了严格的服务契约，保证了服务端和客户端之间的调用是类型安全的，减少了运行时错误的发生。
8. 物联网（IoT） 低资源消耗：gRPC的高效性能和紧凑的消息格式，使得它成为连接IoT设备和传感器的理想通信协议，能够在有限的计算和网络资源下提供可靠的通信。 实时监控与控制：gRPC的流式API非常适合用于实时监控和控制IoT设备，如智能家居系统、工业自动化等场景。
9. 大数据和机器学习 数据传输：在大数据处理和机器学习训练过程中，gRPC可以用来高效地传输大量数据，特别是当数据需要在不同的计算节点之间传递时。 模型服务：gRPC常被用于构建机器学习模型的服务化接口，允许客户端以高效的方式查询模型预测结果。 综上所述，gRPC是一个灵活且强大的通信框架，适用于各种需要高效、可靠通信的场景。无论是构建复杂的微服务架构，还是简单的客户端-服务器应用，gRPC都能提供显著的优势。
Node.js gRPC 创建和调用 gRPC 服务。包括服务器和客户端实现。
1. 安装必要的包 在项目目录下执行以下命令安装 gRPC 相关依赖：
npm install @grpc/grpc-js @grpc/proto-loader 2.</description></item><item><title>ASP.NET Core 9.0</title><link>https://qfsyso.github.io/posts/asp.net-core-9.0/</link><pubDate>Thu, 05 Dec 2024 21:56:25 +0000</pubDate><guid>https://qfsyso.github.io/posts/asp.net-core-9.0/</guid><description>.net9 引入了扩展类型特性，允许开发者扩展实例成员、静态成员以及属性成员，打破了以往只能通过静态类定义扩展方法的限制；params 关键字不再局限于数组类型，可与多种集合类型一起使用；新增 System.Threading.Lock 类型用于线程同步，改进了线程同步机制；异常处理速度大幅提升，环路性能也有所提高，动态 PGO 降低了类型检查成本，RyuJIT 编译器内联更通用的方法以减少方法调用开销等. linq新增了 CountBy 和 AggregateBy 方法，可通过键进行状态聚合，无需通过 GroupBy 进行中间分组，提高了数据查询的效率和灵活性. 引入了 CryptographicOperations 类型中的新的一次性哈希方法，支持最新的加密标准，并新增了一些加密相关的 API；强化了安全机制，如引入更强大的身份验证和授权机制，支持 OAuth 2.0 和 OpenID Connect 等，还通过 AI 驱动的安全功能实现实时威胁检测
Debian 12 安装.NET 9 添加 Microsoft 包签名密钥和包存储库： 打开终端，运行以下命令：
wget https://packages.microsoft.com/config/debian/12/packages-microsoft-prod.deb -O packages-microsoft-prod.deb sudo dpkg -i packages-microsoft-prod.deb rm packages-microsoft-prod.deb 安装.NET SDK： 如果需要开发.NET 应用程序，可安装.NET SDK，运行以下命令：
sudo apt-get update &amp;amp;&amp;amp; \ sudo apt-get install -y dotnet-sdk-9.0 安装.NET 运行时： 如果只需要运行.NET 应用程序，可安装.NET 运行时。建议安装ASP.NET Core 运行时，因为它包含了.NET 和ASP.NET Core 运行时，在终端中运行以下命令：</description></item><item><title>cashrp opencv</title><link>https://qfsyso.github.io/posts/cashrp-opencv/</link><pubDate>Tue, 03 Dec 2024 01:15:38 +0000</pubDate><guid>https://qfsyso.github.io/posts/cashrp-opencv/</guid><description>Emgu CV进行基本的人脸检测。 人脸检测是指定位图像中的人脸位置，而人脸识别是指确认或验证这些脸孔的身份。为了实现人脸识别，需要训练一个模型，或者使用预训练的模型。
安装 Emgu CV 首先，需要通过NuGet安装Emgu CV包。可以通过Visual Studio的NuGet包管理器来安装：
打开的C#项目。 右键点击解决方案资源管理器中的项目名称，选择“管理NuGet程序包”。
搜索并安装Emgu.CV和Emgu.CV.runtime.windows。 // 加载人脸检测分类器 CascadeClassifier faceCascade = new CascadeClassifier(&amp;#34;haarcascade_frontalface_default.xml&amp;#34;); // 读取输入图像 Image&amp;lt;Bgr, byte&amp;gt; inputImage = new Image&amp;lt;Bgr, byte&amp;gt;(&amp;#34;face.jpg&amp;#34;); // 转换为灰度图像，因为人脸检测通常在灰度图像上进行 Image&amp;lt;Gray, byte&amp;gt; grayImage = inputImage.Convert&amp;lt;Gray, byte&amp;gt;(); // 进行人脸检测 Rectangle[] faces = faceCascade.DetectMultiScale(grayImage, 1.1, 3, Size.Empty); // 在检测到的人脸周围绘制矩形框 foreach (Rectangle face in faces) { inputImage.Draw(face, new Bgr(0, 255, 0), 3); } // 保存标记后的图像为output.jpg inputImage.Save(&amp;#34;output.jpg&amp;#34;); Console.WriteLine(&amp;#34;save~output.jpg&amp;#34;); xml来自 https://github.com/opencv/opencv/tree/master/data/haarcascades
runtime 如果没有 Emgu.CV.runtime.windows 则会加载不了xml</description></item><item><title>csharp reflection delegate</title><link>https://qfsyso.github.io/posts/csharp-reflection-delegate/</link><pubDate>Sun, 24 Nov 2024 17:36:50 +0000</pubDate><guid>https://qfsyso.github.io/posts/csharp-reflection-delegate/</guid><description>Reflection 反射 动态加载和创建对象： 反射可以在运行时加载程序集，并基于类型信息创建对象实例，而无需在编译时知道具体的类型。 这对于实现插件系统、动态加载模块或在不同版本的库之间提供兼容性非常有用。
反射可以获取有关类型（如类、接口、结构体等）及其成员（如字段、属性、方法等）的详细信息。 这对于生成文档、进行代码分析或创建序列化/反序列化机制等任务非常有用。
class Program { static void Main(string[] args) { // 加载包含类型的程序集 Assembly assembly = Assembly.LoadFrom(&amp;#34;ReflectionExample.dll&amp;#34;); // 获取类型信息 Type type = assembly.GetType(&amp;#34;ReflectionExample.MyClass&amp;#34;); // 创建对象实例 object instance = Activator.CreateInstance(type); // 获取方法信息 MethodInfo methodInfo = type.GetMethod(&amp;#34;MyMethod&amp;#34;); // 调用方法 methodInfo.Invoke(instance, new object[] { &amp;#34;Hello, Reflection!&amp;#34; }); } } public class MyClass { public void MyMethod(string message) { Console.WriteLine(message); } } Delegate 委托 委托是一种类型安全的函数指针，可以用来引用一个或多个具有相同签名的方法。 委托（Delegate）是一种特殊的类型，它代表对具有特定参数列表和返回类型的函数的引用。委托可以用来封装静态方法或实例方法，并且可以在运行时像普通变量一样传递。这使得委托成为一种强大的工具，用于实现回调函数、事件处理以及其他需要函数作为参数传递的场景。
委托的基本特性 类型安全：委托是类型安全的，因为它们在声明时会指定一个方法签名，只有与这个签名匹配的方法才能被委托引用。 多播能力：大多数委托支持多播，即一个委托实例可以引用多个方法。当调用该委托时，所有引用的方法都会被依次调用。 灵活性：委托可以用来引用类的实例方法或静态方法，也可以引用匿名方法（使用lambda表达式）。 定义委托 委托可以通过delegate关键字定义。定义时需要指定返回类型和参数列表。 有访问修饰符，delegate，返回值类型，委托名称，参数-可选。可以在类内部，可以在外部。</description></item><item><title> .NET MemoryPack</title><link>https://qfsyso.github.io/posts/.net-memorypack/</link><pubDate>Thu, 14 Nov 2024 00:57:37 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-memorypack/</guid><description>MemoryPack 是一个高效的数据序列化库，它专注于性能优化，适用于需要快速序列化和反序列化的场景。这个库是由 Yuki Yogo 开发的，并且在 .NET 社区中获得了相当的关注。MemoryPack 支持零拷贝（zero-copy）读取，这意味着可以在不需要额外内存分配的情况下直接从原始字节数据中读取值。
MemoryPack使用示例，包括定义一个可序列化的类、序列化对象以及反序列化回对象的过程。
安装 MemoryPack 首先，需要安装 MemoryPack 库。可以通过 NuGet 包管理器来安装：
dotnet add package MemoryPack 或者在 Visual Studio 中使用 NuGet 包管理器界面来安装。
定义可序列化的类 为了使一个类能够被 MemoryPack 序列化，需要为该类添加 [MemoryPackable] 属性，并为类中的每个字段或属性添加 [MemoryPackIgnore] 属性（如果想要忽略某些字段或属性的话）。这里有一个简单的例子：
using System; using MemoryPack; [MemoryPackable] public partial class Person { public string Name { get; set; } public int Age { get; set; } [MemoryPackIgnore] public string NotSerializedProperty { get; set; } } 注意：partial 关键字是必须的，因为 MemoryPack 在编译时会生成一些额外的代码来支持序列化/反序列化。</description></item><item><title>.NET ILogger</title><link>https://qfsyso.github.io/posts/.net-ilogger/</link><pubDate>Thu, 14 Nov 2024 00:55:06 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-ilogger/</guid><description>ILogger 是 ASP.NET Core 中的一个接口，用于记录应用程序的日志信息。它是一个泛型接口，其中 T 是日志记录的上下文类型。通常情况下，会使用 ILogger 接口而不是 ILogger，除非需要将特定的上下文类型传递给日志记录器。
ILogger 的示例：
1. 注入 ILogger 在的控制器、服务或其他依赖注入组件中，可以注入 ILogger 或 ILogger。例如，在控制器中注入 ILogger：
public class YourController : ControllerBase { private readonly ILogger&amp;lt;YourController&amp;gt; _logger; public YourController(ILogger&amp;lt;YourController&amp;gt; logger) { _logger = logger; } // ... } 或者，如果不需要特定的上下文类型，可以注入 ILogger：
public class YourService { private readonly ILogger _logger; public YourService(ILogger logger) { _logger = logger; } // ... } 2. 记录日志 使用 _logger 对象记录不同级别的日志，例如：
_logger.LogInformation(&amp;#34;This is an information message.</description></item><item><title>Bogus-.NET Fake Data</title><link>https://qfsyso.github.io/posts/bogus-.net-fake-data/</link><pubDate>Sun, 10 Nov 2024 21:09:29 +0000</pubDate><guid>https://qfsyso.github.io/posts/bogus-.net-fake-data/</guid><description>Bogus 快速生成模拟数据 适用于单元测试、原型设计、演示数据准备。
1.NuGet 安装 Bogus 2.简单使用 var faker = new Faker(); // var faker = new Faker(&amp;#34;zh_CN&amp;#34;); ////中文 Console.WriteLine($&amp;#34;Name: {faker.Name.FullName()}&amp;#34;); Console.WriteLine($&amp;#34;Email: {faker.Internet.Email()}&amp;#34;); Console.WriteLine($&amp;#34;Phone: {faker.Phone.PhoneNumber()}&amp;#34;); Console.WriteLine($&amp;#34;Address: {faker.Address.FullAddress()}&amp;#34;); Console.WriteLine($&amp;#34;Company: {faker.Company.CompanyName()}&amp;#34;); Console.WriteLine($&amp;#34;Catch Phrase: {faker.Company.CatchPhrase()}&amp;#34;); Console.WriteLine($&amp;#34;BS: {faker.Company.Bs()}&amp;#34;); Console.WriteLine($&amp;#34;Product: {faker.Commerce.Product()}&amp;#34;); Console.WriteLine($&amp;#34;Price: {faker.Commerce.Price()}&amp;#34;); Console.WriteLine($&amp;#34;Credit Card: {faker.Finance.CreditCardNumber()}&amp;#34;); Console.WriteLine($&amp;#34;Bitcoin Address: {faker.Finance.BitcoinAddress()}&amp;#34;); Console.WriteLine($&amp;#34;User Agent: {faker.Internet.UserAgent()}&amp;#34;); Console.WriteLine($&amp;#34;Color: {faker.Commerce.Color()}&amp;#34;); Console.WriteLine($&amp;#34;Time Zone: {faker.Date.TimeZoneString()}&amp;#34;); 3.自定义类使用 public class TUser { public int Id { get; set; } public string FirstName { get; set; } public string LastName { get; set; } public string Email { get; set; } public DateTime Birth { get; set; } } //模拟数据 var faker = new Faker&amp;lt;TUser&amp;gt;().</description></item><item><title>.NET WatchDog</title><link>https://qfsyso.github.io/posts/.net-watchdog/</link><pubDate>Sat, 09 Nov 2024 00:01:03 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-watchdog/</guid><description>WatchDog 是一个开源（MIT License）、免费的实时应用监控系统，它可以实时记录并查看应用中的消息、事件、HTTP 请求和响应，以及运行时捕获的异常。
功能特点 实时日志记录：能够实时记录HTTP请求、响应以及运行时捕获的异常。 代码内日志记录：支持在代码中记录消息和事件。 日志搜索功能：支持对HTTP请求和异常日志进行搜索。 HTTP日志筛选：可根据HTTP方法和状态码筛选HTTP日志。 报警通知：支持通过邮件、短信等多种方式发送报警通知，确保能够及时得到反馈。 灵活配置：可以根据应用需求进行灵活的配置，适应不同的监控需求。 使用正则表达式黑名单 ：新增了使用正则表达式进行黑名单过滤的功能。
工作原理 WatchDog 利用 SignalR 实现了实时监控，并使用LiteDb作为无需配置的类似MongoDB的服务器端数据库，同时也支持使用外部数据库（如MSSQL、MySQL、PostgreSQL、MongoDB）。
使用 WatchDog 首先，在项目中安装 WatchDog 包。
NuGet 包管理器中安装： dotnet add package WatchDog 在 Startup.cs 中配置 WatchDog： 在 ConfigureServices 方法中添加 WatchDog：
public void ConfigureServices(IServiceCollection services) { services.AddControllers(); // 添加 WatchDog 服务 services.AddWatchDogServices(); } 然后，在 Configure 方法中配置它：
public void Configure(IApplicationBuilder app, IWebHostEnvironment env) { if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); } app.UseHttpsRedirection(); app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(endpoints =&amp;gt; { endpoints.</description></item><item><title>.net orm</title><link>https://qfsyso.github.io/posts/.net-orm/</link><pubDate>Sat, 26 Oct 2024 22:35:57 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-orm/</guid><description>SqlSugar nuget 安装 SqlSugar
安装 MySql.Data
实体类
[SugarTable(&amp;#34;IMMenu&amp;#34;)] class IMMenu { [SugarColumn(IsPrimaryKey = true, IsIdentity = true)] //id public int id { get; set; } public string name { get; set; } // 其他属性... public override string ToString() { return $&amp;#34;id: {id}, name: {name}&amp;#34;; } } 使用
// 连接字符串 string connectionString = &amp;#34;server=xxx;user=root;password=xxx;database=DB&amp;#34;; // 创建SqlSugar客户端实例 SqlSugarClient db = new SqlSugarClient(new ConnectionConfig() { ConnectionString = connectionString, DbType = DbType.MySql, IsAutoCloseConnection = true, InitKeyType = InitKeyType.</description></item><item><title> .NET ZIP</title><link>https://qfsyso.github.io/posts/.net-zip/</link><pubDate>Thu, 17 Oct 2024 01:03:45 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-zip/</guid><description>压缩一个目录为 ZIP 文件 using System; using System.IO.Compression; class Program { static void Main() { string startPath = @&amp;#34;c:\example\start&amp;#34;; // 要压缩的目录路径 string zipPath = @&amp;#34;c:\example\result.zip&amp;#34;; // 输出的 ZIP 文件路径 ZipFile.CreateFromDirectory(startPath, zipPath); Console.WriteLine(&amp;#34;压缩完成！&amp;#34;); } } 压缩单个文件到 ZIP 文件 using System; using System.IO; using System.IO.Compression; class Program { static void Main() { string filePath = @&amp;#34;c:\example\file.txt&amp;#34;; // 要压缩的文件路径 string zipPath = @&amp;#34;c:\example\result.zip&amp;#34;; // 输出的 ZIP 文件路径 using (FileStream fs = File.OpenRead(filePath)) using (FileStream zipFs = File.</description></item><item><title> .net write wwwroot json</title><link>https://qfsyso.github.io/posts/.net-write-wwwroot-json/</link><pubDate>Wed, 16 Oct 2024 01:24:24 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-write-wwwroot-json/</guid><description>1. 创建一个新的控制器 在Controllers文件夹中创建一个新控制器，例如JsonController.cs。
using Microsoft.AspNetCore.Mvc; using System.IO; using Newtonsoft.Json; namespace Namespace.Controllers { [ApiController] [Route(&amp;#34;[controller]&amp;#34;)] public class JsonController : ControllerBase { private readonly string _jsonFilePath = Path.Combine(Directory.GetCurrentDirectory(), &amp;#34;wwwroot&amp;#34;, &amp;#34;data.json&amp;#34;); // GET: /json [HttpGet] public IActionResult GetJson() { if (!System.IO.File.Exists(_jsonFilePath)) return NotFound(&amp;#34;JSON file not found.&amp;#34;); var jsonContent = System.IO.File.ReadAllText(_jsonFilePath); return Content(jsonContent, &amp;#34;application/json&amp;#34;); } // POST: /json [HttpPost] public IActionResult PostJson([FromBody] DataType data) { var jsonString = JsonConvert.SerializeObject(data); System.IO.File.WriteAllText(_jsonFilePath, jsonString); return Ok(&amp;#34;JSON file updated successfully.</description></item><item><title> .net chacha20 decrypted</title><link>https://qfsyso.github.io/posts/.net-chacha20-decrypted/</link><pubDate>Wed, 16 Oct 2024 01:10:02 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-chacha20-decrypted/</guid><description>.NET 实现 ChaCha20 加密和解密
add package Install-Package BouncyCastle chacha20 helper using Org.BouncyCastle.Crypto; using Org.BouncyCastle.Crypto.Engines; using Org.BouncyCastle.Crypto.Parameters; using System; public class ChaCha20 { private readonly byte[] key; private readonly byte[] nonce; // Constructor to initialize key and nonce public ChaCha20(byte[] key, byte[] nonce) { if (key.Length != 32) { throw new ArgumentException(&amp;#34;Key must be 32 bytes (256 bits).&amp;#34;); } if (nonce.Length != 12) { throw new ArgumentException(&amp;#34;Nonce must be 12 bytes (96 bits).</description></item><item><title>.net local LLM</title><link>https://qfsyso.github.io/posts/.net-local-llm/</link><pubDate>Wed, 16 Oct 2024 00:11:42 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-local-llm/</guid><description>ollama ollama --version 比较常用的指令不多，也很简单 列出本地下载的模型
ollama list 查看正在运行的模型
ollama ps 模型标识下载模型到本地
ollama pull 比如我要下载llama2-chinese:7b则使用
ollama pull llama2-chinese:7b 模型标识运行模型，如果已下载则直接运行，如果没下载则先下载再运行。
ollama run 比如我要运行llama2-chinese:7b可以直接运行
ollama run llama2-chinese:7b .net package dotnet add package Ollama --version 1.9.0 //模型名称是必须要传递的，默认 流式输出,如果想一次返回同样的是设置stream为false。 string modelName = &amp;#34;llama2-chinese:7b&amp;#34;; using var ollama = new OllamaApiClient(baseUri: new Uri(&amp;#34;http://127.0.0.1:11434/api&amp;#34;)); Console.WriteLine(&amp;#34;begin~~~&amp;#34;); string userInput = &amp;#34;&amp;#34;; do { Console.WriteLine(&amp;#34;User:&amp;#34;); userInput = Console.ReadLine()!; var enumerable = ollama.Completions.GenerateCompletionAsync(modelName, userInput); Console.WriteLine(&amp;#34;Agent:&amp;#34;); await foreach (var response in enumerable) { Console.</description></item><item><title> .NET build release 4 linux</title><link>https://qfsyso.github.io/posts/.net-build-release-4-linux/</link><pubDate>Sun, 29 Sep 2024 11:52:15 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-build-release-4-linux/</guid><description>在项目中使用 dotnet publish 命令来发布应用程序。
将发布的应用程序文件夹复制到 Linux 服务器上。
在 Linux 服务器上安装 .NET 运行时，如果应用是 self-contained（独立部署）的。
使用 systemd 创建一个服务单元文件来管理应用作为服务运行。
启动应用程序服务。
发布应用程序：
dotnet publish -c Release -o ./publish 将发布文件夹复制到 Linux 服务器：
scp -r ./publish [user]@[host]:/var/www/myapp 运行
dotnet myapp.dll 创建 systemd 服务文件 /etc/systemd/system/myapp.service：
[Unit] Description=My .NET App [Service] WorkingDirectory=/var/www/myapp ExecStart=/var/www/myapp/MyApp Restart=always RestartSec=10 SyslogIdentifier=dotnet-myapp User=www-data Environment=ASPNETCORE_ENVIRONMENT=Production [Install] WantedBy=multi-user.target 启动服务：
sudo systemctl enable myapp.service sudo systemctl start myapp.service 确保应用程序配置了正确的端口监听和防火墙规则。
++++++++++++++++++&amp;ndash;
api wr wwwroot json
using Microsoft.AspNetCore.Mvc; using System.</description></item><item><title>Anolis8.4 .NET</title><link>https://qfsyso.github.io/posts/anolis8.4-.net/</link><pubDate>Sun, 25 Aug 2024 10:03:23 +0000</pubDate><guid>https://qfsyso.github.io/posts/anolis8.4-.net/</guid><description>Anolis8.4 包管理器为 yum。
打开终端或命令提示符窗口，并切换到 root 用户。
添加 Microsoft 包源。
wget https://packages.microsoft.com/config/centos/8/packages-microsoft-prod.repo -O /etc/yum.repos.d/packages-microsoft-prod.repo 安装.NET 8 SDK。
sudo yum install dotnet-sdk-8.0 运行时
sudo yum install dotnet-runtime-8.0 安装完成后，可以通过以下命令验证.NET 8 是否已成功安装。
dotnet --version test
dotnet new console -o HelloWorld cd HelloWorld dotnet run</description></item><item><title>.NET MSTest Xunit</title><link>https://qfsyso.github.io/posts/.net-mstest-xunit/</link><pubDate>Fri, 26 Jul 2024 23:37:05 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-mstest-xunit/</guid><description>node api 下面是一个使用 Node.js 和 Express.js 编写的简单 RESTful API 示例。
1. 初始化项目 首先，创建一个新的项目目录并进入该目录：
mkdir myapi cd myapi 然后初始化一个新的 Node.js 项目：
npm init -y 2. 安装依赖 安装 Express.js 作为我们的 Web 框架：
npm install express 3. 创建主文件 在项目根目录下创建一个名为 index.js 的文件：
touch index.js 4. 编写 RESTful API 代码 在 index.js 中编写以下代码：
const express = require(&amp;#39;express&amp;#39;); const app = express(); const port = 3000; app.use(express.json()); let items = [ { id: 1, name: &amp;#39;Item 1&amp;#39; }, { id: 2, name: &amp;#39;Item 2&amp;#39; }, { id: 3, name: &amp;#39;Item 3&amp;#39; } ]; // 获取所有项目 app.</description></item><item><title> .NET Web Port</title><link>https://qfsyso.github.io/posts/.net-web-port/</link><pubDate>Thu, 27 Jun 2024 01:02:56 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-web-port/</guid><description>在 .NET8 中，在 Program 类中配置服务和请求管道
示例 using Microsoft.AspNetCore.Builder; using Microsoft.AspNetCore.Hosting; using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Hosting; namespace WServer { public class Program { public static void Main(string[] args) { var builder = WebApplication.CreateBuilder(args); // Add services to the container. builder.Services.AddControllersWithViews(); var app = builder.Build(); // Configure the HTTP request pipeline. if (!app.Environment.IsDevelopment()) { app.UseExceptionHandler(&amp;#34;/Home/Error&amp;#34;); } app.UseStaticFiles(); app.UseRouting(); app.UseAuthorization(); app.MapControllerRoute( name: &amp;#34;default&amp;#34;, pattern: &amp;#34;{controller=Home}/{action=Index}/{id?}&amp;#34;); // 设置默认启动端口 app.Urls.Add(&amp;#34;http://localhost:5000&amp;#34;); // 这里设置为 5000 app.Run(); } } } 启动时自动从环境变量或配置文件中读取端口号</description></item><item><title>.NET MinIO</title><link>https://qfsyso.github.io/posts/.net-minio/</link><pubDate>Tue, 18 Jun 2024 23:11:40 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-minio/</guid><description>安装MinIO docker
docker run --name minio -p 9000:9000 -p 9090:9090 -d -e &amp;#34;MINIO_ROOT_USER=minio&amp;#34; -e &amp;#34;MINIO_ROOT_PASSWORD=minio123&amp;#34; -v /usr/local/minio-data:/data -v /usr/local/minio-config:/root/.minio minio/minio server data --console-address &amp;#34;:9090&amp;#34; --address &amp;#34;:9000&amp;#34; 后台创建 Buckets 访问 localhost:9000 登陆后创建Buckets io617
创建密钥 Access Keys
add package dotnet add package Minio 配置json //... &amp;#34;Minio&amp;#34;: { &amp;#34;Endpoint&amp;#34;: &amp;#34;192.168.80.xx:9000&amp;#34;,//&amp;#34;localhost:9000&amp;#34;, //90/service-account-credentials &amp;#34;AccessKey&amp;#34;: &amp;#34;EctmxSNB9FqfW6UWxxx&amp;#34;, &amp;#34;SecretKey&amp;#34;: &amp;#34;frQhYoH1k7UphMxbwK2PiG2xKadzPjxxx&amp;#34;, &amp;#34;BucketName&amp;#34;: &amp;#34;io617&amp;#34; }, //... 服务类MinioService public class MinioService { private readonly MinioClient _minioClient; private readonly string _bucketName; public MinioService(IConfiguration configuration) { var endpoint = configuration[&amp;#34;Minio:Endpoint&amp;#34;]; var accessKey = configuration[&amp;#34;Minio:AccessKey&amp;#34;]; var secretKey = configuration[&amp;#34;Minio:SecretKey&amp;#34;]; _bucketName = configuration[&amp;#34;Minio:BucketName&amp;#34;]; //http://localhost:9090/api/v1/service-account-credentials _minioClient = (MinioClient?</description></item><item><title>.NET JSON2MySQL</title><link>https://qfsyso.github.io/posts/.net-json2mysql/</link><pubDate>Wed, 12 Jun 2024 22:35:33 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-json2mysql/</guid><description>这是一段json
[ { &amp;#34;id&amp;#34;: 1, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;101010100&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;北京&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;100000&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;010&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:06&amp;#34; }, { &amp;#34;id&amp;#34;: 2, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;安徽&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 3, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;福建&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 4, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;甘肃&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 5, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;广东&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 6, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;广西&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 7, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;贵州&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 8, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;海南&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:03:37&amp;#34; }, { &amp;#34;id&amp;#34;: 9, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;河北&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:06&amp;#34; }, { &amp;#34;id&amp;#34;: 10, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;河南&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:07&amp;#34; }, { &amp;#34;id&amp;#34;: 11, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;黑龙江&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 12, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;湖北&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 13, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;湖南&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 14, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;吉林&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:07&amp;#34; }, { &amp;#34;id&amp;#34;: 15, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;江苏&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 16, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;江西&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 17, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;辽宁&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 18, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;内蒙古&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 19, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;宁夏&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 20, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;青海&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 21, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;山东&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 22, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;山西&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 23, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;陕西&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 24, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;101020100&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;上海&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;200000&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;021&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:08&amp;#34; }, { &amp;#34;id&amp;#34;: 25, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;四川&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 26, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;101030100&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;天津&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;300000&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;022&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:08&amp;#34; }, { &amp;#34;id&amp;#34;: 27, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;西藏&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 28, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;新疆&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 29, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;云南&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 30, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;浙江&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 31, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;101040100&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;重庆&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: &amp;#34;023&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:08&amp;#34; }, { &amp;#34;id&amp;#34;: 32, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;101320101&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;香港&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;999077&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;+852&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:03:38&amp;#34; }, { &amp;#34;id&amp;#34;: 33, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;101330101&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;澳门&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;999078&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;+853&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:03:39&amp;#34; }, { &amp;#34;id&amp;#34;: 34, &amp;#34;pid&amp;#34;: 0, &amp;#34;city_code&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;台湾&amp;#34;, &amp;#34;post_code&amp;#34;: null, &amp;#34;area_code&amp;#34;: null, &amp;#34;ctime&amp;#34;: null }, { &amp;#34;id&amp;#34;: 35, &amp;#34;pid&amp;#34;: 2, &amp;#34;city_code&amp;#34;: &amp;#34;101220601&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;安庆&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;246000&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;0556&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:10&amp;#34; }, { &amp;#34;id&amp;#34;: 36, &amp;#34;pid&amp;#34;: 2, &amp;#34;city_code&amp;#34;: &amp;#34;101220201&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;蚌埠&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;233000&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;0552&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:10&amp;#34; }, { &amp;#34;id&amp;#34;: 37, &amp;#34;pid&amp;#34;: 3400, &amp;#34;city_code&amp;#34;: &amp;#34;101220105&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;巢湖市&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;238000&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;0551&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:03:40&amp;#34; }, { &amp;#34;id&amp;#34;: 38, &amp;#34;pid&amp;#34;: 2, &amp;#34;city_code&amp;#34;: &amp;#34;101221701&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;池州&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;247100&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;0566&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:10&amp;#34; }, { &amp;#34;id&amp;#34;: 39, &amp;#34;pid&amp;#34;: 2, &amp;#34;city_code&amp;#34;: &amp;#34;101221101&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;滁州&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;239000&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;0550&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:10&amp;#34; }, { &amp;#34;id&amp;#34;: 40, &amp;#34;pid&amp;#34;: 2, &amp;#34;city_code&amp;#34;: &amp;#34;101220801&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;阜阳&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;236000&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;0558&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:10&amp;#34; }, { &amp;#34;id&amp;#34;: 41, &amp;#34;pid&amp;#34;: 2, &amp;#34;city_code&amp;#34;: &amp;#34;101221201&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;淮北&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;235000&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;0561&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:11&amp;#34; }, { &amp;#34;id&amp;#34;: 42, &amp;#34;pid&amp;#34;: 2, &amp;#34;city_code&amp;#34;: &amp;#34;101220401&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;淮南&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;232000&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;0554&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:11&amp;#34; }, { &amp;#34;id&amp;#34;: 43, &amp;#34;pid&amp;#34;: 2, &amp;#34;city_code&amp;#34;: &amp;#34;101221001&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;黄山市&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;245000&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;0559&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 21:23:56&amp;#34; }, { &amp;#34;id&amp;#34;: 44, &amp;#34;pid&amp;#34;: 2, &amp;#34;city_code&amp;#34;: &amp;#34;101221501&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;六安&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;237000&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;0564&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:11&amp;#34; }, { &amp;#34;id&amp;#34;: 45, &amp;#34;pid&amp;#34;: 2, &amp;#34;city_code&amp;#34;: &amp;#34;101220501&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;马鞍山&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;243000&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;0555&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:11&amp;#34; }, { &amp;#34;id&amp;#34;: 46, &amp;#34;pid&amp;#34;: 2, &amp;#34;city_code&amp;#34;: &amp;#34;101220701&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;宿州&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;234000&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;0557&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:11&amp;#34; }, { &amp;#34;id&amp;#34;: 47, &amp;#34;pid&amp;#34;: 2, &amp;#34;city_code&amp;#34;: &amp;#34;101221301&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;铜陵&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;244000&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;0562&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:12&amp;#34; }, { &amp;#34;id&amp;#34;: 48, &amp;#34;pid&amp;#34;: 2, &amp;#34;city_code&amp;#34;: &amp;#34;101220301&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;芜湖市&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;241000&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;0553&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 21:23:57&amp;#34; }, { &amp;#34;id&amp;#34;: 49, &amp;#34;pid&amp;#34;: 2, &amp;#34;city_code&amp;#34;: &amp;#34;101221401&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;宣城&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;242000&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;0563&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:12&amp;#34; }, { &amp;#34;id&amp;#34;: 50, &amp;#34;pid&amp;#34;: 2, &amp;#34;city_code&amp;#34;: &amp;#34;101220901&amp;#34;, &amp;#34;city_name&amp;#34;: &amp;#34;亳州&amp;#34;, &amp;#34;post_code&amp;#34;: &amp;#34;236800&amp;#34;, &amp;#34;area_code&amp;#34;: &amp;#34;0558&amp;#34;, &amp;#34;ctime&amp;#34;: &amp;#34;2024-06-11 17:30:12&amp;#34; } //.</description></item><item><title>Azure AI Document Intelligence</title><link>https://qfsyso.github.io/posts/azure-ai-document-intelligence/</link><pubDate>Fri, 07 Jun 2024 23:06:10 +0000</pubDate><guid>https://qfsyso.github.io/posts/azure-ai-document-intelligence/</guid><description>创建智能文档处理解决方案 在第二级中，这3个模块，每一个中都有不同的任务操作，这些操作包括使用 Azure 进行实际创建服务操作或者使用代码调用 Azure的服务，这些代码可以使用python或者C#，这些进行选择。所有的模块内的考试是通过一个邮件的方式进行告知。
https://learn.microsoft.com/en-us/credentials/applied-skills/create-intelligent-document-solution-azure-ai/#applied-skill-take-the-assessment
start
登陆实验环境 加载成功后会出现虚拟机器登陆界面，找到右侧的 Step1 中的用户名密码。登陆 获取实验账号并登陆 Azure 进入到机器后，点击桌面的 Email 图片，打开我们的实验目标。 一个是左侧蓝色的部分：Inbox，这里包括环境信息以及实验目标考题。 另一个是浏览器的页签中的第二个，也就是登陆 Azure 的环境网址
点击上图的 Azure 标签页，进入登陆页面，用email提供的账号密码登陆
试验一： Create a prototype 点击邮件中的 Create a prototype 菜单会出现具体的内容要求。
在第一个实验中主要是使用微软的只能存储服务，并且创建的时候要符合要求，这个服务要满足的要求是要保存所给的文件成Json文件，之后在保存到 Azure 的存储服务中。
实验流程操作 首先到 Azure 中，搜索所给出的资源组，选择 RG1开头的资源组 进入到资源组后，点击创建按钮。 在搜索框中输入document intelligence 点击选择。 点击 文档智能服务
进入到服务后，点击蓝色的创建按钮。 在这里直接选择默认的订阅以及资源组，Region 目前建议选择 Japan East（如果后面的步骤，在运行分析文档时，遇到权限不足问题，请在此步骤选择其他 Region ）
在这里名字填入：from-document-xxx，如（from-document-01）价格层要选择免费层，也就是下图中的 Free F0，之后点击预览创建按钮。
预览没有问题后，直接点击创建按钮。 创建完毕后，在页面中点击 Go to resource 按钮
之后点击 Go to Document Intelligence Studio 按钮 进入到服务页面后，下滑页面，点击 Invoices 的 Try it out。</description></item><item><title>Azure OpenAI Build Natural Language</title><link>https://qfsyso.github.io/posts/azure-openai-build-natural-language/</link><pubDate>Fri, 07 Jun 2024 01:03:12 +0000</pubDate><guid>https://qfsyso.github.io/posts/azure-openai-build-natural-language/</guid><description>https://learn.microsoft.com/en-us/credentials/applied-skills/build-natural-language-solution-azure-ai/#applied-skill-take-the-assessment?ocid=reactor
start 进入环境中，点击Step 1，然后点击Password右边的T，登录环境 双击打开桌面的Email文件 对Inbox的内容进行逐个点击，其中Existing Environment包含了微软官方提供的Azure的用户名和密码，proof of concept、Invoice validation、chatbot backend 分别表示的是本次考试的三大任务的具体要求 将邮箱中Existing Environment的用户名和密码依次复制到Azure的标签页面中，并点击Sign in完成Azure的登录
试验一： Proof of Concept (POC) 点击邮件中的 Proof of Concept (POC) 菜单会出现具体的内容要求，如下图所示。
在第一个实验中主要是使用微软的 language 服务，并且创建的时候要符合要求，这个服务要满足客户自定义文本标准和 NER。 在实验中另外一个要求是需要使用代码最后调用这个你创建服务。 流程操作 首先在登录主页面搜索栏 搜索RG1，并点击Resource Groups下面的RG1 进入后点击 Create 按钮 之后在首页内搜索language service 点击进入到 Language service 后，点击 Create 之后点击右下方的第二个 select 按钮 选择好之后，点击下方的按钮 continue to create your resource
在配置页面，按照我们的题目要求，在 Region 中选择 North Europe， 其中 Name 从邮件中找，在 Proof of concept 这里 lang开头的这个名字，作为刚才创建资源的 Name 值 主要需要注意的是在 Pricing tier层里，需要选择 Free F0 的这个，这一点也是题目要求的。 下面选择 Existing storege account ，在存储账户这里，需要选择题目要求的以sa开头的这个账户。</description></item><item><title>Azure OpenAI Natural Language</title><link>https://qfsyso.github.io/posts/azure-openai-natural-language/</link><pubDate>Tue, 04 Jun 2024 23:02:14 +0000</pubDate><guid>https://qfsyso.github.io/posts/azure-openai-natural-language/</guid><description>简介 Azure OpenAI 为开发人员提供了一个平台，用于在 Python 和 C# SDK 以及 REST API 的帮助下向其应用程序添加人工智能功能。 该平台提供了各种 AI 模型，每个模型都专用于不同的任务，这些任务可通过 Azure OpenAI 服务进行部署。
本模块指导你了解如何将 Azure OpenAI 构建到自己的应用程序中，为你提供一个使用生成式 AI 开发解决方案的起点。
将 Azure OpenAI 集成到应用中 Azure OpenAI 提供 C# 和 Python SDK 以及 REST API，开发人员可以用来向其应用程序添加 AI 功能。 Azure OpenAI 中的生成式 AI 功能通过模型提供。 Azure OpenAI 服务中可用的模型属于不同的系列，每个系列都有自己的重点。 若要使用这些模型之一，需要通过 Azure OpenAI 服务进行部署。
重要
Azure OpenAI 已发布，但支持负责任地使用该服务的访问权限有限。 用户需要先申请访问权限并获得批准，然后才能创建 Azure OpenAI 资源。
创建 Azure OpenAI 资源 可以通过 Azure 命令行接口 (CLI) 和 Azure 门户部署 Azure OpenAI 资源。 通过 Azure 门户创建 Azure OpenAI 资源类似于部署单个 Azure AI 服务资源，并且是 Azure AI 服务的一部分。</description></item><item><title>Azure OpenAI Solution</title><link>https://qfsyso.github.io/posts/azure-openai-solution/</link><pubDate>Sat, 01 Jun 2024 20:02:53 +0000</pubDate><guid>https://qfsyso.github.io/posts/azure-openai-solution/</guid><description>开始使用 Azure OpenAI 服务 简介 假设你想要生成一个汇总文本和建议代码的支持应用程序。 若要生成此应用，需要利用 ChatGPT 中显示的功能，ChatGPT 是 OpenAI 研究公司构建的聊天机器人，它接受用户的自然语言输入，并返回机器创建的类人响应。
生成式 AI 模型支持 ChatGPT 基于自然语言提示生成新内容（如文本、代码和图像）的能力。 许多生成 AI 模型是深度学习算法的子集。 这些算法支持视觉、语音、语言、决策、搜索等各种工作负载。
Azure OpenAI 服务将这些生成式 AI 模型引入 Azure 平台，使你能够开发功能强大的 AI 解决方案，这些解决方案受益于 Azure 云平台提供的其他服务的安全性、可伸缩性和集成。 这些模型可用于通过 REST API、各种 SDK 和 Studio 接口生成应用程序。 本模块将指导你完成 Azure OpenAI Studio 体验，为你使用生成式 AI 进一步开发解决方案奠定了基础。
访问 Azure OpenAI 服务 使用 Azure OpenAI 构建生成型 AI 解决方案的第一步是在 Azure 订阅中预配 Azure OpenAI 资源。 Azure OpenAI 服务目前处于受限访问状态。 用户需要在 https://aka.ms/oai/access 上申请服务访问权限。
注意
Azure OpenAI 服务已发布，但支持以合乎道德的方式使用该服务的访问权限有限。 可以在此处阅读 Azure OpenAI 服务的 Microsoft 透明度说明。</description></item><item><title>.NET AddWatermark</title><link>https://qfsyso.github.io/posts/.net-addwatermark/</link><pubDate>Sat, 01 Jun 2024 19:18:12 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-addwatermark/</guid><description>controller [HttpPost] public async Task&amp;lt;IActionResult&amp;gt; AddWatermark(IFormFile file, string watermarkText, string color, int transparency) { if (file != null &amp;amp;&amp;amp; file.Length &amp;gt; 0) { // 将上传的文件保存到服务器 var uploads = Path.Combine(_environment.WebRootPath, &amp;#34;uploads&amp;#34;); if (!Directory.Exists(uploads)) { Directory.CreateDirectory(uploads); } var filePath = Path.Combine(uploads, file.FileName); using (var fileStream = new FileStream(filePath, FileMode.Create)) { await file.CopyToAsync(fileStream); } // 添加水印 using (Image image = Image.FromFile(filePath)) using (Graphics g = Graphics.FromImage(image)) { // 设置水印文本的字体和颜色 Font font = new Font(&amp;#34;Arial&amp;#34;, 20); Color colorValue = ColorTranslator.</description></item><item><title> .NET Dockerhub</title><link>https://qfsyso.github.io/posts/.net-dockerhub/</link><pubDate>Sat, 01 Jun 2024 01:24:22 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-dockerhub/</guid><description>📚Dockerfile FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build WORKDIR /src COPY [&amp;#34;MyMvcApp.csproj&amp;#34;, &amp;#34;./&amp;#34;] RUN dotnet restore &amp;#34;MyMvcApp.csproj&amp;#34; COPY . . WORKDIR &amp;#34;/src/&amp;#34; RUN dotnet build &amp;#34;MyMvcApp.csproj&amp;#34; -c Release -o /app/build FROM build AS publish RUN dotnet publish &amp;#34;MyMvcApp.csproj&amp;#34; -c Release -o /app/publish FROM base AS final WORKDIR /app COPY --from=publish /app/publish . ENTRYPOINT [&amp;#34;dotnet&amp;#34;, &amp;#34;MyMvcApp.dll&amp;#34;] ✏️ Docker 镜像 docker build -t mymvcapp:latest . 📝在 Docker Hub 上创建仓库 登录 Docker Hub (https://hub.docker.com)。 点击 &amp;ldquo;Create Repository&amp;rdquo;。 输入仓库名称，例如 mymvcapp，然后点击 &amp;ldquo;Create&amp;rdquo;。</description></item><item><title>.NET Redis 10s Rate Limiter Sliding Window Algorithm</title><link>https://qfsyso.github.io/posts/.net-redis-10s-rate-limiter-sliding-window-algorithm/</link><pubDate>Fri, 31 May 2024 06:24:16 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-redis-10s-rate-limiter-sliding-window-algorithm/</guid><description>在.NET中使用Redis来限制接口请求频率（每10秒只允许请求一次）
NuGet setup StackExchange.Redis
实现速率限制逻辑： 在你的控制器或服务层中，你需要编写一个方法来检查并更新Redis中的速率限制计数器。 设置Redis键： 为每个用户或每个IP地址（取决于你的需求）设置一个唯一的键。这个键将用于存储最后一次请求的时间戳和/或请求计数。 检查时间戳： 当请求到达时，从Redis中获取该键的值（时间戳）。如果键不存在或时间戳超过10秒，则允许请求并更新键的值（设置为当前时间戳）。 处理超过速率的请求： 如果时间戳在10秒内，则拒绝或限制该请求（返回限制状态码）。
private static readonly Lazy&amp;lt;ConnectionMultiplexer&amp;gt; LazyConnection = new Lazy&amp;lt;ConnectionMultiplexer&amp;gt;(() =&amp;gt; { // 配置Redis连接字符串 &amp;#34;localhost,abortConnect=false&amp;#34; return ConnectionMultiplexer.Connect(&amp;#34;localhost:6379&amp;#34;); }); private static ConnectionMultiplexer Connection =&amp;gt; LazyConnection.Value; private static IDatabase Db =&amp;gt; Connection.GetDatabase(); public async Task&amp;lt;ActionResult&amp;gt; MyAction() { IPAddress clientIpAddress = HttpContext.Connection.RemoteIpAddress; string ipAddress = clientIpAddress.ToString(); string redisKey = $&amp;#34;rate-limit:{ipAddress}&amp;#34;; // 构建Redis键名 // 获取当前时间戳（可以是Unix时间戳或任何你选择的格式） long currentTimestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds(); // 尝试从Redis获取时间戳 var redisValue = await Db.</description></item><item><title>.NET RocketMQ</title><link>https://qfsyso.github.io/posts/.net-rocketmq/</link><pubDate>Wed, 29 May 2024 20:17:33 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-rocketmq/</guid><description>RocketMQ 是一款由阿里巴巴集团开发并开源给Apache软件基金会的分布式消息及流处理平台。以其高吞吐量、低延迟、高可用性等特点而广受欢迎。支持Java，C++, Python, Go, .NET等。
异步解耦：可以实现上游和下游业务系统的松耦合设计，使得服务部分节点异常不会影响到核心交易系统的正常运转。在电商、金融等分布式系统中，这种解耦设计尤为重要。 削峰填谷：在如秒杀、大促等大型活动中，系统会面临巨大的流量冲击。RocketMQ利用其高性能的消息处理能力，可以有效地应对这种流量冲击，保证系统的稳定运行。 顺序消息：支持顺序消息（分区有序），可以确保消息的先进先出。这在交易系统中的订单创建、支付、退款等流程中尤为重要，因为这些流程对消息的顺序有严格要求。 分布式事务消息：支持分布式事务消息，可以保证分布式事务的强一致性。这在涉及多个服务的分布式系统中非常有用，可以确保数据的一致性和完整性。
RocketMQ优点 高吞吐量和低延迟：能够处理大规模消息流，并提供低延迟的消息传递。这使得它非常适合处理高并发的应用场景，如电子商务和金融交易系统。 可靠性：具有高度可靠的消息传递机制。它支持消息持久化和复制，确保消息不会丢失，并能够在故障发生时进行自动恢复。 分布式扩展：支持水平扩展，可以方便地添加新的消息生产者和消费者来应对负载增加的情况。 易于部署：提供开箱即用的部署方式，非常适合在分布式系统中使用。
RocketMQ架构 生产者（Producer） 用于产生消息的运行实体，通常集成在业务系统的上游。 主题（Topic） 消息传输和存储的分组容器，内部由多个队列组成。 队列（MessageQueue） 消息传输和存储的实际单元容器，类似于其他消息队列中的分区。 消息（Message） RocketMQ 的最小传输单元，具备不可变性。 消费者分组（ConsumerGroup） 发布订阅模型中定义的独立的消费身份分组，用于统一管理多个消费者。 消费者（Consumer） 消费消息的运行实体，集成在业务系统的下游。 订阅关系（Subscription） 发布订阅模型中消息过滤、重试、消费进度的规则配置。
部署RocketMQ（docker） 安装 Docker： #debian curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh 拉取 RocketMQ 镜像： 使用以下命令从 Docker Hub 拉取最新的 RocketMQ 镜像：
docker pull apache/rocketmq:latest 启动 RocketMQ NameServer： RocketMQ 的 NameServer 是负责管理所有 Broker 节点的目录服务。可以使用以下命令启动 NameServer：
docker run -d --name rmqnamesrv -p 9876:9876 apache/rocketmq:latest sh mqnamesrv ```bash ## 启动 RocketMQ Broker： RocketMQ 的 Broker 负责存储消息并处理生产者和消费者的请求。使用以下命令启动 Broker： ```bash docker run -d --name rmqbroker --link rmqnamesrv:namesrv -e &amp;#34;NAMESRV_ADDR=namesrv:9876&amp;#34; -e &amp;#34;BROKER_NAME=broker-a&amp;#34; -e &amp;#34;BROKER_ID=0&amp;#34; -e &amp;#34;AUTO_CREATE_TOPIC_ENABLE=true&amp;#34; -e &amp;#34;AUTO_CREATE_SUBSCRIPTION_GROUP=true&amp;#34; -p 10911:10911 -p 10909:10909 apache/rocketmq:latest sh mqbroker 验证 查看 NameServer 日志：</description></item><item><title>DotNetty ByteBuffer</title><link>https://qfsyso.github.io/posts/dotnetty-bytebuffer/</link><pubDate>Thu, 23 May 2024 21:47:10 +0000</pubDate><guid>https://qfsyso.github.io/posts/dotnetty-bytebuffer/</guid><description>DotNetty是一个高性能的.NET网络通信框架，基于Netty，支持TCP、UDP、HTTP、WebSocket等协议。适用于高并发、低延迟场景，如实时通信、游戏服务器、IoT应用及大型分布式系统，通过异步I/O、零拷贝等技术提升性能，具备易用性、可扩展性。 架构上，围绕Channel、EventLoop、ChannelPipeline、ChannelHandlerContext设计，包含Transport、Codec、Handler等模块，简化网络编程，加速数据传输处理。
ByteBuffer 用于高效处理字节数据，固定容量，通过allocate或wrap创建。涉及position和limit追踪读写位置，提供get/put等读写方法，flip切换读写模式，clear清空缓冲区，compact移动数据并准备下一轮读写，适用于高性能IO与网络通信。.
优点 零拷贝通过复合缓冲区实现。 动态容量增长。 无需flip切换读写模式。 分离读写索引。 内置引用计数。 支持缓冲区池化。 优化网络通信中的字节处理。
结构 readerIndex 读取，随读增。 writerIndex 写入，随写增。 capacity容量。
ByteBuffer属性 readIndex：下一个读位 writeIndex：下一个写位置 capacity：容量 0：缓冲区开始位置
已经读取的区域：[0,readerindex) 可读取的区域：[readerindex,writerIndex) 可写的区域: [writerIndex,capacity) 读写独立索引，操作命名区分（read/write自动进，get/set不影响索引）。 支持设定最大容量，超限写操作将抛异常，默认上限Integer.MAX_VALUE。 readerIndex writerIndex 本质为灵活高效字节容器
堆缓冲区 最常用的 ByteBuffer 模式是将数据存储在堆空间中。这种模式被称为支撑数组（backing array），它能在没有使用池化的情况下提供快速的分配和释放。可以由 hasArray() 来判断检查 ByteBuffer是否由数组支撑。如果不是，则这是一个直接缓冲区。
直接缓冲区 直接缓冲区是另外一种 ByteBuffer 模式。 直接缓冲区的主要缺点是，相对于基于堆的缓冲区，它们的分配和释放都较为昂贵。
复合缓冲区 复合缓冲区 CompositeByteBuf，它为多个 ByteBuffer提供一个聚合视图。比如 HTTP 协议， 分为消息头和消息体，这两部分可能由应用程序的不同模块产生，各有各的 ByteBuffer，将会在消息被发送的时候组装为一个 ByteBuffer，此时可以将这两个 ByteBuffer聚合为一个 CompositeByteBuf，然后使用统一和通用的 ByteBuffer API 来操作。
如何在的程序中获得 ByteBuf 的实例，并使用它呢？Netty 提供了两种方式
ByteBufAllocator 接口 ByteBufAllocator 分配任意类型的 ByteBuffer 实例。
buffer(): 基于堆/直接内存ByteBuffer。 heapBuffer(): 仅堆内存。 directBuffer(): 仅直接内存。 compositeBuffer(): 可组合多个缓冲区，支持堆/直接内存。 ioBuffer(): 适配I/O操作，优先直接内存(需Unsafe支持)。 ByteBufAllocator： Channel ChannelHandlerContext</description></item><item><title> .NET FileUpload</title><link>https://qfsyso.github.io/posts/.net-fileupload/</link><pubDate>Mon, 20 May 2024 21:14:38 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-fileupload/</guid><description>VS2022 .NET8
💾基础上传示例 view
@{ ViewData[&amp;#34;Title&amp;#34;] = &amp;#34;File Upload&amp;#34;; } &amp;lt;h1&amp;gt;@ViewData[&amp;#34;Title&amp;#34;]&amp;lt;/h1&amp;gt; &amp;lt;form method=&amp;#34;post&amp;#34; enctype=&amp;#34;multipart/form-data&amp;#34; action=&amp;#34;/Home/UploadFile&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;form-group&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;file&amp;#34; name=&amp;#34;file&amp;#34; class=&amp;#34;form-control&amp;#34; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;button type=&amp;#34;submit&amp;#34; class=&amp;#34;btn btn-primary&amp;#34;&amp;gt;Upload&amp;lt;/button&amp;gt; &amp;lt;/form&amp;gt; controller
[HttpPost] public async Task&amp;lt;IActionResult&amp;gt; UploadFile() { var file = Request.Form.Files[0]; if (file != null &amp;amp;&amp;amp; file.Length &amp;gt; 0) { var uploads = Path.Combine(Directory.GetCurrentDirectory(), &amp;#34;wwwroot&amp;#34;, &amp;#34;up&amp;#34;); if (!Directory.Exists(uploads)) { Directory.CreateDirectory(uploads); } var filePath = Path.Combine(uploads, file.FileName); using (var fileStream = new FileStream(filePath, FileMode.</description></item><item><title>c# run nodejs</title><link>https://qfsyso.github.io/posts/c%23-run-nodejs/</link><pubDate>Mon, 20 May 2024 21:13:27 +0000</pubDate><guid>https://qfsyso.github.io/posts/c%23-run-nodejs/</guid><description>在C#中调用Node.js时，一种常见的方法是使用进程间通信（Inter-Process Communication，IPC），例如使用子进程。 可以使用C#中的Process类来启动Node.js进程，并通过标准输入输出与其进行通信。
C# run nodejs // n.js // 监听来自标准输入的消息 process.stdin.on(&amp;#39;data&amp;#39;, function (data) { // 收到消息后，在控制台输出并回复消息 console.log(&amp;#34;Message from C#: &amp;#34; + data.toString()); process.stdout.write(&amp;#34;Hello from Node.js!&amp;#34;); }); ProcessStartInfo startInfo = new ProcessStartInfo(); startInfo.FileName = &amp;#34;node&amp;#34;; // Node.js可执行文件路径，如果已在系统路径中，则不需要提供完整路径 startInfo.Arguments = &amp;#34;n.js&amp;#34;; // 执行的Node.js脚本文件路径 startInfo.UseShellExecute = false; startInfo.RedirectStandardInput = true; startInfo.RedirectStandardOutput = true; Process nodeProcess = new Process(); nodeProcess.StartInfo = startInfo; // 启动进程 nodeProcess.Start(); // 与Node.js进程进行通信 using (var writer = nodeProcess.StandardInput) { if (writer.</description></item><item><title>.NET Blazor</title><link>https://qfsyso.github.io/posts/.net-blazor/</link><pubDate>Sat, 18 May 2024 23:10:13 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-blazor/</guid><description>Blazor 是一个使用 C#、HTML 和 CSS 构建交互式 Web UI 的开源框架，支持服务器端和客户端运行，允许开发者利用 C# 和 .NET 生态来创建 Web 应用。
🌱Create carete Blazor Web
Program.cs 是启动服务器以及在其中配置应用服务和中间件的应用的入口点。 在 Components 目录中:
App.razor 为应用的根组件。 Routes.razor 配置 Blazor 路由器。 Pages 目录包含应用的一些示例网页。 BlazorApp.csproj 定义应用项目及其依赖项，且可以通过双击解决方案资源管理器中的 BlazorApp 项目节点进行查看。 Properties 目录中的 launchSettings.json 文件为本地开发环境定义不同的配置文件设置。创建项目时会自动分配端口号并将其保存在此文件上。
🪴Run pages home.razor
@page &amp;#34;/&amp;#34; &amp;lt;PageTitle&amp;gt;Home&amp;lt;/PageTitle&amp;gt; &amp;lt;h1&amp;gt;Hello, world m qqqqq&amp;lt;/h1&amp;gt; hihihi 🌴Counter counter.razor
@page &amp;#34;/counter&amp;#34; @rendermode InteractiveServer &amp;lt;PageTitle&amp;gt;Counter&amp;lt;/PageTitle&amp;gt; &amp;lt;h1&amp;gt;Counter&amp;lt;/h1&amp;gt; &amp;lt;p role=&amp;#34;status&amp;#34;&amp;gt;Current count: @currentCount&amp;lt;/p&amp;gt; &amp;lt;button class=&amp;#34;btn btn-primary&amp;#34; @onclick=&amp;#34;IncrementCount&amp;#34;&amp;gt;Click me&amp;lt;/button&amp;gt; @code { private int currentCount = 0; private void IncrementCount() { currentCount++; } } 像Vue</description></item><item><title>.NET RabbitMQ NOTE</title><link>https://qfsyso.github.io/posts/.net-rabbitmq-note/</link><pubDate>Sat, 18 May 2024 23:05:20 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-rabbitmq-note/</guid><description>setup rabbitmq docker run &amp;ndash;name=rabbit -p 15672:15672 -p 5672:5672 -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=xxx -d rabbitmq:management
ip:15672
nuget RabbitMQ.Client
Send
//1.1.实例化连接工厂 var factory = new ConnectionFactory() { HostName = &amp;#34;localhost&amp;#34; }; //2. 建立连接 using (var connection = factory.CreateConnection()) { //3. 创建信道 using (var channel = connection.CreateModel()) { //4. 申明队列 channel.QueueDeclare(queue: &amp;#34;hello&amp;#34;, durable: false, exclusive: false, autoDelete: false, arguments: null); //5. 构建byte消息数据包 string message = args.Length &amp;gt; 0 ? args[0] : &amp;#34;Hello RabbitMQ!</description></item><item><title>.NET AES DES</title><link>https://qfsyso.github.io/posts/.net-aes-des/</link><pubDate>Wed, 15 May 2024 15:01:42 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-aes-des/</guid><description>.NET AES DES 对称加密
ASE 加密解密 加密方法 (Encrypt):
创建一个 Aes 实例。 设置密钥 (Key) 和初始化向量 (IV)。 使用 CreateEncryptor 创建加密器。 通过 CryptoStream 和 StreamWriter 将明文写入内存流，然后转换为 Base64 字符串。
解密方法 (Decrypt):
同样创建一个 Aes 实例。 设置相同的密钥和初始化向量。 使用 CreateDecryptor 创建解密器。 通过 CryptoStream 和 StreamReader 从内存流读取密文并解密为明文。
注意事项 密钥长度：AES 支持 128, 192, 和 256 位密钥。本例使用 256 位（32 字节）。 初始化向量 (IV)：应确保加密和解密时使用相同的 IV。本例中使用了全零的 IV，在实际应用中建议使用随机 IV，并将其与密文一起存储。
using System; using System.IO; using System.Security.Cryptography; using System.Text; class SymmetricEncryption { // 加密方法 public static string Encrypt(string plainText, string key) { using (Aes aesAlg = Aes.</description></item><item><title>.NET webp</title><link>https://qfsyso.github.io/posts/.net-webp/</link><pubDate>Fri, 10 May 2024 09:28:17 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-webp/</guid><description>在C#中，可以使用Image类和Bitmap类来处理图像，并且可以借助Magick.NET库来将JPG图片转换为WEBP格式。
安装Magick.NET-Q8-AnyCPU NuGet包。
using ImageMagick; 转换方法
public void ConvertJpgToWebP2(string inputFilePath, string outputFilePath) { using (var image = new MagickImage(inputFilePath)) { // 设置WEBP压缩质量，范围从0（最好的质量）到100（最快速压缩） image.Quality = 80; image.Format = MagickFormat.WebP; image.Write(outputFilePath); } } 调用
string jpgPath = &amp;#34;E:\\net8test\\ConsoleApp1Test\\ConsoleApp1Test\\bin\\Debug\\net8.0\\55.jpg&amp;#34;; string webpPath = &amp;#34;E:\\net8test\\ConsoleApp1Test\\ConsoleApp1Test\\bin\\Debug\\net8.0\\55.webp&amp;#34;; Ig ig = new Ig(); ig.ConvertJpgToWebP2(jpgPath, webpPath);</description></item><item><title>.NET native AOT</title><link>https://qfsyso.github.io/posts/.net-native-aot/</link><pubDate>Wed, 08 May 2024 13:01:11 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-native-aot/</guid><description>前言 .NET8对于性能的优化是方方面面的，所以AOT预编译机器码也是不例外的。本篇来看下对于AOT的优化。
概述 首先要明确一个概念，.NET里面的AOT它是原生的。什么意思呢？也就是说通过ILC编译器(AOT编译器，编译出来的代码是各个平台上可以直接运行的二进制代码。比如MacOS的二进制，Linux二进制等等。所以称之为原生。
C#源码被ILC编译之后，生成了一个完全原生态代码的可执行文件。在执行的时候不需要JIT来编译任何东西，因为JIT已经在ILC里面被充分利用过了。实际上AOT里面也没有包含JIT。那么它如何优化呢？只能是在ILC里面调用JIT的时候了。所以它这个优化依然依靠JIT。.NET8里面优化AOT的一个典型的例子，就是ASP.NET应用程序在使用AOT的时候表现不错，同时也降低了总成本。
创建项目 启用AOT
打包指令 dotnet publish DemoAot.csproj -o pub\ -c Release -r win-x64 linux下 先安装SDK 安装后
dotnet --list-sdks dotnet publish DemoAot.csproj -o $PWD/pub -c Release -r linux-x64 macos下 安装SDK后
dotnet --list-sdks dotnet publish DemoAot.csproj -o $PWD/pub -c Release -r osx-x64 重启服务器 通过命令 cd fser 及sudo nohup /root/fser/fileserver &amp;gt; output{当前时间}.log 2&amp;gt;&amp;amp;1 &amp;amp; 和命令 cd nets4 及sudo nohup dotnet /root/nets4/IM.dll &amp;gt; output{当前时间}.log 2&amp;gt;&amp;amp;1 &amp;amp; 自动化运行
为了自动化运行这些程序启动命令，可以编写一个 Shell 脚本并结合系统启动服务（如 systemd）来执行。 以下是具体实现步骤：</description></item><item><title> .NET netty proto</title><link>https://qfsyso.github.io/posts/.net-netty-proto/</link><pubDate>Fri, 03 May 2024 02:09:32 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-netty-proto/</guid><description>DotNetty是微软的Azure团队，使用C#实现的Netty的版本发布。不但使用了C#和.Net平台的技术特点，并且保留了Netty原来绝大部分的编程接口。让我们在使用时，完全可以依照Netty官方的教程来学习和使用DotNetty应用程序。
Netty 是一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。
优点 关注点分离——业务和网络逻辑解耦； 模块化和可复用性； 可测试性作为首要的要求 历史 阻塞Socket通信特点：
建立连接要阻塞线程，读取数据要阻塞线程 如果要管理多个客户端，就需要为每个客户端建立不同的线程 会有大量的线程在休眠状态，等待接收数据，资源浪费 每个线程都要占用系统资源 线程的切换很耗费系统资源 非阻塞Socket（NIO）特点： 每个Socket如果需要读写操作，都通过事件通知的方式通知选择器，这样就实现了一个线程管理多个Socket的目的。 ​
选择器甚至可以在所有的Socket空闲的时候允许线程先去干别的事情 减少了线程数量导致的资源占用，减少了线程切换导致的资源消耗
Protobuf wakeng</description></item><item><title>.NET 检测地址/主机/域名是否正常</title><link>https://qfsyso.github.io/posts/.net-%E6%A3%80%E6%B5%8B%E5%9C%B0%E5%9D%80/%E4%B8%BB%E6%9C%BA/%E5%9F%9F%E5%90%8D%E6%98%AF%E5%90%A6%E6%AD%A3%E5%B8%B8/</link><pubDate>Sun, 28 Apr 2024 19:09:40 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-%E6%A3%80%E6%B5%8B%E5%9C%B0%E5%9D%80/%E4%B8%BB%E6%9C%BA/%E5%9F%9F%E5%90%8D%E6%98%AF%E5%90%A6%E6%AD%A3%E5%B8%B8/</guid><description>🌱PING 地址/主机名/域名
/// &amp;lt;summary&amp;gt; /// PING /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;ip&amp;#34;&amp;gt;ip&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt; public static bool PingIp(string ip) { System.Net.NetworkInformation.Ping p = new System.Net.NetworkInformation.Ping(); System.Net.NetworkInformation.PingOptions options = new System.Net.NetworkInformation.PingOptions(); options.DontFragment = true; string data = &amp;#34;Test Data!&amp;#34;; byte[] buffer = Encoding.ASCII.GetBytes(data); int timeout = 2000; // Timeout System.Net.NetworkInformation.PingReply reply = p.Send(ip, timeout, buffer, options); if (reply.Status == System.Net.NetworkInformation.IPStatus.Success) { // AddToConvo(ip + reply.Status); return true; } else { // AddToConvo(ip + reply.</description></item><item><title>.NET Avalonia Linux</title><link>https://qfsyso.github.io/posts/.net-avalonia-linux/</link><pubDate>Sat, 27 Apr 2024 00:07:15 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-avalonia-linux/</guid><description>环境WIN10 VS2022 debian
👻前言 Avalonia 是一个用于创建跨平台用户界面 (UI) 的开源框架。它是一个基于 .NET 平台的框架，允许开发者使用 XAML 和 C#（F#）来构建跨平台的应用程序。Avalonia 的目标是提供与 Windows Presentation Foundation (WPF) 类似的开发体验，但能够在 Windows、macOS 和 Linux 等多个平台上运行。
使用 Avalonia，开发者可以创建各种类型的应用程序，包括桌面应用、移动应用和嵌入式应用。一些可以通过 Avalonia 实现的功能和应用包括：
桌面应用程序：如办公软件、IDE、游戏客户端等。
移动应用程序：通过 Avalonia 可以构建支持多个平台的移动应用，如 Windows、macOS 和 Linux 上的移动应用。
跨平台工具：Avalonia 可以用于构建跨平台的开发工具、实用工具等。
游戏开发：Avalonia 也可以用于构建游戏的用户界面，适合基于 .NET 平台的游戏开发。
Avalonia 提供了一个强大的工具集，使开发者能够创建具有各种功能和样式的跨平台应用程序。
💻安装Avalonia 选择管理拓展，点击下载，安装
​
​
📦创建项目 ​
​
​
编码&amp;hellip;
📚在win下运行 ​
查看linux内核
uname -a
​
🔑打包发布 复制到linux
授予权限
📻在linux下运行 迁移Socket发布到linux ​
​
实现win linux web 基于socket实时聊天</description></item><item><title> .NET 反编译</title><link>https://qfsyso.github.io/posts/.net-%E5%8F%8D%E7%BC%96%E8%AF%91/</link><pubDate>Sun, 21 Apr 2024 06:14:22 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-%E5%8F%8D%E7%BC%96%E8%AF%91/</guid><description>反编译是对程序进行逆向分析、研究，以推导出软件产品所使用的思路、原理、结构、算法、处理过程、运行方法等设计要素。
反编译.NET程序需要使用专门的反编译工具
🧿使用dotPeek进行反编译 1.下载dotPeek dotPeek：JetBrains 出品的免费 .NET 反编译器与程序集浏览器
​
2.File &amp;gt; Open
​
3.打开需要反编译的文件方法
​
🧝‍♂️使用ILSpy进行反编译 下载并安装 ILSpy：https://github.com/icsharpcode/ILSpy/releases 2.文件-打开-exe
​
3.查看反编译内容
找到Form1 可以看到里面反编译的内容
​
复制到vs里面
替换代码添加相关引用即可
🤖使用Reflector进行反编译 1.File &amp;gt; Open Assembly
​ ​
2.点开WinTime.exe内容
​
3.查看反编译内容
可以看到反编译出来的控件和方法 ​
点开方法，可以看到方法内的内容
注意：
反编译的代码可能不完全等同于原始源代码，因为编译器可能会进行优化，并且某些信息可能因为混淆技术而无法恢复。</description></item><item><title> .NET SMTP</title><link>https://qfsyso.github.io/posts/.net-smtp/</link><pubDate>Sat, 20 Apr 2024 21:13:11 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-smtp/</guid><description>SMTP（Simple Mail Transfer Protocol）是用于电子邮件传输的规则集，可以从邮件客户端向接收电子邮件服务器发送、中继或转发邮件。发件人可使用SMTP 服务器来执行发送电子邮件的过程。SMTP服务器则是按照这些规则中转电子邮件的服务器。
IMAP可以理解为收邮件。 ​
🐧使用QQ邮箱发邮件 首先需要设置开启邮箱的SMTP服务
登录(https://mail.qq.com/)电脑网页版邮箱进入【设置】-&amp;gt;【帐户】-&amp;gt;【POP3/IMAP/SMTP服务】， 开启或关闭相应服务最后保存更改即可。 ​
QQ邮箱 POP3 和 SMTP 服务器地址设置如下：
邮箱 POP3服务器（端口995） SMTP服务器（端口465或587） qq.com pop.qq.com smtp.qq.com SMTP服务器需要身份验证。
以下是示例代码：
using ConsoleApp1Test; //xxx string server = &amp;#34;smtp.qq.com&amp;#34;; string username = &amp;#34;my test email&amp;#34;; string password = &amp;#34;xxx; string from = &amp;#34;from@qq.com&amp;#34;; string to = &amp;#34;to@qq.com&amp;#34;; string subject = &amp;#34;Test Email&amp;#34;; string content = &amp;#34;This is a test email sent asynchronously.&amp;#34;; bool isHtml = false; // 是否为 HTML 格式 try { bool success = await MailHelper.</description></item><item><title>Socket to WebSocket</title><link>https://qfsyso.github.io/posts/socket-to-websocket/</link><pubDate>Sat, 20 Apr 2024 12:56:50 +0000</pubDate><guid>https://qfsyso.github.io/posts/socket-to-websocket/</guid><description>前言 针对IOS App Proxy Server无法直连WebSocket，建立 Socket中转端。
​
WebSocket 端：
WebSocket 端用于实现实时通信功能。
WebSocket 端通过 WebSocket 协议与中转端通信，中转端可以通过 WebSocket 或其他传输协议与 WebSocket 端建立连接，收发消息。
定义 SendMessageToChatRoomIP 和 JoinChatRoom，用于处理来自客户端的消息和连接事件。
中转端 C1 （Socket Server）：
中转端 C1 是一个独立的应用程序，用于连接WebSocket端，建立Socket服务。
中转端 C1 的主要功能是接收来自客户端 C2 的消息，并将其转发给 WebSocket 端，或者接收来自 WebSocket 端的消息，并转发给客户端 C2。
客户端 C2 x N ：
客户端 C2 ，主要与中转端连接 发送数据，接收数据。
在客户端 C2 中，连接到中转端 C1、发送消息给中转端 C1、接收来自中转端 C1 的消息。
调用关系为：
客户端 C2 通过与中转端 C1 的通信，向 WebSocket 端发送消息或接收来自 WebSocket 端的消息。
中转端 C1 接收来自客户端 C2 的消息，并将其转发给 WebSocket 端，或者接收来自 WebSocket 端的消息，并转发给客户端 C2。</description></item><item><title>.NET JWT</title><link>https://qfsyso.github.io/posts/.net-jwt/</link><pubDate>Fri, 19 Apr 2024 01:26:35 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-jwt/</guid><description>前言
JWT (JSON Web Token) 是一种安全传输信息的开放标准，由Header、Payload和Signature三部分组成。它主要用于身份验证、信息交换和授权。JWT可验证用户身份，确保访问权限，实现单点登录，并在客户端和服务器之间安全地交换信息。因其简单、安全和便捷，JWT在现代Web应用中广泛使用。
用JWT有多个原因：
无状态的身份验证：JWT允许服务器无需保存用户的会话信息，因为所有必要的信息都存储在令牌本身中。这降低了服务器的存储需求，并提高了系统的可扩展性。
跨域身份验证：由于JWT是自我包含的，并且可以被轻松传递，因此它非常适合跨域身份验证。用户可以在一个服务上验证身份，然后使用相同的令牌访问另一个服务，从而实现单点登录（SSO）。
安全性：JWT可以通过使用强大的加密算法（如HS256, RS256等）进行签名，以确保其完整性和真实性。服务器可以使用公钥验证令牌的签名，从而确保它没有被篡改，并且确实是由受信任的颁发者签发的。
减少数据库查询：由于用户的身份信息都存储在JWT中，服务器无需每次都去数据库中查询用户的身份信息，从而减少了数据库的压力和查询时间。
可定制性：JWT的Payload部分可以包含自定义的信息，如用户角色、权限等，这使得JWT非常灵活，并可以根据具体需求进行定制。
易于分发和共享：JWT可以轻松地通过网络传输，并且可以在多个服务和客户端之间共享，这使得它在微服务架构和分布式系统中非常有用。
标准化和互操作性：JWT是一个开放标准（RFC 7519），这意味着不同的系统和语言都可以使用相同的方式生成和验证JWT，从而提高了系统的互操作性。
环境 Win10 VS2022 .NET8
✨ 建立项目jwttest 1.创建TestJwtController ​
2.下载JWT ​
3.建实体类 /// &amp;lt;summary&amp;gt; /// 用户信息类 /// &amp;lt;/summary&amp;gt; public class LoginRs { /// &amp;lt;summary&amp;gt; /// 用户ID /// &amp;lt;/summary&amp;gt; public string UserId { get; set; } /// &amp;lt;summary&amp;gt; /// 用户密码 /// &amp;lt;/summary&amp;gt; public string PasswordMD5 { get; set; } } /// &amp;lt;summary&amp;gt; /// 用户登录信息类 /// &amp;lt;/summary&amp;gt; public class LoginInfo { /// &amp;lt;summary&amp;gt; /// 用户信息 /// &amp;lt;/summary&amp;gt; public string UserId { get; set; } /// &amp;lt;summary&amp;gt; /// 检验时间 /// &amp;lt;/summary&amp;gt; public DateTime Expires { get; set; } } /// &amp;lt;summary&amp;gt; /// rsmodel /// &amp;lt;/summary&amp;gt; public class RsModel { /// &amp;lt;summary&amp;gt; /// 是否成功 /// &amp;lt;/summary&amp;gt; public bool isOk { get; set; } /// &amp;lt;summary&amp;gt; /// 返回值 /// &amp;lt;/summary&amp;gt; public int code { get; set; } /// &amp;lt;summary&amp;gt; /// 返回消息 /// &amp;lt;/summary&amp;gt; public string msg { get; set; } /// &amp;lt;summary&amp;gt; /// 返回数据 /// &amp;lt;/summary&amp;gt; public object rsData { get; set; } } 4.</description></item><item><title>.NET spider</title><link>https://qfsyso.github.io/posts/.net-spider/</link><pubDate>Thu, 18 Apr 2024 12:59:30 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-spider/</guid><description>前言 爬虫可以用于外汇，期货，基金，货币，比分，电商，文章等信息的采集。通过数据分析，竞品分析，为商业决策提供数据支持。
​ 金价暴涨，抓取下今日的金价。
💡使用HttpClient爬取数据 try { // 创建HttpClient实例 using (var httpClient = new HttpClient()) { //模拟User-Agent httpClient.DefaultRequestHeaders.Add(&amp;#34;User-Agent&amp;#34;, GetUserAgent()); // 发送GET请求并获取响应 xxx.com是某网站的页面~（保护） var response = await httpClient.GetAsync(&amp;#34;https://xxx.com&amp;#34;); response.EnsureSuccessStatusCode(); var htmlContent = await response.Content.ReadAsStringAsync(); } } catch (HttpRequestException ex) { // 处理请求异常 ViewBag.Error = &amp;#34;Failed to retrieve price data: &amp;#34; + ex.Message; } 🚀模拟User-Agent // 生成随机 User-Agent private string GetUserAgent() { string[] userAgents = new string[] { &amp;#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.</description></item><item><title>.NET i18n</title><link>https://qfsyso.github.io/posts/.net-i18n/</link><pubDate>Tue, 16 Apr 2024 01:29:17 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-i18n/</guid><description>环境 WIN10 VS2022 .NET8
👋创建项目 ​
👀创建Resources Controllers HomeController.en.resx
​ HomeController.fr.resx
​ HomeController.zh.resx
​
🌱Program.cs添加国际化支持 // 添加国际化支持 builder.Services.AddLocalization(options =&amp;gt; { options.ResourcesPath = &amp;#34;Resources&amp;#34;; }); var app = builder.Build(); // 多语言 var supportedCultures = new List&amp;lt;CultureInfo&amp;gt; { new CultureInfo(&amp;#34;en&amp;#34;), new CultureInfo(&amp;#34;zh&amp;#34;), new CultureInfo(&amp;#34;fr&amp;#34;), }; app.UseRequestLocalization(new RequestLocalizationOptions { DefaultRequestCulture = new RequestCulture(&amp;#34;zh&amp;#34;), SupportedCultures = supportedCultures, SupportedUICultures = supportedCultures }); ⚡注入localizer private readonly IStringLocalizer&amp;lt;HomeController&amp;gt; localizer; public HomeController(ILogger&amp;lt;HomeController&amp;gt; logger, IStringLocalizer&amp;lt;HomeController&amp;gt; localizer) { _logger = logger; this.</description></item><item><title>.NET SignalR Redis</title><link>https://qfsyso.github.io/posts/.net-signalr-redis/</link><pubDate>Fri, 12 Apr 2024 07:44:04 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-signalr-redis/</guid><description>环境 Win10 VS2022 .NET8 Docker Redis
前言
什么是 SignalR？ ASP.NET Core SignalR 是一个开放源代码库，可用于简化向应用添加实时 Web 功能。 实时 Web 功能使服务器端代码能够将内容推送到客户端。
适合 SignalR 的候选项：
需要从服务器进行高频率更新的应用。 （游戏、社交网络、投票、拍卖、地图和 GPS 应用） 仪表板和监视应用。 （公司仪表板、即时销售更新或出行警报） 协作应用。 （包括白板应用和团队会议软件） 需要通知的应用。（ 社交网络、电子邮件、聊天、游戏等） SignalR 提供用于创建服务器到客户端的远程过程调用 (RPC) API。 RPC 从服务器端 .NET Core 代码调用客户端上的函数。支持JavaScript ，.NET ，JAVA，Swift （官方没有明确支持，这是第三方库）其中每个平台都有各自的客户端 SDK。 因此，RPC 调用所调用的编程语言有所不同。
ASP.NET Core SignalR 的一些功能：
自动处理连接管理。 同时向所有连接的客户端发送消息。 例如聊天室。 向特定客户端或客户端组发送消息。 对其进行缩放，以处理不断增加的流量。 SignalR 中心协议 1.👋nuget引入SignalR ​​ ​
2.👀创建SignalR Hub
using Microsoft.AspNetCore.SignalR; using System.Threading.Tasks; namespace WebSignalR { public class ChatHub : Hub { public async Task SendMessage(string user, string message) { await Clients.</description></item><item><title>.NET Swagger</title><link>https://qfsyso.github.io/posts/.net-swagger/</link><pubDate>Thu, 11 Apr 2024 23:27:19 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-swagger/</guid><description>开发环境 Win10 VS2022 .NET8.0
1.从NuGet添加Swagger ​
在解决方案资源管理器中右键单击项目&amp;gt;管理 NuGet 包 将包源设置为“nuget.org” 确保启用“包括预发行”选项 在搜索框中输入“Swashbuckle.AspNetCore” 从“浏览”选项卡中选择最新的“Swashbuckle.AspNetCore”包，然后单击“安装”
2.将 Swagger 生成器添加到以下位置的服务集合中Program.cs： builder.Services.AddControllers(); builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); ​
启用中间件 生成
app.UseSwagger(); app.UseSwaggerUI(); app.UseSwaggerUI(options =&amp;gt; { options.SwaggerEndpoint(&amp;#34;/swagger/v1/swagger.json&amp;#34;, &amp;#34;v1&amp;#34;); options.RoutePrefix = string.Empty; }); ​
3.添加API控制器 创建api
// GET api/&amp;lt;myapi&amp;gt;/5 /// &amp;lt;summary&amp;gt; /// getid /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;id&amp;#34;&amp;gt;id参数&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;valuestr&amp;lt;/returns&amp;gt; [HttpGet(&amp;#34;{id}&amp;#34;)] public string Get(int id) { return &amp;#34;value&amp;#34; + id; } // POST api/&amp;lt;myapi&amp;gt; [HttpPost] public string Post([FromBody] string value) { //post逻辑代码 return &amp;#34;myPost&amp;#34;; } // PUT api/&amp;lt;myapi&amp;gt;/5 [HttpPut(&amp;#34;{id}&amp;#34;)] public string Put(int id, [FromBody] string value) { //put逻辑代码 return &amp;#34;myPut&amp;#34;; } // DELETE api/&amp;lt;myapi&amp;gt;/5 [HttpDelete(&amp;#34;{id}&amp;#34;)] public string Delete(int id) { //delete逻辑代码 return &amp;#34;myDelete&amp;#34;; } ​</description></item><item><title>Hello World Hexo</title><link>https://qfsyso.github.io/posts/hello-world-hexo/</link><pubDate>Wed, 20 Mar 2024 22:16:01 +0000</pubDate><guid>https://qfsyso.github.io/posts/hello-world-hexo/</guid><description>Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.
Quick Start Create a new post npm install hexo-cli -g hexo init blog cd blog npm install hexo server $ hexo new &amp;#34;My New Post&amp;#34; More info: Writing
Run server $ hexo server More info: Server</description></item></channel></rss>