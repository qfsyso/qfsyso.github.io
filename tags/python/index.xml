<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Python on MLOG</title><link>https://qfsyso.github.io/tags/python/</link><description>Recent content in Python on MLOG</description><generator>Hugo -- 0.126.3</generator><language>zh-CN</language><lastBuildDate>Tue, 02 Sep 2025 22:59:44 +0800</lastBuildDate><atom:link href="https://qfsyso.github.io/tags/python/index.xml" rel="self" type="application/rss+xml"/><item><title>3XUI Clash</title><link>https://qfsyso.github.io/posts/3xui-clash/</link><pubDate>Tue, 02 Sep 2025 22:59:44 +0800</pubDate><guid>https://qfsyso.github.io/posts/3xui-clash/</guid><description>3x-ui 准备服务器
系统推荐：Debian 11+/Ubuntu 20.04+
确保服务器安全组已放行常用端口（80/443/自定义端口）。
安装 3x-ui bash &amp;lt;(curl -Ls https://raw.githubusercontent.com/MHSanaei/3x-ui/master/install.sh) 安装过程中会提示：
设置面板端口（默认 54321）
设置登录用户名与密码
启动与管理 # 启动 systemctl start x-ui # 停止 systemctl stop x-ui # 重启 systemctl restart x-ui # 查看状态 systemctl status x-ui 访问面板 在浏览器中打开：
http://服务器IP:面板端口
输入用户名和密码登录。
HTTPS 证书配置（推荐） 3x-ui 自带 ACME，可以直接申请免费证书：
确保域名已经解析到服务器 IP。
在面板 → 设置 → 证书管理 → 申请证书。
添加节点用户 登录面板后，可以添加 VLESS、VMess、Trojan 等协议的用户。
面板会生成二维码和连接信息，方便客户端（比如 v2rayN、Clash）导入。
常见问题 面板打不开：检查防火墙/安全组是否放行端口。
证书申请失败：确认域名已解析，且 80/443 端口未被占用。
更改面板端口：
x-ui 在交互菜单里修改端口/用户密码。
sockt5 入站列表</description></item><item><title>Docker Bakup</title><link>https://qfsyso.github.io/posts/docker-bakup/</link><pubDate>Fri, 29 Aug 2025 00:37:18 +0800</pubDate><guid>https://qfsyso.github.io/posts/docker-bakup/</guid><description>Dcoker Bakup 导出时生成 .tar + _config.json，记录容器端口、卷挂载和环境变量。
导入时自动读取配置文件，本地导入或远程导入都能恢复原容器配置。
支持本地导入：无需输入服务器信息。
支持远程导入：传输 .tar 和 .json 到服务器，并在服务器上启动容器。
Code python3 -m venv myenv source myenv/bin/activate import os import json import subprocess import paramiko def list_containers(): result = subprocess.run([&amp;#34;docker&amp;#34;, &amp;#34;ps&amp;#34;, &amp;#34;--format&amp;#34;, &amp;#34;{{.Names}}&amp;#34;], capture_output=True, text=True) containers = result.stdout.strip().split(&amp;#34;\n&amp;#34;) return containers def inspect_container(name): result = subprocess.run([&amp;#34;docker&amp;#34;, &amp;#34;inspect&amp;#34;, name], capture_output=True, text=True) info = json.loads(result.stdout)[0] ports = info[&amp;#39;HostConfig&amp;#39;][&amp;#39;PortBindings&amp;#39;] volumes = info[&amp;#39;Mounts&amp;#39;] envs = info[&amp;#39;Config&amp;#39;][&amp;#39;Env&amp;#39;] return ports, volumes, envs def export_container(name, image_name): subprocess.</description></item><item><title>Notifier</title><link>https://qfsyso.github.io/posts/notifier/</link><pubDate>Sat, 23 Aug 2025 01:40:45 +0800</pubDate><guid>https://qfsyso.github.io/posts/notifier/</guid><description>Python 系统通知
from plyer import notification notification.notify( title=&amp;#34;提醒&amp;#34;, message=&amp;#34;这是一个跨平台通知&amp;#34;, app_name=&amp;#34;我的程序&amp;#34;, timeout=5 # 秒 ) pip install plyer Node npm install node-notifier const notifier = require(&amp;#39;node-notifier&amp;#39;); // 发送一个通知 notifier.notify({ title: &amp;#39;提醒&amp;#39;, message: &amp;#39;任务已完成！&amp;#39;, sound: true, // 有些平台支持声音 wait: false // 是否等待用户操作 }); const notifier = require(&amp;#39;node-notifier&amp;#39;); const path = require(&amp;#39;path&amp;#39;); notifier.notify( { title: &amp;#39;My awesome title&amp;#39;, message: &amp;#39;Hello from node, Mr. User!&amp;#39;, icon: path.join(__dirname, &amp;#39;coulson.jpg&amp;#39;), // Absolute path (doesn&amp;#39;t work on balloons) sound: true, // Only Notification Center or Windows Toasters wait: true // Wait with callback, until user action is taken against notification, does not apply to Windows Toasters as they always wait or notify-send as it does not support the wait option }, function (err, response, metadata) { // Response is response from notification // Metadata contains activationType, activationAt, deliveredAt } ); notifier.</description></item><item><title>Python Stop WinUpdate</title><link>https://qfsyso.github.io/posts/python-stop-winupdate/</link><pubDate>Sat, 23 Aug 2025 01:12:53 +0800</pubDate><guid>https://qfsyso.github.io/posts/python-stop-winupdate/</guid><description>python 禁用win自动更新
Windows KB5063878更新 可能在大量数据写入后硬盘故障 https://www.neowin.net/news/report-microsofts-latest-windows-11-24h2-update-breaks-ssdshdds-may-corrupt-your-data/
禁用win更新 import winreg import subprocess REG_PATH = r&amp;#34;SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate\AU&amp;#34; REG_NAME = &amp;#34;NoAutoUpdate&amp;#34; def get_update_status(): &amp;#34;&amp;#34;&amp;#34;获取 Windows 自动更新状态&amp;#34;&amp;#34;&amp;#34; try: reg_key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, REG_PATH, 0, winreg.KEY_READ) value, _ = winreg.QueryValueEx(reg_key, REG_NAME) winreg.CloseKey(reg_key) if value == 1: return &amp;#34;Windows 自动更新已禁用 (注册表控制)&amp;#34; else: return &amp;#34;Windows 自动更新已启用 (注册表控制)&amp;#34; except FileNotFoundError: return &amp;#34;未设置策略，使用系统默认 (通常为启用自动更新)&amp;#34; def disable_windows_update(): &amp;#34;&amp;#34;&amp;#34;禁用 Windows 自动更新&amp;#34;&amp;#34;&amp;#34; try: reg_key = winreg.CreateKey(winreg.HKEY_LOCAL_MACHINE, REG_PATH) winreg.SetValueEx(reg_key, REG_NAME, 0, winreg.REG_DWORD, 1) winreg.CloseKey(reg_key) refresh_group_policy() return &amp;#34;已禁用 Windows 自动更新 (注册表方式)&amp;#34; except Exception as e: return f&amp;#34;禁用失败: {e}&amp;#34; def enable_windows_update(): &amp;#34;&amp;#34;&amp;#34;启用 Windows 自动更新&amp;#34;&amp;#34;&amp;#34; try: reg_key = winreg.</description></item><item><title>WAV STT</title><link>https://qfsyso.github.io/posts/wav-stt/</link><pubDate>Sat, 09 Aug 2025 02:24:24 +0800</pubDate><guid>https://qfsyso.github.io/posts/wav-stt/</guid><description>WAV STT Python Flask 框架
SQLite 做存储
支持批量上传音频文件
后端调用开源 STT 库
支持音频回放和文本搜索
/app ├── app.py # Flask 后端 ├── templates/ │ └── index.html # 前端页面 ├── static/ │ └── audio/ # 上传音频存储目录（Docker 内） ├── requirements.txt # 依赖 ├── Dockerfile └── stt_utils.py # STT 相关工具函数 后端核心功能 /：首页，返回上传页面
/upload：接受多文件上传，保存音频，调用 STT 转文本，保存结果进 SQLite
/audio/：提供音频文件访问，前端可回放
/search：文本搜索接口，返回匹配记录
SQLite 数据库保存：字段 id, filename, upload_time, transcript
Docker requirements.txt
flask whisper openai-whisper Code app.py
import os import sqlite3 from datetime import datetime from flask import Flask, request, render_template, send_from_directory, jsonify import whisper app = Flask(**name**) app.</description></item><item><title>Multi-room Intercom System , ALSA Flask GStreamer</title><link>https://qfsyso.github.io/posts/multi-room-intercom-system-alsa-flask-gstreamer/</link><pubDate>Sat, 02 Aug 2025 23:16:55 +0800</pubDate><guid>https://qfsyso.github.io/posts/multi-room-intercom-system-alsa-flask-gstreamer/</guid><description>多房间对话系统 实现多线程/多输入/多输出
依赖 sudo apt update sudo apt install python3-pip python3-gi gstreamer1.0-tools \ gstreamer1.0-plugins-base gstreamer1.0-plugins-good gstreamer1.0-plugins-bad \ alsa-utils # 新建环境 python3 -m venv myenv # 激活 source myenv/bin/activate pip3 install flask gi err sudo apt update sudo apt install python3-gi python3-gi-cairo gir1.2-gstreamer-1.0 gir1.2-gst-plugins-base-1.0 sudo apt update sudo apt install gstreamer1.0-tools gstreamer1.0-plugins-base \ gstreamer1.0-plugins-good gstreamer1.0-plugins-bad \ python3-gi gir1.2-gst-plugins-base-1.0 sudo apt install \ gstreamer1.0-plugins-base \ gstreamer1.0-plugins-good \ gstreamer1.0-plugins-bad \ gstreamer1.0-plugins-ugly \ gstreamer1.0-alsa \ gstreamer1.</description></item><item><title>Python Audio</title><link>https://qfsyso.github.io/posts/python-audio/</link><pubDate>Thu, 31 Jul 2025 23:57:43 +0800</pubDate><guid>https://qfsyso.github.io/posts/python-audio/</guid><description>Python Audio 依赖：pyaudio（底层调用 PortAudio），安装命令
pip install pyaudio recorder.py
#!/usr/bin/env python3 &amp;#34;&amp;#34;&amp;#34; 极简录音器 运行：python recorder.py 按提示输入文件名、采样率、通道数、位深、录音时长即可 &amp;#34;&amp;#34;&amp;#34; import pyaudio import wave import sys def record_to_wav(out_file: str, sample_rate: int = 16_000, channels: int = 1, chunk: int = 1_024, record_seconds: int = 5, sample_width: int = 2): &amp;#34;&amp;#34;&amp;#34; 将麦克风输入保存为 WAV 文件 :param out_file: 输出文件名，如 demo.wav :param sample_rate: 采样率（Hz） :param channels: 声道数（1=单声道 2=立体声） :param chunk: 每次读取的帧数 :param record_seconds: 录音时长（秒） :param sample_width: 位深（字节数，2=16bit） &amp;#34;&amp;#34;&amp;#34; p = pyaudio.</description></item><item><title>Clipboard</title><link>https://qfsyso.github.io/posts/clipboard/</link><pubDate>Sat, 26 Jul 2025 20:48:31 +0800</pubDate><guid>https://qfsyso.github.io/posts/clipboard/</guid><description>共享粘贴板 可以在一个设备输入文字，生成一个链接，其他设备在同一局域网内用链接访问可获取文字
用 Python (Flask) + 对称加密 (Fernet) 来实现
📂 项目结构 lan-clipboard/
├── app.py
├── requirements.txt
└── Dockerfile
requirements.txt flask cryptography app.py from flask import Flask, request, redirect, url_for, render_template_string, abort from cryptography.fernet import Fernet import os app = Flask(__name__) # 生成或从环境变量读取密钥 FERNET_KEY = os.environ.get(&amp;#34;FERNET_KEY&amp;#34;) or Fernet.generate_key().decode() fernet = Fernet(FERNET_KEY.encode()) # 简单内存存储 (可替换为文件或数据库) storage = {} # 简单页面模板 FORM_HTML = &amp;#34;&amp;#34;&amp;#34; &amp;lt;!doctype html&amp;gt; &amp;lt;title&amp;gt;LAN Clipboard&amp;lt;/title&amp;gt; &amp;lt;h1&amp;gt;LAN Clipboard&amp;lt;/h1&amp;gt; &amp;lt;form action=&amp;#34;/share&amp;#34; method=&amp;#34;post&amp;#34;&amp;gt; &amp;lt;textarea name=&amp;#34;text&amp;#34; rows=&amp;#34;10&amp;#34; cols=&amp;#34;50&amp;#34; placeholder=&amp;#34;输入文字.</description></item><item><title>Vosk STT</title><link>https://qfsyso.github.io/posts/vosk-stt/</link><pubDate>Thu, 17 Jul 2025 21:36:01 +0800</pubDate><guid>https://qfsyso.github.io/posts/vosk-stt/</guid><description>Vosk STT 一、准备环境（Debian） sudo apt update sudo apt install -y python3 python3-pip ffmpeg pip3 install --user vosk 二、下载微型中文模型（≈ 40 MB） wget https://alphacephei.com/vosk/models/vosk-model-small-cn-0.22.zip unzip vosk-model-small-cn-0.22.zip 三、保存以下脚本为 listen.py #!/usr/bin/env python3 import sys, json, os from vosk import Model, KaldiRecognizer import wave MAP = { &amp;#34;空调&amp;#34;: 1, &amp;#34;电视&amp;#34;: 2, &amp;#34;风扇&amp;#34;: 3, &amp;#34;卧室灯&amp;#34;: 4, &amp;#34;客厅灯&amp;#34;: 5 } def wav2text(path): wf = wave.open(path, &amp;#34;rb&amp;#34;) if wf.getnchannels() != 1 or wf.getsampwidth() != 2 or wf.getframerate() != 16000: raise ValueError(&amp;#34;音频必须是 16 kHz 16-bit 单声道 WAV&amp;#34;) model = Model(&amp;#34;vosk-model-small-cn-0.</description></item><item><title>python whoisdomain</title><link>https://qfsyso.github.io/posts/python-whoisdomain/</link><pubDate>Thu, 21 Nov 2024 23:31:52 +0000</pubDate><guid>https://qfsyso.github.io/posts/python-whoisdomain/</guid><description>pip install python-whois import whois # 读取文件中的域名 def read_domains_from_file(file_path): with open(file_path, &amp;#39;r&amp;#39;) as file: domains = [line.strip() for line in file if line.strip()] return domains # 查询域名的WHOIS信息 def query_whois(domain): try: domain_info = whois.whois(domain) if domain_info.domain_name: return domain_info else: return None except Exception as e: print(f&amp;#34;Error querying WHOIS for {domain}: {e}&amp;#34;) return None # 保存查询结果到文件 def save_results_to_file(domains, results, output_file): with open(output_file, &amp;#39;w&amp;#39;) as file: for domain, result in results.items(): if result: file.</description></item><item><title>Docker mssql</title><link>https://qfsyso.github.io/posts/docker-mssql/</link><pubDate>Sun, 18 Aug 2024 11:08:56 +0000</pubDate><guid>https://qfsyso.github.io/posts/docker-mssql/</guid><description>创建容器 docker run -e &amp;#34;ACCEPT_EULA=Y&amp;#34; -e &amp;#34;MSSQL_SA_PASSWORD=Admin@123&amp;#34; -p 1433:1433 --name sql1 --hostname sql1 -d mcr.microsoft.com/mssql/server:2017-latest 进入 ```bash sudo docker exec -it sql1 &amp;ldquo;bash&amp;rdquo;
/opt/mssql-tools/bin/sqlcmd -S localhost -U SA -P &amp;ldquo;Admin@123&amp;rdquo;
```sql CREATE DATABASE TestDB; go SELECT Name from sys.databases; go use TestDB; go; CREATE TABLE Employees ( EmployeeID INT PRIMARY KEY, FirstName NVARCHAR(50), LastName NVARCHAR(50), BirthDate DATE, Position NVARCHAR(50) ); INSERT INTO Employees (EmployeeID, FirstName, LastName, BirthDate, Position) VALUES (1, &amp;#39;z&amp;#39;, &amp;#39;s&amp;#39;, &amp;#39;2000-01-01&amp;#39;, &amp;#39;Software Developer&amp;#39;); INSERT INTO Employees (EmployeeID, FirstName, LastName, BirthDate, Position) VALUES (2, &amp;#39;l&amp;#39;, &amp;#39;s&amp;#39;, &amp;#39;2001-01-15&amp;#39;, &amp;#39;Project Manager&amp;#39;); INSERT INTO Employees (FirstName, LastName, BirthDate, Position) VALUES ( &amp;#39;l1&amp;#39;, &amp;#39;s&amp;#39;, &amp;#39;2001-01-15&amp;#39;, &amp;#39;Project Manager&amp;#39;); SELECT * FROM Employees; py测试 pip install pyodbc import pyodbc # 配置数据库连接信息 server = &amp;#39;localhost&amp;#39; database = &amp;#39;TestDB&amp;#39; username = &amp;#39;SA&amp;#39; password = &amp;#39;Admin@123&amp;#39; driver = &amp;#39;{ODBC Driver 17 for SQL Server}&amp;#39; # 根据你的SQL Server版本选择合适的驱动 # 建立连接 connection_string = f&amp;#34;DRIVER={driver};SERVER={server};DATABASE={database};UID={username};PWD={password}&amp;#34; conn = pyodbc.</description></item><item><title>Azure AI Document Intelligence</title><link>https://qfsyso.github.io/posts/azure-ai-document-intelligence/</link><pubDate>Fri, 07 Jun 2024 23:06:10 +0000</pubDate><guid>https://qfsyso.github.io/posts/azure-ai-document-intelligence/</guid><description>创建智能文档处理解决方案 在第二级中，这3个模块，每一个中都有不同的任务操作，这些操作包括使用 Azure 进行实际创建服务操作或者使用代码调用 Azure的服务，这些代码可以使用python或者C#，这些进行选择。所有的模块内的考试是通过一个邮件的方式进行告知。
https://learn.microsoft.com/en-us/credentials/applied-skills/create-intelligent-document-solution-azure-ai/#applied-skill-take-the-assessment
start
登陆实验环境 加载成功后会出现虚拟机器登陆界面，找到右侧的 Step1 中的用户名密码。登陆 获取实验账号并登陆 Azure 进入到机器后，点击桌面的 Email 图片，打开我们的实验目标。 打开桌面的 email 后，会出现如下的界面。这里主要关注两点： 一个是左侧蓝色的部分：Inbox，这里包括环境信息以及实验目标考题。 另一个是浏览器的页签中的第二个，也就是登陆 Azure 的环境网址
点击上图的 Azure 标签页，进入登陆页面，用email提供的账号密码登陆
试验一： Create a prototype 点击邮件中的 Create a prototype 菜单会出现具体的内容要求。
在第一个实验中主要是使用微软的只能存储服务，并且创建的时候要符合要求，这个服务要满足的要求是要保存所给的文件成Json文件，之后在保存到 Azure 的存储服务中。
实验流程操作 首先到 Azure 中，搜索所给出的资源组，选择 RG1开头的资源组 进入到资源组后，点击创建按钮。 在搜索框中输入document intelligence 点击选择。 点击 文档智能服务
进入到服务后，点击蓝色的创建按钮。 在这里直接选择默认的订阅以及资源组，Region 目前建议选择 Japan East（如果后面的步骤，在运行分析文档时，遇到权限不足问题，请在此步骤选择其他 Region ）
在这里名字填入：from-document-xxx，如（from-document-01）价格层要选择免费层，也就是下图中的 Free F0，之后点击预览创建按钮。
预览没有问题后，直接点击创建按钮。 创建完毕后，在页面中点击 Go to resource 按钮
之后点击 Go to Document Intelligence Studio 按钮 进入到服务页面后，下滑页面，点击 Invoices 的 Try it out。</description></item><item><title>Azure OpenAI Build Natural Language</title><link>https://qfsyso.github.io/posts/azure-openai-build-natural-language/</link><pubDate>Fri, 07 Jun 2024 01:03:12 +0000</pubDate><guid>https://qfsyso.github.io/posts/azure-openai-build-natural-language/</guid><description>https://learn.microsoft.com/en-us/credentials/applied-skills/build-natural-language-solution-azure-ai/#applied-skill-take-the-assessment?ocid=reactor
start 进入环境中，点击Step 1，然后点击Password右边的T，登录环境 双击打开桌面的Email文件 对Inbox的内容进行逐个点击，其中Existing Environment包含了微软官方提供的Azure的用户名和密码，proof of concept、Invoice validation、chatbot backend 分别表示的是本次考试的三大任务的具体要求 将邮箱中Existing Environment的用户名和密码依次复制到Azure的标签页面中，并点击Sign in完成Azure的登录
试验一： Proof of Concept (POC) 点击邮件中的 Proof of Concept (POC) 菜单会出现具体的内容要求，如下图所示。
在第一个实验中主要是使用微软的 language 服务，并且创建的时候要符合要求，这个服务要满足客户自定义文本标准和 NER。 在实验中另外一个要求是需要使用代码最后调用这个你创建服务。 流程操作 首先在登录主页面搜索栏 搜索RG1，并点击Resource Groups下面的RG1 进入后点击 Create 按钮 之后在首页内搜索language service 点击进入到 Language service 后，点击 Create 之后点击右下方的第二个 select 按钮 选择好之后，点击下方的按钮 continue to create your resource
在配置页面，按照我们的题目要求，在 Region 中选择 North Europe， 其中 Name 从邮件中找，在 Proof of concept 这里 lang开头的这个名字，作为刚才创建资源的 Name 值 主要需要注意的是在 Pricing tier层里，需要选择 Free F0 的这个，这一点也是题目要求的。 下面选择 Existing storege account ，在存储账户这里，需要选择题目要求的以sa开头的这个账户。</description></item><item><title>Azure AI Develop Generative AI solutions</title><link>https://qfsyso.github.io/posts/azure-ai-develop-generative-ai-solutions/</link><pubDate>Thu, 06 Jun 2024 00:18:03 +0000</pubDate><guid>https://qfsyso.github.io/posts/azure-ai-develop-generative-ai-solutions/</guid><description>Start https://learn.microsoft.com/en-us/credentials/applied-skills/develop-generative-ai-solutions-with-azure-openai-service/#applied-skill-take-the-assessment
部署Azure OpenAI 服务 ​
点击Step 1，然后点击Password右边的T ​
鼠标双击Email ​ 对Inbox的内容进行逐个点击，其中Existing Environment包含了微软官方提供的Azure的用户名和密码，Validate proof of concept、Company chatbot、Developer tasks和Use company data分别表示的是本次考试的四大任务的具体要求
切换到Azure登录的标签页
​ 将邮箱中Existing Environment的用户名和密码依次复制到Azure的标签页面中，并点击Sign in完成Azure的登录
然后在浏览器中输入URL：https://portal.azure.com/#home，点击Azure AI services
​ 其中Resource group、Pricing tier勾选下拉列表的存在项，Name可自行填入(如azureservice)，然后点击Next ​
网络中选择第一项：All networks，然后点击页面左下方的Next Tags可直接点击左下方的Next 然后在Review+submit页面点击Create ​ 等待几十秒后，deployment完成后，点击Deployment details 点击Resource中的名称，如azureservice ​ 点击Endpoints右边的Click here to view endpoints ​ ​
点击Key 1右侧的复制按钮，复制其到C:\files\AzureOpenAIPoc\Python.env中的AZURE_OAI_KEY变量中。 点击Endpoint右侧的复制按钮，分别复制任意一个 KEY 和 EndPoint 到C:\files\AzureOpenAIPoc\Python.env中的AZURE_OAI_KEY 和 AZURE_OAI_ENDPOINT。 然后在浏览器中输入https://portal.azure.com/#home，并点击Name下的名称 点击Go to Azure OpenAI Studio
然后点击Create new deployment
按照下图中的内容进行下拉选择或者填写，其中Select a model勾选为gpt-35-turbo-16k，Deployment name可自定义填写，如gpt_deploy，将Tokens per Minute Rate Limit设置为5K，Enable Dynamic Quota设置为Disabled，最后点击Create： 确保Status为Succeed，则说明部署成功了 将C:\files\AzureOpenAIPoc\Python.</description></item><item><title>Python study</title><link>https://qfsyso.github.io/posts/python-study/</link><pubDate>Sun, 26 May 2024 23:02:42 +0000</pubDate><guid>https://qfsyso.github.io/posts/python-study/</guid><description>🌠setup 安装 python.org
🐷helloworld if __name__ == &amp;#39;__main__&amp;#39;: print(&amp;#39;helloworld&amp;#39;) python test.py var 变量
if __name__ == &amp;#39;__main__&amp;#39;: company, date, *others = [&amp;#39;hi&amp;#39;, &amp;#39;20240521&amp;#39;, &amp;#39;000&amp;#39;, &amp;#39;11111&amp;#39;] print(company, date) print(others) random 随机
i = 0 rand_list = [] while i &amp;lt; 4: rand_num = random.randint(0, 499) if rand_num not in rand_list: rand_list.append(rand_num) i += 1 print(rand_list) list 列表 可变
# 创建一个空列表 my_list = [] # 向列表中添加元素 my_list.append(1) my_list.append(2) my_list.append(3) print(my_list) # 输出: [1, 2, 3] # 修改列表中的元素 my_list[1] = &amp;#39;two&amp;#39; print(my_list) # 输出: [1, &amp;#39;two&amp;#39;, 3] # 列表切片 sub_list = my_list[1:3] print(sub_list) # 输出: [&amp;#39;two&amp;#39;, 3] # 删除列表中的元素 del my_list[2] print(my_list) # 输出: [1, &amp;#39;two&amp;#39;] # 创建一个包含0到9的偶数列表 even_numbers = [i for i in range(10) if i % 2 == 0] print(even_numbers) # 输出: [0, 2, 4, 6, 8] tuple 元组 不可变</description></item></channel></rss>