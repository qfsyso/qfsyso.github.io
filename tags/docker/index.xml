<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Docker on MLOG</title><link>https://qfsyso.github.io/tags/docker/</link><description>Recent content in Docker on MLOG</description><generator>Hugo -- 0.126.3</generator><language>zh-CN</language><lastBuildDate>Fri, 29 Aug 2025 00:37:18 +0800</lastBuildDate><atom:link href="https://qfsyso.github.io/tags/docker/index.xml" rel="self" type="application/rss+xml"/><item><title>Docker Bakup</title><link>https://qfsyso.github.io/posts/docker-bakup/</link><pubDate>Fri, 29 Aug 2025 00:37:18 +0800</pubDate><guid>https://qfsyso.github.io/posts/docker-bakup/</guid><description>Dcoker Bakup 导出时生成 .tar + _config.json，记录容器端口、卷挂载和环境变量。
导入时自动读取配置文件，本地导入或远程导入都能恢复原容器配置。
支持本地导入：无需输入服务器信息。
支持远程导入：传输 .tar 和 .json 到服务器，并在服务器上启动容器。
Code python3 -m venv myenv source myenv/bin/activate import os import json import subprocess import paramiko def list_containers(): result = subprocess.run([&amp;#34;docker&amp;#34;, &amp;#34;ps&amp;#34;, &amp;#34;--format&amp;#34;, &amp;#34;{{.Names}}&amp;#34;], capture_output=True, text=True) containers = result.stdout.strip().split(&amp;#34;\n&amp;#34;) return containers def inspect_container(name): result = subprocess.run([&amp;#34;docker&amp;#34;, &amp;#34;inspect&amp;#34;, name], capture_output=True, text=True) info = json.loads(result.stdout)[0] ports = info[&amp;#39;HostConfig&amp;#39;][&amp;#39;PortBindings&amp;#39;] volumes = info[&amp;#39;Mounts&amp;#39;] envs = info[&amp;#39;Config&amp;#39;][&amp;#39;Env&amp;#39;] return ports, volumes, envs def export_container(name, image_name): subprocess.</description></item><item><title>Node TG FileBot</title><link>https://qfsyso.github.io/posts/node-tg-filebot/</link><pubDate>Tue, 26 Aug 2025 22:51:47 +0800</pubDate><guid>https://qfsyso.github.io/posts/node-tg-filebot/</guid><description>Node.js TG 文件管理机器人，支持分类存储、分页浏览、搜索、下载、删除文件，同时支持图片缩略图预览和服务器本地下载。
功能 文件分类管理：支持用户自定义分类。
文件上传自动保存：支持文档、图片、视频，并记录上传用户和分类。
分页查看文件列表：可分页显示最近上传的文件。
图片缩略图：在分页列表中显示图片缩略图。
文件搜索：按文件名关键字搜索文件。
获取文件：支持发送文件回 Telegram。
删除文件：支持单个文件删除，带确认机制。
下载到本地：将文件下载到服务器本地，支持重试和错误提示。
命令： /start # 欢迎信息和操作提示 /setcategory # 设置文件分类 /myfiles # 查看最近 10 条文件 /myfilelist [页码] # 分页显示文件列表 /search 关键字 # 搜索文件 /getfile id # 获取文件到 Telegram /delete id # 删除文件
按钮操作： 分类选择：在 /setcategory 后点击按钮设置分类。
删除文件：点击“删除”按钮，带确认操作。
下载文件：点击“下载本地”按钮，将文件下载到服务器本地。
分页：点击上一页/下一页翻页。
文件存储 默认本地存储目录：./files/分类名/文件名
支持自动创建分类目录。
图片会在分页列表显示缩略图。
错误处理和日志
文件下载支持 3 次重试，失败会输出控制台日志。
用户端收到友好提示，不会导致 bot 崩掉。
依赖 node-telegram-bot-api sqlite3 axios Node.js &amp;gt;= 16 项目目录结构 bot.js # 主程序 db.</description></item><item><title>Go File Manager</title><link>https://qfsyso.github.io/posts/go-file-manager/</link><pubDate>Sat, 23 Aug 2025 01:42:55 +0800</pubDate><guid>https://qfsyso.github.io/posts/go-file-manager/</guid><description>Go-React 文件存储管理 📋 项目概述 这是一个完整的文件存储管理系统，采用 Go 后端 + React 前端的现代化架构。系统提供了用户认证、文件管理、共享功能和管理员控制等核心功能。
🏗 系统架构 ┌─────────────────┐ HTTP API ┌─────────────────┐ │ React 前端 │ ◄──────────── │ Go 后端 │ │ │ │ │ │ - 用户界面 │ │ - RESTful API │ │ - 状态管理 │ │ - 文件处理 │ │ - 路由控制 │ │ - 用户认证 │ └─────────────────┘ └─────────────────┘ │ ▼ ┌─────────────────┐ │ 文件系统 │ │ │ │ - 文件存储 │ │ - 元数据管理 │ │ - 用户数据 │ └─────────────────┘ 🔧 技术栈 后端 (Go) 语言: Go 1.</description></item><item><title>Node Crawler</title><link>https://qfsyso.github.io/posts/node-crawler/</link><pubDate>Fri, 22 Aug 2025 22:09:55 +0800</pubDate><guid>https://qfsyso.github.io/posts/node-crawler/</guid><description>Node.js Puppeteer 基于 Node.js + Puppeteer 的自动化帖子采集系统，专门用于采集资产版块的帖子信息。
核心代码
//app.js const express = require(&amp;#39;express&amp;#39;); const cors = require(&amp;#39;cors&amp;#39;); const helmet = require(&amp;#39;helmet&amp;#39;); const path = require(&amp;#39;path&amp;#39;); const logger = require(&amp;#39;./utils/logger&amp;#39;); const CrawlerService = require(&amp;#39;./services/CrawlerService&amp;#39;); const SchedulerService = require(&amp;#39;./services/SchedulerService&amp;#39;); const PostController = require(&amp;#39;./controllers/PostController&amp;#39;); class App { constructor() { this.app = express(); this.port = process.env.PORT || 3000; this.crawlerService = new CrawlerService(); this.schedulerService = new SchedulerService(this.crawlerService); this.postController = new PostController(this.crawlerService); this.initializeMiddlewares(); this.initializeRoutes(); this.initializeErrorHandling(); } initializeMiddlewares() { // 安全中间件 this.</description></item><item><title>Discourse</title><link>https://qfsyso.github.io/posts/discourse/</link><pubDate>Fri, 15 Aug 2025 23:51:34 +0800</pubDate><guid>https://qfsyso.github.io/posts/discourse/</guid><description>Discourse 是由Stack Overflow联合创始人Jeff Atwood开发的开源论坛平台，旨在革新传统论坛软件形态
注意：Discourse 官方建议至少 1GB 内存（2GB 更稳），必须有 域名，并且能解析到 的服务器公网 IP。
准备环境 的服务器需要：
系统：Ubuntu 22.04 或 Debian 11（官方推荐）
已安装 Docker + Docker Compose
# 安装 Docker curl -fsSL https://get.docker.com | sh # 安装 docker-compose sudo apt install -y docker-compose 获取 Discourse Docker 镜像 git clone https://github.com/discourse/discourse_docker.git /var/discourse cd /var/discourse 创建配置文件 运行：
sudo ./discourse-setup 它会问 几个问题：
Hostname → 的域名（例如：forum.example.com） Email → 管理员邮箱（用来接收验证邮件） SMTP server → 邮件服务器地址（Discourse 必须配置邮件才能注册用户） SMTP port → 邮件服务器端口（常用 587） SMTP user name → 邮件账号 SMTP password → 邮件密码 启动论坛 sudo .</description></item><item><title>Clipboard</title><link>https://qfsyso.github.io/posts/clipboard/</link><pubDate>Sat, 26 Jul 2025 20:48:31 +0800</pubDate><guid>https://qfsyso.github.io/posts/clipboard/</guid><description>共享粘贴板 可以在一个设备输入文字，生成一个链接，其他设备在同一局域网内用链接访问可获取文字
用 Python (Flask) + 对称加密 (Fernet) 来实现
📂 项目结构 lan-clipboard/
├── app.py
├── requirements.txt
└── Dockerfile
requirements.txt flask cryptography app.py from flask import Flask, request, redirect, url_for, render_template_string, abort from cryptography.fernet import Fernet import os app = Flask(__name__) # 生成或从环境变量读取密钥 FERNET_KEY = os.environ.get(&amp;#34;FERNET_KEY&amp;#34;) or Fernet.generate_key().decode() fernet = Fernet(FERNET_KEY.encode()) # 简单内存存储 (可替换为文件或数据库) storage = {} # 简单页面模板 FORM_HTML = &amp;#34;&amp;#34;&amp;#34; &amp;lt;!doctype html&amp;gt; &amp;lt;title&amp;gt;LAN Clipboard&amp;lt;/title&amp;gt; &amp;lt;h1&amp;gt;LAN Clipboard&amp;lt;/h1&amp;gt; &amp;lt;form action=&amp;#34;/share&amp;#34; method=&amp;#34;post&amp;#34;&amp;gt; &amp;lt;textarea name=&amp;#34;text&amp;#34; rows=&amp;#34;10&amp;#34; cols=&amp;#34;50&amp;#34; placeholder=&amp;#34;输入文字.</description></item><item><title>Snapdrop</title><link>https://qfsyso.github.io/posts/snapdrop/</link><pubDate>Fri, 23 May 2025 00:31:40 +0800</pubDate><guid>https://qfsyso.github.io/posts/snapdrop/</guid><description>Snapdrop：开源浏览器版 AirDrop 文件传输工具 Snapdrop 是一个纯浏览器实现的开源局域网文件传输工具，基于 WebRTC 和 WebSocket 技术，提供类似 Apple AirDrop 的跨平台即时文件共享体验。
🚀 Snapdrop 的优势 设备自动发现：同一局域网内自动识别设备，无需手动连接或配对。 无平台限制：只要能打开浏览器（Chrome / Safari / Edge / Firefox 等）即可使用。 匿名上传与下载：无需登录，匿名操作保障隐私。 端到端加密：基于 WebRTC 的 DTLS 和 SDES 协议，确保传输安全。 PWA 支持：可添加到手机主屏，像 App 一样快捷打开。 ⚙️ 快速使用方式 在线使用 直接访问 https://snapdrop.net 确保设备处于同一 Wi-Fi 或局域网 浏览器打开 Snapdrop 网页 选择设备 → 上传文件 → 对方点击下载即可 自托管部署（增强隐私） 方式一：手动部署 git clone https://github.com/Snapdrop/Snapdrop.git cd Snapdrop npm install npm start 访问：http://localhost:3000
方式二：使用 Docker 一键部署 docker run -d --name=snapdrop -p 80:80 -p 443:443 \ -v /path/to/config:/config \ lscr.</description></item><item><title>docker pro</title><link>https://qfsyso.github.io/posts/docker-pro/</link><pubDate>Sat, 26 Oct 2024 22:43:10 +0000</pubDate><guid>https://qfsyso.github.io/posts/docker-pro/</guid><description>docker 运行有趣的项目
Uptime Kuma 简单实用, 主要用来监控 Web 和网络 https://github.com/louislam/uptime-kuma
docker run -d --restart=always -p 3001:3001 -v uptime-kuma:/app/data --name uptime-kuma louislam/uptime-kuma:1 Portainer - 容器管理面板 Portainer 提供了一个简单易用的 Web 界面来管理和监控 Docker 容器、镜像、网络等。你可以通过下面的命令快速启动它：
docker volume create portainer_data docker run -d -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce lobechat &amp;lt;在Linux环境下，如何使用Docker部署Lobehub？
在Linux环境下使用Docker部署Lobehub（一个开源的低代码开发平台）涉及几个步骤。 Lobehub 官方并未提供一个直接的Docker镜像，但你可以通过以下步骤来手动创建并运行一个Docker容器，以使用Lobehub。
步骤 1: 安装Docker 确保你的Linux系统上已安装Docker。你可以通过运行以下命令来安装Docker：
# 对于基于Debian的系统（如Ubuntu） sudo apt-get update sudo apt-get install docker.io # 对于基于RHEL的系统（如CentOS） sudo yum install docker # 启动Docker服务 sudo systemctl start docker sudo systemctl enable docker 步骤 2: 拉取Node.</description></item><item><title>debian docker gitlab gitea</title><link>https://qfsyso.github.io/posts/debian-docker-gitlab-gitea/</link><pubDate>Tue, 15 Oct 2024 23:57:02 +0000</pubDate><guid>https://qfsyso.github.io/posts/debian-docker-gitlab-gitea/</guid><description>使用docker部署私有化代码管理~
docker curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh 国内docker 更新系统包索引
sudo apt update 安装一些必要的包，以便于后续添加 apt 仓库：
sudo apt install -y apt-transport-https ca-certificates curl gnupg2 software-properties-common 添加阿里云密钥 添加 GPG 密钥是为了确保软件包的安全性和完整性，避免安装过程中的潜在问题。建议尽量执行这一步，以确保安装过程顺利进行。
curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/debian/gpg | sudo apt-key add - 设置阿里云docker仓库
sudo add-apt-repository &amp;#34;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/debian $(lsb_release -cs) stable&amp;#34; 再次更新下系统包的索引
sudo apt update 安装docker
sudo apt install -y docker-ce 启动并设置docker的开机自启动
sudo systemctl start docker sudo systemctl enable docker 查看下docker是否安装成功
sudo docker version 最后配置docker的镜像加速推荐阿里云的网址 https://cr.</description></item><item><title> docker oracle</title><link>https://qfsyso.github.io/posts/docker-oracle/</link><pubDate>Sat, 21 Sep 2024 01:27:39 +0000</pubDate><guid>https://qfsyso.github.io/posts/docker-oracle/</guid><description>使用Docker容器安装Oracle数据库
安装Docker sudo apt-get update sudo apt-get install docker.io 下载镜像 docker pull registry.cn-hangzhou.aliyuncs.com/zhuyijun/oracle:19c 创建文件 mkdir -p /home/data/oracle/oradata 授权，不授权会导致后面安装失败 chmod 777 /home/data/oracle/oradata docker run -d -p 1521:1521 -p 5500:5500 -e ORACLE_SID=ORCLCDB -e ORACLE_PDB=ORCLPDB -e ORACLE_PWD=123456 -e ORACLE_EDITION=standard -e ORACLE_CHARACTERSET=AL32UTF8 -v /home/data/oracle/oradata:/opt/oracle/oradata --name oracle registry.cn-hangzhou.aliyuncs.com/zhuyijun/oracle:19c 进入
docker exec -it oracle-db bash -c &amp;#34;source /home/oracle/.bashrc; sqlplus /nolog&amp;#34; SQL&amp;gt; CONNECT sys as sysdba@your_password SQL&amp;gt; ALTER USER sys IDENTIFIED BY your_password; SQL&amp;gt; CREATE USER your_username IDENTIFIED BY your_password; SQL&amp;gt; GRANT CONNECT, RESOURCE TO your_username; CREATE TABLE test_table ( id NUMBER, name VARCHAR2(50) ); INSERT INTO test_table (id, name) VALUES (1, &amp;#39;Test Name&amp;#39;); COMMIT; SELECT * FROM test_table; CONNECT / AS SYSDBA; 以 SYSDBA 角色连接到数据库。 使用 SYSDBA 角色登录，该角色具有最高级别的数据库权限，允许进行系统级别的管理任务。</description></item><item><title>Docker mssql</title><link>https://qfsyso.github.io/posts/docker-mssql/</link><pubDate>Sun, 18 Aug 2024 11:08:56 +0000</pubDate><guid>https://qfsyso.github.io/posts/docker-mssql/</guid><description>创建容器 docker run -e &amp;#34;ACCEPT_EULA=Y&amp;#34; -e &amp;#34;MSSQL_SA_PASSWORD=Admin@123&amp;#34; -p 1433:1433 --name sql1 --hostname sql1 -d mcr.microsoft.com/mssql/server:2017-latest 进入 ```bash sudo docker exec -it sql1 &amp;ldquo;bash&amp;rdquo;
/opt/mssql-tools/bin/sqlcmd -S localhost -U SA -P &amp;ldquo;Admin@123&amp;rdquo;
```sql CREATE DATABASE TestDB; go SELECT Name from sys.databases; go use TestDB; go; CREATE TABLE Employees ( EmployeeID INT PRIMARY KEY, FirstName NVARCHAR(50), LastName NVARCHAR(50), BirthDate DATE, Position NVARCHAR(50) ); INSERT INTO Employees (EmployeeID, FirstName, LastName, BirthDate, Position) VALUES (1, &amp;#39;z&amp;#39;, &amp;#39;s&amp;#39;, &amp;#39;2000-01-01&amp;#39;, &amp;#39;Software Developer&amp;#39;); INSERT INTO Employees (EmployeeID, FirstName, LastName, BirthDate, Position) VALUES (2, &amp;#39;l&amp;#39;, &amp;#39;s&amp;#39;, &amp;#39;2001-01-15&amp;#39;, &amp;#39;Project Manager&amp;#39;); INSERT INTO Employees (FirstName, LastName, BirthDate, Position) VALUES ( &amp;#39;l1&amp;#39;, &amp;#39;s&amp;#39;, &amp;#39;2001-01-15&amp;#39;, &amp;#39;Project Manager&amp;#39;); SELECT * FROM Employees; py测试 pip install pyodbc import pyodbc # 配置数据库连接信息 server = &amp;#39;localhost&amp;#39; database = &amp;#39;TestDB&amp;#39; username = &amp;#39;SA&amp;#39; password = &amp;#39;Admin@123&amp;#39; driver = &amp;#39;{ODBC Driver 17 for SQL Server}&amp;#39; # 根据你的SQL Server版本选择合适的驱动 # 建立连接 connection_string = f&amp;#34;DRIVER={driver};SERVER={server};DATABASE={database};UID={username};PWD={password}&amp;#34; conn = pyodbc.</description></item><item><title>docker postgresql</title><link>https://qfsyso.github.io/posts/docker-postgresql/</link><pubDate>Wed, 14 Aug 2024 23:02:46 +0000</pubDate><guid>https://qfsyso.github.io/posts/docker-postgresql/</guid><description>创建容器 docker run -id --name=postgresql -v postgre-data:/var/lib/postgresql/data -p 5432:5432 -e POSTGRES_PASSWORD=123456 -e LANG=C.UTF-8 postgres 进入 docker exec -it my-postgres psql -U postgres SELECT version(); create database test_db; CREATE TABLE test_table ( id SERIAL PRIMARY KEY, name VARCHAR(50) NOT NULL, age INTEGER ); INSERT INTO test_table (name, age) VALUES (&amp;#39;m&amp;#39;, 30); SELECT * FROM test_table; nodejs测试 // 引入 &amp;#39;pg&amp;#39; 模块 const { Client } = require(&amp;#39;pg&amp;#39;); // 设置数据库连接参数 const client = new Client({ user: &amp;#39;postgres&amp;#39;, host: &amp;#39;localhost&amp;#39;, database: &amp;#39;test_db&amp;#39;, password: &amp;#39;123456&amp;#39;, port: 5432, }); // 连接到数据库 client.</description></item><item><title>docker ittools</title><link>https://qfsyso.github.io/posts/docker-ittools/</link><pubDate>Wed, 07 Aug 2024 22:24:52 +0000</pubDate><guid>https://qfsyso.github.io/posts/docker-ittools/</guid><description>ittools https://github.com/CorentinTh/it-tools/tree/main
pnpm https://www.pnpm.cn/installation#%E4%BD%BF%E7%94%A8-npm-%E5%AE%89%E8%A3%85
Project Setup pnpm install Compile and Hot-Reload for Development pnpm dev Type-Check, Compile and Minify for Production pnpm build Run Unit Tests with Vitest pnpm test Lint with ESLint pnpm lint Create a new tool To create a new tool, there is a script that generate the boilerplate of the new tool, simply run:
pnpm run script:create:tool my-tool-name docker run docker run -d --name it-tools --restart unless-stopped -p 8080:80 corentinth/it-tools:latest</description></item><item><title>Email Server</title><link>https://qfsyso.github.io/posts/email-server/</link><pubDate>Tue, 06 Aug 2024 19:33:24 +0000</pubDate><guid>https://qfsyso.github.io/posts/email-server/</guid><description>docker docker run -d -p 25:25 -p 80:80 -p 110:110 -p 143:143 -p 443:443 -p 587:587 -p 993:993 -p 995:995 -v /etc/localtime:/etc/localtime:ro -v /data/poste/data:/data --name &amp;#34;PosteServ&amp;#34; -h &amp;#34;mx.xxxxxx.com&amp;#34; -t analogic/poste.io 解析 mx A记录 开放25 80 110 143 443 587 993 995端口
#/srv/poste/data为Poste数据存放文件夹，如用户数据库、电子邮件、日志，方便备份。
443为web控制台端口 ip端口访问 https://ip
访问 添加管理邮箱 First poste.io configuration There is no &amp;ldquo;server.ini&amp;rdquo; in your data folder, we will try create one. You can update it later in your data folder.</description></item><item><title>Debian docker mssql</title><link>https://qfsyso.github.io/posts/debian-docker-mssql/</link><pubDate>Tue, 06 Aug 2024 19:30:54 +0000</pubDate><guid>https://qfsyso.github.io/posts/debian-docker-mssql/</guid><description>docker curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh 查看架构
uname -m 安装 docker run -e &amp;#34;ACCEPT_EULA=Y&amp;#34; -e &amp;#34;SA_PASSWORD=Qq123123.&amp;#34; -e &amp;#34;TZ=Asia/Shanghai&amp;#34; -p 1433:1433 --name sqlserver2022 -d mcr.microsoft.com/mssql/server:2022-latest 开放端口 1433
进入容器
docker exec -it sqlserver2022 /bin/bash 使用navicat test sa Qq123123. 测试连接
SQL测试
CREATE DATABASE mydb; GO USE mydb; GO CREATE TABLE Users ( UserId INT PRIMARY KEY IDENTITY(1,1), UserName NVARCHAR(50) NOT NULL ); GO INSERT INTO Users (UserName) VALUES (&amp;#39;zs&amp;#39;); INSERT INTO Users (UserName) VALUES (&amp;#39;ls&amp;#39;); INSERT INTO Users (UserName) VALUES (&amp;#39;w5&amp;#39;); GO SELECT * FROM Users; GO BACKUP USE master; GO BACKUP DATABASE mydb TO DISK = &amp;#39;mydblog.</description></item><item><title> VM Linux win</title><link>https://qfsyso.github.io/posts/vm-linux-win/</link><pubDate>Mon, 24 Jun 2024 23:38:07 +0000</pubDate><guid>https://qfsyso.github.io/posts/vm-linux-win/</guid><description>debian12.5.0服务器安装 参考https://blog.csdn.net/Go_ahead_forever/article/details/132679793
相关命令问题 新用户使用sudo报错 xx is not the sudoers file. 原因：book用户没有sudo的权限 解决：https://blog.csdn.net/weixin_37787043/article/details/123045557
更新 清华-镜像源 (会快一些)： 参考文档： https://blog.csdn.net/sinat_15028281/article/details/135638596
su root cp etc/apt/sources.list etc/apt/sources.list.backup // 备份 vi etc/apt/sources.list // 修改镜像源 将etc/apt/sources.list文件内的内容清空，写入以下内容：
deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmware # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmware deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmware # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmware deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware # deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware deb https://security.</description></item><item><title> .NET Dockerhub</title><link>https://qfsyso.github.io/posts/.net-dockerhub/</link><pubDate>Sat, 01 Jun 2024 01:24:22 +0000</pubDate><guid>https://qfsyso.github.io/posts/.net-dockerhub/</guid><description>📚Dockerfile FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build WORKDIR /src COPY [&amp;#34;MyMvcApp.csproj&amp;#34;, &amp;#34;./&amp;#34;] RUN dotnet restore &amp;#34;MyMvcApp.csproj&amp;#34; COPY . . WORKDIR &amp;#34;/src/&amp;#34; RUN dotnet build &amp;#34;MyMvcApp.csproj&amp;#34; -c Release -o /app/build FROM build AS publish RUN dotnet publish &amp;#34;MyMvcApp.csproj&amp;#34; -c Release -o /app/publish FROM base AS final WORKDIR /app COPY --from=publish /app/publish . ENTRYPOINT [&amp;#34;dotnet&amp;#34;, &amp;#34;MyMvcApp.dll&amp;#34;] ✏️ Docker 镜像 docker build -t mymvcapp:latest . 📝在 Docker Hub 上创建仓库 登录 Docker Hub (https://hub.docker.com)。 点击 &amp;ldquo;Create Repository&amp;rdquo;。 输入仓库名称，例如 mymvcapp，然后点击 &amp;ldquo;Create&amp;rdquo;。</description></item><item><title>Debian Docker Redis</title><link>https://qfsyso.github.io/posts/debian-docker-redis/</link><pubDate>Fri, 12 Apr 2024 09:27:49 +0000</pubDate><guid>https://qfsyso.github.io/posts/debian-docker-redis/</guid><description>Debian安装docker
1.使用官方脚本自动安装docker 安装命令如下：
curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh 如果安装提示
-bash sudo command not found
则需要
#update sudo apt-get update sudo apt-get install sudo 再执行安装脚本1
安装成功后可以输入 docker命令查看docker版本
#version docker --version 能查到表明安装成功
2.pull redis #pull redis docker pull redis:latest pull redis镜像 3.创建reids容器 docker run -itd --name redis-test -p 6379:6379 redis 4.测试redis docker exec -it redis-test /bin/bash redis-cli set test 1 get test set test 1 提示ok
get test 一些命令</description></item><item><title>Docker MySQL</title><link>https://qfsyso.github.io/posts/docker-mysql/</link><pubDate>Thu, 11 Apr 2024 08:35:22 +0000</pubDate><guid>https://qfsyso.github.io/posts/docker-mysql/</guid><description>1.下载docker desktop https://www.docker.com/products/docker-desktop/
创建容器 docker run 创建并启动mysql容器
&amp;ndash;name 容器名字
-d 后台运行容器
-p 映射端口
-e 参数
截至目前最新的mysql是mysql8.0.36 那就整这个试下。
docker run -d --name mysql-container -e TZ=UTC -p 30306:3306 -e MYSQL_ROOT_PASSWORD=你的密码 mysql:8.0.36-debian ​
等待一会，看到mysql已经pull下来。
回到docker看到容器已经创建。
​
​
可以输入docker images查看
​
3.创建mysql数据库管理软件容器
docker run --name myadmin -d --link mysql-container:db -p 8880:80 phpmyadmin/phpmyadmin ​
回到docker查看下容器是否创建成功。 ​
复制地址到浏览器访问。 ​
​
okok
唉哟不错哦~
扩展：ubuntu版本
docker run -d --name mysql-container -e TZ=UTC -p 30306:3306 -e MYSQL_ROOT_PASSWORD=xxxxxx ubuntu/mysql:8.0-22.04_beta https://hub.docker.com/r/ubuntu/mysql?uuid=D64B1F2A-A81A-4D2C-B66B-FCFAECE77EFE</description></item></channel></rss>