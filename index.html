<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.126.3"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MLOG</title>
<meta name=description content="A simple blog "><meta name=author content="dwd"><link rel=canonical href=https://qfsyso.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://qfsyso.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://qfsyso.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://qfsyso.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://qfsyso.github.io/apple-touch-icon.png><link rel=mask-icon href=https://qfsyso.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://qfsyso.github.io/index.xml><link rel=alternate type=application/json href=https://qfsyso.github.io/index.json><link rel=alternate hreflang=en href=https://qfsyso.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://qfsyso.github.io/"><meta property="og:site_name" content="MLOG"><meta property="og:title" content="MLOG"><meta property="og:description" content="A simple blog "><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="MLOG"><meta name=twitter:description content="A simple blog "><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"MLOG","url":"https://qfsyso.github.io/","description":"A simple blog ","logo":"https://qfsyso.github.io/favicon.ico","sameAs":[]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://qfsyso.github.io/ accesskey=h title="MLOG (Alt + H)">MLOG</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://qfsyso.github.io/posts/ title=Archive><span>Archive</span></a></li><li><a href=https://qfsyso.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://qfsyso.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=first-entry><header class=entry-header><h2 class=entry-hint-parent>Clipboard</h2></header><div class=entry-content><p>共享粘贴板 • 可以在一个设备输入文字，生成一个链接 • 其他设备在同一局域网内用链接访问可获取文字
用 Python (Flask) + 对称加密 (Fernet) 来实现
📂 项目结构 lan-clipboard/ ├── app.py ├── requirements.txt └── Dockerfile
requirements.txt flask cryptography app.py from flask import Flask, request, redirect, url_for, render_template_string, abort from cryptography.fernet import Fernet import os app = Flask(__name__) # 生成或从环境变量读取密钥 FERNET_KEY = os.environ.get("FERNET_KEY") or Fernet.generate_key().decode() fernet = Fernet(FERNET_KEY.encode()) # 简单内存存储 (可替换为文件或数据库) storage = {} # 简单页面模板 FORM_HTML = """ &lt;!doctype html> &lt;title>LAN Clipboard&lt;/title> &lt;h1>LAN Clipboard&lt;/h1> &lt;form action="/share" method="post"> &lt;textarea name="text" rows="10" cols="50" placeholder="输入文字....</p></div><footer class=entry-footer><span title='2025-07-26 20:48:31 +0800 +0800'>July 26, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to Clipboard" href=https://qfsyso.github.io/posts/clipboard/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Owntone TTS To AirPlay</h2></header><div class=entry-content><p>Owntone Owntone（以前叫 forked-daapd）是一个自建音乐服务器，支持：
音乐库管理（本地音乐）， AirPlay / Chromecast / Roon / MPD 等协议， 播放列表 / 电台 / 播放控制， 通过 REST API 控制。
TTS（文本转语音） 用外部TTS 如 Google TTS ， Edge TTS， OpenAI TTS生成.wav .mp3， 放入媒体库文件夹 ，通过API刷新 添加 播放。
Owntone创建 # 确保有写权限： sudo chown -R 1000:1000 /var/cache/owntone sudo chmod -R 755 /var/cache/owntone docker run -d \ --name=OwnTone1 \ --network=host \ -e UID=1000 \ -e GID=1000 \ -v /etc/owntone:/etc/owntone \ -v /mnt/media:/srv/media \ -v /var/cache/owntone:/var/cache/owntone \ --restart unless-stopped \ owntone/owntone:latest # 停止删除 docker stop OwnTone1 && docker rm OwnTone1 # 精简版 docker run -d \ --name=OwnTone1 \ --network=host \ -v /root/owntone/config:/etc/owntone \ -v /root/owntone/media:/srv/media/ \ -v /root/owntone/cache:/var/cache/owntone \ --restart unless-stopped \ docker....</p></div><footer class=entry-footer><span title='2025-07-25 21:46:09 +0800 +0800'>July 25, 2025</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to Owntone TTS To AirPlay" href=https://qfsyso.github.io/posts/owntone-tts-to-airplay/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Chrome Extensions</h2></header><div class=entry-content><p>Chrome Extensions目录结构。 📁 L-ToDo/
├─ 📄 manifest.json
├─ 📄 popup.html
├─ 📄 popup.js
├─ 📄 background.js
├─ 📄 content.css
├─ 📄 icons/
│ ├─ 16.png
│ ├─ 48.png
│ └─ 128.png
└─ 📁 _metadata (Chrome生成)
一、manifest.json { "manifest_version": 3, "name": " L-ToDo", "description": "Minimal new-tab with quick links & to-do list", "version": "1.0", "icons": { "16": "icons/16.png", "48": "icons/48.png", "128": "icons/128.png" }, "chrome_url_overrides": { "newtab": "popup.html" }, "permissions": ["storage"], "background": { "service_worker": "background....</p></div><footer class=entry-footer><span title='2025-07-24 00:32:26 +0800 +0800'>July 24, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to Chrome Extensions" href=https://qfsyso.github.io/posts/chrome-extensions/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ICloud Download TG Bot Sync</h2></header><div class=entry-content><p>iCloudPD iCloudPD官方镜像仓库地址：https://hub.docker.com/r/icloudpd/icloudpd
iCloudPD官方仓库地址：https://github.com/icloud-photos-downloader/icloud_photos_downloader/
一、环境准备 1.1 目录结构 /root/
├── config # 存放配置文件
├── iCloud # 同步照片存储目录
1.2 关键配置说明 TZ 时区设置 Asia/Shanghai
authentication_type 认证类型 MFA(国际) 2FA(国内)
icloud_china 是否使用国内服务器 true
auth_china 是否生成国内Cookie true
二、Docker部署 2.1 国际 docker run -d \ --name icloudpd \ --restart always \ -v /root/config:/config \ -v /root/iCloud:/iCloud \ -e TZ=Asia/Shanghai \ -e apple_id=dxxr@outlook.com \ -e authentication_type='MFA' \ -e icloud_china=true \ -e auth_china=true \ -e download_path=/iCloud \ boredazfcuk/icloudpd 2.2 国内 docker run -d \ --name x2_icloudpd \ --restart always \ -v /root/config:/config \ -v /root/photos:/photos \ -e TZ=Asia/Shanghai \ -e apple_id=dxxr@outlook....</p></div><footer class=entry-footer><span title='2025-07-24 00:28:01 +0800 +0800'>July 24, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to ICloud Download TG Bot Sync" href=https://qfsyso.github.io/posts/icloud-download-tg-bot-sync/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Immich</h2></header><div class=entry-content><p>Immich Immich是一个自托管的照片和视频备份解决方案，允许用户在私有服务器上存储、管理和分享他们的媒体文件。这个项目旨在提供一个类似于Google照片或iCloud照片库的体验，但是用户可以完全控制自己的数据。通过自托管，用户不需要依赖第三方云服务提供商来存储私人照片和视频，这增加了隐私保护和数据所有权。
以下是使用 Docker 安装 Immich 的步骤（基于官方推荐方法）： 安装 Docker 和 Docker Compose（若未安装） 。
创建项目目录： mkdir ./immich-app && cd ./immich-app 下载必要文件： docker-compose.yml：
wget https://github.com/immich-app/immich/releases/latest/download/docker-compose.yml .env 文件（从 example.env 改名）：
wget -O .env https://github.com/immich-app/immich/releases/latest/download/example.env 修改 .env 文件（可选，如设置 UPLOAD_LOCATION、DB_DATA_LOCATION、TZ 等） 。
启动容器： docker compose up -d （若需升级，可运行 docker compose pull && docker compose up -d） 。
访问 Immich： 浏览器打开 http://IP地址:2283
（默认端口，可在 docker-compose.yml 中修改） 。
参考 https://immich.app/docs/install/docker-compose/ https://apps.apple.com/us/app/immich/id1613945652 https://github.com/immich-app/immich
nextcloud 网盘 https://github.com/nextcloud/server https://github.com/nextcloud/android https://apps.apple.com/us/app/nextcloud/id1125420102</p></div><footer class=entry-footer><span title='2025-07-21 23:34:25 +0800 +0800'>July 21, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to Immich" href=https://qfsyso.github.io/posts/immich/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Vosk STT</h2></header><div class=entry-content><p>Vosk STT 一、准备环境（Debian） sudo apt update sudo apt install -y python3 python3-pip ffmpeg pip3 install --user vosk 二、下载微型中文模型（≈ 40 MB） wget https://alphacephei.com/vosk/models/vosk-model-small-cn-0.22.zip unzip vosk-model-small-cn-0.22.zip 三、保存以下脚本为 listen.py #!/usr/bin/env python3 import sys, json, os from vosk import Model, KaldiRecognizer import wave MAP = { "空调": 1, "电视": 2, "风扇": 3, "卧室灯": 4, "客厅灯": 5 } def wav2text(path): wf = wave.open(path, "rb") if wf.getnchannels() != 1 or wf.getsampwidth() != 2 or wf.getframerate() != 16000: raise ValueError("音频必须是 16 kHz 16-bit 单声道 WAV") model = Model("vosk-model-small-cn-0....</p></div><footer class=entry-footer><span title='2025-07-17 21:36:01 +0800 +0800'>July 17, 2025</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to Vosk STT" href=https://qfsyso.github.io/posts/vosk-stt/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>API Signature</h2></header><div class=entry-content><p>接口签名核心知识点总结 1. ​​核心原理：验证完整性与身份​​ 接口签名（API Signature）是一种通过加密机制确保API请求的​​数据完整性​​和​​来源合法性​​的技术。客户端使用密钥（Secret Key）对请求内容生成签名，服务端用相同密钥和算法重新计算签名并比对，匹配则通过验证。
2. ​​签名生成的关键步骤​​ ​​参数排序​​：按参数名的ASCII码升序排列（如 a=1&amp;b=2&amp;c=3），确保顺序一致性。 ​​拼接字符串​​：将排序后的参数拼接为待签名字符串（如 key1=value1&amp;key2=value2）。 ​​添加密钥​​：在字符串末尾附加密钥（如 待签名字符串&amp;key=API_SECRET）。 ​​加密生成签名​​：使用算法（如HMAC-SHA256、MD5）生成签名，并附加到请求中。
3. ​​核心参数设计​​ ​​appid​​：应用标识，与密钥配对使用。 ​​timestamp​​：请求时间戳（推荐UTC时间），服务端验证是否在有效窗口内（如±5分钟）。 ​​nonce​​：唯一随机数，防止重放攻击（需服务端缓存校验）。 ​​signature​​：加密生成的签名值。
4. ​​常见问题与解决方案​​ ​​签名不一致​​： 原因：参数顺序/编码不一致、密钥错误、时间戳不同步。 解决：统一序列化规则（禁用JSON缩进）、同步UTC时间、校验密钥。 ​​重放攻击​​： 原因：nonce重复使用。 解决：服务端用缓存（如内存缓存）记录已使用的nonce。 ​​时区导致时间戳失效​​： 解决：客户端同步服务端时间（如NTP校准），或服务端放宽时间窗口。
5. ​​四大安全价值​​ ​​防伪装​​：验证请求来源（依赖密钥保密性）。 ​​防篡改​​：签名变化即提示数据被篡改。 ​​防重放​​：通过nonce和timestamp拦截重复请求。 ​​防泄露​​：敏感参数可加密传输（如结合RSA）。
6. ​​最佳实践​​ ​​算法选择​​：优先HMAC-SHA256（比MD5更安全）。 ​​密钥管理​​：避免硬编码，使用环境变量或密钥管理系统。 ​​调试工具​​： 客户端/服务端打印签名字符串对比差异。 使用在线工具（如HMAC生成器）交叉验证。
实战 实现一个API接口， 对客户端请求进行签名验证。
在C#服务端： 创建一个API控制器（如SignController），包含一个处理请求的Action（如Post）。 在Action中，按照以下步骤进行验证： a. 检查时间戳是否在有效期内（例如5分钟内）。 b. 检查nonce是否在内存缓存中存在，如果存在则拒绝（重放攻击），否则将nonce存入缓存（设置过期时间，例如5分钟）。 c. 验证配置版本号，如果和服务器最新版本一致，则返回304（NotModified）。 d. 重新计算签名，并与请求中的sign比对，如果不一致则返回401。 使用HMAC-SHA256算法计算签名，注意签名生成规则：对请求参数（除sign外）按照键名字典序排序，然后序列化为规范的JSON字符串（确保键的顺序一致），然后使用密钥进行HMAC-SHA256计算。
具体代码实现如下： C#服务端代码（.NET Core） 创建SignController 使用MemoryCache来存储nonce Node.js测试客户端代码 使用axios发送请求 使用crypto模块计算HMAC-SHA256签名 我们假设服务端的最新配置版本为"1.0.3"（为了测试，可以硬编码，实际中可能从配置文件中读取）。
错误码： 时间戳过期：401 nonce重复（重放攻击）：403 配置版本一致：304 签名不匹配：401 成功：200...</p></div><footer class=entry-footer><span title='2025-06-28 21:24:17 +0800 +0800'>June 28, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to API Signature" href=https://qfsyso.github.io/posts/api-signature/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Proxmox Virtual Environment Debian</h2></header><div class=entry-content><p>安装 Proxmox VE（PVE）前的准备
1. 下载 PVE 镜像 访问官网：https://www.proxmox.com/en/downloads
下载最新版的 Proxmox VE ISO Installer（例如：proxmox-ve_8.x.iso）
2. 制作启动U盘 使用工具制作启动盘（推荐）：
Ventoy（推荐）：支持多镜像启动，简单拖入 ISO 即可。 官网：https://www.ventoy.net/
或者使用 Rufus：
打开 Rufus，插入U盘（建议 8GB 以上）
选择 ISO 镜像
分区类型：推荐 MBR（兼容性更好）或根据你 BIOS 设置为 UEFI/GPT
点击“开始”制作启动盘
安装 PVE 设置 BIOS 启动项 插入U盘，重启电脑
在开机画面按下启动快捷键（如 F12, Esc, F2, Del，不同厂商略有不同）
选择从 U盘启动
安装 启动后选择 Install Proxmox VE
阅读并接受许可协议
选择硬盘（注意：会格式化此硬盘）
设置地区、时区和键盘布局
设置管理员密码与邮箱
设置管理 IP（如默认DHCP，建议改为静态IP以方便局域网访问）
等待安装完成
安装完成后 安装完成后，拔掉U盘并重启
启动后，系统会提示你使用浏览器访问管理界面：
https://ip-address:8006 注意：此为 https，浏览器会提示不安全连接，选择“继续前往”即可
使用建议 推荐使用 局域网静态 IP，便于访问和远程管理...</p></div><footer class=entry-footer><span title='2025-06-21 02:08:58 +0800 +0800'>June 21, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to Proxmox Virtual Environment Debian" href=https://qfsyso.github.io/posts/proxmox-virtual-environment-debian/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Kubernetes k8s</h2></header><div class=entry-content><p>Kubernetes k8s 描述什么是Kubernetes 描述Kubernetes的基本架构及核心概念 描述Kubernetes的应用编排方法 使用华为云CCE创建简单工作负载
容器编排技术 容器（如Docker）以及周边生态系统提供了很多工具来实现容器生命周期管理，能够满足在单台宿主机管理容器的需求。但越来越多企业开始使用容器，对容器技术的进一步发展提出了以下新的诉求： □高效的容器管理及编排。 □容器的跨主机部署及调度。 □容器的存储、网络、运维、安全等能力的拓展。 统一的容器编排管理工具
容器编排的价值 容器编排是指自动化容器的部署、管理、扩展和联网，可为企业带来以下价值： 灵活的资源管理及调度 自动化部署及服务发现 高效的监控及运维 弹性扩展及高可用
大规模容器集群管理工具，从Borg到Kubernetes ·Kubernetes起源于Google内部的Borg项目，它对计算资源进行了更高层次的抽象，通过将容器进行细致的组合，将最终的应用服务交给用户。它的目标是管理大规模的容器，提供基本的部署、维护以及应用伸缩等功能，其主要实现语言为Go语言。 ·Kubernetes作为容器集群管理工具，于2015年7月22日迭代到v1.0并正式对外公布。与此同时，谷歌联合Linux基金会及其他合作伙伴共同成立了CNCF基金会（CloudNativeComputingFoundation），并将Kuberentes作为首个编入CNCF管理体系的开源项目，助力容器技术生态的发展进步。
Kubernetes架构 ·一个基础的Kubernetes集群（Cluster）通常包含一个Master节点和多个Node节点。每个节点可以是一台物理机，也可以是一台虚拟机。
pod最小容器（container）
Kubernetes核心概念-Pod Pod是Kubernetes中最重要最基本的概念，Pod是Kubernetes最小工作单元。每一个Pod包含一个或多个相关容器，Kubernetes将Pod看做一个整体进行调度。 引入Pod的目的： 将联系紧密的容器封装在一个Pod单元内，以Pod整体进行调度、扩展和实现生命周期管理。 Pod内所有容器使用相同的网络Namespace和共享存储。即Pod内容器拥有相同IP地址和Port空间，容器间直接使用localhost通信。当挂载volume到Pod，即可实现将volume挂载到Pod中的每个容器。
Kubernetes核心概念-Controller ·工作负载是在Pod之上的一层抽象，我们可以通过控制器（controller）实现一系列基于Pod的高级特性，比如节点故障时Pod的自动迁移，Pod多副本横向扩展，应用滚动升级等。我们通常使用controller来做应用的真正的管理，而Pod是组成工作负载最小的单元
Kubernetes核心概念-Label ·当资源变得非常多的时候，如何分类管理就非常重要了，Kubernetes提供了一种机制来为资源分类，那就是Label（标签）。Label非常简单，但是却很强大，Kubernetes中几乎所有资源都可以用Label来组织。Label的具体形式是key-value的标记对，可以在创建资源的时候设置，也可以在后期添加和修改。
Kubernetes核心概念-Namespace ·命名空间（Namespace）是对一组资源和对象的抽象整合。在同一个集群内可创建不同的命名空间，不同命名空间中的数据彼此隔离。使得它们既可以共享同一个集群的服务，也能够互不干扰。 kube-public kube-system kube-node-lease default
Kubernetes核心概念-Service ·在Kubernetes中，Pod副本发生迁移或者伸缩的时候会发生变化，IP也是变化的。Kubernetes中的Service是一种抽象概念，它定义了一个Pod逻辑集合以及访问它们的策略。Service定义了外界访问一组特定Pod的方式。Service有自己的IP和端口，Service为Pod提供了负载均衡。
Kubernetes核心概念-Volume ·Volume用来管理Kubernetes存储，是用来声明在Pod中的容器可以访问的文件目录，含义如下： 声明在Pod中的容器可以访问的文件目录。 可以被挂载在Pod中一个或多个容器的指定路径下。 支持多种后端存储（本地存储、分布式存储、云存储等）。
Kubernetes管理-Kubectl ·Kubectl是Kubernetes的命令行工具。通过kubectl，用户能对集群进行管理，并在集群上进行容器化应用的安装部署。
Kubectl支持以下对象管理方式： 指令式：通过kubectl内置的驱动命令，如:kubectl +create/scale/delete/..+参数的形式， 直接快速创建、更新和删除Kubernetes对象。
声明式：使用kubectlapply创建指定目录中配置文件所定义的所有对象。通常，此配置文件 采用yaml进行描述。
Kubernetes管理-命令行语法 在Kubernetes中的很多操作都是用kubectl来完成，通过其命令可以管理Deployment、Replicaset、ReplicationController、Pod等，进行操作、扩容、删除等全生命周期操作，同时可以对管理对象进行查看或者监控资源使用情况。
kubectl的语法
kubectl [command] [TYPElNAME] [flags] Command：指定你希望进行的操作，如create，get，describe，delete等。 TYPE：指定操作对象的类型，如deployment，pod，service等。 hiPnNAME：指定对象的名字。hidhwyun flags:可选的标志位。
Kubernetes管理-yaml示例 ·kubernetes中的对象可以使用YAML描述（如果您对YAML格式不了解，可以参考YAML语法少，也可以使用JSON。其内容可以分为如下四个部分： typeMeta：对象类型的元信息，声明对象使用哪个API版本，哪个类型的对象。 objectMeta：对象的元信息，包括对象名称、使用的标签等。 spec：对象的期望状态，例如对象使用什么镜像、有多少副本等。 status：对象的实际状态，只能在对象创建后看到，创建对象时无需指定。...</p></div><footer class=entry-footer><span title='2025-06-06 00:54:55 +0800 +0800'>June 6, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to Kubernetes k8s" href=https://qfsyso.github.io/posts/kubernetes-k8s/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Docker DevOps</h2></header><div class=entry-content><p>云原生应用十二要素原则解析表 原则 核心价值 实现方法 技术案例 1. 基准代码 快速交付；合理划分边界 单一代码库+多环境部署，版本控制统一管理 Git仓库管理，Kubernetes多集群部署 2. 依赖 提升开发效率；排除意外风险 显式声明依赖+隔离环境（容器化） Docker镜像打包依赖，Helm Chart管理应用包 3. 配置 软件发布管理；环境无差别 配置与代码分离→环境变量注入 Kubernetes ConfigMap/Secret动态加载 4. 后端服务 弹性/敏捷；解耦状态管理 将慢速进程（如DB/队列）转为RESTful服务 Redis缓存服务，消息队列(Kafka)独立部署 5. 构建发布运行 持续交付；流水线自动化 CI/CD全流程自动化（构建→测试→部署） Jenkins/GitLab CI流水线，K8s Rolling Update 6. 进程 云兼容性；无状态设计 应用无状态化，会话数据外置后端服务 会话存储Redis，文件存储OSS 7. 端口绑定 自包含服务；独立暴露接口 服务直接监听端口，不依赖Web服务器转发 Spring Boot内嵌Tomcat，gRPC直连 8. 并发 自动弹性伸缩 水平扩展替代垂直扩展，依赖云平台弹性能力 Kubernetes HPA自动扩缩容 9. 易处理 快速故障恢复 断路器模式+优雅终止，进程可随时启停 Istio服务熔断，K8s Liveness探针 10. 环境等价 可靠性；开发与生产环境一致 容器化保证环境一致性，禁用环境特殊配置 Docker跨环境运行，开发环境Minikube 11. 日志 实时系统监控 日志作为事件流→集中式管理 EFK栈(Elasticsearch+Fluentd+Kibana) 12. 管理进程 运维效率；运营解耦 管理任务（如DB迁移）作为独立进程，与主应用隔离 K8s Job/CronJob执行批处理任务 特性 云原生应用 传统应用 可预测性 符合弹性框架，通过容器编排和微服务实现可预测行为 不可预测，批量发布易引发单点故障，扩展能力有限 操作系统依赖 抽象化（容器技术隔离OS依赖，实现跨平台运行） 强依赖（需特定OS环境，迁移困难） 资源调度 弹性伸缩（按需自动分配资源，利用率＞70%） 冗余静态（预留资源应对峰值，利用率＜40%） 团队协作 DevOps驱动（开发运维一体化，自动化流水线） 部门墙隔离（开发/测试/运维独立，沟通成本高） 开发模式 敏捷迭代（CI/CD支持每日多次部署） 瀑布模型（数月/年周期发布，变更困难） 服务架构 微服务（独立部署、高内聚低耦合） 单体架构（模块紧耦合，牵一发而动全身） 运维能力 自动化（K8s实现自愈、监控、扩缩容） 手动操作（人工监控、故障排查效率低） 故障恢复 秒级恢复（容器快速重启+服务网格流量调度） 小时级恢复（依赖备份还原，流程复杂） 云原生架构模式:微服务架构 云原生架构演进原则 01....</p></div><footer class=entry-footer><span title='2025-06-05 20:23:33 +0800 +0800'>June 5, 2025</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to Docker DevOps" href=https://qfsyso.github.io/posts/docker-devops/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://qfsyso.github.io/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><div class=wtime><div class=wtime2>CST<span id=beijingTime></span> GMT <span id=londonTime></span> EST <span id=newYorkTime></span> PST<span id=losAngelesTime></span></div><div class=wtime2 style=display:none>东京<span id=tokyoTime></span></div><div class=wtime2 style=display:none>欧洲-巴黎<span id=parisTime></span></div><div class=wtime2 style=display:none>UTC<span id=utcTime></span></div></div><span>&copy; 2025 <a href=https://qfsyso.github.io/>MLOG</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span><script type=text/javascript>const timeZoneOffsets={beijing:8,tokyo:9,paris:[1,2],london:[0,1],newYork:[-5,-4],losAngeles:[-8,-7]};function padZero(e){return e<10?"0"+e:e}function formatTime(e){const t=e.getFullYear(),n=padZero(e.getMonth()+1),s=padZero(e.getDate()),o=padZero(e.getHours()),i=padZero(e.getMinutes()),a=padZero(e.getSeconds());return`${t}-${n}-${s} ${o}:${i}:${a}`}function isDaylightSavingTime(e,t){const o=e.getMonth(),n=new Date(e.getFullYear(),3,8,2,0,0),s=new Date(e.getFullYear(),10,1,2,0,0);return(t==="paris"||t==="london"||t==="newYork"||t==="losAngeles")&&e>=n&&e<s}function updateTime(){const e=new Date,t=new Date(e.getUTCFullYear(),e.getUTCMonth(),e.getUTCDate(),e.getUTCHours(),e.getUTCMinutes(),e.getUTCSeconds()),n=formatTime(t);document.getElementById("utcTime").innerHTML=n;for(const n in timeZoneOffsets){const e=timeZoneOffsets[n];let s;Array.isArray(e)?s=isDaylightSavingTime(t,n)?e[1]:e[0]:s=e;const o=new Date(t.getTime()+s*60*60*1e3);document.getElementById(n+"Time").innerHTML=formatTime(o)}setTimeout(updateTime,1e3)}window.onload=function(){updateTime()};function notfound(e){var n=e.src,t=n.split("/"),s=t[t.length-1];e.src="https://47.115.223.75:8080/group1/v2/"+s+"?timestamp="+Date.now(),e.onerror=null}</script></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>