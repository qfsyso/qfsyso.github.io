<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.126.3"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MLOG</title>
<meta name=description content="A simple blog "><meta name=author content="dwd"><link rel=canonical href=https://qfsyso.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://qfsyso.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://qfsyso.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://qfsyso.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://qfsyso.github.io/apple-touch-icon.png><link rel=mask-icon href=https://qfsyso.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://qfsyso.github.io/index.xml><link rel=alternate type=application/json href=https://qfsyso.github.io/index.json><link rel=alternate hreflang=en href=https://qfsyso.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://qfsyso.github.io/"><meta property="og:site_name" content="MLOG"><meta property="og:title" content="MLOG"><meta property="og:description" content="A simple blog "><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="MLOG"><meta name=twitter:description content="A simple blog "><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"MLOG","url":"https://qfsyso.github.io/","description":"A simple blog ","logo":"https://qfsyso.github.io/favicon.ico","sameAs":[]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://qfsyso.github.io/ accesskey=h title="MLOG (Alt + H)">MLOG</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://qfsyso.github.io/posts/ title=Archive><span>Archive</span></a></li><li><a href=https://qfsyso.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://qfsyso.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Go Background</h2></header><div class=entry-content><p>debian go程序 后台运行 要在Debian系统上将Go程序设置为后台运行，使用nohup命令和&符号。
编译Go程序，生成可执行文件。
go build -o myapp main.go 使用nohup将程序放到后台运行，并将输出重定向到nohup.out文件。
nohup ./myapp & 如果您想要程序在系统启动时自动运行，可以创建一个systemd服务文件。
创建一个名为myapp.service的文件：
sudo nano /etc/systemd/system/myapp.service 在编辑器中添加以下内容：
[Unit] Description=My Go Application After=network.target [Service] Type=simple ExecStart=/path/to/your/myapp Restart=on-failure RestartSec=5 [Install] WantedBy=multi-user.target 保存并退出编辑器。
启用并启动服务：
sudo systemctl enable myapp.service sudo systemctl start myapp.service Go程序就会在Debian系统上作为服务后台运行。
c# run~ sudo nohup dotnet run /root/socketa/TcpSk > output20240805.log 2>&amp;1 & sudo nohup dotnet run /root/netser/xx > output1.log 2>&amp;1 & ps -ef | grep nohup kill</p></div><footer class=entry-footer><span title='2024-08-05 01:44:01 +0000 UTC'>August 5, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to  Go Background" href=https://qfsyso.github.io/posts/go-background/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>C# keep alive</h2></header><div class=entry-content><p>在C#中，想让一个控制台应用程序保持运行而不依赖 Cnsole.ReadKey()，可以通过多种方式实现。
1. 使用事件循环 可以使用 EventWaitHandle 或者其他类似的同步原语来创建一个事件循环，让程序保持在等待状态。
using System; using System.Threading; class Program { static void Main() { // 创建一个自动重置的事件对象 EventWaitHandle waitHandle = new EventWaitHandle(false, EventResetMode.AutoReset); Console.WriteLine("Press any key to exit..."); // 等待事件被设置，如果没有接收到信号，则保持等待状态 waitHandle.WaitOne(); Console.Clear(); } } 使用无限循环 你可以创建一个无限循环，直到你手动终止程序。
//cpu占用高~ using System; class Program { static void Main() { while (true) { // 程序在这里保持运行状态，等待事件或其他中断。 Console.WriteLine("The program is running. Press CTRL+C to exit."); } } } 3. 使用定时器 创建一个定时器，定期执行某些任务，或者用于控制程序行为。
using System; using System....</p></div><footer class=entry-footer><span title='2024-08-05 00:38:00 +0000 UTC'>August 5, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to C# keep alive" href=https://qfsyso.github.io/posts/c%23-keep-alive/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Electron App</h2></header><div class=entry-content><p>Electron fetch API发送HTTP请求 npm install electron --save-dev 创建： your-electron-app/ ├── main.js ├── renderer.js └── index.html
main.js - Electron
const { app, BrowserWindow } = require('electron'); function createWindow () { // 创建浏览器窗口 let win = new BrowserWindow({ width: 800, height: 600, webPreferences: { nodeIntegration: true } }); // 加载index.html文件 win.loadFile('index.html'); } app.whenReady().then(createWindow); renderer.js - Electron的渲染器进程文件，使用fetch发送请求： document.addEventListener('DOMContentLoaded', () => { fetch('https://jsonplaceholder.typicode.com/posts/1') .then(response => response.json()) .then(data => { document.getElementById('result').textContent = JSON.stringify(data, null, 2); }) ....</p></div><footer class=entry-footer><span title='2024-08-04 21:28:01 +0000 UTC'>August 4, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to Electron App" href=https://qfsyso.github.io/posts/electron-app/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Axios Cors && Timestamp</h2></header><div class=entry-content><p>具体步骤 安装 Axios: 使用 Axios 进行 HTTP 请求。
封装 Axios: 将 Axios 封装成一个模块以便在项目中复用。
解决跨域问题: 在 vite.config.ts 文件中配置代理以解决跨域问题。
调用 API: 在 Vue 组件中使用封装的 Axios 进行数据请求和显示。
安装 Axios 首先，确保你已经安装了 Axios：
bash Copy Code npm install axios
封装 Axios 创建一个 http 文件夹并在其中创建一个 request.ts 文件：
src/http/request.ts:
import axios from 'axios'; const service = axios.create({ baseURL: 'http://localhost:16552/api/zblack', // 根据你的后端API地址调整 timeout: 5000, // 请求超时时间 }); // 请求拦截器 service.interceptors.request.use( config => { return config; }, error => { console....</p></div><footer class=entry-footer><span title='2024-08-04 12:16:25 +0000 UTC'>August 4, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to Axios Cors  && Timestamp" href=https://qfsyso.github.io/posts/axios-cors-timestamp/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>yolov10</h2></header><div class=entry-content><p>YOLOv3、YOLov3-Ultralytics和YOLOv3u 概述 本文件概述了三种密切相关的物体检测模型，即YOLOv3、YOLOv3-Ultralytics 和YOLOv3u。 1.YOLOv3:这是"You Only Look Once"(YOLO)物体检测算法的第三个版本。YOLOv3最初由约瑟夫-雷德蒙(Joseph Redmon)开发，通过引入多尺度预测和三种不同大小的检测内核等功能，YOLOv3 对其前身进行了改进。 YOLOv3-Ultralvtics: 这是Ultralvtics’ YOLov3 模型的实现。它再现了原始的 YOLOv3 架构，并提供了更多的功2. 能，如支持更多的预训练模型和更简单的定制选项。 YOLOv3u:这是 yOLOv3-ultralvtics 的更新版本，它采用了YOLOv8 模型中使用的无锚、无对象性分割头,3. YOLOv3u 保留了与 YOLOv3 相同的骨干和颈部结构，但使用了YOLOv8 更新的检测头。
YOLov4:高速、精确的物体探测 欢迎访问Ultralytics YoLov4 文档页面，YOLOv4 是由 Alexey Bochkovskiy于 2020,年在https://github.com/AlexeyAB/darknet 推出的最先进的实时物体检测器。 YOLOv4 的设计在速度和精确度之间实现了最佳平衡，是许多应用的理想选择。
YOLOv5u 代表着物体检测方法的进步。YOLOv5u 源自 开发的 YOLOv5 Ultralvtics 开发的模型的基础结构，YOLOv5u整合了无锚点、无对象性的分割头，这是以前的 YOLov8模型中引入的功能。这一调整完善了模型的架构，从而提高了物体检测任务中的精度·速度权衡。鉴于经验结果及其衍生特征，YOLov5u 为那些在研究和实际应用中寻求稳健解决方案的人提供了一个高效的替代方案。
美团YOLOv6 是一款先进的物体检测器，在速度和准确性之间取得了出色的平衡，是实时应用的热门选择。该模型在架构和训练方案上引入了几项显著的改进，包括双向串联(Bic)模块、锚点辅助训练(AAT)策略以及改进的骨干和颈部设计，从而在 COCo 数据集上实现了最先进的精度。 Bic AAT
YOLOv7: 可训练的免费书包 YOLOv7 是最先进的实时物体检测器，在5FPS 到 160 FPS 的范围内，其速度和准确性都超过了所有已知的物体检测器。在GPU V100 上，YOLOv7 的准确率(56.8% AP)在 30 FPS 或更高的所有已知实时物体检测器中是最高的。此外，YOLOv7 在速度和准确性上都优于 YOLOR、YOLOX、Scaled-YOLOv4、YOLOv5 等其他物体检测器。该模型是在 MS COC0 数据集上从头开始训练的，没有使用任何其他数据集或预先训练的权重。YoLov7 的源代码可在GitHub 上获取。...</p></div><footer class=entry-footer><span title='2024-07-29 23:49:16 +0000 UTC'>July 29, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to yolov10" href=https://qfsyso.github.io/posts/yolov10/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>VUE npm yarn</h2></header><div class=entry-content><p>vite cretae vue npm yarn npm init vite PN vue3 ts
cd PN npm install npm run dev or
npm install -g yarn yarn yarn dev NPM npm init 初始化某个项目 npm install/link 默认的安装依赖操作 npm install taco --save 安装某个依赖，并且默认保存到package. npm uninstall taco --save 安装某个开发时依赖项目 npm install taco --save-dev 更新某个依赖项目 npm update taco --save安装某个全局依赖项目 npm install taco --global 安装某个全局依赖项目 npm publish/login/1ogout 发布/登录/登出，一系列NPM Registry操作 npm rutest 运行某个命令 YARN yarn init 初始化某个项目 yarn install/link 默认的安装依赖操作 yarn add taco 安装某个依赖，并且默认保存到package....</p></div><footer class=entry-footer><span title='2024-07-27 23:53:03 +0000 UTC'>July 27, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to  VUE npm yarn" href=https://qfsyso.github.io/posts/vue-npm-yarn/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>.NET MSTest Xunit</h2></header><div class=entry-content><p>node api 下面是一个使用 Node.js 和 Express.js 编写的简单 RESTful API 示例。
1. 初始化项目 首先，创建一个新的项目目录并进入该目录：
mkdir myapi cd myapi 然后初始化一个新的 Node.js 项目：
npm init -y 2. 安装依赖 安装 Express.js 作为我们的 Web 框架：
npm install express 3. 创建主文件 在项目根目录下创建一个名为 index.js 的文件：
touch index.js 4. 编写 RESTful API 代码 在 index.js 中编写以下代码：
const express = require('express'); const app = express(); const port = 3000; app.use(express.json()); let items = [ { id: 1, name: 'Item 1' }, { id: 2, name: 'Item 2' }, { id: 3, name: 'Item 3' } ]; // 获取所有项目 app....</p></div><footer class=entry-footer><span title='2024-07-26 23:37:05 +0000 UTC'>July 26, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to .NET MSTest Xunit" href=https://qfsyso.github.io/posts/.net-mstest-xunit/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ollama gpt qwen gemma2 deepseek loacl AI</h2></header><div class=entry-content><p>ollama https://ollama.com/ ollama
https://ollama.com/library models
ollama run qwen2 send a message ollama run gemma2 https://github.com/open-webui/open-webui webui
docker run -d -p 3000:8080 --add-host=host.docker.internal:host-gateway -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:main N卡 gpu
docker run -d -p 3000:8080 --gpus all --add-host=host.docker.internal:host-gateway -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:cuda http://localhost:3000/
deepseek https://ollama.com/library/deepseek-coder-v2 deepseek-coder-v2 ~~ codeqwen sqlcoder
curl -X POST http://localhost:11434/api/generate -d '{ "model": "llama2-chinese:7b-chat-q4_0", "prompt":"为什么天空是蓝色的" }' https://docs.openwebui.com/
单独部署Open WebUI Open WebUI https://docs.openwebui.com/ 安装默认配置...</p></div><footer class=entry-footer><span title='2024-07-26 23:33:08 +0000 UTC'>July 26, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to ollama gpt qwen gemma2 deepseek loacl AI" href=https://qfsyso.github.io/posts/ollama-gpt-qwen-gemma2-deepseek-loacl-ai/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Gofastdfs whitelist</h2></header><div class=entry-content><p>在go-fastdfs项目中，要实现IP白名单限制上传功能，你需要在处理上传请求的地方进行检查。根据你提供的代码，上传逻辑主要在server.go文件中的HttpHandler的ServeHTTP方法里通过调用mux.ServeHTTP(res, req)来分发请求到不同的处理函数。
IP白名单限制 定义白名单：首先需要定义一个变量来存储允许的IP地址。可以在server.go的Server结构体中添加一个字段来存储这个白名单。
type Server struct { // ... 其他字段 ... allowedIPs map[string]struct{} } func NewServer() *Server { server := &amp;Server{ // ... 初始化其他字段 ... allowedIPs: make(map[string]struct{}), } // 假设允许的IP是 "192.168.1.1" 和 "10.12.188.85" server.allowedIPs["192.168.1.1"] = struct{}{} server.allowedIPs["10.12.188.85"] = struct{}{} return server } 修改HttpHandler：在HttpHandler的ServeHTTP方法中添加一个检查逻辑，以确定请求的IP是否在白名单中。
func (httpHandler *HttpHandler) ServeHTTP(res http.ResponseWriter, req *http.Request) { if !server.isIPAllowed(req) { http.Error(res, "Access denied", http.StatusForbidden) return } // 原有的处理逻辑 mux.ServeHTTP(res, req) } func (server *Server) isIPAllowed(req *http....</p></div><footer class=entry-footer><span title='2024-07-25 23:46:59 +0000 UTC'>July 25, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to  Gofastdfs whitelist" href=https://qfsyso.github.io/posts/gofastdfs-whitelist/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Nginx whitelist</h2></header><div class=entry-content><p>在 Debian 系统上安装 Nginx
更新包列表：
sudo apt update 安装 Nginx： 使用 apt 包管理器来安装 Nginx。
sudo apt install nginx 启动 Nginx：
sudo systemctl start nginx 启用开机自启动：
sudo systemctl enable nginx 检查 Nginx 状态：
sudo systemctl status nginx 配置防火墙（可选）：
sudo ufw allow 'Nginx Full' 访问你的服务器： 安装完成后，你可以通过浏览器访问你的服务器 IP 地址来验证 Nginx 是否安装成功。你应该会看到默认的 Nginx 欢迎页面。
配置 HTTPS（可选）
如果你希望使用 HTTPS，可以按照以下步骤操作：
获取 SSL 证书： 可以使用 Let’s Encrypt 免费获取一个 SSL 证书。运行以下命令来安装 Certbot 和 Nginx 插件：
sudo apt install certbot python3-certbot-nginx 获取并安装证书： 运行以下命令来获取并安装证书：...</p></div><footer class=entry-footer><span title='2024-07-23 23:56:32 +0000 UTC'>July 23, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to Nginx whitelist" href=https://qfsyso.github.io/posts/nginx-whitelist/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://qfsyso.github.io/page/11/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://qfsyso.github.io/page/13/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><div class=wtime><div class=wtime2>CST<span id=beijingTime></span> GMT <span id=londonTime></span> EST <span id=newYorkTime></span> PST<span id=losAngelesTime></span></div><div class=wtime2 style=display:none>东京<span id=tokyoTime></span></div><div class=wtime2 style=display:none>欧洲-巴黎<span id=parisTime></span></div><div class=wtime2 style=display:none>UTC<span id=utcTime></span></div></div><span>&copy; 2025 <a href=https://qfsyso.github.io/>MLOG</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span><script type=text/javascript>const timeZoneOffsets={beijing:8,tokyo:9,paris:[1,2],london:[0,1],newYork:[-5,-4],losAngeles:[-8,-7]};function padZero(e){return e<10?"0"+e:e}function formatTime(e){const t=e.getFullYear(),n=padZero(e.getMonth()+1),s=padZero(e.getDate()),o=padZero(e.getHours()),i=padZero(e.getMinutes()),a=padZero(e.getSeconds());return`${t}-${n}-${s} ${o}:${i}:${a}`}function isDaylightSavingTime(e,t){const o=e.getMonth(),n=new Date(e.getFullYear(),3,8,2,0,0),s=new Date(e.getFullYear(),10,1,2,0,0);return(t==="paris"||t==="london"||t==="newYork"||t==="losAngeles")&&e>=n&&e<s}function updateTime(){const e=new Date,t=new Date(e.getUTCFullYear(),e.getUTCMonth(),e.getUTCDate(),e.getUTCHours(),e.getUTCMinutes(),e.getUTCSeconds()),n=formatTime(t);document.getElementById("utcTime").innerHTML=n;for(const n in timeZoneOffsets){const e=timeZoneOffsets[n];let s;Array.isArray(e)?s=isDaylightSavingTime(t,n)?e[1]:e[0]:s=e;const o=new Date(t.getTime()+s*60*60*1e3);document.getElementById(n+"Time").innerHTML=formatTime(o)}setTimeout(updateTime,1e3)}window.onload=function(){updateTime()};function notfound(e){var n=e.src,t=n.split("/"),s=t[t.length-1];e.src="https://47.115.223.75:8080/group1/v2/"+s+"?timestamp="+Date.now(),e.onerror=null}</script></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>