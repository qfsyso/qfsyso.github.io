<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.126.3"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MLOG</title>
<meta name=description content="A simple blog "><meta name=author content="dwd"><link rel=canonical href=https://qfsyso.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://qfsyso.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://qfsyso.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://qfsyso.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://qfsyso.github.io/apple-touch-icon.png><link rel=mask-icon href=https://qfsyso.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://qfsyso.github.io/index.xml><link rel=alternate type=application/json href=https://qfsyso.github.io/index.json><link rel=alternate hreflang=en href=https://qfsyso.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://qfsyso.github.io/"><meta property="og:site_name" content="MLOG"><meta property="og:title" content="MLOG"><meta property="og:description" content="A simple blog "><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="MLOG"><meta name=twitter:description content="A simple blog "><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"MLOG","url":"https://qfsyso.github.io/","description":"A simple blog ","logo":"https://qfsyso.github.io/favicon.ico","sameAs":[]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://qfsyso.github.io/ accesskey=h title="MLOG (Alt + H)">MLOG</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://qfsyso.github.io/posts/ title=Archive><span>Archive</span></a></li><li><a href=https://qfsyso.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://qfsyso.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>jwt redis</h2></header><div class=entry-content><p>Redis JWT 在 .NET 中使用 Redis 来存储 JWT（JSON Web Token）可以通过多种方式实现， 例如在用户登录时将生成的 JWT 存储在 Redis 中以便于后续验证和管理。
实现步骤
引入依赖 确保你的项目引入了以下必要的 NuGet 包：
Microsoft.AspNetCore.Authentication.JwtBearer：用于 JWT 身份验证。 StackExchange.Redis：用于与 Redis 通信。
dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer dotnet add package StackExchange.Redis 配置 Redis 客户端 设置 Redis 的连接和操作。
生成 JWT 根据用户信息生成 JWT 并将其存储到 Redis。
验证 JWT 在验证阶段从 Redis 检查 token 是否有效。
实现 Token 的失效机制 利用 Redis 的 TTL（过期时间）特性来管理 token 的生命周期。
代码实现 1. 配置 Redis 客户端 在 Program.cs 或 Startup....</p></div><footer class=entry-footer><span title='2024-12-03 01:20:03 +0000 UTC'>December 3, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to jwt redis" href=https://qfsyso.github.io/posts/jwt-redis/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>cashrp opencv</h2></header><div class=entry-content><p>Emgu CV进行基本的人脸检测。 人脸检测是指定位图像中的人脸位置，而人脸识别是指确认或验证这些脸孔的身份。为了实现人脸识别，需要训练一个模型，或者使用预训练的模型。
安装 Emgu CV 首先，需要通过NuGet安装Emgu CV包。可以通过Visual Studio的NuGet包管理器来安装：
打开的C#项目。 右键点击解决方案资源管理器中的项目名称，选择“管理NuGet程序包”。
搜索并安装Emgu.CV和Emgu.CV.runtime.windows。 // 加载人脸检测分类器 CascadeClassifier faceCascade = new CascadeClassifier("haarcascade_frontalface_default.xml"); // 读取输入图像 Image&lt;Bgr, byte> inputImage = new Image&lt;Bgr, byte>("face.jpg"); // 转换为灰度图像，因为人脸检测通常在灰度图像上进行 Image&lt;Gray, byte> grayImage = inputImage.Convert&lt;Gray, byte>(); // 进行人脸检测 Rectangle[] faces = faceCascade.DetectMultiScale(grayImage, 1.1, 3, Size.Empty); // 在检测到的人脸周围绘制矩形框 foreach (Rectangle face in faces) { inputImage.Draw(face, new Bgr(0, 255, 0), 3); } // 保存标记后的图像为output.jpg inputImage.Save("output.jpg"); Console.WriteLine("save~output.jpg"); xml来自 https://github.com/opencv/opencv/tree/master/data/haarcascades
runtime 如果没有 Emgu.CV.runtime.windows 则会加载不了xml...</p></div><footer class=entry-footer><span title='2024-12-03 01:15:38 +0000 UTC'>December 3, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to cashrp opencv" href=https://qfsyso.github.io/posts/cashrp-opencv/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>DeepSeek-V2.5</h2></header><div class=entry-content><p>DeepSeek-V2.5 在目前大模型主流榜单中，DeepSeek-V2.5 均表现出色
中文综合能力（AlignBench）位列开源榜首 与 GPT-4-Turbo，文心 4.0 等闭源模型在评测中处于同一梯队
英文综合能力（MT-Bench）处于第一梯队 英文综合能力（MT-Bench）与最强的开源模型 LLaMA3-70B 处于同一梯队，超过最强 MoE 开源模型 Mixtral8x22B
知识、数学、推理、编程等榜单结果位居前列 开源模型支持 128K 上下文
api curl https://api.deepseek.com/chat/completions \ -H "Content-Type: application/json" \ -H "Authorization: Bearer xx" \ -d '{ "model": "deepseek-chat", "messages": [ {"role": "system", "content": "You are a helpful assistant."}, {"role": "user", "content": "Hello!"} ], "stream": false }' py # Please install OpenAI SDK first: `pip3 install openai` from openai import OpenAI client = OpenAI(api_key="skx", base_url="https://api....</p></div><footer class=entry-footer><span title='2024-11-30 03:13:44 +0000 UTC'>November 30, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to  DeepSeek-V2.5" href=https://qfsyso.github.io/posts/deepseek-v2.5/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>packet splicing</h2></header><div class=entry-content><p>模拟粘包的场景 粘包通常在发送端因数据频繁写入缓冲区并一起发送，或者在接收端没有明确的分包逻辑导致读取不完整的数据包时发生。
使用固定分隔符或包头+包体 常见的解决粘包方案是使用分隔符（如 \n 或特殊字符），或采用固定的包头标识数据长度。
服务端代码
using System; using System.Net; using System.Net.Sockets; using System.Text; using System.Threading; class TcpServer { static void Main() { TcpListener listener = new TcpListener(IPAddress.Any, 5000); listener.Start(); Console.WriteLine("Server started, waiting for connection..."); Socket clientSocket = listener.AcceptSocket(); Console.WriteLine("Client connected!"); byte[] buffer = new byte[1024]; int bytesRead; while ((bytesRead = clientSocket.Receive(buffer)) > 0) { string receivedData = Encoding.UTF8.GetString(buffer, 0, bytesRead); Console.WriteLine($"Received: {receivedData}"); // 模拟数据未分包的场景 Console.WriteLine("Processing received data..."); string[] messages = receivedData....</p></div><footer class=entry-footer><span title='2024-11-27 22:46:43 +0000 UTC'>November 27, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to packet splicing" href=https://qfsyso.github.io/posts/packet-splicing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>csharp reflection delegate</h2></header><div class=entry-content><p>Reflection 反射 动态加载和创建对象： 反射可以在运行时加载程序集，并基于类型信息创建对象实例，而无需在编译时知道具体的类型。 这对于实现插件系统、动态加载模块或在不同版本的库之间提供兼容性非常有用。
反射可以获取有关类型（如类、接口、结构体等）及其成员（如字段、属性、方法等）的详细信息。 这对于生成文档、进行代码分析或创建序列化/反序列化机制等任务非常有用。
class Program { static void Main(string[] args) { // 加载包含类型的程序集 Assembly assembly = Assembly.LoadFrom("ReflectionExample.dll"); // 获取类型信息 Type type = assembly.GetType("ReflectionExample.MyClass"); // 创建对象实例 object instance = Activator.CreateInstance(type); // 获取方法信息 MethodInfo methodInfo = type.GetMethod("MyMethod"); // 调用方法 methodInfo.Invoke(instance, new object[] { "Hello, Reflection!" }); } } public class MyClass { public void MyMethod(string message) { Console.WriteLine(message); } } Delegate 委托 委托是一种类型安全的函数指针，可以用来引用一个或多个具有相同签名的方法。 委托（Delegate）是一种特殊的类型，它代表对具有特定参数列表和返回类型的函数的引用。委托可以用来封装静态方法或实例方法，并且可以在运行时像普通变量一样传递。这使得委托成为一种强大的工具，用于实现回调函数、事件处理以及其他需要函数作为参数传递的场景。
委托的基本特性 类型安全：委托是类型安全的，因为它们在声明时会指定一个方法签名，只有与这个签名匹配的方法才能被委托引用。 多播能力：大多数委托支持多播，即一个委托实例可以引用多个方法。当调用该委托时，所有引用的方法都会被依次调用。 灵活性：委托可以用来引用类的实例方法或静态方法，也可以引用匿名方法（使用lambda表达式）。 定义委托 委托可以通过delegate关键字定义。定义时需要指定返回类型和参数列表。 有访问修饰符，delegate，返回值类型，委托名称，参数-可选。可以在类内部，可以在外部。...</p></div><footer class=entry-footer><span title='2024-11-24 17:36:50 +0000 UTC'>November 24, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to csharp reflection delegate" href=https://qfsyso.github.io/posts/csharp-reflection-delegate/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>redis sentinel cluster</h2></header><div class=entry-content><p>Debian 服务器上部署分布式 Redis 可以实现高可用性或负载均衡，具体可以选择以下两种方案之一：
主从复制 (Master-Slave Replication) 主从复制用于数据冗余备份和读写分离，但并不提供自动故障切换功能。
Redis Sentinel (哨兵模式) Redis Sentinel 在主从复制的基础上增加了自动故障切换功能，用于实现高可用性。
Redis Cluster (集群模式) Redis Cluster 是一种分布式部署方式，支持数据分片和高可用性，适用于需要扩展性的场景。
Redis Sentinel 部署架构 两台服务器： 主 Redis 服务器（假设 IP：192.168.1.101） 从 Redis 服务器（假设 IP：192.168.1.102） Sentinel 哨兵进程： 每台服务器运行一个 Sentinel 进程，用于监控和故障切换。
步骤 1：安装 Redis 在两台服务器上分别安装 Redis：
sudo apt update sudo apt install redis-server 验证 Redis 版本：
redis-server --version 步骤 2：配置 Redis 主从复制 在主服务器 (192.168.1.101) 上 编辑 Redis 配置文件 /etc/redis/redis.conf：
bind 0.0.0.0 # 允许外部访问 protected-mode no # 关闭保护模式（测试环境使用） appendonly yes # 开启持久化 启动 Redis 服务：...</p></div><footer class=entry-footer><span title='2024-11-22 22:18:29 +0000 UTC'>November 22, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to redis sentinel cluster" href=https://qfsyso.github.io/posts/redis-sentinel-cluster/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>nginx keepalived</h2></header><div class=entry-content><p>Keepalived 是一种用于实现高可用性的工具，它通过VRRP（虚拟路由冗余协议）来管理虚拟IP地址，从而确保在主服务器故障时，备用服务器能够接管服务。
环境准备 假设有两台Debian服务器：
Server 1 (Master): IP地址 192.168.1.100 Server 2 (Backup): IP地址 192.168.1.101 虚拟IP地址: 192.168.1.102
步骤一：安装Nginx 在两台服务器上安装Nginx。
Server 1 (Master)
sudo apt update sudo apt install nginx Server 2 (Backup)
sudo apt update sudo apt install nginx 步骤二：安装Keepalived 在两台服务器上安装Keepalived。
Server 1 (Master)
sudo apt install keepalived Server 2 (Backup) ```Bash sudo apt install keepalived 步骤三：配置Keepalived 编辑Keepalived的配置文件 /etc/keepalived/keepalived.conf。
Server 1 (Master)
sudo nano /etc/keepalived/keepalived.conf 添加以下配置：
vrrp_instance VI_1 { state MASTER interface eth0 virtual_router_id 51 priority 100 advert_int 1 authentication { auth_type PASS auth_pass 1111 } virtual_ipaddress { 192....</p></div><footer class=entry-footer><span title='2024-11-21 23:37:23 +0000 UTC'>November 21, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to  nginx keepalived" href=https://qfsyso.github.io/posts/nginx-keepalived/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>python whoisdomain</h2></header><div class=entry-content><p>pip install python-whois import whois # 读取文件中的域名 def read_domains_from_file(file_path): with open(file_path, 'r') as file: domains = [line.strip() for line in file if line.strip()] return domains # 查询域名的WHOIS信息 def query_whois(domain): try: domain_info = whois.whois(domain) if domain_info.domain_name: return domain_info else: return None except Exception as e: print(f"Error querying WHOIS for {domain}: {e}") return None # 保存查询结果到文件 def save_results_to_file(domains, results, output_file): with open(output_file, 'w') as file: for domain, result in results.items(): if result: file....</p></div><footer class=entry-footer><span title='2024-11-21 23:31:52 +0000 UTC'>November 21, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to python whoisdomain" href=https://qfsyso.github.io/posts/python-whoisdomain/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>uniapp postman</h2></header><div class=entry-content><p>基础页面 &lt;template> &lt;view class="content"> &lt;input v-model="url" placeholder="请输入请求地址" /> &lt;picker :range="methods" @change="onMethodChange"> &lt;view>{{ methods[selectedIndex] }}&lt;/view> &lt;/picker> &lt;textarea v-model="body" placeholder="请输入请求体">&lt;/textarea> &lt;button @click="sendRequest">发送请求&lt;/button> &lt;view v-if="response" class="response"> &lt;text>响应:&lt;/text> &lt;pre>{{ response }}&lt;/pre> &lt;/view> &lt;/view> &lt;/template> &lt;script> export default { data() { return { url: '', body: '', response: '', methods: ['GET', 'POST'], selectedIndex: 0 }; }, methods: { onMethodChange(e) { this.selectedIndex = e.detail.value; }, sendRequest() { const method = this.methods[this.selectedIndex]; const data = method === 'POST' ?...</p></div><footer class=entry-footer><span title='2024-11-21 21:43:36 +0000 UTC'>November 21, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to uniapp postman" href=https://qfsyso.github.io/posts/uniapp-postman/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>XAI Grok</h2></header><div class=entry-content><p>X.AI Reg
Create API key curl https://api.x.ai/v1/chat/completions -H "Content-Type: application/json" -H "Authorization: Bearer xai-xxx" -d '{ "messages": [ { "role": "system", "content": "You are a test assistant." }, { "role": "user", "content": "what can u do?" } ], "model": "grok-beta", "stream": false, "temperature": 0 }' python import requests # API URL 和 API 密钥 API_URL = "https://api.x.ai/v1/chat/completions" API_KEY = "xai-bELnXX" # 替换为实际 API 密钥 # 请求头 headers = { "Content-Type": "application/json", "Authorization": f"Bearer {API_KEY}" } # 请求数据 data = { "messages": [ { "role": "system", "content": "You are a test assistant....</p></div><footer class=entry-footer><span title='2024-11-19 22:54:15 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;dwd</footer><a class=entry-link aria-label="post link to  XAI Grok" href=https://qfsyso.github.io/posts/xai-grok/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://qfsyso.github.io/page/9/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://qfsyso.github.io/page/11/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><div class=wtime><div class=wtime2>CST<span id=beijingTime></span> GMT <span id=londonTime></span> EST <span id=newYorkTime></span> PST<span id=losAngelesTime></span></div><div class=wtime2 style=display:none>东京<span id=tokyoTime></span></div><div class=wtime2 style=display:none>欧洲-巴黎<span id=parisTime></span></div><div class=wtime2 style=display:none>UTC<span id=utcTime></span></div></div><span>&copy; 2025 <a href=https://qfsyso.github.io/>MLOG</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span><script type=text/javascript>const timeZoneOffsets={beijing:8,tokyo:9,paris:[1,2],london:[0,1],newYork:[-5,-4],losAngeles:[-8,-7]};function padZero(e){return e<10?"0"+e:e}function formatTime(e){const t=e.getFullYear(),n=padZero(e.getMonth()+1),s=padZero(e.getDate()),o=padZero(e.getHours()),i=padZero(e.getMinutes()),a=padZero(e.getSeconds());return`${t}-${n}-${s} ${o}:${i}:${a}`}function isDaylightSavingTime(e,t){const o=e.getMonth(),n=new Date(e.getFullYear(),3,8,2,0,0),s=new Date(e.getFullYear(),10,1,2,0,0);return(t==="paris"||t==="london"||t==="newYork"||t==="losAngeles")&&e>=n&&e<s}function updateTime(){const e=new Date,t=new Date(e.getUTCFullYear(),e.getUTCMonth(),e.getUTCDate(),e.getUTCHours(),e.getUTCMinutes(),e.getUTCSeconds()),n=formatTime(t);document.getElementById("utcTime").innerHTML=n;for(const n in timeZoneOffsets){const e=timeZoneOffsets[n];let s;Array.isArray(e)?s=isDaylightSavingTime(t,n)?e[1]:e[0]:s=e;const o=new Date(t.getTime()+s*60*60*1e3);document.getElementById(n+"Time").innerHTML=formatTime(o)}setTimeout(updateTime,1e3)}window.onload=function(){updateTime()};function notfound(e){var n=e.src,t=n.split("/"),s=t[t.length-1];e.src="https://47.115.223.75:8080/group1/v2/"+s+"?timestamp="+Date.now(),e.onerror=null}</script></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>